<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Coq of OCaml</title>
    <link href="bootstrap.min.css" rel="stylesheet">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container" style="width: 100%;">
      <div class="navbar navbar-default" role="navigation">
        <div class="container-fluid">
          <div class="navbar-header">
            <a class="navbar-brand" href="https://github.com/clarus/coq-of-ocaml">üê´ üêì Coq of OCaml</a>
          </div>
        </div>
      </div>
      <div class="article">
        <div class="row">
          <div class="col-md-6">
            <h2>Kernel of Coq</h2>
            <p>This is a demo of the current development version of <a href="https://github.com/clarus/coq-of-ocaml">coq-of-ocaml</a> on the <a href="https://github.com/coq/coq/tree/master/kernel">kernel</a> of <a =href="https://coq.inria.fr/">Coq</a>. Coq is written in <a =href="https://ocaml.org/">OCaml</a>. We show the original source code on the left and the imported Coq code on the right. The imported code probably does not compile. This is due to either various incompleteness in our tool, or to side-effects in the source code.</p>
          </div>
        </div>
        <div class="row">
          
          <div class="col-md-2">
            <ul>
              
              <li><a href="#cClosure">cClosure.ml</a></li>
              
              <li><a href="#cPrimitives">cPrimitives.ml</a></li>
              
              <li><a href="#cbytecodes">cbytecodes.ml</a></li>
              
              <li><a href="#cbytegen">cbytegen.ml</a></li>
              
              <li><a href="#cemitcodes">cemitcodes.ml</a></li>
              
              <li><a href="#clambda">clambda.ml</a></li>
              
              <li><a href="#context">context.ml</a></li>
              
              <li><a href="#conv_oracle">conv_oracle.ml</a></li>
              
              <li><a href="#cooking">cooking.ml</a></li>
              
              <li><a href="#csymtable">csymtable.ml</a></li>
              
            </ul>
          </div>
          
          <div class="col-md-2">
            <ul>
              
              <li><a href="#declarations">declarations.ml</a></li>
              
              <li><a href="#declareops">declareops.ml</a></li>
              
              <li><a href="#entries">entries.ml</a></li>
              
              <li><a href="#environ">environ.ml</a></li>
              
              <li><a href="#esubst">esubst.ml</a></li>
              
              <li><a href="#evar">evar.ml</a></li>
              
              <li><a href="#genOpcodeFiles">genOpcodeFiles.ml</a></li>
              
              <li><a href="#indTyping">indTyping.ml</a></li>
              
              <li><a href="#indtypes">indtypes.ml</a></li>
              
              <li><a href="#inductive">inductive.ml</a></li>
              
            </ul>
          </div>
          
          <div class="col-md-2">
            <ul>
              
              <li><a href="#inferCumulativity">inferCumulativity.ml</a></li>
              
              <li><a href="#mod_subst">mod_subst.ml</a></li>
              
              <li><a href="#mod_typing">mod_typing.ml</a></li>
              
              <li><a href="#modops">modops.ml</a></li>
              
              <li><a href="#names">names.ml</a></li>
              
              <li><a href="#nativecode">nativecode.ml</a></li>
              
              <li><a href="#nativeconv">nativeconv.ml</a></li>
              
              <li><a href="#nativelambda">nativelambda.ml</a></li>
              
              <li><a href="#nativelib">nativelib.ml</a></li>
              
              <li><a href="#nativelibrary">nativelibrary.ml</a></li>
              
            </ul>
          </div>
          
          <div class="col-md-2">
            <ul>
              
              <li><a href="#nativevalues">nativevalues.ml</a></li>
              
              <li><a href="#opaqueproof">opaqueproof.ml</a></li>
              
              <li><a href="#primred">primred.ml</a></li>
              
              <li><a href="#reduction">reduction.ml</a></li>
              
              <li><a href="#retroknowledge">retroknowledge.ml</a></li>
              
              <li><a href="#retypeops">retypeops.ml</a></li>
              
              <li><a href="#safe_typing">safe_typing.ml</a></li>
              
              <li><a href="#section">section.ml</a></li>
              
              <li><a href="#sorts">sorts.ml</a></li>
              
              <li><a href="#subtyping">subtyping.ml</a></li>
              
            </ul>
          </div>
          
          <div class="col-md-2">
            <ul>
              
              <li><a href="#term">term.ml</a></li>
              
              <li><a href="#term_typing">term_typing.ml</a></li>
              
              <li><a href="#transparentState">transparentState.ml</a></li>
              
              <li><a href="#type_errors">type_errors.ml</a></li>
              
              <li><a href="#typeops">typeops.ml</a></li>
              
              <li><a href="#uGraph">uGraph.ml</a></li>
              
              <li><a href="#uint63_31">uint63_31.ml</a></li>
              
              <li><a href="#uint63_63">uint63_63.ml</a></li>
              
              <li><a href="#univ">univ.ml</a></li>
              
              <li><a href="#vars">vars.ml</a></li>
              
            </ul>
          </div>
          
          <div class="col-md-2">
            <ul>
              
              <li><a href="#vconv">vconv.ml</a></li>
              
              <li><a href="#vm">vm.ml</a></li>
              
              <li><a href="#vmvalues">vmvalues.ml</a></li>
              
            </ul>
          </div>
          
        </div>
        
        <hr />
        <div class="row" id="cClosure" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>cClosure.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Bruno Barras with Benjamin Werner's account to implement
   a call-by-value conversion algorithm and a lazy reduction machine
   with sharing, Nov 1996 *)
(* Addition of zeta-reduction (let-in contraction) by Hugo Herbelin, Oct 2000 *)
(* Call-by-value machine moved to cbv.ml, Mar 01 *)
(* Additional tools for module subtyping by Jacek Chrzaszcz, Aug 2002 *)
(* Extension with closure optimization by Bruno Barras, Aug 2003 *)
(* Support for evar reduction by Bruno Barras, Feb 2009 *)
(* Miscellaneous other improvements by Bruno Barras, 1997-2009 *)

(* This file implements a lazy reduction for the Calculus of Inductive
   Constructions *)

[@@@ocaml.warning &quot;+4&quot;]

open CErrors
open Util
open Pp
open Names
open Constr
open Declarations
open Context
open Environ
open Vars
open Esubst

let stats = ref false

(* Profiling *)
let beta = ref 0
let delta = ref 0
let eta = ref 0
let zeta = ref 0
let evar = ref 0
let nb_match = ref 0
let fix = ref 0
let cofix = ref 0
let prune = ref 0

let reset () =
  beta := 0; delta := 0; zeta := 0; evar := 0; nb_match := 0; fix := 0;
  cofix := 0; evar := 0; prune := 0

let stop() =
  Feedback.msg_debug (str &quot;[Reds: beta=&quot; ++ int !beta ++ str&quot; delta=&quot; ++ int !delta ++
	 str &quot; eta=&quot; ++ int !eta ++ str&quot; zeta=&quot; ++ int !zeta ++ str&quot; evar=&quot; ++
	 int !evar ++ str&quot; match=&quot; ++ int !nb_match ++ str&quot; fix=&quot; ++ int !fix ++
         str &quot; cofix=&quot; ++ int !cofix ++ str&quot; prune=&quot; ++ int !prune ++
	 str&quot;]&quot;)

let incr_cnt red cnt =
  if red then begin
    if !stats then incr cnt;
    true
  end else
    false

let with_stats c =
  if !stats then begin
    reset();
    let r = Lazy.force c in
    stop();
    r
  end else
    Lazy.force c

let all_opaque = TransparentState.empty
let all_transparent = TransparentState.full

module type RedFlagsSig = sig
  type reds
  type red_kind
  val fBETA : red_kind
  val fDELTA : red_kind
  val fETA : red_kind
  val fMATCH : red_kind
  val fFIX : red_kind
  val fCOFIX : red_kind
  val fZETA : red_kind
  val fCONST : Constant.t -&gt; red_kind
  val fVAR : Id.t -&gt; red_kind
  val no_red : reds
  val red_add : reds -&gt; red_kind -&gt; reds
  val red_sub : reds -&gt; red_kind -&gt; reds
  val red_add_transparent : reds -&gt; TransparentState.t -&gt; reds
  val red_transparent : reds -&gt; TransparentState.t
  val mkflags : red_kind list -&gt; reds
  val red_set : reds -&gt; red_kind -&gt; bool
  val red_projection : reds -&gt; Projection.t -&gt; bool
end

module RedFlags : RedFlagsSig = struct

  (* [r_const=(true,cl)] means all constants but those in [cl] *)
  (* [r_const=(false,cl)] means only those in [cl] *)
  (* [r_delta=true] just mean [r_const=(true,[])] *)

  open TransparentState

  type reds = {
    r_beta : bool;
    r_delta : bool;
    r_eta : bool;
    r_const : TransparentState.t;
    r_zeta : bool;
    r_match : bool;
    r_fix : bool;
    r_cofix : bool }

  type red_kind = BETA | DELTA | ETA | MATCH | FIX
              | COFIX | ZETA
	      | CONST of Constant.t | VAR of Id.t
  let fBETA = BETA
  let fDELTA = DELTA
  let fETA = ETA
  let fMATCH = MATCH
  let fFIX = FIX
  let fCOFIX = COFIX
  let fZETA = ZETA
  let fCONST kn  = CONST kn
  let fVAR id  = VAR id
  let no_red = {
    r_beta = false;
    r_delta = false;
    r_eta = false;
    r_const = all_opaque;
    r_zeta = false;
    r_match = false;
    r_fix = false;
    r_cofix = false }

  let red_add red = function
    | BETA -&gt; { red with r_beta = true }
    | ETA -&gt; { red with r_eta = true }
    | DELTA -&gt; { red with r_delta = true; r_const = all_transparent }
    | CONST kn -&gt;
      let r = red.r_const in
      { red with r_const = { r with tr_cst = Cpred.add kn r.tr_cst } }
    | MATCH -&gt; { red with r_match = true }
    | FIX -&gt; { red with r_fix = true }
    | COFIX -&gt; { red with r_cofix = true }
    | ZETA -&gt; { red with r_zeta = true }
    | VAR id -&gt;
      let r = red.r_const in
      { red with r_const = { r with tr_var = Id.Pred.add id r.tr_var } }

  let red_sub red = function
    | BETA -&gt; { red with r_beta = false }
    | ETA -&gt; { red with r_eta = false }
    | DELTA -&gt; { red with r_delta = false }
    | CONST kn -&gt;
      let r = red.r_const in
      { red with r_const = { r with tr_cst = Cpred.remove kn r.tr_cst } }
    | MATCH -&gt; { red with r_match = false }
    | FIX -&gt; { red with r_fix = false }
    | COFIX -&gt; { red with r_cofix = false }
    | ZETA -&gt; { red with r_zeta = false }
    | VAR id -&gt;
      let r = red.r_const in
      { red with r_const = { r with tr_var = Id.Pred.remove id r.tr_var } }

  let red_transparent red = red.r_const

  let red_add_transparent red tr =
    { red with r_const = tr }

  let mkflags = List.fold_left red_add no_red

  let red_set red = function
    | BETA -&gt; incr_cnt red.r_beta beta
    | ETA -&gt; incr_cnt red.r_eta eta
    | CONST kn -&gt;
      let c = is_transparent_constant red.r_const kn in
	incr_cnt c delta
    | VAR id -&gt; (* En attendant d'avoir des kn pour les Var *)
      let c = is_transparent_variable red.r_const id in
	incr_cnt c delta
    | ZETA -&gt; incr_cnt red.r_zeta zeta
    | MATCH -&gt; incr_cnt red.r_match nb_match
    | FIX -&gt; incr_cnt red.r_fix fix
    | COFIX -&gt; incr_cnt red.r_cofix cofix
    | DELTA -&gt; (* Used for Rel/Var defined in context *)
	incr_cnt red.r_delta delta

  let red_projection red p =
    if Projection.unfolded p then true
    else red_set red (fCONST (Projection.constant p))

end

open RedFlags

let all = mkflags [fBETA;fDELTA;fZETA;fMATCH;fFIX;fCOFIX]
let allnolet = mkflags [fBETA;fDELTA;fMATCH;fFIX;fCOFIX]
let beta = mkflags [fBETA]
let betadeltazeta = mkflags [fBETA;fDELTA;fZETA]
let betaiota = mkflags [fBETA;fMATCH;fFIX;fCOFIX]
let betaiotazeta = mkflags [fBETA;fMATCH;fFIX;fCOFIX;fZETA]
let betazeta = mkflags [fBETA;fZETA]
let delta = mkflags [fDELTA]
let zeta = mkflags [fZETA]
let nored = no_red

(* Flags of reduction and cache of constants: 'a is a type that may be
 * mapped to constr. 'a infos implements a cache for constants and
 * abstractions, storing a representation (of type 'a) of the body of
 * this constant or abstraction.
 *  * i_tab is the cache table of the results
 *
 * ref_value_cache searches in the tab, otherwise uses i_repr to
 * compute the result and store it in the table. If the constant can't
 * be unfolded, returns None, but does not store this failure.  * This
 * doesn't take the RESET into account. You mustn't keep such a table
 * after a Reset.  * This type is not exported. Only its two
 * instantiations (cbv or lazy) are.
 *)

type table_key = Constant.t Univ.puniverses tableKey

let eq_pconstant_key (c,u) (c',u') =
  eq_constant_key c c' &amp;&amp; Univ.Instance.equal u u'

module IdKeyHash =
struct
  open Hashset.Combine
  type t = table_key
  let equal = Names.eq_table_key eq_pconstant_key
  let hash = function
  | ConstKey (c, _) -&gt; combinesmall 1 (Constant.UserOrd.hash c)
  | VarKey id -&gt; combinesmall 2 (Id.hash id)
  | RelKey i -&gt; combinesmall 3 (Int.hash i)
end

module KeyTable = Hashtbl.Make(IdKeyHash)

open Context.Named.Declaration

let assoc_defined id env = match Environ.lookup_named id env with
| LocalDef (_, c, _) -&gt; c
| LocalAssum _ -&gt; raise Not_found

(**********************************************************************)
(* Lazy reduction: the one used in kernel operations                  *)

(* type of shared terms. fconstr and frterm are mutually recursive.
 * Clone of the constr structure, but completely mutable, and
 * annotated with reduction state (reducible or not).
 *  - FLIFT is a delayed shift; allows sharing between 2 lifted copies
 *    of a given term.
 *  - FCLOS is a delayed substitution applied to a constr
 *  - FLOCKED is used to erase the content of a reference that must
 *    be updated. This is to allow the garbage collector to work
 *    before the term is computed.
 *)

(* Norm means the term is fully normalized and cannot create a redex
     when substituted
   Cstr means the term is in head normal form and that it can
     create a redex when substituted (i.e. constructor, fix, lambda)
   Whnf means we reached the head normal form and that it cannot
     create a redex when substituted
   Red is used for terms that might be reduced
*)
type red_state = Norm | Cstr | Whnf | Red

let neutr = function
  | Whnf|Norm -&gt; Whnf
  | Red|Cstr -&gt; Red

type optrel = Unknown | KnownR | KnownI

let opt_of_rel = function
  | Sorts.Relevant -&gt; KnownR
  | Sorts.Irrelevant -&gt; KnownI

module Mark : sig

  type t

  val mark : red_state -&gt; optrel -&gt; t
  val relevance : t -&gt; optrel
  val red_state : t -&gt; red_state

  val neutr : t -&gt; t

  val set_norm : t -&gt; t

end = struct
  type t = int

  let[@inline] of_state = function
    | Norm -&gt; 0b00 | Cstr -&gt; 0b01 | Whnf -&gt; 0b10 | Red -&gt; 0b11

  let[@inline] of_relevance = function
    | Unknown -&gt; 0
    | KnownR -&gt; 0b01
    | KnownI -&gt; 0b10

  let[@inline] mark state relevance = (of_state state) * 4 + (of_relevance relevance)

  let[@inline] relevance x = match x land 0b11 with
    | 0b00 -&gt; Unknown
    | 0b01 -&gt; KnownR
    | 0b10 -&gt; KnownI
    | _ -&gt; assert false

  let[@inline] red_state x = match x land 0b1100 with
    | 0b0000 -&gt; Norm
    | 0b0100 -&gt; Cstr
    | 0b1000 -&gt; Whnf
    | 0b1100 -&gt; Red
    | _ -&gt; assert false

  let[@inline] neutr x = x lor 0b1000 (* Whnf|Norm -&gt; Whnf | Red|Cstr -&gt; Red *)

  let[@inline] set_norm x = x land 0b0011
end
let mark = Mark.mark

type fconstr = {
  mutable mark : Mark.t;
  mutable term: fterm;
}

and fterm =
  | FRel of int
  | FAtom of constr (* Metas and Sorts *)
  | FFlex of table_key
  | FInd of pinductive
  | FConstruct of pconstructor
  | FApp of fconstr * fconstr array
  | FProj of Projection.t * fconstr
  | FFix of fixpoint * fconstr subs
  | FCoFix of cofixpoint * fconstr subs
  | FCaseT of case_info * constr * fconstr * constr array * fconstr subs (* predicate and branches are closures *)
  | FLambda of int * (Name.t Context.binder_annot * constr) list * constr * fconstr subs
  | FProd of Name.t Context.binder_annot * fconstr * constr * fconstr subs
  | FLetIn of Name.t Context.binder_annot * fconstr * fconstr * constr * fconstr subs
  | FEvar of existential * fconstr subs
  | FInt of Uint63.t
  | FLIFT of int * fconstr
  | FCLOS of constr * fconstr subs
  | FLOCKED

let fterm_of v = v.term
let set_norm v = v.mark &lt;- Mark.set_norm v.mark
let is_val v = match Mark.red_state v.mark with Norm -&gt; true | Cstr | Whnf | Red -&gt; false

let mk_atom c = {mark=mark Norm Unknown;term=FAtom c}
let mk_red f = {mark=mark Red Unknown;term=f}

(* Could issue a warning if no is still Red, pointing out that we loose
   sharing. *)
let update ~share v1 mark t =
  if share then
    (v1.mark &lt;- mark;
     v1.term &lt;- t;
     v1)
  else {mark;term=t;}

(** Reduction cache *)

type infos_cache = {
  i_env : env;
  i_sigma : existential -&gt; constr option;
  i_share : bool;
}

type clos_infos = {
  i_flags : reds;
  i_cache : infos_cache }

type clos_tab = (fconstr, Empty.t) constant_def KeyTable.t

let info_flags info = info.i_flags
let info_env info = info.i_cache.i_env

(**********************************************************************)
(* The type of (machine) stacks (= lambda-bar-calculus' contexts)     *)
type 'a next_native_args = (CPrimitives.arg_kind * 'a) list

type stack_member =
  | Zapp of fconstr array
  | ZcaseT of case_info * constr * constr array * fconstr subs
  | Zproj of Projection.Repr.t
  | Zfix of fconstr * stack
  | Zprimitive of CPrimitives.t * pconstant * fconstr list * fconstr next_native_args
       (* operator, constr def, arguments already seen (in rev order), next arguments *)
  | Zshift of int
  | Zupdate of fconstr

and stack = stack_member list

let empty_stack = []
let append_stack v s =
  if Int.equal (Array.length v) 0 then s else
  match s with
  | Zapp l :: s -&gt; Zapp (Array.append v l) :: s
  | (ZcaseT _ | Zproj _ | Zfix _ | Zshift _ | Zupdate _ | Zprimitive _) :: _ | [] -&gt;
    Zapp v :: s

(* Collapse the shifts in the stack *)
let zshift n s =
  match (n,s) with
      (0,_) -&gt; s
    | (_,Zshift(k)::s) -&gt; Zshift(n+k)::s
    | (_,(ZcaseT _ | Zproj _ | Zfix _ | Zapp _ | Zupdate _ | Zprimitive _) :: _) | _,[] -&gt; Zshift(n)::s

let rec stack_args_size = function
  | Zapp v :: s -&gt; Array.length v + stack_args_size s
  | Zshift(_)::s -&gt; stack_args_size s
  | Zupdate(_)::s -&gt; stack_args_size s
  | (ZcaseT _ | Zproj _ | Zfix _ | Zprimitive _) :: _ | [] -&gt; 0

(* Lifting. Preserves sharing (useful only for cell with norm=Red).
   lft_fconstr always create a new cell, while lift_fconstr avoids it
   when the lift is 0. *)
let rec lft_fconstr n ft =
  let r = Mark.relevance ft.mark in
  match ft.term with
    | (FInd _|FConstruct _|FFlex(ConstKey _|VarKey _)|FInt _) -&gt; ft
    | FRel i -&gt; {mark=mark Norm r;term=FRel(i+n)}
    | FLambda(k,tys,f,e) -&gt; {mark=mark Cstr r; term=FLambda(k,tys,f,subs_shft(n,e))}
    | FFix(fx,e) -&gt;
      {mark=mark Cstr r; term=FFix(fx,subs_shft(n,e))}
    | FCoFix(cfx,e) -&gt;
      {mark=mark Cstr r; term=FCoFix(cfx,subs_shft(n,e))}
    | FLIFT(k,m) -&gt; lft_fconstr (n+k) m
    | FLOCKED -&gt; assert false
    | FFlex (RelKey _) | FAtom _ | FApp _ | FProj _ | FCaseT _ | FProd _
      | FLetIn _ | FEvar _ | FCLOS _ -&gt; {mark=ft.mark; term=FLIFT(n,ft)}
let lift_fconstr k f =
  if Int.equal k 0 then f else lft_fconstr k f
let lift_fconstr_vect k v =
  if Int.equal k 0 then v else Array.Fun1.map lft_fconstr k v

let clos_rel e i =
  match expand_rel i e with
    | Inl(n,mt) -&gt; lift_fconstr n mt
    | Inr(k,None) -&gt; {mark=mark Norm Unknown; term= FRel k}
    | Inr(k,Some p) -&gt;
        lift_fconstr (k-p) {mark=mark Red Unknown;term=FFlex(RelKey p)}

(* since the head may be reducible, we might introduce lifts of 0 *)
let compact_stack head stk =
  let rec strip_rec depth = function
    | Zshift(k)::s -&gt; strip_rec (depth+k) s
    | Zupdate(m)::s -&gt;
        (* Be sure to create a new cell otherwise sharing would be
           lost by the update operation *)
        let h' = lft_fconstr depth head in
        (** The stack contains [Zupdate] marks only if in sharing mode *)
        let _ = update ~share:true m h'.mark h'.term in
        strip_rec depth s
    | ((ZcaseT _ | Zproj _ | Zfix _ | Zapp _ | Zprimitive _) :: _ | []) as stk -&gt; zshift depth stk
  in
  strip_rec 0 stk

(* Put an update mark in the stack, only if needed *)
let zupdate info m s =
  let share = info.i_cache.i_share in
  if share &amp;&amp; begin match Mark.red_state m.mark with Red -&gt; true  | Norm | Whnf | Cstr -&gt; false end
  then
    let s' = compact_stack m s in
    let _ = m.term &lt;- FLOCKED in
    Zupdate(m)::s'
  else s

let mk_lambda env t =
  let (rvars,t') = Term.decompose_lam t in
  FLambda(List.length rvars, List.rev rvars, t', env)

let destFLambda clos_fun t =
  match [@ocaml.warning &quot;-4&quot;] t.term with
      FLambda(_,[(na,ty)],b,e) -&gt; (na,clos_fun e ty,clos_fun (subs_lift e) b)
    | FLambda(n,(na,ty)::tys,b,e) -&gt;
        (na,clos_fun e ty,{mark=t.mark;term=FLambda(n-1,tys,b,subs_lift e)})
    | _ -&gt; assert false
        (* t must be a FLambda and binding list cannot be empty *)

(* Optimization: do not enclose variables in a closure.
   Makes variable access much faster *)
let mk_clos e t =
  match kind t with
    | Rel i -&gt; clos_rel e i
    | Var x -&gt; {mark = mark Red Unknown; term = FFlex (VarKey x) }
    | Const c -&gt; {mark = mark Red Unknown; term = FFlex (ConstKey c) }
    | Meta _ | Sort _ -&gt;  {mark = mark Norm KnownR; term = FAtom t }
    | Ind kn -&gt; {mark = mark Norm KnownR; term = FInd kn }
    | Construct kn -&gt; {mark = mark Cstr Unknown; term = FConstruct kn }
    | Int i -&gt; {mark = mark Cstr Unknown; term = FInt i}
    | (CoFix _|Lambda _|Fix _|Prod _|Evar _|App _|Case _|Cast _|LetIn _|Proj _) -&gt;
        {mark = mark Red Unknown; term = FCLOS(t,e)}

let inject c = mk_clos (subs_id 0) c

(** Hand-unrolling of the map function to bypass the call to the generic array
    allocation *)
let mk_clos_vect env v = match v with
| [||] -&gt; [||]
| [|v0|] -&gt; [|mk_clos env v0|]
| [|v0; v1|] -&gt; [|mk_clos env v0; mk_clos env v1|]
| [|v0; v1; v2|] -&gt; [|mk_clos env v0; mk_clos env v1; mk_clos env v2|]
| [|v0; v1; v2; v3|] -&gt;
  [|mk_clos env v0; mk_clos env v1; mk_clos env v2; mk_clos env v3|]
| v -&gt; Array.Fun1.map mk_clos env v

let ref_value_cache ({ i_cache = cache; _ }) tab ref =
  try
    KeyTable.find tab ref
  with Not_found -&gt;
    let v =
      try
        let body =
          match ref with
          | RelKey n -&gt;
            let open! Context.Rel.Declaration in
            let i = n - 1 in
            let (d, _) =
              try Range.get cache.i_env.env_rel_context.env_rel_map i
              with Invalid_argument _ -&gt; raise Not_found
            in
            begin match d with
              | LocalAssum _ -&gt; raise Not_found
              | LocalDef (_, t, _) -&gt; lift n t
            end
          | VarKey id -&gt; assoc_defined id cache.i_env
          | ConstKey cst -&gt; constant_value_in cache.i_env cst
        in
        Def (inject body)
      with
      | NotEvaluableConst (IsPrimitive op) (* Const *) -&gt; Primitive op
      | Not_found (* List.assoc *)
      | NotEvaluableConst _ (* Const *)
        -&gt; Undef None
    in
    KeyTable.add tab ref v; v

(* The inverse of mk_clos: move back to constr *)
let rec to_constr lfts v =
  match v.term with
    | FRel i -&gt; mkRel (reloc_rel i lfts)
    | FFlex (RelKey p) -&gt; mkRel (reloc_rel p lfts)
    | FFlex (VarKey x) -&gt; mkVar x
    | FAtom c -&gt; exliftn lfts c
    | FFlex (ConstKey op) -&gt; mkConstU op
    | FInd op -&gt; mkIndU op
    | FConstruct op -&gt; mkConstructU op
    | FCaseT (ci,p,c,ve,env) -&gt;
      if is_subs_id env &amp;&amp; is_lift_id lfts then
        mkCase (ci, p, to_constr lfts c, ve)
      else
        let subs = comp_subs lfts env in
        mkCase (ci, subst_constr subs p,
            to_constr lfts c,
            Array.map (fun b -&gt; subst_constr subs b) ve)
    | FFix ((op,(lna,tys,bds)) as fx, e) -&gt;
      if is_subs_id e &amp;&amp; is_lift_id lfts then
        mkFix fx
      else
        let n = Array.length bds in
        let subs_ty = comp_subs lfts e in
        let subs_bd = comp_subs (el_liftn n lfts) (subs_liftn n e) in
        let tys = Array.Fun1.map subst_constr subs_ty tys in
        let bds = Array.Fun1.map subst_constr subs_bd bds in
        mkFix (op, (lna, tys, bds))
    | FCoFix ((op,(lna,tys,bds)) as cfx, e) -&gt;
      if is_subs_id e &amp;&amp; is_lift_id lfts then
        mkCoFix cfx
      else
        let n = Array.length bds in
        let subs_ty = comp_subs lfts e in
        let subs_bd = comp_subs (el_liftn n lfts) (subs_liftn n e) in
        let tys = Array.Fun1.map subst_constr subs_ty tys in
        let bds = Array.Fun1.map subst_constr subs_bd bds in
        mkCoFix (op, (lna, tys, bds))
    | FApp (f,ve) -&gt;
        mkApp (to_constr lfts f,
               Array.Fun1.map to_constr lfts ve)
    | FProj (p,c) -&gt;
        mkProj (p,to_constr lfts c)

    | FLambda (len, tys, f, e) -&gt;
      if is_subs_id e &amp;&amp; is_lift_id lfts then
        Term.compose_lam (List.rev tys) f
      else
        let subs = comp_subs lfts e in
        let tys = List.mapi (fun i (na, c) -&gt; na, subst_constr (subs_liftn i subs) c) tys in
        let f = subst_constr (subs_liftn len subs) f in
        Term.compose_lam (List.rev tys) f
    | FProd (n, t, c, e) -&gt;
      if is_subs_id e &amp;&amp; is_lift_id lfts then
        mkProd (n, to_constr lfts t, c)
      else
        let subs' = comp_subs lfts e in
        mkProd (n, to_constr lfts t, subst_constr (subs_lift subs') c)
    | FLetIn (n,b,t,f,e) -&gt;
      let subs = comp_subs (el_lift lfts) (subs_lift e) in
        mkLetIn (n, to_constr lfts b,
                    to_constr lfts t,
                    subst_constr subs f)
    | FEvar ((ev,args),env) -&gt;
      let subs = comp_subs lfts env in
        mkEvar(ev,Array.map (fun a -&gt; subst_constr subs a) args)
    | FLIFT (k,a) -&gt; to_constr (el_shft k lfts) a

    | FInt i -&gt;
       Constr.mkInt i

    | FCLOS (t,env) -&gt;
      if is_subs_id env &amp;&amp; is_lift_id lfts then t
      else
        let subs = comp_subs lfts env in
        subst_constr subs t
    | FLOCKED -&gt; assert false (*mkVar(Id.of_string&quot;_LOCK_&quot;)*)

and subst_constr subst c = match [@ocaml.warning &quot;-4&quot;] Constr.kind c with
| Rel i -&gt;
  begin match expand_rel i subst with
  | Inl (k, lazy v) -&gt; Vars.lift k v
  | Inr (m, _) -&gt; mkRel m
  end
| _ -&gt;
  Constr.map_with_binders Esubst.subs_lift subst_constr subst c

and comp_subs el s =
  Esubst.lift_subst (fun el c -&gt; lazy (to_constr el c)) el s

(* This function defines the correspondence between constr and
   fconstr. When we find a closure whose substitution is the identity,
   then we directly return the constr to avoid possibly huge
   reallocation. *)
let term_of_fconstr c = to_constr el_id c

(* fstrong applies unfreeze_fun recursively on the (freeze) term and
 * yields a term.  Assumes that the unfreeze_fun never returns a
 * FCLOS term.
let rec fstrong unfreeze_fun lfts v =
  to_constr (fstrong unfreeze_fun) lfts (unfreeze_fun v)
*)

let rec zip m stk =
  match stk with
    | [] -&gt; m
    | Zapp args :: s -&gt; zip {mark=Mark.neutr m.mark; term=FApp(m, args)} s
    | ZcaseT(ci,p,br,e)::s -&gt;
        let t = FCaseT(ci, p, m, br, e) in
        let mark = mark (neutr (Mark.red_state m.mark)) Unknown  in
        zip {mark; term=t} s
    | Zproj p :: s -&gt;
        let mark = mark (neutr (Mark.red_state m.mark)) Unknown in
        zip {mark; term=FProj(Projection.make p true,m)} s
    | Zfix(fx,par)::s -&gt;
        zip fx (par @ append_stack [|m|] s)
    | Zshift(n)::s -&gt;
        zip (lift_fconstr n m) s
    | Zupdate(rf)::s -&gt;
      (** The stack contains [Zupdate] marks only if in sharing mode *)
        zip (update ~share:true rf m.mark m.term) s
    | Zprimitive(_op,c,rargs,kargs)::s -&gt;
      let args = List.rev_append rargs (m::List.map snd kargs) in
      let f = {mark = mark Red Unknown;term = FFlex (ConstKey c)} in
      zip {mark=mark (neutr (Mark.red_state m.mark)) KnownR; term = FApp (f, Array.of_list args)} s

let fapp_stack (m,stk) = zip m stk

(*********************************************************************)

(* The assertions in the functions below are granted because they are
   called only when m is a constructor, a cofix
   (strip_update_shift_app), a fix (get_nth_arg) or an abstraction
   (strip_update_shift, through get_arg). *)

(* optimised for the case where there are no shifts... *)
let strip_update_shift_app_red head stk =
  let rec strip_rec rstk h depth = function
    | Zshift(k) as e :: s -&gt;
        strip_rec (e::rstk) (lift_fconstr k h) (depth+k) s
    | (Zapp args :: s) -&gt;
        strip_rec (Zapp args :: rstk)
          {mark=h.mark;term=FApp(h,args)} depth s
    | Zupdate(m)::s -&gt;
      (** The stack contains [Zupdate] marks only if in sharing mode *)
        strip_rec rstk (update ~share:true m h.mark h.term) depth s
    | ((ZcaseT _ | Zproj _ | Zfix _ | Zprimitive _) :: _ | []) as stk -&gt;
      (depth,List.rev rstk, stk)
  in
  strip_rec [] head 0 stk

let strip_update_shift_app head stack =
  assert (match Mark.red_state head.mark with Red -&gt; false | Norm | Cstr | Whnf -&gt; true);
  strip_update_shift_app_red head stack

let get_nth_arg head n stk =
  assert (match Mark.red_state head.mark with Red -&gt; false | Norm | Cstr | Whnf -&gt; true);
  let rec strip_rec rstk h n = function
    | Zshift(k) as e :: s -&gt;
        strip_rec (e::rstk) (lift_fconstr k h) n s
    | Zapp args::s' -&gt;
        let q = Array.length args in
        if n &gt;= q
        then
          strip_rec (Zapp args::rstk) {mark=h.mark;term=FApp(h,args)} (n-q) s'
        else
          let bef = Array.sub args 0 n in
          let aft = Array.sub args (n+1) (q-n-1) in
          let stk' =
            List.rev (if Int.equal n 0 then rstk else (Zapp bef :: rstk)) in
          (Some (stk', args.(n)), append_stack aft s')
    | Zupdate(m)::s -&gt;
        (** The stack contains [Zupdate] mark only if in sharing mode *)
        strip_rec rstk (update ~share:true m h.mark h.term) n s
    | ((ZcaseT _ | Zproj _ | Zfix _ | Zprimitive _) :: _ | []) as s -&gt; (None, List.rev rstk @ s) in
  strip_rec [] head n stk

(* Beta reduction: look for an applied argument in the stack.
   Since the encountered update marks are removed, h must be a whnf *)
let rec get_args n tys f e = function
    | Zupdate r :: s -&gt;
        (** The stack contains [Zupdate] mark only if in sharing mode *)
        let _hd = update ~share:true r (mark Cstr (Mark.relevance r.mark)) (FLambda(n,tys,f,e)) in
        get_args n tys f e s
    | Zshift k :: s -&gt;
        get_args n tys f (subs_shft (k,e)) s
    | Zapp l :: s -&gt;
        let na = Array.length l in
        if n == na then (Inl (subs_cons(l,e)),s)
        else if n &lt; na then (* more arguments *)
          let args = Array.sub l 0 n in
          let eargs = Array.sub l n (na-n) in
          (Inl (subs_cons(args,e)), Zapp eargs :: s)
        else (* more lambdas *)
          let etys = List.skipn na tys in
          get_args (n-na) etys f (subs_cons(l,e)) s
    | ((ZcaseT _ | Zproj _ | Zfix _ | Zprimitive _) :: _ | []) as stk -&gt;
      (Inr {mark=mark Cstr Unknown;term=FLambda(n,tys,f,e)}, stk)

(* Eta expansion: add a reference to implicit surrounding lambda at end of stack *)
let rec eta_expand_stack = function
  | (Zapp _ | Zfix _ | ZcaseT _ | Zproj _
        | Zshift _ | Zupdate _ | Zprimitive _ as e) :: s -&gt;
      e :: eta_expand_stack s
  | [] -&gt;
      [Zshift 1; Zapp [|{mark=mark Norm Unknown; term= FRel 1}|]]

(* Get the arguments of a native operator *)
let rec skip_native_args rargs nargs =
  match nargs with
  | (kd, a) :: nargs' -&gt;
      if kd = CPrimitives.Kwhnf then rargs, nargs
      else skip_native_args (a::rargs) nargs'
  | [] -&gt; rargs, []

let get_native_args op c stk =
  let kargs = CPrimitives.kind op in
  let rec get_args rnargs kargs args =
    match kargs, args with
    | kd::kargs, a::args -&gt; get_args ((kd,a)::rnargs) kargs args
    | _, _ -&gt; rnargs, kargs, args in
  let rec strip_rec rnargs h depth kargs = function
    | Zshift k :: s -&gt;
      strip_rec (List.map (fun (kd,f) -&gt; kd,lift_fconstr k f) rnargs)
        (lift_fconstr k h) (depth+k) kargs s
    | Zapp args :: s' -&gt;
      begin match get_args rnargs kargs (Array.to_list args) with
        | rnargs, [], [] -&gt;
          (skip_native_args [] (List.rev rnargs), s')
        | rnargs, [], eargs -&gt;
          (skip_native_args [] (List.rev rnargs),
           Zapp (Array.of_list eargs) :: s')
        | rnargs, kargs, _ -&gt;
          strip_rec rnargs {mark = h.mark;term=FApp(h, args)} depth kargs s'
      end
    | Zupdate(m) :: s -&gt;
      strip_rec rnargs (update ~share:true m h.mark h.term) depth  kargs s
    | (Zprimitive _ | ZcaseT _ | Zproj _ | Zfix _) :: _ | [] -&gt; assert false
  in strip_rec [] {mark = mark Red Unknown;term = FFlex(ConstKey c)} 0 kargs stk

let get_native_args1 op c stk =
  match get_native_args op c stk with
  | ((rargs, (kd,a):: nargs), stk) -&gt;
      assert (kd = CPrimitives.Kwhnf);
      (rargs, a, nargs, stk)
  | _ -&gt; assert false

let check_native_args op stk =
  let nargs = CPrimitives.arity op in
  let rargs = stack_args_size stk in
  nargs &lt;= rargs


(* Iota reduction: extract the arguments to be passed to the Case
   branches *)
let rec reloc_rargs_rec depth = function
  | Zapp args :: s -&gt;
    Zapp (lift_fconstr_vect depth args) :: reloc_rargs_rec depth s
  | Zshift(k)::s -&gt; if Int.equal k depth then s else reloc_rargs_rec (depth-k) s
  | ((ZcaseT _ | Zproj _ | Zfix _ | Zupdate _ | Zprimitive _) :: _ | []) as stk -&gt; stk

let reloc_rargs depth stk =
  if Int.equal depth 0 then stk else reloc_rargs_rec depth stk

let rec try_drop_parameters depth n = function
    | Zapp args::s -&gt;
        let q = Array.length args in
        if n &gt; q then try_drop_parameters depth (n-q) s
        else if Int.equal n q then reloc_rargs depth s
        else
          let aft = Array.sub args n (q-n) in
          reloc_rargs depth (append_stack aft s)
    | Zshift(k)::s -&gt; try_drop_parameters (depth-k) n s
    | [] -&gt;
	if Int.equal n 0 then []
	else raise Not_found
    | (ZcaseT _ | Zproj _ | Zfix _ | Zupdate _ | Zprimitive _) :: _ -&gt; assert false
	(* strip_update_shift_app only produces Zapp and Zshift items *)

let drop_parameters depth n argstk =
  try try_drop_parameters depth n argstk
  with Not_found -&gt;
  (* we know that n &lt; stack_args_size(argstk) (if well-typed term) *)
  anomaly (Pp.str &quot;ill-typed term: found a match on a partially applied constructor.&quot;)

(** [eta_expand_ind_stack env ind c s t] computes stacks corresponding
    to the conversion of the eta expansion of t, considered as an inhabitant
    of ind, and the Constructor c of this inductive type applied to arguments
    s.
    @assumes [t] is an irreducible term, and not a constructor. [ind] is the inductive
    of the constructor term [c]
    @raise Not_found if the inductive is not a primitive record, or if the
    constructor is partially applied.
 *)
let eta_expand_ind_stack env ind m s (f, s') =
  let open Declarations in
  let mib = lookup_mind (fst ind) env in
  (* disallow eta-exp for non-primitive records *)
  if not (mib.mind_finite == BiFinite) then raise Not_found;
  match Declareops.inductive_make_projections ind mib with
  | Some projs -&gt;
    (* (Construct, pars1 .. parsm :: arg1...argn :: []) ~= (f, s') -&gt;
	   arg1..argn ~= (proj1 t...projn t) where t = zip (f,s') *)
    let pars = mib.Declarations.mind_nparams in
    let right = fapp_stack (f, s') in
    let (depth, args, _s) = strip_update_shift_app m s in
    (** Try to drop the params, might fail on partially applied constructors. *)
    let argss = try_drop_parameters depth pars args in
    let hstack = Array.map (fun p -&gt;
        { mark = mark Red Unknown; (* right can't be a constructor though *)
          term = FProj (Projection.make p true, right) })
        projs
    in
    argss, [Zapp hstack]
  | None -&gt; raise Not_found (* disallow eta-exp for non-primitive records *)

let rec project_nth_arg n = function
  | Zapp args :: s -&gt;
      let q = Array.length args in
	if n &gt;= q then project_nth_arg (n - q) s
	else (* n &lt; q *) args.(n)
  | (ZcaseT _ | Zproj _ | Zfix _ | Zupdate _ | Zshift _ | Zprimitive _) :: _ | [] -&gt; assert false
      (* After drop_parameters we have a purely applicative stack *)


(* Iota reduction: expansion of a fixpoint.
 * Given a fixpoint and a substitution, returns the corresponding
 * fixpoint body, and the substitution in which it should be
 * evaluated: its first variables are the fixpoint bodies
 *
 * FCLOS(fix Fi {F0 := T0 .. Fn-1 := Tn-1}, S)
 *    -&gt; (S. FCLOS(F0,S) . ... . FCLOS(Fn-1,S), Ti)
 *)
(* does not deal with FLIFT *)
let contract_fix_vect fix =
  let (thisbody, make_body, env, nfix) =
    match [@ocaml.warning &quot;-4&quot;] fix with
      | FFix (((reci,i),(nas,_,bds as rdcl)),env) -&gt;
          (bds.(i),
           (fun j -&gt; { mark = mark Cstr (opt_of_rel nas.(j).binder_relevance);
                       term = FFix (((reci,j),rdcl),env) }),
	   env, Array.length bds)
      | FCoFix ((i,(nas,_,bds as rdcl)),env) -&gt;
          (bds.(i),
           (fun j -&gt; { mark = mark Cstr (opt_of_rel nas.(j).binder_relevance);
                       term = FCoFix ((j,rdcl),env) }),
	   env, Array.length bds)
      | _ -&gt; assert false
  in
  (subs_cons(Array.init nfix make_body, env), thisbody)

let unfold_projection info p =
  if red_projection info.i_flags p
  then
    Some (Zproj (Projection.repr p))
  else None

(*********************************************************************)
(* A machine that inspects the head of a term until it finds an
   atom or a subterm that may produce a redex (abstraction,
   constructor, cofix, letin, constant), or a neutral term (product,
   inductive) *)
let rec knh info m stk =
  match m.term with
    | FLIFT(k,a) -&gt; knh info a (zshift k stk)
    | FCLOS(t,e) -&gt; knht info e t (zupdate info m stk)
    | FLOCKED -&gt; assert false
    | FApp(a,b) -&gt; knh info a (append_stack b (zupdate info m stk))
    | FCaseT(ci,p,t,br,e) -&gt; knh info t (ZcaseT(ci,p,br,e)::zupdate info m stk)
    | FFix(((ri,n),_),_) -&gt;
        (match get_nth_arg m ri.(n) stk with
             (Some(pars,arg),stk') -&gt; knh info arg (Zfix(m,pars)::stk')
           | (None, stk') -&gt; (m,stk'))
    | FProj (p,c) -&gt;
      (match unfold_projection info p with
       | None -&gt; (m, stk)
       | Some s -&gt; knh info c (s :: zupdate info m stk))

(* cases where knh stops *)
    | (FFlex _|FLetIn _|FConstruct _|FEvar _|
       FCoFix _|FLambda _|FRel _|FAtom _|FInd _|FProd _|FInt _) -&gt;
        (m, stk)

(* The same for pure terms *)
and knht info e t stk =
  match kind t with
    | App(a,b) -&gt;
        knht info e a (append_stack (mk_clos_vect e b) stk)
    | Case(ci,p,t,br) -&gt;
        knht info e t (ZcaseT(ci, p, br, e)::stk)
    | Fix fx -&gt; knh info { mark = mark Cstr Unknown; term = FFix (fx, e) } stk
    | Cast(a,_,_) -&gt; knht info e a stk
    | Rel n -&gt; knh info (clos_rel e n) stk
    | Proj (p, c) -&gt; knh info { mark = mark Red Unknown; term = FProj (p, mk_clos e c) } stk
    | (Ind _|Const _|Construct _|Var _|Meta _ | Sort _ | Int _) -&gt; (mk_clos e t, stk)
    | CoFix cfx -&gt; { mark = mark Cstr Unknown; term = FCoFix (cfx,e) }, stk
    | Lambda _ -&gt; { mark = mark Cstr Unknown; term = mk_lambda e t }, stk
    | Prod (n, t, c) -&gt;
      { mark = mark Whnf KnownR; term = FProd (n, mk_clos e t, c, e) }, stk
    | LetIn (n,b,t,c) -&gt;
      { mark = mark Red Unknown; term = FLetIn (n, mk_clos e b, mk_clos e t, c, e) }, stk
    | Evar ev -&gt; { mark = mark Red Unknown; term = FEvar (ev, e) }, stk

let inject c = mk_clos (subs_id 0) c

(************************************************************************)
(* Reduction of Native operators                                        *)

open Primred

module FNativeEntries =
  struct
    type elem = fconstr
    type args = fconstr array
    type evd = unit

    let get = Array.get

    let get_int () e =
      match [@ocaml.warning &quot;-4&quot;] e.term with
      | FInt i -&gt; i
      | _ -&gt; raise Primred.NativeDestKO

    let dummy = {mark = mark Norm KnownR; term = FRel 0}

    let current_retro = ref Retroknowledge.empty
    let defined_int = ref false
    let fint = ref dummy

    let init_int retro =
      match retro.Retroknowledge.retro_int63 with
      | Some c -&gt;
        defined_int := true;
        fint := { mark = mark Norm KnownR; term = FFlex (ConstKey (Univ.in_punivs c)) }
      | None -&gt; defined_int := false

    let defined_bool = ref false
    let ftrue = ref dummy
    let ffalse = ref dummy

    let init_bool retro =
      match retro.Retroknowledge.retro_bool with
      | Some (ct,cf) -&gt;
        defined_bool := true;
        ftrue := { mark = mark Cstr KnownR; term = FConstruct (Univ.in_punivs ct) };
        ffalse := { mark = mark Cstr KnownR; term = FConstruct (Univ.in_punivs cf) }
      | None -&gt; defined_bool :=false

    let defined_carry = ref false
    let fC0 = ref dummy
    let fC1 = ref dummy

    let init_carry retro =
      match retro.Retroknowledge.retro_carry with
      | Some(c0,c1) -&gt;
        defined_carry := true;
        fC0 := { mark = mark Cstr KnownR; term = FConstruct (Univ.in_punivs c0) };
        fC1 := { mark = mark Cstr KnownR; term = FConstruct (Univ.in_punivs c1) }
      | None -&gt; defined_carry := false

    let defined_pair = ref false
    let fPair = ref dummy

    let init_pair retro =
      match retro.Retroknowledge.retro_pair with
      | Some c -&gt;
        defined_pair := true;
        fPair := { mark = mark Cstr KnownR; term = FConstruct (Univ.in_punivs c) }
      | None -&gt; defined_pair := false

    let defined_cmp = ref false
    let fEq = ref dummy
    let fLt = ref dummy
    let fGt = ref dummy

    let init_cmp retro =
      match retro.Retroknowledge.retro_cmp with
      | Some (cEq, cLt, cGt) -&gt;
        defined_cmp := true;
        fEq := { mark = mark Cstr KnownR; term = FConstruct (Univ.in_punivs cEq) };
        fLt := { mark = mark Cstr KnownR; term = FConstruct (Univ.in_punivs cLt) };
        fGt := { mark = mark Cstr KnownR; term = FConstruct (Univ.in_punivs cGt) }
      | None -&gt; defined_cmp := false

    let defined_refl = ref false

    let frefl = ref dummy

    let init_refl retro =
      match retro.Retroknowledge.retro_refl with
      | Some crefl -&gt;
        defined_refl := true;
        frefl := { mark = mark Cstr KnownR; term = FConstruct (Univ.in_punivs crefl) }
      | None -&gt; defined_refl := false

    let init env =
      current_retro := env.retroknowledge;
      init_int !current_retro;
      init_bool !current_retro;
      init_carry !current_retro;
      init_pair !current_retro;
      init_cmp !current_retro;
      init_refl !current_retro

    let check_env env =
      if not (!current_retro == env.retroknowledge) then init env

    let check_int env =
      check_env env;
      assert (!defined_int)

    let check_bool env =
      check_env env;
      assert (!defined_bool)

    let check_carry env =
      check_env env;
      assert (!defined_carry &amp;&amp; !defined_int)

    let check_pair env =
      check_env env;
      assert (!defined_pair &amp;&amp; !defined_int)

    let check_cmp env =
      check_env env;
      assert (!defined_cmp)

    let mkInt env i =
      check_int env;
      { mark = mark Cstr KnownR; term = FInt i }

    let mkBool env b =
      check_bool env;
      if b then !ftrue else !ffalse

    let mkCarry env b e =
      check_carry env;
      {mark = mark Cstr KnownR;
       term = FApp ((if b then !fC1 else !fC0),[|!fint;e|])}

    let mkIntPair env e1 e2 =
      check_pair env;
      { mark = mark Cstr KnownR; term = FApp(!fPair, [|!fint;!fint;e1;e2|]) }

    let mkLt env =
      check_cmp env;
      !fLt

    let mkEq env =
      check_cmp env;
      !fEq

    let mkGt env =
      check_cmp env;
      !fGt

  end

module FredNative = RedNative(FNativeEntries)

(************************************************************************)

(* Computes a weak head normal form from the result of knh. *)
let rec knr info tab m stk =
  match m.term with
  | FLambda(n,tys,f,e) when red_set info.i_flags fBETA -&gt;
      (match get_args n tys f e stk with
          Inl e', s -&gt; knit info tab e' f s
        | Inr lam, s -&gt; (lam,s))
  | FFlex(ConstKey (kn,_ as c)) when red_set info.i_flags (fCONST kn) -&gt;
      (match ref_value_cache info tab (ConstKey c) with
        | Def v -&gt; kni info tab v stk
        | Primitive op when check_native_args op stk -&gt;
          let rargs, a, nargs, stk = get_native_args1 op c stk in
          kni info tab a (Zprimitive(op,c,rargs,nargs)::stk)
        | Undef _ | OpaqueDef _ | Primitive _ -&gt; (set_norm m; (m,stk)))
  | FFlex(VarKey id) when red_set info.i_flags (fVAR id) -&gt;
      (match ref_value_cache info tab (VarKey id) with
        | Def v -&gt; kni info tab v stk
        | Primitive _ -&gt; assert false
        | OpaqueDef _ | Undef _ -&gt; (set_norm m; (m,stk)))
  | FFlex(RelKey k) when red_set info.i_flags fDELTA -&gt;
      (match ref_value_cache info tab (RelKey k) with
        | Def v -&gt; kni info tab v stk
        | Primitive _ -&gt; assert false
        | OpaqueDef _ | Undef _ -&gt; (set_norm m; (m,stk)))
  | FConstruct((_ind,c),_u) -&gt;
     let use_match = red_set info.i_flags fMATCH in
     let use_fix = red_set info.i_flags fFIX in
     if use_match || use_fix then
      (match [@ocaml.warning &quot;-4&quot;] strip_update_shift_app m stk with
        | (depth, args, ZcaseT(ci,_,br,e)::s) when use_match -&gt;
            assert (ci.ci_npar&gt;=0);
            let rargs = drop_parameters depth ci.ci_npar args in
            knit info tab e br.(c-1) (rargs@s)
        | (_, cargs, Zfix(fx,par)::s) when use_fix -&gt;
            let rarg = fapp_stack(m,cargs) in
            let stk' = par @ append_stack [|rarg|] s in
            let (fxe,fxbd) = contract_fix_vect fx.term in
            knit info tab fxe fxbd stk'
        | (depth, args, Zproj p::s) when use_match -&gt;
            let rargs = drop_parameters depth (Projection.Repr.npars p) args in
            let rarg = project_nth_arg (Projection.Repr.arg p) rargs in
            kni info tab rarg s
        | (_,args,s) -&gt; (m,args@s))
     else (m,stk)
  | FCoFix _ when red_set info.i_flags fCOFIX -&gt;
      (match strip_update_shift_app m stk with
        | (_, args, (((ZcaseT _|Zproj _)::_) as stk')) -&gt;
            let (fxe,fxbd) = contract_fix_vect m.term in
            knit info tab fxe fxbd (args@stk')
        | (_,args, ((Zapp _ | Zfix _ | Zshift _ | Zupdate _ | Zprimitive _) :: _ | [] as s)) -&gt; (m,args@s))
  | FLetIn (_,v,_,bd,e) when red_set info.i_flags fZETA -&gt;
      knit info tab (subs_cons([|v|],e)) bd stk
  | FEvar(ev,env) -&gt;
      (match info.i_cache.i_sigma ev with
          Some c -&gt; knit info tab env c stk
        | None -&gt; (m,stk))
  | FInt _ -&gt;
    (match [@ocaml.warning &quot;-4&quot;] strip_update_shift_app m stk with
     | (_, _, Zprimitive(op,c,rargs,nargs)::s) -&gt;
       let (rargs, nargs) = skip_native_args (m::rargs) nargs in
       begin match nargs with
         | [] -&gt;
           let args = Array.of_list (List.rev rargs) in
           begin match FredNative.red_prim (info_env info) () op args with
             | Some m -&gt; kni info tab m s
             | None -&gt;
               let f = {mark = mark Whnf KnownR; term = FFlex (ConstKey c)} in
               let m = {mark = mark Whnf KnownR; term = FApp(f,args)} in
               (m,s)
           end
         | (kd,a)::nargs -&gt;
           assert (kd = CPrimitives.Kwhnf);
           kni info tab a (Zprimitive(op,c,rargs,nargs)::s)
             end
     | (_, _, s) -&gt; (m, s))
  | FLOCKED | FRel _ | FAtom _ | FFlex (RelKey _ | ConstKey _ | VarKey _) | FInd _ | FApp _ | FProj _
    | FFix _ | FCoFix _ | FCaseT _ | FLambda _ | FProd _ | FLetIn _ | FLIFT _
    | FCLOS _ -&gt; (m, stk)


(* Computes the weak head normal form of a term *)
and kni info tab m stk =
  let (hm,s) = knh info m stk in
  knr info tab hm s
and knit info tab e t stk =
  let (ht,s) = knht info e t stk in
  knr info tab ht s

let kh info tab v stk = fapp_stack(kni info tab v stk)

(************************************************************************)

let rec zip_term zfun m stk =
  match stk with
    | [] -&gt; m
    | Zapp args :: s -&gt;
        zip_term zfun (mkApp(m, Array.map zfun args)) s
    | ZcaseT(ci,p,br,e)::s -&gt;
        let t = mkCase(ci, zfun (mk_clos e p), m,
		       Array.map (fun b -&gt; zfun (mk_clos e b)) br) in
        zip_term zfun t s
    | Zproj p::s -&gt;
        let t = mkProj (Projection.make p true, m) in
	zip_term zfun t s
    | Zfix(fx,par)::s -&gt;
        let h = mkApp(zip_term zfun (zfun fx) par,[|m|]) in
        zip_term zfun h s
    | Zshift(n)::s -&gt;
        zip_term zfun (lift n m) s
    | Zupdate(_rf)::s -&gt;
        zip_term zfun m s
    | Zprimitive(_,c,rargs, kargs)::s -&gt;
        let kargs = List.map (fun (_,a) -&gt; zfun a) kargs in
        let args =
          List.fold_left (fun args a -&gt; zfun a ::args) (m::kargs) rargs in
        let h = mkApp (mkConstU c, Array.of_list args) in
        zip_term zfun h s

(* Computes the strong normal form of a term.
   1- Calls kni
   2- tries to rebuild the term. If a closure still has to be computed,
      calls itself recursively. *)
let rec kl info tab m =
  let share = info.i_cache.i_share in
  if is_val m then (incr prune; term_of_fconstr m)
  else
    let (nm,s) = kni info tab m [] in
    let () = if share then ignore (fapp_stack (nm, s)) in (* to unlock Zupdates! *)
    zip_term (kl info tab) (norm_head info tab nm) s

(* no redex: go up for atoms and already normalized terms, go down
   otherwise. *)
and norm_head info tab m =
  if is_val m then (incr prune; term_of_fconstr m) else
    match m.term with
      | FLambda(_n,tys,f,e) -&gt;
        let (e',info,rvtys) =
          List.fold_left (fun (e,info,ctxt) (na,ty) -&gt;
              (subs_lift e, info, (na,kl info tab (mk_clos e ty))::ctxt))
            (e,info,[]) tys in
        let bd = kl info tab (mk_clos e' f) in
        List.fold_left (fun b (na,ty) -&gt; mkLambda(na,ty,b)) bd rvtys
      | FLetIn(na,a,b,f,e) -&gt;
          let c = mk_clos (subs_lift e) f in
          mkLetIn(na, kl info tab a, kl info tab b, kl info tab c)
      | FProd(na,dom,rng,e) -&gt;
          mkProd(na, kl info tab dom, kl info tab (mk_clos (subs_lift e) rng))
      | FCoFix((n,(na,tys,bds)),e) -&gt;
          let ftys = Array.Fun1.map mk_clos e tys in
          let fbds =
            Array.Fun1.map mk_clos (subs_liftn (Array.length na) e) bds in
          mkCoFix(n,(na, CArray.map (kl info tab) ftys, CArray.map (kl info tab) fbds))
      | FFix((n,(na,tys,bds)),e) -&gt;
          let ftys = Array.Fun1.map mk_clos e tys in
          let fbds =
            Array.Fun1.map mk_clos (subs_liftn (Array.length na) e) bds in
          mkFix(n,(na, CArray.map (kl info tab) ftys, CArray.map (kl info tab) fbds))
      | FEvar((i,args),env) -&gt;
          mkEvar(i, Array.map (fun a -&gt; kl info tab (mk_clos env a)) args)
      | FProj (p,c) -&gt;
          mkProj (p, kl info tab c)
      | FLOCKED | FRel _ | FAtom _ | FFlex _ | FInd _ | FConstruct _
        | FApp _ | FCaseT _ | FLIFT _ | FCLOS _ | FInt _ -&gt; term_of_fconstr m

(* Initialization and then normalization *)

(* weak reduction *)
let whd_val info tab v =
  with_stats (lazy (term_of_fconstr (kh info tab v [])))

(* strong reduction *)
let norm_val info tab v =
  with_stats (lazy (kl info tab v))

let whd_stack infos tab m stk = match Mark.red_state m.mark with
| Whnf | Norm -&gt;
  (** No need to perform [kni] nor to unlock updates because
      every head subterm of [m] is [Whnf] or [Norm] *)
  knh infos m stk
| Red | Cstr -&gt;
  let k = kni infos tab m stk in
  let () = if infos.i_cache.i_share then ignore (fapp_stack k) in (* to unlock Zupdates! *)
  k

let create_clos_infos ?(evars=fun _ -&gt; None) flgs env =
  let share = (Environ.typing_flags env).Declarations.share_reduction in
  let cache = {
    i_env = env;
    i_sigma = evars;
    i_share = share;
  } in
  { i_flags = flgs; i_cache = cache }

let create_tab () = KeyTable.create 17

let oracle_of_infos infos = Environ.oracle infos.i_cache.i_env

let infos_with_reds infos reds =
  { infos with i_flags = reds }

let unfold_reference info tab key =
  match key with
  | ConstKey (kn,_) -&gt;
    if red_set info.i_flags (fCONST kn) then
      ref_value_cache info tab key
    else Undef None
  | VarKey i -&gt;
    if red_set info.i_flags (fVAR i) then
      ref_value_cache info tab key
    else Undef None
  | RelKey _ -&gt; ref_value_cache info tab key

let relevance_of f = Mark.relevance f.mark
let set_relevance r f = f.mark &lt;- Mark.mark (Mark.red_state f.mark) (opt_of_rel r)
</pre>
          </div>
          <div class="col-md-6">
            <code>cClosure.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import CErrors.

Import Util.

Import Pp.

Import Names.

Import Constr.

Import Declarations.

Import Context.

Import Environ.

Import Vars.

Import Esubst.

Definition stats : Stdlib.ref bool := Stdlib.ref false.

Definition beta : Stdlib.ref Z := Stdlib.ref 0.

Definition delta : Stdlib.ref Z := Stdlib.ref 0.

Definition eta : Stdlib.ref Z := Stdlib.ref 0.

Definition zeta : Stdlib.ref Z := Stdlib.ref 0.

Definition evar : Stdlib.ref Z := Stdlib.ref 0.

Definition nb_match : Stdlib.ref Z := Stdlib.ref 0.

Definition fix : Stdlib.ref Z := Stdlib.ref 0.

Definition cofix : Stdlib.ref Z := Stdlib.ref 0.

Definition prune : Stdlib.ref Z := Stdlib.ref 0.

Definition reset (function_parameter : unit) : unit :=
  match function_parameter with
  | tt =&gt;
    Stdlib.op_colon_eq beta 0;
    Stdlib.op_colon_eq delta 0;
    Stdlib.op_colon_eq zeta 0;
    Stdlib.op_colon_eq evar 0;
    Stdlib.op_colon_eq nb_match 0;
    Stdlib.op_colon_eq fix 0;
    Stdlib.op_colon_eq cofix 0;
    Stdlib.op_colon_eq evar 0;
    Stdlib.op_colon_eq prune 0
  end.

Definition stop (function_parameter : unit) : unit :=
  match function_parameter with
  | tt =&gt;
    Feedback.msg_debug None
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus
            (Pp.op_plus_plus
              (Pp.op_plus_plus
                (Pp.op_plus_plus
                  (Pp.op_plus_plus
                    (Pp.op_plus_plus
                      (Pp.op_plus_plus
                        (Pp.op_plus_plus
                          (Pp.op_plus_plus
                            (Pp.op_plus_plus
                              (Pp.op_plus_plus
                                (Pp.op_plus_plus
                                  (Pp.op_plus_plus
                                    (Pp.op_plus_plus
                                      (Pp.op_plus_plus
                                        (Pp.op_plus_plus
                                          (Pp.str &quot;[Reds: beta=&quot; % string)
                                          (Pp.int (Util.op_exclamation beta)))
                                        (Pp.str &quot; delta=&quot; % string))
                                      (Pp.int (Util.op_exclamation delta)))
                                    (Pp.str &quot; eta=&quot; % string))
                                  (Pp.int (Util.op_exclamation eta)))
                                (Pp.str &quot; zeta=&quot; % string))
                              (Pp.int (Util.op_exclamation zeta)))
                            (Pp.str &quot; evar=&quot; % string))
                          (Pp.int (Util.op_exclamation evar)))
                        (Pp.str &quot; match=&quot; % string))
                      (Pp.int (Util.op_exclamation nb_match)))
                    (Pp.str &quot; fix=&quot; % string))
                  (Pp.int (Util.op_exclamation fix)))
                (Pp.str &quot; cofix=&quot; % string))
              (Pp.int (Util.op_exclamation cofix))) (Pp.str &quot; prune=&quot; % string))
          (Pp.int (Util.op_exclamation prune))) (Pp.str &quot;]&quot; % string))
  end.

Definition incr_cnt (red : bool) (cnt : Stdlib.ref Z) : bool :=
  if red then
    if Util.op_exclamation stats then
      Stdlib.incr cnt
    else
      tt;
    true
  else
    false.

Definition with_stats {A : Type} (c : Stdlib.Lazy.t A) : A :=
  if Util.op_exclamation stats then
    reset tt;
    let r := Stdlib.Lazy.force c in
    stop tt;
    r
  else
    Stdlib.Lazy.force c.

Definition all_opaque : TransparentState.t := TransparentState.empty.

Definition all_transparent : TransparentState.t := TransparentState.full.

Module RedFlagsSig.
  Record signature {reds red_kind : Type} := {
    reds := reds;
    red_kind := red_kind;
    fBETA : red_kind;
    fDELTA : red_kind;
    fETA : red_kind;
    fMATCH : red_kind;
    fFIX : red_kind;
    fCOFIX : red_kind;
    fZETA : red_kind;
    fCONST : Names.Constant.t -&gt; red_kind;
    fVAR : Names.Id.t -&gt; red_kind;
    no_red : reds;
    red_add : reds -&gt; red_kind -&gt; reds;
    red_sub : reds -&gt; red_kind -&gt; reds;
    red_add_transparent : reds -&gt; TransparentState.t -&gt; reds;
    red_transparent : reds -&gt; TransparentState.t;
    mkflags : (list red_kind) -&gt; reds;
    red_set : reds -&gt; red_kind -&gt; bool;
    red_projection : reds -&gt; Names.Projection.t -&gt; bool;
  }.
  Arguments signature : clear implicits.
End RedFlagsSig.

Module RedFlags.
  Import TransparentState.
  
  Record reds := {
    r_beta : bool;
    r_delta : bool;
    r_eta : bool;
    r_const : TransparentState.t;
    r_zeta : bool;
    r_match : bool;
    r_fix : bool;
    r_cofix : bool }.
  
  Inductive red_kind : Type :=
  | BETA : red_kind
  | DELTA : red_kind
  | ETA : red_kind
  | MATCH : red_kind
  | FIX : red_kind
  | COFIX : red_kind
  | ZETA : red_kind
  | CONST : Names.Constant.t -&gt; red_kind
  | VAR : Names.Id.t -&gt; red_kind.
  
  Definition fBETA : red_kind := BETA.
  
  Definition fDELTA : red_kind := DELTA.
  
  Definition fETA : red_kind := ETA.
  
  Definition fMATCH : red_kind := MATCH.
  
  Definition fFIX : red_kind := FIX.
  
  Definition fCOFIX : red_kind := COFIX.
  
  Definition fZETA : red_kind := ZETA.
  
  Definition fCONST (kn : Names.Constant.t) : red_kind := CONST kn.
  
  Definition fVAR (id : Names.Id.t) : red_kind := VAR id.
  
  Definition no_red : reds :=
    {| r_beta := false; r_delta := false; r_eta := false; r_const := all_opaque;
      r_zeta := false; r_match := false; r_fix := false; r_cofix := false |}.
  
  Definition red_add (red : reds) (function_parameter : red_kind) : reds :=
    match function_parameter with
    | BETA =&gt; record
    | ETA =&gt; record
    | DELTA =&gt; record
    | CONST kn =&gt;
      let r := r_const red in
      record
    | MATCH =&gt; record
    | FIX =&gt; record
    | COFIX =&gt; record
    | ZETA =&gt; record
    | VAR id =&gt;
      let r := r_const red in
      record
    end.
  
  Definition red_sub (red : reds) (function_parameter : red_kind) : reds :=
    match function_parameter with
    | BETA =&gt; record
    | ETA =&gt; record
    | DELTA =&gt; record
    | CONST kn =&gt;
      let r := r_const red in
      record
    | MATCH =&gt; record
    | FIX =&gt; record
    | COFIX =&gt; record
    | ZETA =&gt; record
    | VAR id =&gt;
      let r := r_const red in
      record
    end.
  
  Definition red_transparent (red : reds) : TransparentState.t := r_const red.
  
  Definition red_add_transparent (red : reds) (tr : TransparentState.t)
    : reds := record.
  
  Definition mkflags : (list red_kind) -&gt; reds :=
    Util.List.(CList.ExtS.fold_left) red_add no_red.
  
  Definition red_set (red : reds) (function_parameter : red_kind) : bool :=
    match function_parameter with
    | BETA =&gt; incr_cnt (r_beta red) beta
    | ETA =&gt; incr_cnt (r_eta red) eta
    | CONST kn =&gt;
      let c := TransparentState.is_transparent_constant (r_const red) kn in
      incr_cnt c delta
    | VAR id =&gt;
      let c := TransparentState.is_transparent_variable (r_const red) id in
      incr_cnt c delta
    | ZETA =&gt; incr_cnt (r_zeta red) zeta
    | MATCH =&gt; incr_cnt (r_match red) nb_match
    | FIX =&gt; incr_cnt (r_fix red) fix
    | COFIX =&gt; incr_cnt (r_cofix red) cofix
    | DELTA =&gt; incr_cnt (r_delta red) delta
    end.
  
  Definition red_projection (red : reds) (p : Names.Projection.t) : bool :=
    if Names.Projection.unfolded p then
      true
    else
      red_set red (fCONST (Names.Projection.constant p)).
End RedFlags.

Import RedFlags.

Definition all : RedFlags.(RedFlagsSig.reds) :=
  RedFlags.(RedFlagsSig.mkflags)
    (cons RedFlags.(RedFlagsSig.fBETA)
      (cons RedFlags.(RedFlagsSig.fDELTA)
        (cons RedFlags.(RedFlagsSig.fZETA)
          (cons RedFlags.(RedFlagsSig.fMATCH)
            (cons RedFlags.(RedFlagsSig.fFIX)
              (cons RedFlags.(RedFlagsSig.fCOFIX) [])))))).

Definition allnolet : RedFlags.(RedFlagsSig.reds) :=
  RedFlags.(RedFlagsSig.mkflags)
    (cons RedFlags.(RedFlagsSig.fBETA)
      (cons RedFlags.(RedFlagsSig.fDELTA)
        (cons RedFlags.(RedFlagsSig.fMATCH)
          (cons RedFlags.(RedFlagsSig.fFIX)
            (cons RedFlags.(RedFlagsSig.fCOFIX) []))))).

Definition beta : RedFlags.(RedFlagsSig.reds) :=
  RedFlags.(RedFlagsSig.mkflags) (cons RedFlags.(RedFlagsSig.fBETA) []).

Definition betadeltazeta : RedFlags.(RedFlagsSig.reds) :=
  RedFlags.(RedFlagsSig.mkflags)
    (cons RedFlags.(RedFlagsSig.fBETA)
      (cons RedFlags.(RedFlagsSig.fDELTA) (cons RedFlags.(RedFlagsSig.fZETA) []))).

Definition betaiota : RedFlags.(RedFlagsSig.reds) :=
  RedFlags.(RedFlagsSig.mkflags)
    (cons RedFlags.(RedFlagsSig.fBETA)
      (cons RedFlags.(RedFlagsSig.fMATCH)
        (cons RedFlags.(RedFlagsSig.fFIX)
          (cons RedFlags.(RedFlagsSig.fCOFIX) [])))).

Definition betaiotazeta : RedFlags.(RedFlagsSig.reds) :=
  RedFlags.(RedFlagsSig.mkflags)
    (cons RedFlags.(RedFlagsSig.fBETA)
      (cons RedFlags.(RedFlagsSig.fMATCH)
        (cons RedFlags.(RedFlagsSig.fFIX)
          (cons RedFlags.(RedFlagsSig.fCOFIX)
            (cons RedFlags.(RedFlagsSig.fZETA) []))))).

Definition betazeta : RedFlags.(RedFlagsSig.reds) :=
  RedFlags.(RedFlagsSig.mkflags)
    (cons RedFlags.(RedFlagsSig.fBETA) (cons RedFlags.(RedFlagsSig.fZETA) [])).

Definition delta : RedFlags.(RedFlagsSig.reds) :=
  RedFlags.(RedFlagsSig.mkflags) (cons RedFlags.(RedFlagsSig.fDELTA) []).

Definition zeta : RedFlags.(RedFlagsSig.reds) :=
  RedFlags.(RedFlagsSig.mkflags) (cons RedFlags.(RedFlagsSig.fZETA) []).

Definition nored : RedFlags.(RedFlagsSig.reds) := RedFlags.(RedFlagsSig.no_red).

Definition table_key := Names.tableKey (Univ.puniverses Names.Constant.t).

Definition eq_pconstant_key
  (function_parameter : Names.Constant.t * Univ.Instance.t)
  : (Names.Constant.t * Univ.Instance.t) -&gt; bool :=
  match function_parameter with
  | (c, u) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (c', u') =&gt; andb (Names.eq_constant_key c c') (Univ.Instance.equal u u')
      end
  end.

Module IdKeyHash.
  Import Hashset.Combine.
  
  Definition t := table_key.
  
  Definition equal
    : (Names.tableKey (Names.Constant.t * Univ.Instance.t)) -&gt;
      (Names.tableKey (Names.Constant.t * Univ.Instance.t)) -&gt; bool :=
    Names.eq_table_key eq_pconstant_key.
  
  Definition hash {A : Type}
    (function_parameter : Names.tableKey (Names.Constant.t * A)) : Z :=
    match function_parameter with
    | ConstKey (c, _) =&gt;
      Hashset.Combine.combinesmall 1 (Names.Constant.UserOrd.hash c)
    | VarKey id =&gt; Hashset.Combine.combinesmall 2 (Names.Id.hash id)
    | RelKey i =&gt; Hashset.Combine.combinesmall 3 (Int.hash i)
    end.
End IdKeyHash.

Import Context.Named.Declaration.

Definition assoc_defined (id : Names.variable) (env : Environ.env)
  : Constr.constr :=
  match Environ.lookup_named id env with
  | LocalDef _ c _ =&gt; c
  | LocalAssum _ _ =&gt; Stdlib.raise OCaml.Not_found
  end.

Inductive red_state : Type :=
| Norm : red_state
| Cstr : red_state
| Whnf : red_state
| Red : red_state.

Definition neutr (function_parameter : red_state) : red_state :=
  match function_parameter with
  | Whnf | Norm =&gt; Whnf
  | Red | Cstr =&gt; Red
  end.

Inductive optrel : Type :=
| Unknown : optrel
| KnownR : optrel
| KnownI : optrel.

Definition opt_of_rel (function_parameter : Sorts.relevance) : optrel :=
  match function_parameter with
  | Sorts.Relevant =&gt; KnownR
  | Sorts.Irrelevant =&gt; KnownI
  end.

Module Mark.
  Definition t := Z.
  
  Definition of_state (function_parameter : red_state) : Z :=
    match function_parameter with
    | Norm =&gt; 0
    | Cstr =&gt; 1
    | Whnf =&gt; 2
    | Red =&gt; 3
    end.
  
  Definition of_relevance (function_parameter : optrel) : Z :=
    match function_parameter with
    | Unknown =&gt; 0
    | KnownR =&gt; 1
    | KnownI =&gt; 2
    end.
  
  Definition mark (state : red_state) (relevance : optrel) : Z :=
    Util.op_plus (Z.mul (of_state state) 4) (of_relevance relevance).
  
  Definition relevance (x : Z) : optrel :=
    match Z.land x 3 with
    | 0 =&gt; Unknown
    | 1 =&gt; KnownR
    | 2 =&gt; KnownI
    | _ =&gt; false
    end.
  
  Definition red_state (x : Z) : red_state :=
    match Z.land x 12 with
    | 0 =&gt; Norm
    | 4 =&gt; Cstr
    | 8 =&gt; Whnf
    | 12 =&gt; Red
    | _ =&gt; false
    end.
  
  Definition neutr (x : Z) : Z := Z.lor x 8.
  
  Definition set_norm (x : Z) : Z := Z.land x 3.
End Mark.

Definition mark : red_state -&gt; optrel -&gt; Mark.t := Mark.mark.

Inductive fterm : Type :=
| FRel : Z -&gt; fterm
| FAtom : Constr.constr -&gt; fterm
| FFlex : table_key -&gt; fterm
| FInd : Constr.pinductive -&gt; fterm
| FConstruct : Constr.pconstructor -&gt; fterm
| FApp : fconstr -&gt; (array fconstr) -&gt; fterm
| FProj : Names.Projection.t -&gt; fconstr -&gt; fterm
| FFix : Constr.fixpoint -&gt; (Esubst.subs fconstr) -&gt; fterm
| FCoFix : Constr.cofixpoint -&gt; (Esubst.subs fconstr) -&gt; fterm
| FCaseT : Constr.case_info -&gt; Constr.constr -&gt; fconstr -&gt; (array Constr.constr)
  -&gt; (Esubst.subs fconstr) -&gt; fterm
| FLambda : Z -&gt; (list ((Context.binder_annot Names.Name.t) * Constr.constr)) -&gt;
  Constr.constr -&gt; (Esubst.subs fconstr) -&gt; fterm
| FProd : (Context.binder_annot Names.Name.t) -&gt; fconstr -&gt; Constr.constr -&gt;
  (Esubst.subs fconstr) -&gt; fterm
| FLetIn : (Context.binder_annot Names.Name.t) -&gt; fconstr -&gt; fconstr -&gt;
  Constr.constr -&gt; (Esubst.subs fconstr) -&gt; fterm
| FEvar : Constr.existential -&gt; (Esubst.subs fconstr) -&gt; fterm
| FInt : Uint63.t -&gt; fterm
| FLIFT : Z -&gt; fconstr -&gt; fterm
| FCLOS : Constr.constr -&gt; (Esubst.subs fconstr) -&gt; fterm
| FLOCKED : fterm.

Definition fterm_of (v : fconstr) : fterm := term v.

Definition set_norm (v : fconstr) : unit := set_field.

Definition is_val (v : fconstr) : bool :=
  match Mark.red_state (mark v) with
  | Norm =&gt; true
  | Cstr | Whnf | Red =&gt; false
  end.

Definition mk_atom (c : Constr.constr) : fconstr :=
  {| mark := mark Norm Unknown; term := FAtom c |}.

Definition mk_red (f : fterm) : fconstr :=
  {| mark := mark Red Unknown; term := f |}.

Definition update (share : bool) (v1 : fconstr) (mark : Mark.t) (t : fterm)
  : fconstr :=
  if share then
    set_field;
    set_field;
    v1
  else
    {| mark := mark; term := t |}.

Record infos_cache := {
  i_env : Environ.env;
  i_sigma : Constr.existential -&gt; option Constr.constr;
  i_share : bool }.

Record clos_infos := {
  i_flags : RedFlags.(RedFlagsSig.reds);
  i_cache : infos_cache }.

Definition clos_tab :=
  KeyTable.t (Declarations.constant_def fconstr Util.Empty.t).

Definition info_flags (info : clos_infos) : RedFlags.(RedFlagsSig.reds) :=
  i_flags info.

Definition info_env (info : clos_infos) : Environ.env := i_env (i_cache info).

Definition next_native_args (a : Type) := list (CPrimitives.arg_kind * a).

Reserved Notation &quot;'stack&quot;.

Inductive stack_member : Type :=
| Zapp : (array fconstr) -&gt; stack_member
| ZcaseT : Constr.case_info -&gt; Constr.constr -&gt; (array Constr.constr) -&gt;
  (Esubst.subs fconstr) -&gt; stack_member
| Zproj : Names.Projection.Repr.t -&gt; stack_member
| Zfix : fconstr -&gt; 'stack -&gt; stack_member
| Zprimitive : CPrimitives.t -&gt; Constr.pconstant -&gt; (list fconstr) -&gt;
  (next_native_args fconstr) -&gt; stack_member
| Zshift : Z -&gt; stack_member
| Zupdate : fconstr -&gt; stack_member

where &quot;'stack&quot; := ( list stack_member).

Definition stack := 'stack.

Definition empty_stack {A : Type} : list A := [].

Definition append_stack (v : array fconstr) (s : list stack_member)
  : list stack_member :=
  if Int.equal (Util.Array.(CArray.ExtS.length) v) 0 then
    s
  else
    match s with
    | cons (Zapp l) s =&gt; cons (Zapp (Util.Array.(CArray.ExtS.append) v l)) s
    |
      cons
        (ZcaseT _ _ _ _ | Zproj _ | Zfix _ _ | Zshift _ | Zupdate _ |
          Zprimitive _ _ _ _) _ | [] =&gt; cons (Zapp v) s
    end.

Definition zshift (n : Z) (s : list stack_member) : list stack_member :=
  match (n, s) with
  | (0, _) =&gt; s
  | (_, cons (Zshift k) s) =&gt; cons (Zshift (Util.op_plus n k)) s
  |
    (_,
      cons
        (ZcaseT _ _ _ _ | Zproj _ | Zfix _ _ | Zapp _ | Zupdate _ |
          Zprimitive _ _ _ _) _) | (_, []) =&gt; cons (Zshift n) s
  end.

Fixpoint stack_args_size (function_parameter : list stack_member) : Z :=
  match function_parameter with
  | cons (Zapp v) s =&gt;
    Util.op_plus (Util.Array.(CArray.ExtS.length) v) (stack_args_size s)
  | cons (Zshift _) s =&gt; stack_args_size s
  | cons (Zupdate _) s =&gt; stack_args_size s
  | cons (ZcaseT _ _ _ _ | Zproj _ | Zfix _ _ | Zprimitive _ _ _ _) _ | [] =&gt; 0
  end.

Fixpoint lft_fconstr (n : Z) (ft : fconstr) : fconstr :=
  let r := Mark.relevance (mark ft) in
  match term ft with
  | FInd _ | FConstruct _ | FFlex (ConstKey _ | VarKey _) | FInt _ =&gt; ft
  | FRel i =&gt; {| mark := mark Norm r; term := FRel (Util.op_plus i n) |}
  | FLambda k tys f e =&gt;
    {| mark := mark Cstr r; term := FLambda k tys f (Esubst.subs_shft (n, e)) |}
  | FFix fx e =&gt;
    {| mark := mark Cstr r; term := FFix fx (Esubst.subs_shft (n, e)) |}
  | FCoFix cfx e =&gt;
    {| mark := mark Cstr r; term := FCoFix cfx (Esubst.subs_shft (n, e)) |}
  | FLIFT k m =&gt; lft_fconstr (Util.op_plus n k) m
  | FLOCKED =&gt; false
  |
    FFlex (RelKey _) | FAtom _ | FApp _ _ | FProj _ _ | FCaseT _ _ _ _ _ |
      FProd _ _ _ _ | FLetIn _ _ _ _ _ | FEvar _ _ | FCLOS _ _ =&gt;
    {| mark := mark ft; term := FLIFT n ft |}
  end.

Definition lift_fconstr (k : Int.t) (f : fconstr) : fconstr :=
  if Int.equal k 0 then
    f
  else
    lft_fconstr k f.

Definition lift_fconstr_vect (k : Int.t) (v : array fconstr) : array fconstr :=
  if Int.equal k 0 then
    v
  else
    Util.Array.Fun1.map lft_fconstr k v.

Definition clos_rel (e : Esubst.subs fconstr) (i : Z) : fconstr :=
  match Esubst.expand_rel i e with
  | Inl (n, mt) =&gt; lift_fconstr n mt
  | Inr (k, None) =&gt; {| mark := mark Norm Unknown; term := FRel k |}
  | Inr (k, Some p) =&gt;
    lift_fconstr (Util.op_minus k p)
      {| mark := mark Red Unknown; term := FFlex (RelKey p) |}
  end.

Definition compact_stack (head : fconstr) (stk : list stack_member)
  : list stack_member :=
  let fix strip_rec (depth : Z) (function_parameter : list stack_member)
    : list stack_member :=
    match function_parameter with
    | cons (Zshift k) s =&gt; strip_rec (Util.op_plus depth k) s
    | cons (Zupdate m) s =&gt;
      let h' := lft_fconstr depth head in
      match update true m (mark h') (term h') with
      | _ =&gt; strip_rec depth s
      end
    |
      (cons (ZcaseT _ _ _ _ | Zproj _ | Zfix _ _ | Zapp _ | Zprimitive _ _ _ _)
        _ | []) as stk =&gt; zshift depth stk
    end in
  strip_rec 0 stk.

Definition zupdate (info : clos_infos) (m : fconstr) (s : list stack_member)
  : list stack_member :=
  let share := i_share (i_cache info) in
  if
    andb share
      match Mark.red_state (mark m) with
      | Red =&gt; true
      | Norm | Whnf | Cstr =&gt; false
      end then
    let s' := compact_stack m s in
    match set_field with
    | _ =&gt; cons (Zupdate m) s'
    end
  else
    s.

Definition mk_lambda (env : Esubst.subs fconstr) (t : Constr.constr) : fterm :=
  match Term.decompose_lam t with
  | (rvars, t') =&gt;
    FLambda (Util.List.(CList.ExtS.length) rvars)
      (Util.List.(CList.ExtS.rev) rvars) t' env
  end.

Definition destFLambda
  (clos_fun : (Esubst.subs fconstr) -&gt; Constr.constr -&gt; fconstr) (t : fconstr)
  : (Context.binder_annot Names.Name.t) * fconstr * fconstr :=
  match term t with
  | FLambda _ (cons (na, ty) []) b e =&gt;
    (na, (clos_fun e ty), (clos_fun (Esubst.subs_lift e) b))
  | FLambda n (cons (na, ty) tys) b e =&gt;
    (na, (clos_fun e ty),
      {| mark := mark t;
        term := FLambda (Util.op_minus n 1) tys b (Esubst.subs_lift e) |})
  | _ =&gt; false
  end.

Definition mk_clos (e : Esubst.subs fconstr) (t : Constr.constr) : fconstr :=
  match Constr.kind t with
  | Rel i =&gt; clos_rel e i
  | Var x =&gt; {| mark := mark Red Unknown; term := FFlex (VarKey x) |}
  | Const c =&gt; {| mark := mark Red Unknown; term := FFlex (ConstKey c) |}
  | Meta _ | Sort _ =&gt; {| mark := mark Norm KnownR; term := FAtom t |}
  | Ind kn =&gt; {| mark := mark Norm KnownR; term := FInd kn |}
  | Construct kn =&gt; {| mark := mark Cstr Unknown; term := FConstruct kn |}
  | Int i =&gt; {| mark := mark Cstr Unknown; term := FInt i |}
  |
    CoFix _ | Lambda _ _ _ | Fix _ | Prod _ _ _ | Evar _ | App _ _ |
      Case _ _ _ _ | Cast _ _ _ | LetIn _ _ _ _ | Proj _ _ =&gt;
    {| mark := mark Red Unknown; term := FCLOS t e |}
  end.

Definition inject (c : Constr.constr) : fconstr := mk_clos (Esubst.subs_id 0) c.

Definition mk_clos_vect (env : Esubst.subs fconstr) (v : array Constr.constr)
  : array fconstr :=
  match v with
  | tt =&gt; tt
  | (v0) =&gt; ((mk_clos env v0))
  | (v0, v1) =&gt; ((mk_clos env v0), (mk_clos env v1))
  | (v0, v1, v2) =&gt; ((mk_clos env v0), (mk_clos env v1), (mk_clos env v2))
  | (v0, v1, v2, v3) =&gt;
    ((mk_clos env v0), (mk_clos env v1), (mk_clos env v2), (mk_clos env v3))
  | v =&gt; Util.Array.Fun1.map mk_clos env v
  end.

Definition ref_value_cache {A : Type} (function_parameter : clos_infos)
  : (KeyTable.t (Declarations.constant_def fconstr A)) -&gt;
    KeyTable.key -&gt; Declarations.constant_def fconstr A :=
  match function_parameter with
  | {| i_cache := cache |} =&gt; fun tab =&gt; fun ref =&gt; try
  end.

Fixpoint to_constr (lfts : Esubst.lift) (v : fconstr) : Constr.constr :=
  match term v with
  | FRel i =&gt; Constr.mkRel (Esubst.reloc_rel i lfts)
  | FFlex (RelKey p) =&gt; Constr.mkRel (Esubst.reloc_rel p lfts)
  | FFlex (VarKey x) =&gt; Constr.mkVar x
  | FAtom c =&gt; Vars.exliftn lfts c
  | FFlex (ConstKey op) =&gt; Constr.mkConstU op
  | FInd op =&gt; Constr.mkIndU op
  | FConstruct op =&gt; Constr.mkConstructU op
  | FCaseT ci p c ve env =&gt;
    if andb (Esubst.is_subs_id env) (Esubst.is_lift_id lfts) then
      Constr.mkCase (ci, p, (to_constr lfts c), ve)
    else
      let subs := comp_subs lfts env in
      Constr.mkCase
        (ci, (subst_constr subs p), (to_constr lfts c),
          (Util.Array.(CArray.ExtS.map) (fun b =&gt; subst_constr subs b) ve))
  | FFix ((op, (lna, tys, bds)) as fx) e =&gt;
    if andb (Esubst.is_subs_id e) (Esubst.is_lift_id lfts) then
      Constr.mkFix fx
    else
      let n := Util.Array.(CArray.ExtS.length) bds in
      let subs_ty := comp_subs lfts e in
      let subs_bd := comp_subs (Esubst.el_liftn n lfts) (Esubst.subs_liftn n e)
        in
      let tys := Util.Array.Fun1.map subst_constr subs_ty tys in
      let bds := Util.Array.Fun1.map subst_constr subs_bd bds in
      Constr.mkFix (op, (lna, tys, bds))
  | FCoFix ((op, (lna, tys, bds)) as cfx) e =&gt;
    if andb (Esubst.is_subs_id e) (Esubst.is_lift_id lfts) then
      Constr.mkCoFix cfx
    else
      let n := Util.Array.(CArray.ExtS.length) bds in
      let subs_ty := comp_subs lfts e in
      let subs_bd := comp_subs (Esubst.el_liftn n lfts) (Esubst.subs_liftn n e)
        in
      let tys := Util.Array.Fun1.map subst_constr subs_ty tys in
      let bds := Util.Array.Fun1.map subst_constr subs_bd bds in
      Constr.mkCoFix (op, (lna, tys, bds))
  | FApp f ve =&gt;
    Constr.mkApp ((to_constr lfts f), (Util.Array.Fun1.map to_constr lfts ve))
  | FProj p c =&gt; Constr.mkProj (p, (to_constr lfts c))
  | FLambda len tys f e =&gt;
    if andb (Esubst.is_subs_id e) (Esubst.is_lift_id lfts) then
      Term.compose_lam (Util.List.(CList.ExtS.rev) tys) f
    else
      let subs := comp_subs lfts e in
      let tys :=
        Util.List.(CList.ExtS.mapi)
          (fun i =&gt;
            fun function_parameter =&gt;
              match function_parameter with
              | (na, c) =&gt; (na, (subst_constr (Esubst.subs_liftn i subs) c))
              end) tys in
      let f := subst_constr (Esubst.subs_liftn len subs) f in
      Term.compose_lam (Util.List.(CList.ExtS.rev) tys) f
  | FProd n t c e =&gt;
    if andb (Esubst.is_subs_id e) (Esubst.is_lift_id lfts) then
      Constr.mkProd (n, (to_constr lfts t), c)
    else
      let subs' := comp_subs lfts e in
      Constr.mkProd
        (n, (to_constr lfts t), (subst_constr (Esubst.subs_lift subs') c))
  | FLetIn n b t f e =&gt;
    let subs := comp_subs (Esubst.el_lift lfts) (Esubst.subs_lift e) in
    Constr.mkLetIn
      (n, (to_constr lfts b), (to_constr lfts t), (subst_constr subs f))
  | FEvar (ev, args) env =&gt;
    let subs := comp_subs lfts env in
    Constr.mkEvar
      (ev, (Util.Array.(CArray.ExtS.map) (fun a =&gt; subst_constr subs a) args))
  | FLIFT k a =&gt; to_constr (Esubst.el_shft k lfts) a
  | FInt i =&gt; Constr.mkInt i
  | FCLOS t env =&gt;
    if andb (Esubst.is_subs_id env) (Esubst.is_lift_id lfts) then
      t
    else
      let subs := comp_subs lfts env in
      subst_constr subs t
  | FLOCKED =&gt; false
  end

with subst_constr
  (subst : Esubst.subs (lazy_t Constr.constr)) (c : Constr.constr)
  : Constr.constr :=
  match Constr.kind c with
  | Rel i =&gt;
    match Esubst.expand_rel i subst with
    | Inl (k, v) =&gt; Vars.lift k v
    | Inr (m, _) =&gt; Constr.mkRel m
    end
  | _ =&gt; Constr.map_with_binders Esubst.subs_lift subst_constr subst c
  end

with comp_subs (el : Esubst.lift) (s : Esubst.subs fconstr)
  : Esubst.subs (lazy_t Constr.constr) :=
  Esubst.lift_subst (fun el =&gt; fun c =&gt; to_constr el c) el s.

Definition term_of_fconstr (c : fconstr) : Constr.constr :=
  to_constr Esubst.el_id c.

Fixpoint zip (m : fconstr) (stk : list stack_member) : fconstr :=
  match stk with
  | [] =&gt; m
  | cons (Zapp args) s =&gt;
    zip {| mark := Mark.neutr (mark m); term := FApp m args |} s
  | cons (ZcaseT ci p br e) s =&gt;
    let t := FCaseT ci p m br e in
    let mark := mark (neutr (Mark.red_state (mark m))) Unknown in
    zip {| mark := mark; term := t |} s
  | cons (Zproj p) s =&gt;
    let mark := mark (neutr (Mark.red_state (mark m))) Unknown in
    zip {| mark := mark; term := FProj (Names.Projection.make p true) m |} s
  | cons (Zfix fx par) s =&gt; zip fx (Util.op_at par (append_stack (m) s))
  | cons (Zshift n) s =&gt; zip (lift_fconstr n m) s
  | cons (Zupdate rf) s =&gt; zip (update true rf (mark m) (term m)) s
  | cons (Zprimitive _op c rargs kargs) s =&gt;
    let args :=
      Util.List.(CList.ExtS.rev_append) rargs
        (cons m (Util.List.(CList.ExtS.map) snd kargs)) in
    let f := {| mark := mark Red Unknown; term := FFlex (ConstKey c) |} in
    zip
      {| mark := mark (neutr (Mark.red_state (mark m))) KnownR;
        term := FApp f (Util.Array.(CArray.ExtS.of_list) args) |} s
  end.

Definition fapp_stack (function_parameter : fconstr * (list stack_member))
  : fconstr :=
  match function_parameter with
  | (m, stk) =&gt; zip m stk
  end.

Definition strip_update_shift_app_red (head : fconstr) (stk : list stack_member)
  : Z * (list stack_member) * (list stack_member) :=
  let fix strip_rec
    (rstk : list stack_member) (h : fconstr) (depth : Z) (function_parameter :
    list stack_member) : Z * (list stack_member) * (list stack_member) :=
    match function_parameter with
    | cons ((Zshift k) as e) s =&gt;
      strip_rec (cons e rstk) (lift_fconstr k h) (Util.op_plus depth k) s
    | cons (Zapp args) s =&gt;
      strip_rec (cons (Zapp args) rstk)
        {| mark := mark h; term := FApp h args |} depth s
    | cons (Zupdate m) s =&gt;
      strip_rec rstk (update true m (mark h) (term h)) depth s
    |
      (cons (ZcaseT _ _ _ _ | Zproj _ | Zfix _ _ | Zprimitive _ _ _ _) _ | [])
        as stk =&gt; (depth, (Util.List.(CList.ExtS.rev) rstk), stk)
    end in
  strip_rec [] head 0 stk.

Definition strip_update_shift_app (head : fconstr) (stack : list stack_member)
  : Z * (list stack_member) * (list stack_member) :=
  match Mark.red_state (mark head) with
  | Red =&gt; false
  | Norm | Cstr | Whnf =&gt; true
  end;
  strip_update_shift_app_red head stack.

Definition get_nth_arg (head : fconstr) (n : Int.t) (stk : list stack_member)
  : (option ((list stack_member) * fconstr)) * (list stack_member) :=
  match Mark.red_state (mark head) with
  | Red =&gt; false
  | Norm | Cstr | Whnf =&gt; true
  end;
  let fix strip_rec
    (rstk : list stack_member) (h : fconstr) (n : Int.t) (function_parameter :
    list stack_member)
    : (option ((list stack_member) * fconstr)) * (list stack_member) :=
    match function_parameter with
    | cons ((Zshift k) as e) s =&gt; strip_rec (cons e rstk) (lift_fconstr k h) n s
    | cons (Zapp args) s' =&gt;
      let q := Util.Array.(CArray.ExtS.length) args in
      if OCaml.Stdlib.ge n q then
        strip_rec (cons (Zapp args) rstk)
          {| mark := mark h; term := FApp h args |} (Util.op_minus n q) s'
      else
        let bef := Util.Array.(CArray.ExtS.sub) args 0 n in
        let aft :=
          Util.Array.(CArray.ExtS.sub) args (Util.op_plus n 1)
            (Util.op_minus (Util.op_minus q n) 1) in
        let stk' :=
          Util.List.(CList.ExtS.rev)
            (if Int.equal n 0 then
              rstk
            else
              cons (Zapp bef) rstk) in
        ((Some (stk', (Util.Array.(CArray.ExtS.get) args n))),
          (append_stack aft s'))
    | cons (Zupdate m) s =&gt; strip_rec rstk (update true m (mark h) (term h)) n s
    |
      (cons (ZcaseT _ _ _ _ | Zproj _ | Zfix _ _ | Zprimitive _ _ _ _) _ | [])
        as s =&gt; (None, (Util.op_at (Util.List.(CList.ExtS.rev) rstk) s))
    end in
  strip_rec [] head n stk.

Fixpoint get_args
  (n : Z) (tys : list ((Context.binder_annot Names.Name.t) * Constr.constr))
  (f : Constr.constr) (e : Esubst.subs fconstr)
  (function_parameter : list stack_member)
  : (Util.union (Esubst.subs fconstr) fconstr) * (list stack_member) :=
  match function_parameter with
  | cons (Zupdate r) s =&gt;
    let _hd :=
      update true r (mark Cstr (Mark.relevance (mark r))) (FLambda n tys f e) in
    get_args n tys f e s
  | cons (Zshift k) s =&gt; get_args n tys f (Esubst.subs_shft (k, e)) s
  | cons (Zapp l) s =&gt;
    let na := Util.Array.(CArray.ExtS.length) l in
    if Stdlib.op_eq_eq n na then
      ((Inl (Esubst.subs_cons (l, e))), s)
    else
      if OCaml.Stdlib.lt n na then
        let args := Util.Array.(CArray.ExtS.sub) l 0 n in
        let eargs := Util.Array.(CArray.ExtS.sub) l n (Util.op_minus na n) in
        ((Inl (Esubst.subs_cons (args, e))), (cons (Zapp eargs) s))
      else
        let etys := Util.List.(CList.ExtS.skipn) na tys in
        get_args (Util.op_minus n na) etys f (Esubst.subs_cons (l, e)) s
  |
    (cons (ZcaseT _ _ _ _ | Zproj _ | Zfix _ _ | Zprimitive _ _ _ _) _ | []) as
      stk =&gt;
    ((Inr {| mark := mark Cstr Unknown; term := FLambda n tys f e |}), stk)
  end.

Fixpoint eta_expand_stack (function_parameter : list stack_member)
  : list stack_member :=
  match function_parameter with
  |
    cons
      ((Zapp _ | Zfix _ _ | ZcaseT _ _ _ _ | Zproj _ | Zshift _ | Zupdate _ |
        Zprimitive _ _ _ _) as e) s =&gt; cons e (eta_expand_stack s)
  | [] =&gt;
    cons (Zshift 1)
      (cons (Zapp ({| mark := mark Norm Unknown; term := FRel 1 |})) [])
  end.

Fixpoint skip_native_args {A : Type}
  (rargs : list A) (nargs : list (CPrimitives.arg_kind * A))
  : (list A) * (list (CPrimitives.arg_kind * A)) :=
  match nargs with
  | cons (kd, a) nargs' =&gt;
    if equiv_decb kd CPrimitives.Kwhnf then
      (rargs, nargs)
    else
      skip_native_args (cons a rargs) nargs'
  | [] =&gt; (rargs, [])
  end.

Definition get_native_args
  (op : CPrimitives.t) (c : Univ.puniverses Names.Constant.t)
  (stk : list stack_member)
  : ((list fconstr) * (list (CPrimitives.arg_kind * fconstr))) *
    (list stack_member) :=
  let kargs := CPrimitives.kind op in
  let fix get_args {A B : Type}
    (rnargs : list (A * B)) (kargs : list A) (args : list B)
    : (list (A * B)) * (list A) * (list B) :=
    match (kargs, args) with
    | (cons kd kargs, cons a args) =&gt; get_args (cons (kd, a) rnargs) kargs args
    | (_, _) =&gt; (rnargs, kargs, args)
    end in
  let fix strip_rec
    (rnargs : list (CPrimitives.arg_kind * fconstr)) (h : fconstr) (depth : Z)
    (kargs : list CPrimitives.arg_kind) (function_parameter : list stack_member)
    : ((list fconstr) * (list (CPrimitives.arg_kind * fconstr))) *
      (list stack_member) :=
    match function_parameter with
    | cons (Zshift k) s =&gt;
      strip_rec
        (Util.List.(CList.ExtS.map)
          (fun function_parameter =&gt;
            match function_parameter with
            | (kd, f) =&gt; (kd, (lift_fconstr k f))
            end) rnargs) (lift_fconstr k h) (Util.op_plus depth k) kargs s
    | cons (Zapp args) s' =&gt;
      match get_args rnargs kargs (Util.Array.(CArray.ExtS.to_list) args) with
      | (rnargs, [], []) =&gt;
        ((skip_native_args [] (Util.List.(CList.ExtS.rev) rnargs)), s')
      | (rnargs, [], eargs) =&gt;
        ((skip_native_args [] (Util.List.(CList.ExtS.rev) rnargs)),
          (cons (Zapp (Util.Array.(CArray.ExtS.of_list) eargs)) s'))
      | (rnargs, kargs, _) =&gt;
        strip_rec rnargs {| mark := mark h; term := FApp h args |} depth kargs
          s'
      end
    | cons (Zupdate m) s =&gt;
      strip_rec rnargs (update true m (mark h) (term h)) depth kargs s
    | cons (Zprimitive _ _ _ _ | ZcaseT _ _ _ _ | Zproj _ | Zfix _ _) _ | [] =&gt;
      false
    end in
  strip_rec [] {| mark := mark Red Unknown; term := FFlex (ConstKey c) |} 0
    kargs stk.

Definition get_native_args1
  (op : CPrimitives.t) (c : Univ.puniverses Names.Constant.t)
  (stk : list stack_member)
  : (list fconstr) * fconstr * (list (CPrimitives.arg_kind * fconstr)) *
    (list stack_member) :=
  match get_native_args op c stk with
  | ((rargs, cons (kd, a) nargs), stk) =&gt;
    equiv_decb kd CPrimitives.Kwhnf;
    (rargs, a, nargs, stk)
  | _ =&gt; false
  end.

Definition check_native_args (op : CPrimitives.t) (stk : list stack_member)
  : bool :=
  let nargs := CPrimitives.arity op in
  let rargs := stack_args_size stk in
  OCaml.Stdlib.le nargs rargs.

Fixpoint reloc_rargs_rec
  (depth : Int.t) (function_parameter : list stack_member)
  : list stack_member :=
  match function_parameter with
  | cons (Zapp args) s =&gt;
    cons (Zapp (lift_fconstr_vect depth args)) (reloc_rargs_rec depth s)
  | cons (Zshift k) s =&gt;
    if Int.equal k depth then
      s
    else
      reloc_rargs_rec (Util.op_minus depth k) s
  |
    (cons (ZcaseT _ _ _ _ | Zproj _ | Zfix _ _ | Zupdate _ | Zprimitive _ _ _ _)
      _ | []) as stk =&gt; stk
  end.

Definition reloc_rargs (depth : Int.t) (stk : list stack_member)
  : list stack_member :=
  if Int.equal depth 0 then
    stk
  else
    reloc_rargs_rec depth stk.

Fixpoint try_drop_parameters
  (depth : Int.t) (n : Int.t) (function_parameter : list stack_member)
  : list stack_member :=
  match function_parameter with
  | cons (Zapp args) s =&gt;
    let q := Util.Array.(CArray.ExtS.length) args in
    if OCaml.Stdlib.gt n q then
      try_drop_parameters depth (Util.op_minus n q) s
    else
      if Int.equal n q then
        reloc_rargs depth s
      else
        let aft := Util.Array.(CArray.ExtS.sub) args n (Util.op_minus q n) in
        reloc_rargs depth (append_stack aft s)
  | cons (Zshift k) s =&gt; try_drop_parameters (Util.op_minus depth k) n s
  | [] =&gt;
    if Int.equal n 0 then
      []
    else
      Stdlib.raise OCaml.Not_found
  |
    cons (ZcaseT _ _ _ _ | Zproj _ | Zfix _ _ | Zupdate _ | Zprimitive _ _ _ _)
      _ =&gt; false
  end.

Definition drop_parameters
  (depth : Int.t) (n : Int.t) (argstk : list stack_member)
  : list stack_member := try.

Definition eta_expand_ind_stack
  (env : Environ.env) (ind : Names.inductive) (m : fconstr)
  (s : list stack_member) (function_parameter : fconstr * (list stack_member))
  : (list stack_member) * (list stack_member) :=
  match function_parameter with
  | (f, s') =&gt;
    let mib := Environ.lookup_mind (fst ind) env in
    if negb (Stdlib.op_eq_eq (mind_finite mib) BiFinite) then
      Stdlib.raise OCaml.Not_found
    else
      tt;
    match Declareops.inductive_make_projections ind mib with
    | Some projs =&gt;
      let pars := Declarations.mind_nparams mib in
      let right := fapp_stack (f, s') in
      match strip_update_shift_app m s with
      | (depth, args, _s) =&gt;
        let argss := try_drop_parameters depth pars args in
        let hstack :=
          Util.Array.(CArray.ExtS.map)
            (fun p =&gt;
              {| mark := mark Red Unknown;
                term := FProj (Names.Projection.make p true) right |}) projs in
        (argss, (cons (Zapp hstack) []))
      end
    | None =&gt; Stdlib.raise OCaml.Not_found
    end
  end.

Fixpoint project_nth_arg (n : Z) (function_parameter : list stack_member)
  : fconstr :=
  match function_parameter with
  | cons (Zapp args) s =&gt;
    let q := Util.Array.(CArray.ExtS.length) args in
    if OCaml.Stdlib.ge n q then
      project_nth_arg (Util.op_minus n q) s
    else
      Util.Array.(CArray.ExtS.get) args n
  |
    cons
      (ZcaseT _ _ _ _ | Zproj _ | Zfix _ _ | Zupdate _ | Zshift _ |
        Zprimitive _ _ _ _) _ | [] =&gt; false
  end.

Definition contract_fix_vect (fix : fterm)
  : (Esubst.subs fconstr) * Constr.constr :=
  match
    match fix with
    | FFix ((reci, i), (nas, _, bds) as rdcl) env =&gt;
      ((Util.Array.(CArray.ExtS.get) bds i),
        (fun j =&gt;
          {|
            mark :=
              mark Cstr
                (opt_of_rel
                  (binder_relevance (Util.Array.(CArray.ExtS.get) nas j)));
            term := FFix ((reci, j), rdcl) env |}), env,
        (Util.Array.(CArray.ExtS.length) bds))
    | FCoFix (i, (nas, _, bds) as rdcl) env =&gt;
      ((Util.Array.(CArray.ExtS.get) bds i),
        (fun j =&gt;
          {|
            mark :=
              mark Cstr
                (opt_of_rel
                  (binder_relevance (Util.Array.(CArray.ExtS.get) nas j)));
            term := FCoFix (j, rdcl) env |}), env,
        (Util.Array.(CArray.ExtS.length) bds))
    | _ =&gt; false
    end with
  | (thisbody, make_body, env, nfix) =&gt;
    ((Esubst.subs_cons ((Util.Array.(CArray.ExtS.init) nfix make_body), env)),
      thisbody)
  end.

Definition unfold_projection (info : clos_infos) (p : Names.Projection.t)
  : option stack_member :=
  if RedFlags.(RedFlagsSig.red_projection) (i_flags info) p then
    Some (Zproj (Names.Projection.repr p))
  else
    None.

Fixpoint knh (info : clos_infos) (m : fconstr) (stk : list stack_member)
  : fconstr * (list stack_member) :=
  match term m with
  | FLIFT k a =&gt; knh info a (zshift k stk)
  | FCLOS t e =&gt; knht info e t (zupdate info m stk)
  | FLOCKED =&gt; false
  | FApp a b =&gt; knh info a (append_stack b (zupdate info m stk))
  | FCaseT ci p t br e =&gt;
    knh info t (cons (ZcaseT ci p br e) (zupdate info m stk))
  | FFix ((ri, n), _) _ =&gt;
    match get_nth_arg m (Util.Array.(CArray.ExtS.get) ri n) stk with
    | (Some (pars, arg), stk') =&gt; knh info arg (cons (Zfix m pars) stk')
    | (None, stk') =&gt; (m, stk')
    end
  | FProj p c =&gt;
    match unfold_projection info p with
    | None =&gt; (m, stk)
    | Some s =&gt; knh info c (cons s (zupdate info m stk))
    end
  |
    FFlex _ | FLetIn _ _ _ _ _ | FConstruct _ | FEvar _ _ | FCoFix _ _ |
      FLambda _ _ _ _ | FRel _ | FAtom _ | FInd _ | FProd _ _ _ _ | FInt _ =&gt;
    (m, stk)
  end

with knht
  (info : clos_infos) (e : Esubst.subs fconstr) (t : Constr.constr)
  (stk : list stack_member) : fconstr * (list stack_member) :=
  match Constr.kind t with
  | App a b =&gt; knht info e a (append_stack (mk_clos_vect e b) stk)
  | Case ci p t br =&gt; knht info e t (cons (ZcaseT ci p br e) stk)
  | Fix fx =&gt; knh info {| mark := mark Cstr Unknown; term := FFix fx e |} stk
  | Cast a _ _ =&gt; knht info e a stk
  | Rel n =&gt; knh info (clos_rel e n) stk
  | Proj p c =&gt;
    knh info {| mark := mark Red Unknown; term := FProj p (mk_clos e c) |} stk
  | Ind _ | Const _ | Construct _ | Var _ | Meta _ | Sort _ | Int _ =&gt;
    ((mk_clos e t), stk)
  | CoFix cfx =&gt; ({| mark := mark Cstr Unknown; term := FCoFix cfx e |}, stk)
  | Lambda _ _ _ =&gt;
    ({| mark := mark Cstr Unknown; term := mk_lambda e t |}, stk)
  | Prod n t c =&gt;
    ({| mark := mark Whnf KnownR; term := FProd n (mk_clos e t) c e |}, stk)
  | LetIn n b t c =&gt;
    ({| mark := mark Red Unknown;
      term := FLetIn n (mk_clos e b) (mk_clos e t) c e |}, stk)
  | Evar ev =&gt; ({| mark := mark Red Unknown; term := FEvar ev e |}, stk)
  end.

Definition inject (c : Constr.constr) : fconstr := mk_clos (Esubst.subs_id 0) c.

Import Primred.

Module FNativeEntries.
  Definition elem := fconstr.
  
  Definition args := array fconstr.
  
  Definition evd := unit.
  
  Definition get {A : Type} : (array A) -&gt; Z -&gt; A :=
    Util.Array.(CArray.ExtS.get).
  
  Definition get_int (function_parameter : unit) : fconstr -&gt; Uint63.t :=
    match function_parameter with
    | tt =&gt;
      fun e =&gt;
        match term e with
        | FInt i =&gt; i
        | _ =&gt; Stdlib.raise Primred.NativeDestKO
        end
    end.
  
  Definition dummy : fconstr := {| mark := mark Norm KnownR; term := FRel 0 |}.
  
  Definition current_retro : Stdlib.ref Retroknowledge.retroknowledge :=
    Stdlib.ref Retroknowledge.empty.
  
  Definition defined_int : Stdlib.ref bool := Stdlib.ref false.
  
  Definition fint : Stdlib.ref fconstr := Stdlib.ref dummy.
  
  Definition init_int (retro : Retroknowledge.retroknowledge) : unit :=
    match Retroknowledge.retro_int63 retro with
    | Some c =&gt;
      Stdlib.op_colon_eq defined_int true;
      Stdlib.op_colon_eq fint
        {| mark := mark Norm KnownR; term := FFlex (ConstKey (Univ.in_punivs c))
          |}
    | None =&gt; Stdlib.op_colon_eq defined_int false
    end.
  
  Definition defined_bool : Stdlib.ref bool := Stdlib.ref false.
  
  Definition ftrue : Stdlib.ref fconstr := Stdlib.ref dummy.
  
  Definition ffalse : Stdlib.ref fconstr := Stdlib.ref dummy.
  
  Definition init_bool (retro : Retroknowledge.retroknowledge) : unit :=
    match Retroknowledge.retro_bool retro with
    | Some (ct, cf) =&gt;
      Stdlib.op_colon_eq defined_bool true;
      Stdlib.op_colon_eq ftrue
        {| mark := mark Cstr KnownR; term := FConstruct (Univ.in_punivs ct) |};
      Stdlib.op_colon_eq ffalse
        {| mark := mark Cstr KnownR; term := FConstruct (Univ.in_punivs cf) |}
    | None =&gt; Stdlib.op_colon_eq defined_bool false
    end.
  
  Definition defined_carry : Stdlib.ref bool := Stdlib.ref false.
  
  Definition fC0 : Stdlib.ref fconstr := Stdlib.ref dummy.
  
  Definition fC1 : Stdlib.ref fconstr := Stdlib.ref dummy.
  
  Definition init_carry (retro : Retroknowledge.retroknowledge) : unit :=
    match Retroknowledge.retro_carry retro with
    | Some (c0, c1) =&gt;
      Stdlib.op_colon_eq defined_carry true;
      Stdlib.op_colon_eq fC0
        {| mark := mark Cstr KnownR; term := FConstruct (Univ.in_punivs c0) |};
      Stdlib.op_colon_eq fC1
        {| mark := mark Cstr KnownR; term := FConstruct (Univ.in_punivs c1) |}
    | None =&gt; Stdlib.op_colon_eq defined_carry false
    end.
  
  Definition defined_pair : Stdlib.ref bool := Stdlib.ref false.
  
  Definition fPair : Stdlib.ref fconstr := Stdlib.ref dummy.
  
  Definition init_pair (retro : Retroknowledge.retroknowledge) : unit :=
    match Retroknowledge.retro_pair retro with
    | Some c =&gt;
      Stdlib.op_colon_eq defined_pair true;
      Stdlib.op_colon_eq fPair
        {| mark := mark Cstr KnownR; term := FConstruct (Univ.in_punivs c) |}
    | None =&gt; Stdlib.op_colon_eq defined_pair false
    end.
  
  Definition defined_cmp : Stdlib.ref bool := Stdlib.ref false.
  
  Definition fEq : Stdlib.ref fconstr := Stdlib.ref dummy.
  
  Definition fLt : Stdlib.ref fconstr := Stdlib.ref dummy.
  
  Definition fGt : Stdlib.ref fconstr := Stdlib.ref dummy.
  
  Definition init_cmp (retro : Retroknowledge.retroknowledge) : unit :=
    match Retroknowledge.retro_cmp retro with
    | Some (cEq, cLt, cGt) =&gt;
      Stdlib.op_colon_eq defined_cmp true;
      Stdlib.op_colon_eq fEq
        {| mark := mark Cstr KnownR; term := FConstruct (Univ.in_punivs cEq) |};
      Stdlib.op_colon_eq fLt
        {| mark := mark Cstr KnownR; term := FConstruct (Univ.in_punivs cLt) |};
      Stdlib.op_colon_eq fGt
        {| mark := mark Cstr KnownR; term := FConstruct (Univ.in_punivs cGt) |}
    | None =&gt; Stdlib.op_colon_eq defined_cmp false
    end.
  
  Definition defined_refl : Stdlib.ref bool := Stdlib.ref false.
  
  Definition frefl : Stdlib.ref fconstr := Stdlib.ref dummy.
  
  Definition init_refl (retro : Retroknowledge.retroknowledge) : unit :=
    match Retroknowledge.retro_refl retro with
    | Some crefl =&gt;
      Stdlib.op_colon_eq defined_refl true;
      Stdlib.op_colon_eq frefl
        {| mark := mark Cstr KnownR; term := FConstruct (Univ.in_punivs crefl)
          |}
    | None =&gt; Stdlib.op_colon_eq defined_refl false
    end.
  
  Definition init (env : Environ.env) : unit :=
    Stdlib.op_colon_eq current_retro (retroknowledge env);
    init_int (Util.op_exclamation current_retro);
    init_bool (Util.op_exclamation current_retro);
    init_carry (Util.op_exclamation current_retro);
    init_pair (Util.op_exclamation current_retro);
    init_cmp (Util.op_exclamation current_retro);
    init_refl (Util.op_exclamation current_retro).
  
  Definition check_env (env : Environ.env) : unit :=
    if
      negb
        (Stdlib.op_eq_eq (Util.op_exclamation current_retro)
          (retroknowledge env)) then
      init env
    else
      tt.
  
  Definition check_int (env : Environ.env) : unit :=
    check_env env;
    Util.op_exclamation defined_int.
  
  Definition check_bool (env : Environ.env) : unit :=
    check_env env;
    Util.op_exclamation defined_bool.
  
  Definition check_carry (env : Environ.env) : unit :=
    check_env env;
    andb (Util.op_exclamation defined_carry) (Util.op_exclamation defined_int).
  
  Definition check_pair (env : Environ.env) : unit :=
    check_env env;
    andb (Util.op_exclamation defined_pair) (Util.op_exclamation defined_int).
  
  Definition check_cmp (env : Environ.env) : unit :=
    check_env env;
    Util.op_exclamation defined_cmp.
  
  Definition mkInt (env : Environ.env) (i : Uint63.t) : fconstr :=
    check_int env;
    {| mark := mark Cstr KnownR; term := FInt i |}.
  
  Definition mkBool (env : Environ.env) (b : bool) : fconstr :=
    check_bool env;
    if b then
      Util.op_exclamation ftrue
    else
      Util.op_exclamation ffalse.
  
  Definition mkCarry (env : Environ.env) (b : bool) (e : fconstr) : fconstr :=
    check_carry env;
    {| mark := mark Cstr KnownR;
      term :=
        FApp
          (if b then
            Util.op_exclamation fC1
          else
            Util.op_exclamation fC0) ((Util.op_exclamation fint), e) |}.
  
  Definition mkIntPair (env : Environ.env) (e1 : fconstr) (e2 : fconstr)
    : fconstr :=
    check_pair env;
    {| mark := mark Cstr KnownR;
      term :=
        FApp (Util.op_exclamation fPair)
          ((Util.op_exclamation fint), (Util.op_exclamation fint), e1, e2) |}.
  
  Definition mkLt (env : Environ.env) : fconstr :=
    check_cmp env;
    Util.op_exclamation fLt.
  
  Definition mkEq (env : Environ.env) : fconstr :=
    check_cmp env;
    Util.op_exclamation fEq.
  
  Definition mkGt (env : Environ.env) : fconstr :=
    check_cmp env;
    Util.op_exclamation fGt.
End FNativeEntries.

Fixpoint knr {A : Type}
  (info : clos_infos) (tab : KeyTable.t (Declarations.constant_def fconstr A))
  (m : fconstr) (stk : list stack_member) : fconstr * (list stack_member) :=
  match term m with
  | FConstruct ((_ind, c), _u) =&gt;
    let use_match :=
      RedFlags.(RedFlagsSig.red_set) (i_flags info)
        RedFlags.(RedFlagsSig.fMATCH) in
    let use_fix :=
      RedFlags.(RedFlagsSig.red_set) (i_flags info) RedFlags.(RedFlagsSig.fFIX)
      in
    if orb use_match use_fix then
      match strip_update_shift_app m stk with
      | (_, args, s) =&gt; (m, (Util.op_at args s))
      end
    else
      (m, stk)
  | FEvar ev env =&gt;
    match (i_sigma (i_cache info)) ev with
    | Some c =&gt; knit info tab env c stk
    | None =&gt; (m, stk)
    end
  | FInt _ =&gt;
    match strip_update_shift_app m stk with
    | (_, _, cons (Zprimitive op c rargs nargs) s) =&gt;
      match skip_native_args (cons m rargs) nargs with
      | (rargs, nargs) =&gt;
        match nargs with
        | [] =&gt;
          let args :=
            Util.Array.(CArray.ExtS.of_list) (Util.List.(CList.ExtS.rev) rargs)
            in
          match
            FredNative.(Primred.RedNative.red_prim) (info_env info) tt op args
            with
          | Some m =&gt; kni info tab m s
          | None =&gt;
            let f := {| mark := mark Whnf KnownR; term := FFlex (ConstKey c) |}
              in
            let m := {| mark := mark Whnf KnownR; term := FApp f args |} in
            (m, s)
          end
        | cons (kd, a) nargs =&gt;
          equiv_decb kd CPrimitives.Kwhnf;
          kni info tab a (cons (Zprimitive op c rargs nargs) s)
        end
      end
    | (_, _, s) =&gt; (m, s)
    end
  |
    FLOCKED | FRel _ | FAtom _ | FFlex (RelKey _ | ConstKey _ | VarKey _) |
      FInd _ | FApp _ _ | FProj _ _ | FFix _ _ | FCoFix _ _ | FCaseT _ _ _ _ _ |
      FLambda _ _ _ _ | FProd _ _ _ _ | FLetIn _ _ _ _ _ | FLIFT _ _ | FCLOS _ _
    =&gt; (m, stk)
  end

with kni {A : Type}
  (info : clos_infos) (tab : KeyTable.t (Declarations.constant_def fconstr A))
  (m : fconstr) (stk : list stack_member) : fconstr * (list stack_member) :=
  match knh info m stk with
  | (hm, s) =&gt; knr info tab hm s
  end

with knit {A : Type}
  (info : clos_infos) (tab : KeyTable.t (Declarations.constant_def fconstr A))
  (e : Esubst.subs fconstr) (t : Constr.constr) (stk : list stack_member)
  : fconstr * (list stack_member) :=
  match knht info e t stk with
  | (ht, s) =&gt; knr info tab ht s
  end.

Definition kh {A : Type}
  (info : clos_infos) (tab : KeyTable.t (Declarations.constant_def fconstr A))
  (v : fconstr) (stk : list stack_member) : fconstr :=
  fapp_stack (kni info tab v stk).

Fixpoint zip_term
  (zfun : fconstr -&gt; Constr.constr) (m : Constr.constr) (stk : stack)
  : Constr.constr :=
  match stk with
  | [] =&gt; m
  | cons (Zapp args) s =&gt;
    zip_term zfun (Constr.mkApp (m, (Util.Array.(CArray.ExtS.map) zfun args))) s
  | cons (ZcaseT ci p br e) s =&gt;
    let t :=
      Constr.mkCase
        (ci, (zfun (mk_clos e p)), m,
          (Util.Array.(CArray.ExtS.map) (fun b =&gt; zfun (mk_clos e b)) br)) in
    zip_term zfun t s
  | cons (Zproj p) s =&gt;
    let t := Constr.mkProj ((Names.Projection.make p true), m) in
    zip_term zfun t s
  | cons (Zfix fx par) s =&gt;
    let h := Constr.mkApp ((zip_term zfun (zfun fx) par), (m)) in
    zip_term zfun h s
  | cons (Zshift n) s =&gt; zip_term zfun (Vars.lift n m) s
  | cons (Zupdate _rf) s =&gt; zip_term zfun m s
  | cons (Zprimitive _ c rargs kargs) s =&gt;
    let kargs :=
      Util.List.(CList.ExtS.map)
        (fun function_parameter =&gt;
          match function_parameter with
          | (_, a) =&gt; zfun a
          end) kargs in
    let args :=
      Util.List.(CList.ExtS.fold_left) (fun args =&gt; fun a =&gt; cons (zfun a) args)
        (cons m kargs) rargs in
    let h :=
      Constr.mkApp
        ((Constr.mkConstU c), (Util.Array.(CArray.ExtS.of_list) args)) in
    zip_term zfun h s
  end.

Fixpoint kl {A : Type}
  (info : clos_infos) (tab : KeyTable.t (Declarations.constant_def fconstr A))
  (m : fconstr) : Constr.constr :=
  let share := i_share (i_cache info) in
  if is_val m then
    Stdlib.incr prune;
    term_of_fconstr m
  else
    match kni info tab m [] with
    | (nm, s) =&gt;
      match
        if share then
          OCaml.Stdlib.ignore (fapp_stack (nm, s))
        else
          tt with
      | tt =&gt; zip_term (kl info tab) (norm_head info tab nm) s
      end
    end

with norm_head {A : Type}
  (info : clos_infos) (tab : KeyTable.t (Declarations.constant_def fconstr A))
  (m : fconstr) : Constr.constr :=
  if is_val m then
    Stdlib.incr prune;
    term_of_fconstr m
  else
    match term m with
    | FLambda _n tys f e =&gt;
      match
        Util.List.(CList.ExtS.fold_left)
          (fun function_parameter =&gt;
            match function_parameter with
            | (e, info, ctxt) =&gt;
              fun function_parameter =&gt;
                match function_parameter with
                | (na, ty) =&gt;
                  ((Esubst.subs_lift e), info,
                    (cons (na, (kl info tab (mk_clos e ty))) ctxt))
                end
            end) (e, info, []) tys with
      | (e', info, rvtys) =&gt;
        let bd := kl info tab (mk_clos e' f) in
        Util.List.(CList.ExtS.fold_left)
          (fun b =&gt;
            fun function_parameter =&gt;
              match function_parameter with
              | (na, ty) =&gt; Constr.mkLambda (na, ty, b)
              end) bd rvtys
      end
    | FLetIn na a b f e =&gt;
      let c := mk_clos (Esubst.subs_lift e) f in
      Constr.mkLetIn (na, (kl info tab a), (kl info tab b), (kl info tab c))
    | FProd na dom rng e =&gt;
      Constr.mkProd
        (na, (kl info tab dom), (kl info tab (mk_clos (Esubst.subs_lift e) rng)))
    | FCoFix (n, (na, tys, bds)) e =&gt;
      let ftys := Util.Array.Fun1.map mk_clos e tys in
      let fbds :=
        Util.Array.Fun1.map mk_clos
          (Esubst.subs_liftn (Util.Array.(CArray.ExtS.length) na) e) bds in
      Constr.mkCoFix
        (n,
          (na, (CArray.(CArray.ExtS.map) (kl info tab) ftys),
            (CArray.(CArray.ExtS.map) (kl info tab) fbds)))
    | FFix (n, (na, tys, bds)) e =&gt;
      let ftys := Util.Array.Fun1.map mk_clos e tys in
      let fbds :=
        Util.Array.Fun1.map mk_clos
          (Esubst.subs_liftn (Util.Array.(CArray.ExtS.length) na) e) bds in
      Constr.mkFix
        (n,
          (na, (CArray.(CArray.ExtS.map) (kl info tab) ftys),
            (CArray.(CArray.ExtS.map) (kl info tab) fbds)))
    | FEvar (i, args) env =&gt;
      Constr.mkEvar
        (i,
          (Util.Array.(CArray.ExtS.map) (fun a =&gt; kl info tab (mk_clos env a))
            args))
    | FProj p c =&gt; Constr.mkProj (p, (kl info tab c))
    |
      FLOCKED | FRel _ | FAtom _ | FFlex _ | FInd _ | FConstruct _ | FApp _ _ |
        FCaseT _ _ _ _ _ | FLIFT _ _ | FCLOS _ _ | FInt _ =&gt; term_of_fconstr m
    end.

Definition whd_val {A : Type}
  (info : clos_infos) (tab : KeyTable.t (Declarations.constant_def fconstr A))
  (v : fconstr) : Constr.constr :=
  with_stats (term_of_fconstr (kh info tab v [])).

Definition norm_val {A : Type}
  (info : clos_infos) (tab : KeyTable.t (Declarations.constant_def fconstr A))
  (v : fconstr) : Constr.constr := with_stats (kl info tab v).

Definition whd_stack {A : Type}
  (infos : clos_infos) (tab : KeyTable.t (Declarations.constant_def fconstr A))
  (m : fconstr) (stk : list stack_member) : fconstr * (list stack_member) :=
  match Mark.red_state (mark m) with
  | Whnf | Norm =&gt; knh infos m stk
  | Red | Cstr =&gt;
    let k := kni infos tab m stk in
    match
      if i_share (i_cache infos) then
        OCaml.Stdlib.ignore (fapp_stack k)
      else
        tt with
    | tt =&gt; k
    end
  end.

Definition create_clos_infos
  (op_star_o_p_t_star : option (Constr.existential -&gt; option Constr.constr))
  : RedFlags.(RedFlagsSig.reds) -&gt; Environ.env -&gt; clos_infos :=
  let evars :=
    match op_star_o_p_t_star with
    | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
    | None =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | _ =&gt; None
        end
    end in
  fun flgs =&gt;
    fun env =&gt;
      let share := Declarations.share_reduction (Environ.typing_flags env) in
      let cache := {| i_env := env; i_sigma := evars; i_share := share |} in
      {| i_flags := flgs; i_cache := cache |}.

Definition create_tab {A : Type} (function_parameter : unit) : KeyTable.t A :=
  match function_parameter with
  | tt =&gt; KeyTable.create 17
  end.

Definition oracle_of_infos (infos : clos_infos) : Conv_oracle.oracle :=
  Environ.oracle (i_env (i_cache infos)).

Definition infos_with_reds
  (infos : clos_infos) (reds : RedFlags.(RedFlagsSig.reds)) : clos_infos :=
  record.

Definition unfold_reference {A : Type}
  (info : clos_infos) (tab : KeyTable.t (Declarations.constant_def fconstr A))
  (key : KeyTable.key) : Declarations.constant_def fconstr A :=
  match key with
  | ConstKey (kn, _) =&gt;
    if
      RedFlags.(RedFlagsSig.red_set) (i_flags info)
        (RedFlags.(RedFlagsSig.fCONST) kn) then
      ref_value_cache info tab key
    else
      Undef None
  | VarKey i =&gt;
    if
      RedFlags.(RedFlagsSig.red_set) (i_flags info)
        (RedFlags.(RedFlagsSig.fVAR) i) then
      ref_value_cache info tab key
    else
      Undef None
  | RelKey _ =&gt; ref_value_cache info tab key
  end.

Definition relevance_of (f : fconstr) : optrel := Mark.relevance (mark f).

Definition set_relevance (r : Sorts.relevance) (f : fconstr) : unit := set_field.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="cPrimitives" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>cPrimitives.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

type t =
  | Int63head0
  | Int63tail0
  | Int63add
  | Int63sub
  | Int63mul
  | Int63div
  | Int63mod
  | Int63lsr
  | Int63lsl
  | Int63land
  | Int63lor
  | Int63lxor
  | Int63addc
  | Int63subc
  | Int63addCarryC
  | Int63subCarryC
  | Int63mulc
  | Int63diveucl
  | Int63div21
  | Int63addMulDiv
  | Int63eq
  | Int63lt
  | Int63le
  | Int63compare

let equal (p1 : t) (p2 : t) =
  p1 == p2

let hash = function
  | Int63head0 -&gt; 1
  | Int63tail0 -&gt; 2
  | Int63add -&gt; 3
  | Int63sub -&gt; 4
  | Int63mul -&gt; 5
  | Int63div -&gt; 6
  | Int63mod -&gt; 7
  | Int63lsr -&gt; 8
  | Int63lsl -&gt; 9
  | Int63land -&gt; 10
  | Int63lor -&gt; 11
  | Int63lxor -&gt; 12
  | Int63addc -&gt; 13
  | Int63subc -&gt; 14
  | Int63addCarryC -&gt; 15
  | Int63subCarryC -&gt; 16
  | Int63mulc -&gt; 17
  | Int63diveucl -&gt; 18
  | Int63div21 -&gt; 19
  | Int63addMulDiv -&gt; 20
  | Int63eq -&gt; 21
  | Int63lt -&gt; 22
  | Int63le -&gt; 23
  | Int63compare -&gt; 24

(* Should match names in nativevalues.ml *)
let to_string = function
  | Int63head0 -&gt; &quot;head0&quot;
  | Int63tail0 -&gt; &quot;tail0&quot;
  | Int63add -&gt; &quot;add&quot;
  | Int63sub -&gt; &quot;sub&quot;
  | Int63mul -&gt; &quot;mul&quot;
  | Int63div -&gt; &quot;div&quot;
  | Int63mod -&gt; &quot;rem&quot;
  | Int63lsr -&gt; &quot;l_sr&quot;
  | Int63lsl -&gt; &quot;l_sl&quot;
  | Int63land -&gt; &quot;l_and&quot;
  | Int63lor -&gt; &quot;l_or&quot;
  | Int63lxor -&gt; &quot;l_xor&quot;
  | Int63addc -&gt; &quot;addc&quot;
  | Int63subc -&gt; &quot;subc&quot;
  | Int63addCarryC -&gt; &quot;addCarryC&quot;
  | Int63subCarryC -&gt; &quot;subCarryC&quot;
  | Int63mulc -&gt; &quot;mulc&quot;
  | Int63diveucl -&gt; &quot;diveucl&quot;
  | Int63div21 -&gt; &quot;div21&quot;
  | Int63addMulDiv -&gt; &quot;addMulDiv&quot;
  | Int63eq -&gt; &quot;eq&quot;
  | Int63lt -&gt; &quot;lt&quot;
  | Int63le -&gt; &quot;le&quot;
  | Int63compare -&gt; &quot;compare&quot;

type arg_kind =
  | Kparam (* not needed for the evaluation of the primitive when it reduces *)
  | Kwhnf  (* need to be reduced in whnf before reducing the primitive *)
  | Karg   (* no need to be reduced in whnf. example: [v] in [Array.set t i v] *)

type args_red = arg_kind list

(* Invariant only argument of type int63 or an inductive can
   have kind Kwhnf *)

let kind = function
  | Int63head0 | Int63tail0 -&gt; [Kwhnf]

  | Int63add | Int63sub | Int63mul
  | Int63div | Int63mod
  | Int63lsr | Int63lsl
  | Int63land | Int63lor | Int63lxor
  | Int63addc | Int63subc
  | Int63addCarryC | Int63subCarryC  | Int63mulc | Int63diveucl
  | Int63eq | Int63lt | Int63le | Int63compare -&gt; [Kwhnf; Kwhnf]

  | Int63div21 | Int63addMulDiv -&gt; [Kwhnf; Kwhnf; Kwhnf]

let arity = function
  | Int63head0 | Int63tail0 -&gt; 1
  | Int63add | Int63sub | Int63mul
  | Int63div | Int63mod
  | Int63lsr | Int63lsl
  | Int63land | Int63lor | Int63lxor
  | Int63addc | Int63subc
  | Int63addCarryC | Int63subCarryC | Int63mulc | Int63diveucl
  | Int63eq | Int63lt | Int63le
  | Int63compare -&gt; 2

  | Int63div21 | Int63addMulDiv -&gt; 3

(** Special Entries for Register **)

type prim_ind =
  | PIT_bool
  | PIT_carry
  | PIT_pair
  | PIT_cmp

type prim_type =
  | PT_int63

type op_or_type =
  | OT_op of t
  | OT_type of prim_type

let prim_ind_to_string = function
  | PIT_bool -&gt; &quot;bool&quot;
  | PIT_carry -&gt; &quot;carry&quot;
  | PIT_pair -&gt; &quot;pair&quot;
  | PIT_cmp -&gt; &quot;cmp&quot;

let prim_type_to_string = function
  | PT_int63 -&gt; &quot;int63_type&quot;

let op_or_type_to_string = function
  | OT_op op -&gt; to_string op
  | OT_type t -&gt; prim_type_to_string t
</pre>
          </div>
          <div class="col-md-6">
            <code>cPrimitives.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Inductive t : Type :=
| Int63head0 : t
| Int63tail0 : t
| Int63add : t
| Int63sub : t
| Int63mul : t
| Int63div : t
| Int63mod : t
| Int63lsr : t
| Int63lsl : t
| Int63land : t
| Int63lor : t
| Int63lxor : t
| Int63addc : t
| Int63subc : t
| Int63addCarryC : t
| Int63subCarryC : t
| Int63mulc : t
| Int63diveucl : t
| Int63div21 : t
| Int63addMulDiv : t
| Int63eq : t
| Int63lt : t
| Int63le : t
| Int63compare : t.

Definition equal (p1 : t) (p2 : t) : bool := Stdlib.op_eq_eq p1 p2.

Definition hash (function_parameter : t) : Z :=
  match function_parameter with
  | Int63head0 =&gt; 1
  | Int63tail0 =&gt; 2
  | Int63add =&gt; 3
  | Int63sub =&gt; 4
  | Int63mul =&gt; 5
  | Int63div =&gt; 6
  | Int63mod =&gt; 7
  | Int63lsr =&gt; 8
  | Int63lsl =&gt; 9
  | Int63land =&gt; 10
  | Int63lor =&gt; 11
  | Int63lxor =&gt; 12
  | Int63addc =&gt; 13
  | Int63subc =&gt; 14
  | Int63addCarryC =&gt; 15
  | Int63subCarryC =&gt; 16
  | Int63mulc =&gt; 17
  | Int63diveucl =&gt; 18
  | Int63div21 =&gt; 19
  | Int63addMulDiv =&gt; 20
  | Int63eq =&gt; 21
  | Int63lt =&gt; 22
  | Int63le =&gt; 23
  | Int63compare =&gt; 24
  end.

Definition to_string (function_parameter : t) : string :=
  match function_parameter with
  | Int63head0 =&gt; &quot;head0&quot; % string
  | Int63tail0 =&gt; &quot;tail0&quot; % string
  | Int63add =&gt; &quot;add&quot; % string
  | Int63sub =&gt; &quot;sub&quot; % string
  | Int63mul =&gt; &quot;mul&quot; % string
  | Int63div =&gt; &quot;div&quot; % string
  | Int63mod =&gt; &quot;rem&quot; % string
  | Int63lsr =&gt; &quot;l_sr&quot; % string
  | Int63lsl =&gt; &quot;l_sl&quot; % string
  | Int63land =&gt; &quot;l_and&quot; % string
  | Int63lor =&gt; &quot;l_or&quot; % string
  | Int63lxor =&gt; &quot;l_xor&quot; % string
  | Int63addc =&gt; &quot;addc&quot; % string
  | Int63subc =&gt; &quot;subc&quot; % string
  | Int63addCarryC =&gt; &quot;addCarryC&quot; % string
  | Int63subCarryC =&gt; &quot;subCarryC&quot; % string
  | Int63mulc =&gt; &quot;mulc&quot; % string
  | Int63diveucl =&gt; &quot;diveucl&quot; % string
  | Int63div21 =&gt; &quot;div21&quot; % string
  | Int63addMulDiv =&gt; &quot;addMulDiv&quot; % string
  | Int63eq =&gt; &quot;eq&quot; % string
  | Int63lt =&gt; &quot;lt&quot; % string
  | Int63le =&gt; &quot;le&quot; % string
  | Int63compare =&gt; &quot;compare&quot; % string
  end.

Inductive arg_kind : Type :=
| Kparam : arg_kind
| Kwhnf : arg_kind
| Karg : arg_kind.

Definition args_red := list arg_kind.

Definition kind (function_parameter : t) : list arg_kind :=
  match function_parameter with
  | Int63head0 | Int63tail0 =&gt; cons Kwhnf []
  |
    Int63add | Int63sub | Int63mul | Int63div | Int63mod | Int63lsr | Int63lsl |
      Int63land | Int63lor | Int63lxor | Int63addc | Int63subc | Int63addCarryC
      | Int63subCarryC | Int63mulc | Int63diveucl | Int63eq | Int63lt | Int63le
      | Int63compare =&gt; cons Kwhnf (cons Kwhnf [])
  | Int63div21 | Int63addMulDiv =&gt; cons Kwhnf (cons Kwhnf (cons Kwhnf []))
  end.

Definition arity (function_parameter : t) : Z :=
  match function_parameter with
  | Int63head0 | Int63tail0 =&gt; 1
  |
    Int63add | Int63sub | Int63mul | Int63div | Int63mod | Int63lsr | Int63lsl |
      Int63land | Int63lor | Int63lxor | Int63addc | Int63subc | Int63addCarryC
      | Int63subCarryC | Int63mulc | Int63diveucl | Int63eq | Int63lt | Int63le
      | Int63compare =&gt; 2
  | Int63div21 | Int63addMulDiv =&gt; 3
  end.

Inductive prim_ind : Type :=
| PIT_bool : prim_ind
| PIT_carry : prim_ind
| PIT_pair : prim_ind
| PIT_cmp : prim_ind.

Inductive prim_type : Type :=
| PT_int63 : prim_type.

Inductive op_or_type : Type :=
| OT_op : t -&gt; op_or_type
| OT_type : prim_type -&gt; op_or_type.

Definition prim_ind_to_string (function_parameter : prim_ind) : string :=
  match function_parameter with
  | PIT_bool =&gt; &quot;bool&quot; % string
  | PIT_carry =&gt; &quot;carry&quot; % string
  | PIT_pair =&gt; &quot;pair&quot; % string
  | PIT_cmp =&gt; &quot;cmp&quot; % string
  end.

Definition prim_type_to_string (function_parameter : prim_type) : string :=
  match function_parameter with
  | PT_int63 =&gt; &quot;int63_type&quot; % string
  end.

Definition op_or_type_to_string (function_parameter : op_or_type) : string :=
  match function_parameter with
  | OT_op op =&gt; to_string op
  | OT_type t =&gt; prim_type_to_string t
  end.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="cbytecodes" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>cbytecodes.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Bruno Barras for Benjamin Gr√©goire as part of the
   bytecode-based reduction machine, Oct 2004 *)
(* Support for native arithmetics by Arnaud Spiwack, May 2007 *)

(* This file defines the type of bytecode instructions *)

open Names
open Vmvalues
open Constr

module Label =
  struct
    type t = int
    let no = -1
    let counter = ref no
    let create () = incr counter; !counter
    let reset_label_counter () = counter := no
  end

type instruction =
  | Klabel of Label.t
  | Kacc of int
  | Kenvacc of int
  | Koffsetclosure of int
  | Kpush
  | Kpop of int
  | Kpush_retaddr of Label.t
  | Kapply of int
  | Kappterm of int * int
  | Kreturn of int
  | Kjump
  | Krestart
  | Kgrab of int
  | Kgrabrec of int
  | Kclosure of Label.t * int
  | Kclosurerec of int * int * Label.t array * Label.t array
  | Kclosurecofix of int * int * Label.t array * Label.t array
                   (* nb fv, init, lbl types, lbl bodies *)
  | Kgetglobal of Constant.t
  | Kconst of structured_constant
  | Kmakeblock of int * tag
  | Kmakeprod
  | Kmakeswitchblock of Label.t * Label.t * annot_switch * int
  | Kswitch of Label.t array * Label.t array
  | Kpushfields of int
  | Kfield of int
  | Ksetfield of int
  | Kstop
  | Ksequence of bytecodes * bytecodes
  | Kproj of Projection.Repr.t
  | Kensurestackcapacity of int
  | Kbranch of Label.t                  (* jump to label *)
  | Kprim of CPrimitives.t * pconstant option
  | Kareint of int

and bytecodes = instruction list

type fv_elem =
  | FVnamed of Id.t
  | FVrel of int
  | FVuniv_var of int
  | FVevar of Evar.t

type fv = fv_elem array

(* --- Pretty print *)
open Pp
open Util

let pp_lbl lbl = str &quot;L&quot; ++ int lbl

let pp_fv_elem = function
  | FVnamed id -&gt; str &quot;FVnamed(&quot; ++ Id.print id ++ str &quot;)&quot;
  | FVrel i -&gt; str &quot;Rel(&quot; ++ int i ++ str &quot;)&quot;
  | FVuniv_var v -&gt; str &quot;FVuniv(&quot; ++ int v ++ str &quot;)&quot;
  | FVevar e -&gt; str &quot;FVevar(&quot; ++ int (Evar.repr e) ++ str &quot;)&quot;

let rec pp_instr i =
  match i with
  | Klabel _   | Ksequence _ -&gt; assert false
  | Kacc n -&gt; str &quot;acc &quot; ++ int n
  | Kenvacc n -&gt; str &quot;envacc &quot; ++ int n
  | Koffsetclosure n -&gt; str &quot;offsetclosure &quot; ++ int n
  | Kpush -&gt; str &quot;push&quot;
  | Kpop n -&gt; str &quot;pop &quot; ++ int n
  | Kpush_retaddr lbl -&gt; str &quot;push_retaddr &quot; ++ pp_lbl lbl
  | Kapply n -&gt; str &quot;apply &quot; ++ int n
  | Kappterm(n, m) -&gt;
      str &quot;appterm &quot; ++ int n ++ str &quot;, &quot; ++ int m
  | Kreturn n -&gt; str &quot;return &quot; ++ int n
  | Kjump -&gt; str &quot;jump&quot;
  | Krestart -&gt; str &quot;restart&quot;
  | Kgrab n -&gt; str &quot;grab &quot; ++ int n
  | Kgrabrec n -&gt; str &quot;grabrec &quot; ++ int n
  | Kclosure(lbl, n) -&gt;
      str &quot;closure &quot; ++ pp_lbl lbl ++ str &quot;, &quot; ++ int n
  | Kclosurerec(fv,init,lblt,lblb) -&gt;
      h 1 (str &quot;closurerec &quot; ++
	     int fv ++ str &quot;, &quot; ++ int init ++
	     str &quot; types = &quot; ++
	     prlist_with_sep spc pp_lbl (Array.to_list lblt) ++
	     str &quot; bodies = &quot; ++
	     prlist_with_sep spc pp_lbl (Array.to_list lblb))
  | Kclosurecofix (fv,init,lblt,lblb) -&gt;
      h 1 (str &quot;closurecofix &quot; ++
	     int fv ++ str &quot;, &quot; ++ int init ++
	     str &quot; types = &quot; ++
	     prlist_with_sep spc pp_lbl (Array.to_list lblt) ++
	     str &quot; bodies = &quot; ++
	     prlist_with_sep spc pp_lbl (Array.to_list lblb))
  | Kgetglobal idu -&gt; str &quot;getglobal &quot; ++ Constant.print idu
  | Kconst sc -&gt;
      str &quot;const &quot; ++ pp_struct_const sc
  | Kmakeblock(n, m) -&gt;
      str &quot;makeblock &quot; ++ int n ++ str &quot;, &quot; ++ int m
  | Kmakeprod -&gt; str &quot;makeprod&quot;
  | Kmakeswitchblock(lblt,lbls,_,sz) -&gt;
      str &quot;makeswitchblock &quot; ++ pp_lbl lblt ++ str &quot;, &quot; ++
	pp_lbl lbls ++ str &quot;, &quot; ++ int sz
  | Kswitch(lblc,lblb) -&gt;
      h 1 (str &quot;switch &quot; ++
	     prlist_with_sep spc pp_lbl (Array.to_list lblc) ++
	     str &quot; | &quot; ++
	     prlist_with_sep spc pp_lbl (Array.to_list lblb))
  | Kpushfields n -&gt; str &quot;pushfields &quot; ++ int n
  | Kfield n -&gt; str &quot;field &quot; ++ int n
  | Ksetfield n -&gt; str &quot;setfield &quot; ++ int n

  | Kstop -&gt; str &quot;stop&quot;

  | Kbranch lbl -&gt; str &quot;branch &quot; ++ pp_lbl lbl

  | Kproj p -&gt; str &quot;proj &quot; ++ Projection.Repr.print p

  | Kensurestackcapacity size -&gt; str &quot;growstack &quot; ++ int size

  | Kprim (op, id) -&gt; str (CPrimitives.to_string op) ++ str &quot; &quot; ++
        (match id with Some (id,_u) -&gt; Constant.print id | None -&gt; str &quot;&quot;)

  | Kareint n -&gt; str &quot;areint &quot; ++ int n

and pp_bytecodes c =
  match c with
  | [] -&gt; str &quot;&quot;
  | Klabel lbl :: c -&gt;
	str &quot;L&quot; ++ int lbl ++ str &quot;:&quot; ++ fnl () ++
	pp_bytecodes c
  | Ksequence (l1, l2) :: c -&gt;
      pp_bytecodes l1 ++ pp_bytecodes l2 ++  pp_bytecodes c
  | i :: c -&gt;
      pp_instr i ++ fnl () ++ pp_bytecodes c
</pre>
          </div>
          <div class="col-md-6">
            <code>cbytecodes.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Names.

Import Vmvalues.

Import Constr.

Module Label.
  Definition t := Z.
  
  Definition no : Z := (-1).
  
  Definition counter : Stdlib.ref Z := Stdlib.ref no.
  
  Definition create (function_parameter : unit) : Z :=
    match function_parameter with
    | tt =&gt;
      Stdlib.incr counter;
      Stdlib.op_exclamation counter
    end.
  
  Definition reset_label_counter (function_parameter : unit) : unit :=
    match function_parameter with
    | tt =&gt; Stdlib.op_colon_eq counter no
    end.
End Label.

Reserved Notation &quot;'bytecodes&quot;.

Inductive instruction : Type :=
| Klabel : Label.t -&gt; instruction
| Kacc : Z -&gt; instruction
| Kenvacc : Z -&gt; instruction
| Koffsetclosure : Z -&gt; instruction
| Kpush : instruction
| Kpop : Z -&gt; instruction
| Kpush_retaddr : Label.t -&gt; instruction
| Kapply : Z -&gt; instruction
| Kappterm : Z -&gt; Z -&gt; instruction
| Kreturn : Z -&gt; instruction
| Kjump : instruction
| Krestart : instruction
| Kgrab : Z -&gt; instruction
| Kgrabrec : Z -&gt; instruction
| Kclosure : Label.t -&gt; Z -&gt; instruction
| Kclosurerec : Z -&gt; Z -&gt; (array Label.t) -&gt; (array Label.t) -&gt; instruction
| Kclosurecofix : Z -&gt; Z -&gt; (array Label.t) -&gt; (array Label.t) -&gt; instruction
| Kgetglobal : Names.Constant.t -&gt; instruction
| Kconst : Vmvalues.structured_constant -&gt; instruction
| Kmakeblock : Z -&gt; Vmvalues.tag -&gt; instruction
| Kmakeprod : instruction
| Kmakeswitchblock : Label.t -&gt; Label.t -&gt; Vmvalues.annot_switch -&gt; Z -&gt;
  instruction
| Kswitch : (array Label.t) -&gt; (array Label.t) -&gt; instruction
| Kpushfields : Z -&gt; instruction
| Kfield : Z -&gt; instruction
| Ksetfield : Z -&gt; instruction
| Kstop : instruction
| Ksequence : 'bytecodes -&gt; 'bytecodes -&gt; instruction
| Kproj : Names.Projection.Repr.t -&gt; instruction
| Kensurestackcapacity : Z -&gt; instruction
| Kbranch : Label.t -&gt; instruction
| Kprim : CPrimitives.t -&gt; (option Constr.pconstant) -&gt; instruction
| Kareint : Z -&gt; instruction

where &quot;'bytecodes&quot; := ( list instruction).

Definition bytecodes := 'bytecodes.

Inductive fv_elem : Type :=
| FVnamed : Names.Id.t -&gt; fv_elem
| FVrel : Z -&gt; fv_elem
| FVuniv_var : Z -&gt; fv_elem
| FVevar : Evar.t -&gt; fv_elem.

Definition fv := array fv_elem.

Import Pp.

Import Util.

Definition pp_lbl (lbl : Z) : Pp.t :=
  Pp.op_plus_plus (Pp.str &quot;L&quot; % string) (Pp.int lbl).

Definition pp_fv_elem (function_parameter : fv_elem) : Pp.t :=
  match function_parameter with
  | FVnamed id =&gt;
    Pp.op_plus_plus
      (Pp.op_plus_plus (Pp.str &quot;FVnamed(&quot; % string) (Names.Id.print id))
      (Pp.str &quot;)&quot; % string)
  | FVrel i =&gt;
    Pp.op_plus_plus (Pp.op_plus_plus (Pp.str &quot;Rel(&quot; % string) (Pp.int i))
      (Pp.str &quot;)&quot; % string)
  | FVuniv_var v =&gt;
    Pp.op_plus_plus (Pp.op_plus_plus (Pp.str &quot;FVuniv(&quot; % string) (Pp.int v))
      (Pp.str &quot;)&quot; % string)
  | FVevar e =&gt;
    Pp.op_plus_plus
      (Pp.op_plus_plus (Pp.str &quot;FVevar(&quot; % string) (Pp.int (Evar.repr e)))
      (Pp.str &quot;)&quot; % string)
  end.

Fixpoint pp_instr (i : instruction) : Pp.t :=
  match i with
  | Klabel _ | Ksequence _ _ =&gt; false
  | Kacc n =&gt; Pp.op_plus_plus (Pp.str &quot;acc &quot; % string) (Pp.int n)
  | Kenvacc n =&gt; Pp.op_plus_plus (Pp.str &quot;envacc &quot; % string) (Pp.int n)
  | Koffsetclosure n =&gt;
    Pp.op_plus_plus (Pp.str &quot;offsetclosure &quot; % string) (Pp.int n)
  | Kpush =&gt; Pp.str &quot;push&quot; % string
  | Kpop n =&gt; Pp.op_plus_plus (Pp.str &quot;pop &quot; % string) (Pp.int n)
  | Kpush_retaddr lbl =&gt;
    Pp.op_plus_plus (Pp.str &quot;push_retaddr &quot; % string) (pp_lbl lbl)
  | Kapply n =&gt; Pp.op_plus_plus (Pp.str &quot;apply &quot; % string) (Pp.int n)
  | Kappterm n m =&gt;
    Pp.op_plus_plus
      (Pp.op_plus_plus (Pp.op_plus_plus (Pp.str &quot;appterm &quot; % string) (Pp.int n))
        (Pp.str &quot;, &quot; % string)) (Pp.int m)
  | Kreturn n =&gt; Pp.op_plus_plus (Pp.str &quot;return &quot; % string) (Pp.int n)
  | Kjump =&gt; Pp.str &quot;jump&quot; % string
  | Krestart =&gt; Pp.str &quot;restart&quot; % string
  | Kgrab n =&gt; Pp.op_plus_plus (Pp.str &quot;grab &quot; % string) (Pp.int n)
  | Kgrabrec n =&gt; Pp.op_plus_plus (Pp.str &quot;grabrec &quot; % string) (Pp.int n)
  | Kclosure lbl n =&gt;
    Pp.op_plus_plus
      (Pp.op_plus_plus
        (Pp.op_plus_plus (Pp.str &quot;closure &quot; % string) (pp_lbl lbl))
        (Pp.str &quot;, &quot; % string)) (Pp.int n)
  | Kclosurerec fv init lblt lblb =&gt;
    Pp.h 1
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus
            (Pp.op_plus_plus
              (Pp.op_plus_plus
                (Pp.op_plus_plus
                  (Pp.op_plus_plus (Pp.str &quot;closurerec &quot; % string) (Pp.int fv))
                  (Pp.str &quot;, &quot; % string)) (Pp.int init))
              (Pp.str &quot; types = &quot; % string))
            (Pp.prlist_with_sep Pp.spc pp_lbl
              (Util.Array.(CArray.ExtS.to_list) lblt)))
          (Pp.str &quot; bodies = &quot; % string))
        (Pp.prlist_with_sep Pp.spc pp_lbl
          (Util.Array.(CArray.ExtS.to_list) lblb)))
  | Kclosurecofix fv init lblt lblb =&gt;
    Pp.h 1
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus
            (Pp.op_plus_plus
              (Pp.op_plus_plus
                (Pp.op_plus_plus
                  (Pp.op_plus_plus (Pp.str &quot;closurecofix &quot; % string) (Pp.int fv))
                  (Pp.str &quot;, &quot; % string)) (Pp.int init))
              (Pp.str &quot; types = &quot; % string))
            (Pp.prlist_with_sep Pp.spc pp_lbl
              (Util.Array.(CArray.ExtS.to_list) lblt)))
          (Pp.str &quot; bodies = &quot; % string))
        (Pp.prlist_with_sep Pp.spc pp_lbl
          (Util.Array.(CArray.ExtS.to_list) lblb)))
  | Kgetglobal idu =&gt;
    Pp.op_plus_plus (Pp.str &quot;getglobal &quot; % string) (Names.Constant.print idu)
  | Kconst sc =&gt;
    Pp.op_plus_plus (Pp.str &quot;const &quot; % string) (Vmvalues.pp_struct_const sc)
  | Kmakeblock n m =&gt;
    Pp.op_plus_plus
      (Pp.op_plus_plus
        (Pp.op_plus_plus (Pp.str &quot;makeblock &quot; % string) (Pp.int n))
        (Pp.str &quot;, &quot; % string)) (Pp.int m)
  | Kmakeprod =&gt; Pp.str &quot;makeprod&quot; % string
  | Kmakeswitchblock lblt lbls _ sz =&gt;
    Pp.op_plus_plus
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus
            (Pp.op_plus_plus (Pp.str &quot;makeswitchblock &quot; % string) (pp_lbl lblt))
            (Pp.str &quot;, &quot; % string)) (pp_lbl lbls)) (Pp.str &quot;, &quot; % string))
      (Pp.int sz)
  | Kswitch lblc lblb =&gt;
    Pp.h 1
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus (Pp.str &quot;switch &quot; % string)
            (Pp.prlist_with_sep Pp.spc pp_lbl
              (Util.Array.(CArray.ExtS.to_list) lblc))) (Pp.str &quot; | &quot; % string))
        (Pp.prlist_with_sep Pp.spc pp_lbl
          (Util.Array.(CArray.ExtS.to_list) lblb)))
  | Kpushfields n =&gt; Pp.op_plus_plus (Pp.str &quot;pushfields &quot; % string) (Pp.int n)
  | Kfield n =&gt; Pp.op_plus_plus (Pp.str &quot;field &quot; % string) (Pp.int n)
  | Ksetfield n =&gt; Pp.op_plus_plus (Pp.str &quot;setfield &quot; % string) (Pp.int n)
  | Kstop =&gt; Pp.str &quot;stop&quot; % string
  | Kbranch lbl =&gt; Pp.op_plus_plus (Pp.str &quot;branch &quot; % string) (pp_lbl lbl)
  | Kproj p =&gt;
    Pp.op_plus_plus (Pp.str &quot;proj &quot; % string) (Names.Projection.Repr.print p)
  | Kensurestackcapacity size =&gt;
    Pp.op_plus_plus (Pp.str &quot;growstack &quot; % string) (Pp.int size)
  | Kprim op id =&gt;
    Pp.op_plus_plus
      (Pp.op_plus_plus (Pp.str (CPrimitives.to_string op)) (Pp.str &quot; &quot; % string))
      match id with
      | Some (id, _u) =&gt; Names.Constant.print id
      | None =&gt; Pp.str &quot;&quot; % string
      end
  | Kareint n =&gt; Pp.op_plus_plus (Pp.str &quot;areint &quot; % string) (Pp.int n)
  end

with pp_bytecodes (c : bytecodes) : Pp.t :=
  match c with
  | [] =&gt; Pp.str &quot;&quot; % string
  | cons (Klabel lbl) c =&gt;
    Pp.op_plus_plus
      (Pp.op_plus_plus
        (Pp.op_plus_plus (Pp.op_plus_plus (Pp.str &quot;L&quot; % string) (Pp.int lbl))
          (Pp.str &quot;:&quot; % string)) (Pp.fnl tt)) (pp_bytecodes c)
  | cons (Ksequence l1 l2) c =&gt;
    Pp.op_plus_plus (Pp.op_plus_plus (pp_bytecodes l1) (pp_bytecodes l2))
      (pp_bytecodes c)
  | cons i c =&gt;
    Pp.op_plus_plus (Pp.op_plus_plus (pp_instr i) (Pp.fnl tt)) (pp_bytecodes c)
  end.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="cbytegen" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>cbytegen.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Author: Benjamin Gr√©goire as part of the bytecode-based virtual reduction
   machine, Oct 2004 *)
(* Extension: Arnaud Spiwack (support for native arithmetic), May 2005 *)

open Util
open Names
open Vmvalues
open Cbytecodes
open Cemitcodes
open Clambda
open Constr
open Declarations
open Environ


(* Compilation of variables + computing free variables                    *)

(* The virtual machine doesn't distinguish closures and their environment *)

(* Representation of function environments :                              *)
(*        [clos_t | code | fv1 | fv2 | ... | fvn ]                        *)
(*                ^                                                       *)
(*  The offset for accessing free variables is 1 (we must skip the code   *)
(*  pointer).                                                             *)
(*  While compiling, free variables are stored in [in_env] in order       *)
(*  opposite to machine representation, so we can add new free variables  *)
(*  easily (i.e. without changing the position of previous variables)     *)
(* Function arguments are on the stack in the same order as the           *)
(* application :  f arg1 ... argn                                         *)
(*   - the stack is then :                                                *)
(*        arg1 : ... argn : extra args : return addr : ...                *)
(* In the function body [arg1] is represented by de Bruijn [n], and       *)
(* [argn] by de Bruijn [1]                                                *)

(* Representation of environments of mutual fixpoints :                  *)
(* [t1|C1| ... |tc|Cc| ... |t(nbr)|C(nbr)| fv1 | fv2 | .... | fvn | type] *)
(*                ^&lt;----------offset---------&gt;                            *)
(* type = [Ct1 | .... | Ctn]                                              *)
(* Ci is the code pointer of the i-th body                                *)
(* At runtime, a fixpoint environment (which is the same as the fixpoint  *)
(* itself) is a pointer to the field holding its code pointer.            *)
(* In each fixpoint body, de Bruijn [nbr] represents the first fixpoint   *)
(* and de Bruijn [1] the last one.                                        *)
(* Access to these variables is performed by the [Koffsetclosure n]       *)
(* instruction that shifts the environment pointer of [n] fields.         *)

(* This allows representing mutual fixpoints in just one block.           *)
(* [Ct1 | ... | Ctn] is an array holding code pointers of the fixpoint    *)
(* types. They are used in conversion tests (which requires that          *)
(* fixpoint types must be convertible). Their environment is the one of   *)
(* the last fixpoint :                                                    *)
(* [t1|C1| ... |tc|Cc| ... |t(nbr)|C(nbr)| fv1 | fv2 | .... | fvn | type] *)
(*                                ^                                       *)

(* Representation of mutual cofix :                                       *)
(*  a1 =   [A_t | accumulate | [Cfx_t | fcofix1 ] ]                       *)
(*                ...                                                     *)
(*  anbr = [A_t | accumulate | [Cfx_t | fcofixnbr ] ]                     *)
(*                                                                        *)
(*  fcofix1 = [clos_t   | code1   | a1 |...| anbr | fv1 |...| fvn | type] *)
(*                      ^                                                 *)
(*                ...                                                     *)
(*  fcofixnbr = [clos_t | codenbr | a1 |...| anbr | fv1 |...| fvn | type] *)
(*                      ^                                                 *)
(* The [ai] blocks are functions that accumulate their arguments:         *)
(*           ai arg1  argp ---&gt;                                           *)
(*    ai' = [A_t | accumulate | [Cfx_t | fcofixi] | arg1 | ... | argp ]   *)
(* If such a block is matched against, we have to force evaluation,       *)
(* function [fcofixi] is then applied to [ai'] [arg1] ... [argp]          *)
(* (note that [ai'] is a pointer to the closure, passed as argument)      *)
(* Once evaluation is completed [ai'] is updated with the result:         *)
(*  ai' &lt;--                                                               *)
(*   [A_t | accumulate | [Cfxe_t |fcofixi|result] | arg1 | ... | argp ]   *)
(* This representation is nice because the application of the cofix is    *)
(* evaluated only once (it simulates a lazy evaluation)                   *)
(* Moreover, when cofix don't have arguments, it is possible to create    *)
(* a cycle, e.g.:                                                         *)
(*   cofix one := cons 1 one                                              *)
(*   a1 = [A_t | accumulate | [Cfx_t|fcofix1] ]                           *)
(*   fcofix1 = [clos_t | code | a1]                                       *)
(* The result of evaluating [a1] is [cons_t | 1 | a1].                    *)
(* When [a1] is updated :                                                 *)
(*  a1 = [A_t | accumulate | [Cfxe_t | fcofix1 | [cons_t | 1 | a1]] ]     *)
(* The cycle is created ...                                               *)
(*                                                                        *)
(* In Cfxe_t accumulators, we need to store [fcofixi] for testing         *)
(* conversion of cofixpoints (which is intentional).                      *)

module Fv_elem =
struct
type t = fv_elem

let compare e1 e2 = match e1, e2 with
| FVnamed id1, FVnamed id2 -&gt; Id.compare id1 id2
| FVnamed _, (FVrel _ | FVuniv_var _ | FVevar _) -&gt; -1
| FVrel _, FVnamed _ -&gt; 1
| FVrel r1, FVrel r2 -&gt; Int.compare r1 r2
| FVrel _, (FVuniv_var _ | FVevar _) -&gt; -1
| FVuniv_var i1, FVuniv_var i2 -&gt; Int.compare i1 i2
| FVuniv_var _, (FVnamed _ | FVrel _) -&gt; 1
| FVuniv_var _, FVevar _ -&gt; -1
| FVevar _, (FVnamed _ | FVrel _ | FVuniv_var _) -&gt; 1
| FVevar e1, FVevar e2 -&gt; Evar.compare e1 e2

end

module FvMap = Map.Make(Fv_elem)

(*spiwack: both type have been moved from Cbytegen because I needed then
  for the retroknowledge *)
type vm_env = {
    size : int;              (* longueur de la liste [n] *)
    fv_rev : fv_elem list;   (* [fvn; ... ;fv1] *)
    fv_fwd : int FvMap.t;    (* reverse mapping *)
  }


type comp_env = {
    arity : int;                 (* arity of the current function, 0 if none *)
    nb_uni_stack : int ;         (* number of universes on the stack,      *)
                                 (* universes are always at the bottom.    *)
    nb_stack : int;              (* number of variables on the stack       *)
    in_stack : int list;         (* position in the stack                  *)
    nb_rec : int;                (* number of mutually recursive functions *)
    pos_rec  : instruction list; (* instruction d'acces pour les variables *)
                                 (*  de point fix ou de cofix              *)
    offset : int;
    in_env : vm_env ref          (* The free variables of the expression   *)
  }

module Config = struct
  let stack_threshold = 256 (* see byterun/coq_memory.h *)
  let stack_safety_margin = 15
end

type argument = ArgLambda of lambda | ArgUniv of Univ.Level.t

let empty_fv = { size= 0;  fv_rev = []; fv_fwd = FvMap.empty }
let push_fv d e = {
  size = e.size + 1;
  fv_rev = d :: e.fv_rev;
  fv_fwd = FvMap.add d e.size e.fv_fwd;
}

let fv r = !(r.in_env)

let empty_comp_env ()=
  { arity = 0;
    nb_uni_stack = 0;
    nb_stack = 0;
    in_stack = [];
    nb_rec = 0;
    pos_rec = [];
    offset = 0;
    in_env = ref empty_fv
  }

(* Maximal stack size reached during the current function body. Used to
   reallocate the stack if we lack space. *)
let max_stack_size = ref 0

let set_max_stack_size stack_size =
  if stack_size &gt; !max_stack_size then
    max_stack_size := stack_size

let ensure_stack_capacity f x =
  let old = !max_stack_size in
  max_stack_size := 0;
  let code = f x in
  let used_safe =
    !max_stack_size + Config.stack_safety_margin
  in
  max_stack_size := old;
  if used_safe &gt; Config.stack_threshold then
    Kensurestackcapacity used_safe :: code
  else code

(*i Creation functions for comp_env *)

let rec add_param n sz l =
  if Int.equal n 0 then l else add_param (n - 1) sz (n+sz::l)

let comp_env_fun ?(univs=0) arity =
  { arity;
    nb_uni_stack = univs ;
    nb_stack = arity;
    in_stack = add_param arity 0 [];
    nb_rec = 0;
    pos_rec = [];
    offset = 1;
    in_env = ref empty_fv
  }


let comp_env_fix_type  rfv =
  { arity = 0;
    nb_uni_stack = 0;
    nb_stack = 0;
    in_stack = [];
    nb_rec = 0;
    pos_rec = [];
    offset = 1;
    in_env = rfv
  }

let comp_env_fix ndef curr_pos arity rfv =
   let prec = ref [] in
   for i = ndef downto 1 do
     prec := Koffsetclosure (2 * (ndef - curr_pos - i)) :: !prec
   done;
   { arity;
     nb_uni_stack = 0;
     nb_stack = arity;
     in_stack = add_param arity 0 [];
     nb_rec = ndef;
     pos_rec = !prec;
     offset = 2 * (ndef - curr_pos - 1)+1;
     in_env = rfv
   }

let comp_env_cofix_type ndef rfv =
  { arity = 0;
    nb_uni_stack = 0;
    nb_stack = 0;
    in_stack = [];
    nb_rec = 0;
    pos_rec = [];
    offset = 1+ndef;
    in_env = rfv
  }

let comp_env_cofix ndef arity rfv =
   let prec = ref [] in
   for i = 1 to ndef do
     prec := Kenvacc i :: !prec
   done;
   { arity;
     nb_uni_stack = 0;
     nb_stack = arity;
     in_stack = add_param arity 0 [];
     nb_rec = ndef;
     pos_rec = !prec;
     offset = ndef+1;
     in_env = rfv
   }

(* [push_param ] add function parameters on the stack *)
let push_param n sz r =
  { r with
    nb_stack = r.nb_stack + n;
    in_stack = add_param n sz r.in_stack }

(* [push_local sz r] add a new variable on the stack at position [sz] *)
let push_local sz r =
  { r with
    nb_stack = r.nb_stack + 1;
    in_stack = (sz + 1) :: r.in_stack }

(*i Compilation of variables *)
let find_at fv env = FvMap.find fv env.fv_fwd

let pos_named id r =
  let env = !(r.in_env) in
  let cid = FVnamed id in
  try Kenvacc(r.offset + find_at cid env)
  with Not_found -&gt;
    let pos = env.size in
    r.in_env := push_fv cid env;
    Kenvacc (r.offset + pos)

let pos_rel i r sz =
  if i &lt;= r.nb_stack then
    Kacc(sz - (List.nth r.in_stack (i-1)))
  else
    let i = i - r.nb_stack in
    if i &lt;= r.nb_rec then
      try List.nth r.pos_rec (i-1)
      with (Failure _|Invalid_argument _) -&gt; assert false
    else
      let i = i - r.nb_rec in
      let db = FVrel(i) in
      let env = !(r.in_env) in
      try Kenvacc(r.offset + find_at db env)
      with Not_found -&gt;
	let pos = env.size in
	r.in_env := push_fv db env;
	Kenvacc(r.offset + pos)

let pos_universe_var i r sz =
  (* Compilation of a universe variable can happen either at toplevel (the
  current closure correspond to a constant and has local universes) or in a
  local closure (which has no local universes). *)
  if r.nb_uni_stack != 0 then
    (* Universe variables are represented by De Bruijn levels (not indices),
    starting at 0. The shape of the stack will be [v1|..|vn|u1..up|arg1..argq]
    with size = n + p + q, and q = r.arity. So Kacc (sz - r.arity - 1) will access
    the last universe. *)
    Kacc (sz - r.arity - (r.nb_uni_stack - i))
  else
    let env = !(r.in_env) in
    let db = FVuniv_var i in
    try Kenvacc (r.offset + find_at db env)
    with Not_found -&gt;
      let pos = env.size in
      r.in_env := push_fv db env;
      Kenvacc(r.offset + pos)

let pos_evar evk r =
  let env = !(r.in_env) in
  let cid = FVevar evk in
  try Kenvacc(r.offset + find_at cid env)
  with Not_found -&gt;
    let pos = env.size in
    r.in_env := push_fv cid env;
    Kenvacc (r.offset + pos)

(*i  Examination of the continuation *)

(* Discard all instructions up to the next label.                        *)
(* This function is to be applied to the continuation before adding a    *)
(* non-terminating instruction (branch, raise, return, appterm)          *)
(* in front of it.                                                       *)

let discard_dead_code cont = cont
(*function
    [] -&gt; []
  | (Klabel _ | Krestart ) :: _ as cont -&gt; cont
  | _ :: cont -&gt; discard_dead_code cont
*)

(* Return a label to the beginning of the given continuation.            *)
(*   If the sequence starts with a branch, use the target of that branch *)
(*   as the label, thus avoiding a jump to a jump.                       *)

let label_code = function
  | Klabel lbl :: _ as cont -&gt; (lbl, cont)
  | Kbranch lbl :: _ as cont -&gt; (lbl, cont)
  | cont -&gt; let lbl = Label.create() in (lbl, Klabel lbl :: cont)

(* Return a branch to the continuation. That is, an instruction that,
   when executed, branches to the continuation or performs what the
   continuation performs. We avoid generating branches to returns. *)
(* spiwack: make_branch was only used once. Changed it back to the ZAM
      one to match the appropriate semantics (old one avoided the
      introduction of an unconditional branch operation, which seemed
      appropriate for the 31-bit integers' code). As a memory, I leave
      the former version in this comment.
let make_branch cont =
  match cont with
  | (Kreturn _ as return) :: cont' -&gt; return, cont'
  | Klabel lbl as b :: _ -&gt; b, cont
  | _ -&gt; let b = Klabel(Label.create()) in b,b::cont
*)

let rec make_branch_2 lbl n cont =
  function
    Kreturn m :: _ -&gt; (Kreturn (n + m), cont)
  | Klabel _ :: c  -&gt; make_branch_2 lbl n cont c
  | Kpop m :: c    -&gt; make_branch_2 lbl (n + m) cont c
  | _              -&gt;
      match lbl with
        Some lbl -&gt; (Kbranch lbl, cont)
      | None     -&gt; let lbl = Label.create() in (Kbranch lbl, Klabel lbl :: cont)

let make_branch cont =
  match cont with
    (Kbranch _ as branch) :: _ -&gt; (branch, cont)
  | (Kreturn _ as return) :: _ -&gt; (return, cont)
  | Klabel lbl :: _ -&gt; make_branch_2 (Some lbl) 0 cont cont
  | _ -&gt;  make_branch_2 (None) 0 cont cont

(* Check if we're in tailcall position *)

let rec is_tailcall = function
  | Kreturn k :: _ -&gt; Some k
  | Klabel _ :: c -&gt; is_tailcall c
  | _ -&gt; None

(* Extension of the continuation *)

(* Add a Kpop n instruction in front of a continuation *)
let rec add_pop n = function
  | Kpop m :: cont -&gt; add_pop (n+m) cont
  | Kreturn m:: cont -&gt; Kreturn (n+m) ::cont
  | cont -&gt; if Int.equal n 0 then cont else Kpop n :: cont

let add_grab arity lbl cont =
  if Int.equal arity 1 then Klabel lbl :: cont
  else Krestart :: Klabel lbl :: Kgrab (arity - 1) :: cont

let add_grabrec rec_arg arity lbl cont =
  if Int.equal arity 1 &amp;&amp; rec_arg &lt; arity then
    Klabel lbl :: Kgrabrec 0 :: Krestart :: cont
  else
    Krestart :: Klabel lbl :: Kgrabrec rec_arg ::
    Krestart :: Kgrab (arity - 1) :: cont

(* continuation of a cofix *)

let cont_cofix arity =
    (* accu = res                                                         *)
    (* stk  = ai::args::ra::...                                           *)
    (* ai   = [At|accumulate|[Cfx_t|fcofix]|args]                         *)
  [ Kpush;
    Kpush;        (*                 stk = res::res::ai::args::ra::...    *)
    Kacc 2;
    Kfield 1;
    Kfield 0;
    Kmakeblock(2, cofix_evaluated_tag);
    Kpush;        (*  stk = [Cfxe_t|fcofix|res]::res::ai::args::ra::...*)
    Kacc 2;
    Ksetfield 1;  (*   ai = [At|accumulate|[Cfxe_t|fcofix|res]|args]      *)
                  (*  stk = res::ai::args::ra::...                        *)
    Kacc 0;       (* accu = res                                           *)
    Kreturn (arity+2) ]


(* Code of closures *)
let fun_code = ref []

let init_fun_code () = fun_code := []

(* Compilation of constructors and inductive types *)


(*
If [tag] hits the OCaml limitation for non constant constructors, we switch to
another representation for the remaining constructors:
[last_variant_tag|tag - Obj.last_non_constant_constructor_tag|args]

We subtract Obj.last_non_constant_constructor_tag for efficiency of match interpretation.
 *)

let nest_block tag arity cont =
  Kconst (Const_b0 (tag - Obj.last_non_constant_constructor_tag)) ::
    Kmakeblock(arity+1, Obj.last_non_constant_constructor_tag) :: cont

let code_makeblock ~stack_size ~arity ~tag cont = 
  if tag &lt; Obj.last_non_constant_constructor_tag then
    Kmakeblock(arity, tag) :: cont
  else begin
    set_max_stack_size (stack_size + 1);
    Kpush :: nest_block tag arity cont
  end

let compile_structured_constant _cenv sc sz cont =
  set_max_stack_size sz;
  Kconst sc :: cont

(* compiling application *)
let comp_args comp_expr cenv args sz cont =
  let nargs_m_1 = Array.length args - 1 in
  let c = ref (comp_expr cenv args.(0) (sz + nargs_m_1) cont) in
  for i = 1 to nargs_m_1 do
    c := comp_expr cenv args.(i) (sz + nargs_m_1 - i) (Kpush :: !c)
  done;
  !c

let comp_app comp_fun comp_arg cenv f args sz cont =
  let nargs = Array.length args in
  if Int.equal nargs 0 then comp_fun cenv f sz cont
  else
  match is_tailcall cont with
  | Some k -&gt;
      comp_args comp_arg cenv args sz
	(Kpush ::
         comp_fun cenv f (sz + nargs)
	   (Kappterm(nargs, k + nargs) :: (discard_dead_code cont)))
  | None -&gt;
      if nargs &lt;= 4 then
        comp_args comp_arg cenv args sz
          (Kpush :: (comp_fun cenv f (sz+nargs) (Kapply nargs :: cont)))
      else
	let lbl,cont1 = label_code cont in
	Kpush_retaddr lbl ::
        (comp_args comp_arg cenv args (sz + 3)
           (Kpush :: (comp_fun cenv f (sz+3+nargs) (Kapply nargs :: cont1))))

(* Compiling free variables *)

let compile_fv_elem cenv fv sz cont =
  match fv with
  | FVrel i -&gt; pos_rel i cenv sz :: cont
  | FVnamed id -&gt; pos_named id cenv :: cont
  | FVuniv_var i -&gt; pos_universe_var i cenv sz :: cont
  | FVevar evk -&gt; pos_evar evk cenv :: cont

let rec compile_fv cenv l sz cont =
  match l with
  | [] -&gt; cont
  | [fvn] -&gt; set_max_stack_size (sz + 1); compile_fv_elem cenv fvn sz cont
  | fvn :: tl -&gt;
      compile_fv_elem cenv fvn sz
        (Kpush :: compile_fv cenv tl (sz + 1) cont)


(* Compiling constants *)

let rec get_alias env kn =
  let cb = lookup_constant kn env in
  let tps = cb.const_body_code in
    match tps with
    | None -&gt; kn
    | Some tps -&gt;
       (match Cemitcodes.force tps with
	| BCalias kn' -&gt; get_alias env kn'
	| _ -&gt; kn)

(* sz is the size of the local stack *)
let rec compile_lam env cenv lam sz cont =
  set_max_stack_size sz;
  match lam with
  | Lrel(_, i) -&gt; pos_rel i cenv sz :: cont

  | Lint i -&gt; compile_structured_constant cenv (Const_b0 i) sz cont

  | Lval v -&gt; compile_structured_constant cenv (Const_val v) sz cont

  | Luint i -&gt; compile_structured_constant cenv (Const_uint i) sz cont

  | Lproj (p,arg) -&gt;
     compile_lam env cenv arg sz (Kproj p :: cont)

  | Lvar id -&gt; pos_named id cenv :: cont

  | Levar (evk, args) -&gt;
      if Array.is_empty args then
        compile_fv_elem cenv (FVevar evk) sz cont
      else
        (** Arguments are reversed in evar instances *)
        let args = Array.copy args in
        let () = Array.rev args in
        comp_app compile_fv_elem (compile_lam env) cenv (FVevar evk) args sz cont

  | Lconst (kn,u) -&gt; compile_constant env cenv kn u [||] sz cont

  | Lind (ind,u) -&gt;
    if Univ.Instance.is_empty u then
      compile_structured_constant cenv (Const_ind ind) sz cont
    else comp_app compile_structured_constant compile_universe cenv
        (Const_ind ind) (Univ.Instance.to_array u) sz cont

  | Lsort (Sorts.SProp | Sorts.Prop | Sorts.Set as s) -&gt;
    compile_structured_constant cenv (Const_sort s) sz cont
  | Lsort (Sorts.Type u) -&gt;
    (* We represent universes as a global constant with local universes
       &quot;compacted&quot;, i.e. as [u arg0 ... argn] where we will substitute (after
       evaluation) [Var 0,...,Var n] with values of [arg0,...,argn] *)
    let u,s = Univ.compact_univ u in
    let compile_get_univ cenv idx sz cont =
      set_max_stack_size sz;
      compile_fv_elem cenv (FVuniv_var idx) sz cont
    in
    if List.is_empty s then
      compile_structured_constant cenv (Const_sort (Sorts.sort_of_univ u)) sz cont
    else
      comp_app compile_structured_constant compile_get_univ cenv
        (Const_sort (Sorts.sort_of_univ u)) (Array.of_list s) sz cont

  | Llet (_id,def,body) -&gt;
      compile_lam env cenv def sz
        (Kpush ::
         compile_lam env (push_local sz cenv) body (sz+1) (add_pop 1 cont))

  | Lprod (dom,codom) -&gt;
     let cont1 =
       Kpush :: compile_lam env cenv dom (sz+1) (Kmakeprod :: cont) in
     compile_lam env cenv codom sz cont1

  | Llam (ids,body) -&gt;
     let arity = Array.length ids in
     let r_fun = comp_env_fun arity in
     let lbl_fun = Label.create() in
     let cont_fun =
       ensure_stack_capacity (compile_lam env r_fun body arity) [Kreturn arity]
     in
     fun_code := [Ksequence(add_grab arity lbl_fun cont_fun,!fun_code)];
     let fv = fv r_fun in
     compile_fv cenv fv.fv_rev sz (Kclosure(lbl_fun,fv.size) :: cont)

  | Lapp (f, args) -&gt;
    begin match f with
    | Lconst (kn,u) -&gt; compile_constant env cenv kn u args sz cont
    | _ -&gt; comp_app (compile_lam env) (compile_lam env) cenv f args sz cont
    end

  | Lfix ((rec_args, init), (_decl, types, bodies)) -&gt;
      let ndef = Array.length types in
      let rfv = ref empty_fv in
      let lbl_types = Array.make ndef Label.no in
      let lbl_bodies = Array.make ndef Label.no in
      (* Compiling types *)
      let env_type = comp_env_fix_type rfv in
      for i = 0 to ndef - 1 do
        let fcode =
          ensure_stack_capacity (compile_lam env env_type types.(i) 0) [Kstop]
        in
        let lbl,fcode = label_code fcode in
        lbl_types.(i) &lt;- lbl;
	fun_code := [Ksequence(fcode,!fun_code)]
      done;
      (* Compiling bodies *)
      for i = 0 to ndef - 1 do
        let params,body = decompose_Llam bodies.(i) in
        let arity = Array.length params in
	let env_body = comp_env_fix ndef i arity rfv in
        let cont1 =
          ensure_stack_capacity (compile_lam env env_body body arity) [Kreturn arity]
        in
	let lbl = Label.create () in
	lbl_bodies.(i) &lt;- lbl;
	let fcode =  add_grabrec rec_args.(i) arity lbl cont1 in
	fun_code := [Ksequence(fcode,!fun_code)]
      done;
      let fv = !rfv in
      compile_fv cenv fv.fv_rev sz
	(Kclosurerec(fv.size,init,lbl_types,lbl_bodies) :: cont)


  | Lcofix(init, (_decl,types,bodies)) -&gt;
      let ndef = Array.length types in
      let lbl_types = Array.make ndef Label.no in
      let lbl_bodies = Array.make ndef Label.no in
      (* Compiling types *)
      let rfv = ref empty_fv in
      let env_type = comp_env_cofix_type ndef rfv in
      for i = 0 to ndef - 1 do
        let fcode =
          ensure_stack_capacity (compile_lam env env_type types.(i) 0) [Kstop]
        in
        let lbl,fcode = label_code fcode in
        lbl_types.(i) &lt;- lbl;
	fun_code := [Ksequence(fcode,!fun_code)]
      done;
      (* Compiling bodies *)
      for i = 0 to ndef - 1 do
        let params,body = decompose_Llam bodies.(i) in
        let arity = Array.length params in
	let env_body = comp_env_cofix ndef arity rfv in
	let lbl = Label.create () in
        let comp arity =
          (* 4 stack slots are needed to update the cofix when forced *)
          set_max_stack_size (arity + 4);
          compile_lam env env_body body (arity+1) (cont_cofix arity)
        in
	let cont = ensure_stack_capacity comp arity in
	lbl_bodies.(i) &lt;- lbl;
	fun_code := [Ksequence(add_grab (arity+1) lbl cont,!fun_code)];
      done;
      let fv = !rfv in
      set_max_stack_size (sz + fv.size + ndef + 2);
      compile_fv cenv fv.fv_rev sz
	(Kclosurecofix(fv.size, init, lbl_types, lbl_bodies) :: cont)

  | Lif(t, bt, bf) -&gt;
      let branch, cont = make_branch cont in
      let lbl_true =  Label.create() in
      let lbl_false = Label.create() in
      compile_lam env cenv t sz
        (Kswitch([|lbl_true;lbl_false|],[||]) ::
         Klabel lbl_false ::
         compile_lam env cenv bf sz
           (branch ::
            Klabel lbl_true ::
            compile_lam env cenv bt sz cont))

  | Lcase(ci,rtbl,t,a,branches) -&gt;
      let ind = ci.ci_ind in
      let mib = lookup_mind (fst ind) env in
      let oib = mib.mind_packets.(snd ind) in
      let lbl_consts = Array.make oib.mind_nb_constant Label.no in
      let nallblock = oib.mind_nb_args + 1 in (* +1 : accumulate *)
      let nconst = Array.length branches.constant_branches in
      let nblock = min nallblock (Obj.last_non_constant_constructor_tag + 1) in
      let lbl_blocks = Array.make nblock Label.no in
      let neblock = max 0 (nallblock - Obj.last_non_constant_constructor_tag) in
      let lbl_eblocks = Array.make neblock Label.no in 
      let branch1, cont = make_branch cont in
      (* Compilation of the return type *)
      let fcode =
        ensure_stack_capacity (compile_lam env cenv t sz) [Kpop sz; Kstop]
      in
      let lbl_typ,fcode = label_code fcode in
      fun_code := [Ksequence(fcode,!fun_code)];
      (* Compilation of the branches *)
      let lbl_sw = Label.create () in
      let sz_b,branch,is_tailcall =
        match branch1 with
        | Kreturn k -&gt;
          assert (Int.equal k sz) ;
          sz, branch1, true
        | Kbranch _ -&gt; sz+3, Kjump, false
        | _ -&gt; assert false
      in

      let c = ref cont in
      (* Perform the extra match if needed (too many block constructors) *)
      if neblock &lt;&gt; 0 then begin
        let lbl_b, code_b = 
          label_code (
            Kpush :: Kfield 0 :: Kswitch(lbl_eblocks, [||]) :: !c) in
        lbl_blocks.(Obj.last_non_constant_constructor_tag) &lt;- lbl_b;
        c := code_b
      end;

      (* Compilation of constant branches *)
      for i = nconst - 1 downto 0 do
        let aux =
          compile_lam env cenv branches.constant_branches.(i) sz_b (branch::!c)
        in
        let lbl_b,code_b = label_code aux in
        lbl_consts.(i) &lt;- lbl_b;
        c := code_b
      done;
      (* -1 for accu branch *)
      for i = nallblock - 2 downto 0 do
        let tag = i + 1 in
        let (ids, body) = branches.nonconstant_branches.(i) in
        let arity = Array.length ids in
        let code_b =
          compile_lam env (push_param arity sz_b cenv)
            body (sz_b+arity) (add_pop arity (branch::!c)) in
        let code_b =
            if tag &lt; Obj.last_non_constant_constructor_tag then begin
                set_max_stack_size (sz_b + arity);
                Kpushfields arity :: code_b
              end
            else begin
                set_max_stack_size (sz_b + arity + 1);
                Kacc 0::Kpop 1::Kpushfields(arity+1)::Kpop 1::code_b
              end
        in
        let lbl_b, code_b = label_code code_b in
        if tag &lt; Obj.last_non_constant_constructor_tag then lbl_blocks.(tag) &lt;- lbl_b
          else lbl_eblocks.(tag - Obj.last_non_constant_constructor_tag) &lt;- lbl_b;
        c := code_b
      done;

      let annot =
        {ci = ci; rtbl = rtbl; tailcall = is_tailcall;
         max_stack_size = !max_stack_size - sz}
      in

     (* Compiling branch for accumulators *)
      let lbl_accu, code_accu =
        set_max_stack_size (sz+3);
	label_code(Kmakeswitchblock(lbl_typ,lbl_sw,annot,sz) :: branch :: !c)
      in
      lbl_blocks.(0) &lt;- lbl_accu;

      c := Klabel lbl_sw :: Kswitch(lbl_consts,lbl_blocks) :: code_accu;
      let code_sw =
 	match branch1 with
        (* spiwack : branch1 can't be a lbl anymore it's a Branch instead
	| Klabel lbl -&gt; Kpush_retaddr lbl ::  !c *)
        | Kbranch lbl -&gt; Kpush_retaddr lbl ::  !c
	| _ -&gt; !c
      in
      compile_lam env cenv a sz code_sw

  | Lmakeblock (tag,args) -&gt;
    let arity = Array.length args in
    let cont = code_makeblock ~stack_size:(sz+arity-1) ~arity ~tag cont in
    comp_args (compile_lam env) cenv args sz cont

  | Lprim (kn, op, args) -&gt;
    comp_args (compile_lam env) cenv args sz (Kprim(op, kn)::cont)

and compile_get_global cenv (kn,u) sz cont =
  set_max_stack_size sz;
  if Univ.Instance.is_empty u then
    Kgetglobal kn :: cont
  else
    comp_app (fun _ _ _ cont -&gt; Kgetglobal kn :: cont)
      compile_universe cenv () (Univ.Instance.to_array u) sz cont

and compile_universe cenv uni sz cont =
  set_max_stack_size sz;
  match Univ.Level.var_index uni with
  | None -&gt; compile_structured_constant cenv (Const_univ_level uni) sz cont
  | Some idx -&gt; pos_universe_var idx cenv sz :: cont

and compile_constant env cenv kn u args sz cont =
  set_max_stack_size sz;
  if Univ.Instance.is_empty u then
    (* normal compilation *)
    comp_app (fun _ _ sz cont -&gt;
        compile_get_global cenv (kn,u) sz cont)
      (compile_lam env) cenv () args sz cont
  else
    let compile_arg cenv constr_or_uni sz cont =
      match constr_or_uni with
      | ArgLambda t -&gt; compile_lam env cenv t sz cont
      | ArgUniv uni -&gt; compile_universe cenv uni sz cont
    in
    let u = Univ.Instance.to_array u in
    let lu = Array.length u in
    let all =
      Array.init (lu + Array.length args)
        (fun i -&gt; if i &lt; lu then ArgUniv u.(i) else ArgLambda args.(i-lu))
    in
    comp_app (fun _ _ _ cont -&gt; Kgetglobal kn :: cont)
      compile_arg cenv () all sz cont

let is_univ_copy max u =
  let u = Univ.Instance.to_array u in
  if Array.length u = max then
    Array.fold_left_i (fun i acc u -&gt;
        if acc then
          match Univ.Level.var_index u with
          | None -&gt; false
          | Some l -&gt; l = i
        else false) true u
  else
    false

let dump_bytecode = ref false

let dump_bytecodes init code fvs =
  let open Pp in
    (str &quot;code =&quot; ++ fnl () ++
     pp_bytecodes init ++ fnl () ++
     pp_bytecodes code ++ fnl () ++
     str &quot;fv = &quot; ++
     prlist_with_sep (fun () -&gt; str &quot;; &quot;) pp_fv_elem fvs ++
     fnl ())

let compile ~fail_on_error ?universes:(universes=0) env c =
  init_fun_code ();
  Label.reset_label_counter ();
  let cont = [Kstop] in
  try
    let cenv, init_code =
      if Int.equal universes 0 then
        let lam = lambda_of_constr ~optimize:true env c in
        let cenv = empty_comp_env () in
        cenv, ensure_stack_capacity (compile_lam env cenv lam 0) cont
      else
        (* We are going to generate a lambda, but merge the universe closure
         * with the function closure if it exists.
         *)
        let lam = lambda_of_constr ~optimize:true env c in
        let params, body = decompose_Llam lam in
        let arity = Array.length params in
        let cenv = empty_comp_env () in
        let full_arity = arity + universes in
        let r_fun = comp_env_fun ~univs:universes arity in
        let lbl_fun = Label.create () in
        let cont_fun =
          ensure_stack_capacity (compile_lam env r_fun body full_arity)
                         [Kreturn full_arity]
        in
        fun_code := [Ksequence(add_grab full_arity lbl_fun cont_fun,!fun_code)];
        let fv = fv r_fun in
        let init_code =
          ensure_stack_capacity (compile_fv cenv fv.fv_rev 0)
                         (Kclosure(lbl_fun,fv.size) :: cont)
        in
        cenv, init_code
    in
    let fv = List.rev (!(cenv.in_env).fv_rev) in
    (if !dump_bytecode then
      Feedback.msg_debug (dump_bytecodes init_code !fun_code fv)) ;
    Some (init_code,!fun_code, Array.of_list fv)
  with TooLargeInductive msg -&gt;
    let fn = if fail_on_error then CErrors.user_err ?loc:None ~hdr:&quot;compile&quot; else
        (fun x -&gt; Feedback.msg_warning x) in
    fn msg; None

let compile_constant_body ~fail_on_error env univs = function
  | Undef _ | OpaqueDef _ | Primitive _ -&gt; Some BCconstant
  | Def sb -&gt;
      let body = Mod_subst.force_constr sb in
      let instance_size = Univ.AUContext.size (Declareops.universes_context univs) in
      match kind body with
	| Const (kn',u) when is_univ_copy instance_size u -&gt;
	    (* we use the canonical name of the constant*)
	    let con= Constant.make1 (Constant.canonical kn') in
	      Some (BCalias (get_alias env con))
	| _ -&gt;
            let res = compile ~fail_on_error ~universes:instance_size env body in
	      Option.map (fun x -&gt; BCdefined (to_memory x)) res

(* Shortcut of the previous function used during module strengthening *)

let compile_alias kn = BCalias (Constant.make1 (Constant.canonical kn))
</pre>
          </div>
          <div class="col-md-6">
            <code>cbytegen.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Util.

Import Names.

Import Vmvalues.

Import Cbytecodes.

Import Cemitcodes.

Import Clambda.

Import Constr.

Import Declarations.

Import Environ.

Module Fv_elem.
  Definition t := Cbytecodes.fv_elem.
  
  Definition compare (e1 : Cbytecodes.fv_elem) (e2 : Cbytecodes.fv_elem) : Z :=
    match (e1, e2) with
    | (FVnamed id1, FVnamed id2) =&gt; Names.Id.compare id1 id2
    | (FVnamed _, FVrel _ | FVuniv_var _ | FVevar _) =&gt; (-1)
    | (FVrel _, FVnamed _) =&gt; 1
    | (FVrel r1, FVrel r2) =&gt; Int.compare r1 r2
    | (FVrel _, FVuniv_var _ | FVevar _) =&gt; (-1)
    | (FVuniv_var i1, FVuniv_var i2) =&gt; Int.compare i1 i2
    | (FVuniv_var _, FVnamed _ | FVrel _) =&gt; 1
    | (FVuniv_var _, FVevar _) =&gt; (-1)
    | (FVevar _, FVnamed _ | FVrel _ | FVuniv_var _) =&gt; 1
    | (FVevar e1, FVevar e2) =&gt; Evar.compare e1 e2
    end.
End Fv_elem.

Record vm_env := {
  size : Z;
  fv_rev : list Cbytecodes.fv_elem;
  fv_fwd : FvMap.t Z }.

Record comp_env := {
  arity : Z;
  nb_uni_stack : Z;
  nb_stack : Z;
  in_stack : list Z;
  nb_rec : Z;
  pos_rec : list Cbytecodes.instruction;
  offset : Z;
  in_env : Stdlib.ref vm_env }.

Module Config.
  Definition stack_threshold : Z := 256.
  
  Definition stack_safety_margin : Z := 15.
End Config.

Inductive argument : Type :=
| ArgLambda : Clambda.lambda -&gt; argument
| ArgUniv : Univ.Level.t -&gt; argument.

Definition empty_fv : vm_env :=
  {| size := 0; fv_rev := []; fv_fwd := FvMap.empty |}.

Definition push_fv (d : FvMap.key) (e : vm_env) : vm_env :=
  {| size := Util.op_plus (size e) 1; fv_rev := cons d (fv_rev e);
    fv_fwd := FvMap.add d (size e) (fv_fwd e) |}.

Definition fv (r : comp_env) : vm_env := Util.op_exclamation (in_env r).

Definition empty_comp_env (function_parameter : unit) : comp_env :=
  match function_parameter with
  | tt =&gt;
    {| arity := 0; nb_uni_stack := 0; nb_stack := 0; in_stack := [];
      nb_rec := 0; pos_rec := []; offset := 0; in_env := Stdlib.ref empty_fv |}
  end.

Definition max_stack_size : Stdlib.ref Z := Stdlib.ref 0.

Definition set_max_stack_size (stack_size : Z) : unit :=
  if OCaml.Stdlib.gt stack_size (Util.op_exclamation max_stack_size) then
    Stdlib.op_colon_eq max_stack_size stack_size
  else
    tt.

Definition ensure_stack_capacity {A : Type}
  (f : A -&gt; list Cbytecodes.instruction) (x : A)
  : list Cbytecodes.instruction :=
  let old := Util.op_exclamation max_stack_size in
  Stdlib.op_colon_eq max_stack_size 0;
  let code := f x in
  let used_safe :=
    Util.op_plus (Util.op_exclamation max_stack_size) Config.stack_safety_margin
    in
  Stdlib.op_colon_eq max_stack_size old;
  if OCaml.Stdlib.gt used_safe Config.stack_threshold then
    cons (Kensurestackcapacity used_safe) code
  else
    code.

Fixpoint add_param (n : Int.t) (sz : Z) (l : list Z) : list Z :=
  if Int.equal n 0 then
    l
  else
    add_param (Util.op_minus n 1) sz (cons (Util.op_plus n sz) l).

Definition comp_env_fun (op_star_o_p_t_star : option Z) : Int.t -&gt; comp_env :=
  let univs :=
    match op_star_o_p_t_star with
    | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
    | None =&gt; 0
    end in
  fun arity =&gt;
    {| arity := arity; nb_uni_stack := univs; nb_stack := arity;
      in_stack := add_param arity 0 []; nb_rec := 0; pos_rec := []; offset := 1;
      in_env := Stdlib.ref empty_fv |}.

Definition comp_env_fix_type (rfv : Stdlib.ref vm_env) : comp_env :=
  {| arity := 0; nb_uni_stack := 0; nb_stack := 0; in_stack := []; nb_rec := 0;
    pos_rec := []; offset := 1; in_env := rfv |}.

Definition comp_env_fix
  (ndef : Z) (curr_pos : Z) (arity : Int.t) (rfv : Stdlib.ref vm_env)
  : comp_env :=
  let prec := Stdlib.ref [] in
  for;
  {| arity := arity; nb_uni_stack := 0; nb_stack := arity;
    in_stack := add_param arity 0 []; nb_rec := ndef;
    pos_rec := Util.op_exclamation prec;
    offset :=
      Util.op_plus (Z.mul 2 (Util.op_minus (Util.op_minus ndef curr_pos) 1)) 1;
    in_env := rfv |}.

Definition comp_env_cofix_type (ndef : Z) (rfv : Stdlib.ref vm_env)
  : comp_env :=
  {| arity := 0; nb_uni_stack := 0; nb_stack := 0; in_stack := []; nb_rec := 0;
    pos_rec := []; offset := Util.op_plus 1 ndef; in_env := rfv |}.

Definition comp_env_cofix (ndef : Z) (arity : Int.t) (rfv : Stdlib.ref vm_env)
  : comp_env :=
  let prec := Stdlib.ref [] in
  for;
  {| arity := arity; nb_uni_stack := 0; nb_stack := arity;
    in_stack := add_param arity 0 []; nb_rec := ndef;
    pos_rec := Util.op_exclamation prec; offset := Util.op_plus ndef 1;
    in_env := rfv |}.

Definition push_param (n : Int.t) (sz : Z) (r : comp_env) : comp_env := record.

Definition push_local (sz : Z) (r : comp_env) : comp_env := record.

Definition find_at (fv : FvMap.key) (env : vm_env) : Z :=
  FvMap.find fv (fv_fwd env).

Definition pos_named (id : Names.Id.t) (r : comp_env)
  : Cbytecodes.instruction :=
  let env := Util.op_exclamation (in_env r) in
  let cid := FVnamed id in
  try.

Definition pos_rel (i : Z) (r : comp_env) (sz : Z) : Cbytecodes.instruction :=
  if OCaml.Stdlib.le i (nb_stack r) then
    Kacc
      (Util.op_minus sz
        (Util.List.(CList.ExtS.nth) (in_stack r) (Util.op_minus i 1)))
  else
    let i := Util.op_minus i (nb_stack r) in
    if OCaml.Stdlib.le i (nb_rec r) then
      try
    else
      let i := Util.op_minus i (nb_rec r) in
      let db := FVrel i in
      let env := Util.op_exclamation (in_env r) in
      try.

Definition pos_universe_var (i : Z) (r : comp_env) (sz : Z)
  : Cbytecodes.instruction :=
  if Stdlib.op_exclamation_eq (nb_uni_stack r) 0 then
    Kacc
      (Util.op_minus (Util.op_minus sz (arity r))
        (Util.op_minus (nb_uni_stack r) i))
  else
    let env := Util.op_exclamation (in_env r) in
    let db := FVuniv_var i in
    try.

Definition pos_evar (evk : Evar.t) (r : comp_env) : Cbytecodes.instruction :=
  let env := Util.op_exclamation (in_env r) in
  let cid := FVevar evk in
  try.

Definition discard_dead_code {A : Type} (cont : A) : A := cont.

Definition label_code (function_parameter : list Cbytecodes.instruction)
  : Cbytecodes.Label.t * (list Cbytecodes.instruction) :=
  match function_parameter with
  | (cons (Klabel lbl) _) as cont =&gt; (lbl, cont)
  | (cons (Kbranch lbl) _) as cont =&gt; (lbl, cont)
  | cont =&gt;
    let lbl := Cbytecodes.Label.create tt in
    (lbl, (cons (Klabel lbl) cont))
  end.

Fixpoint make_branch_2
  (lbl : option Cbytecodes.Label.t) (n : Z) (cont : list Cbytecodes.instruction)
  (function_parameter : list Cbytecodes.instruction)
  : Cbytecodes.instruction * (list Cbytecodes.instruction) :=
  match function_parameter with
  | cons (Kreturn m) _ =&gt; ((Kreturn (Util.op_plus n m)), cont)
  | cons (Klabel _) c =&gt; make_branch_2 lbl n cont c
  | cons (Kpop m) c =&gt; make_branch_2 lbl (Util.op_plus n m) cont c
  | _ =&gt;
    match lbl with
    | Some lbl =&gt; ((Kbranch lbl), cont)
    | None =&gt;
      let lbl := Cbytecodes.Label.create tt in
      ((Kbranch lbl), (cons (Klabel lbl) cont))
    end
  end.

Definition make_branch (cont : list Cbytecodes.instruction)
  : Cbytecodes.instruction * (list Cbytecodes.instruction) :=
  match cont with
  | cons ((Kbranch _) as branch) _ =&gt; (branch, cont)
  | cons ((Kreturn _) as _return) _ =&gt; (_return, cont)
  | cons (Klabel lbl) _ =&gt; make_branch_2 (Some lbl) 0 cont cont
  | _ =&gt; make_branch_2 None 0 cont cont
  end.

Fixpoint is_tailcall (function_parameter : list Cbytecodes.instruction)
  : option Z :=
  match function_parameter with
  | cons (Kreturn k) _ =&gt; Some k
  | cons (Klabel _) c =&gt; is_tailcall c
  | _ =&gt; None
  end.

Fixpoint add_pop (n : Int.t) (function_parameter : list Cbytecodes.instruction)
  : list Cbytecodes.instruction :=
  match function_parameter with
  | cons (Kpop m) cont =&gt; add_pop (Util.op_plus n m) cont
  | cons (Kreturn m) cont =&gt; cons (Kreturn (Util.op_plus n m)) cont
  | cont =&gt;
    if Int.equal n 0 then
      cont
    else
      cons (Kpop n) cont
  end.

Definition add_grab
  (arity : Int.t) (lbl : Cbytecodes.Label.t)
  (cont : list Cbytecodes.instruction) : list Cbytecodes.instruction :=
  if Int.equal arity 1 then
    cons (Klabel lbl) cont
  else
    cons Krestart
      (cons (Klabel lbl) (cons (Kgrab (Util.op_minus arity 1)) cont)).

Definition add_grabrec
  (rec_arg : Int.t) (arity : Int.t) (lbl : Cbytecodes.Label.t)
  (cont : list Cbytecodes.instruction) : list Cbytecodes.instruction :=
  if andb (Int.equal arity 1) (OCaml.Stdlib.lt rec_arg arity) then
    cons (Klabel lbl) (cons (Kgrabrec 0) (cons Krestart cont))
  else
    cons Krestart
      (cons (Klabel lbl)
        (cons (Kgrabrec rec_arg)
          (cons Krestart (cons (Kgrab (Util.op_minus arity 1)) cont)))).

Definition cont_cofix (arity : Z) : list Cbytecodes.instruction :=
  cons Kpush
    (cons Kpush
      (cons (Kacc 2)
        (cons (Kfield 1)
          (cons (Kfield 0)
            (cons (Kmakeblock 2 Vmvalues.cofix_evaluated_tag)
              (cons Kpush
                (cons (Kacc 2)
                  (cons (Ksetfield 1)
                    (cons (Kacc 0) (cons (Kreturn (Util.op_plus arity 2)) [])))))))))).

Definition fun_code : Stdlib.ref (list Cbytecodes.instruction) := Stdlib.ref [].

Definition init_fun_code (function_parameter : unit) : unit :=
  match function_parameter with
  | tt =&gt; Stdlib.op_colon_eq fun_code []
  end.

Definition nest_block (tag : Z) (arity : Z) (cont : list Cbytecodes.instruction)
  : list Cbytecodes.instruction :=
  cons
    (Kconst
      (Const_b0 (Util.op_minus tag Stdlib.Obj.last_non_constant_constructor_tag)))
    (cons
      (Kmakeblock (Util.op_plus arity 1)
        Stdlib.Obj.last_non_constant_constructor_tag) cont).

Definition code_makeblock
  (stack_size : Z) (arity : Z) (tag : Vmvalues.tag)
  (cont : list Cbytecodes.instruction) : list Cbytecodes.instruction :=
  if OCaml.Stdlib.lt tag Stdlib.Obj.last_non_constant_constructor_tag then
    cons (Kmakeblock arity tag) cont
  else
    set_max_stack_size (Util.op_plus stack_size 1);
    cons Kpush (nest_block tag arity cont).

Definition compile_structured_constant {A : Type}
  (_cenv : A) (sc : Vmvalues.structured_constant) (sz : Z)
  (cont : list Cbytecodes.instruction) : list Cbytecodes.instruction :=
  set_max_stack_size sz;
  cons (Kconst sc) cont.

Definition comp_args {A B : Type}
  (comp_expr :
    A -&gt; B -&gt; Z -&gt; (list Cbytecodes.instruction) -&gt; list Cbytecodes.instruction)
  (cenv : A) (args : array B) (sz : Z) (cont : list Cbytecodes.instruction)
  : list Cbytecodes.instruction :=
  let nargs_m_1 := Util.op_minus (Util.Array.(CArray.ExtS.length) args) 1 in
  let c :=
    Stdlib.ref
      (comp_expr cenv (Util.Array.(CArray.ExtS.get) args 0)
        (Util.op_plus sz nargs_m_1) cont) in
  for;
  Util.op_exclamation c.

Definition comp_app {A B C : Type}
  (comp_fun :
    A -&gt; B -&gt; Z -&gt; (list Cbytecodes.instruction) -&gt; list Cbytecodes.instruction)
  (comp_arg :
    A -&gt; C -&gt; Z -&gt; (list Cbytecodes.instruction) -&gt; list Cbytecodes.instruction)
  (cenv : A) (f : B) (args : array C) (sz : Z)
  (cont : list Cbytecodes.instruction) : list Cbytecodes.instruction :=
  let nargs := Util.Array.(CArray.ExtS.length) args in
  if Int.equal nargs 0 then
    comp_fun cenv f sz cont
  else
    match is_tailcall cont with
    | Some k =&gt;
      comp_args comp_arg cenv args sz
        (cons Kpush
          (comp_fun cenv f (Util.op_plus sz nargs)
            (cons (Kappterm nargs (Util.op_plus k nargs))
              (discard_dead_code cont))))
    | None =&gt;
      if OCaml.Stdlib.le nargs 4 then
        comp_args comp_arg cenv args sz
          (cons Kpush
            (comp_fun cenv f (Util.op_plus sz nargs) (cons (Kapply nargs) cont)))
      else
        match label_code cont with
        | (lbl, cont1) =&gt;
          cons (Kpush_retaddr lbl)
            (comp_args comp_arg cenv args (Util.op_plus sz 3)
              (cons Kpush
                (comp_fun cenv f (Util.op_plus (Util.op_plus sz 3) nargs)
                  (cons (Kapply nargs) cont1))))
        end
    end.

Definition compile_fv_elem
  (cenv : comp_env) (fv : Cbytecodes.fv_elem) (sz : Z)
  (cont : list Cbytecodes.instruction) : list Cbytecodes.instruction :=
  match fv with
  | FVrel i =&gt; cons (pos_rel i cenv sz) cont
  | FVnamed id =&gt; cons (pos_named id cenv) cont
  | FVuniv_var i =&gt; cons (pos_universe_var i cenv sz) cont
  | FVevar evk =&gt; cons (pos_evar evk cenv) cont
  end.

Fixpoint compile_fv
  (cenv : comp_env) (l : list Cbytecodes.fv_elem) (sz : Z)
  (cont : list Cbytecodes.instruction) : list Cbytecodes.instruction :=
  match l with
  | [] =&gt; cont
  | cons fvn [] =&gt;
    set_max_stack_size (Util.op_plus sz 1);
    compile_fv_elem cenv fvn sz cont
  | cons fvn tl =&gt;
    compile_fv_elem cenv fvn sz
      (cons Kpush (compile_fv cenv tl (Util.op_plus sz 1) cont))
  end.

Fixpoint get_alias (env : Environ.env) (kn : Names.Constant.t)
  : Names.Constant.t :=
  let cb := Environ.lookup_constant kn env in
  let tps := const_body_code cb in
  match tps with
  | None =&gt; kn
  | Some tps =&gt;
    match Cemitcodes.force tps with
    | BCalias kn' =&gt; get_alias env kn'
    | _ =&gt; kn
    end
  end.

Fixpoint compile_lam
  (env : Environ.env) (cenv : comp_env) (lam : Clambda.lambda) (sz : Z)
  (cont : list Cbytecodes.instruction) : list Cbytecodes.instruction :=
  set_max_stack_size sz;
  match lam with
  | Lrel _ i =&gt; cons (pos_rel i cenv sz) cont
  | Lint i =&gt; compile_structured_constant cenv (Const_b0 i) sz cont
  | Lval v =&gt; compile_structured_constant cenv (Const_val v) sz cont
  | Luint i =&gt; compile_structured_constant cenv (Const_uint i) sz cont
  | Lproj p arg =&gt; compile_lam env cenv arg sz (cons (Kproj p) cont)
  | Lvar id =&gt; cons (pos_named id cenv) cont
  | Levar evk args =&gt;
    if Util.Array.(CArray.ExtS.is_empty) args then
      compile_fv_elem cenv (FVevar evk) sz cont
    else
      let args := Util.Array.(CArray.ExtS.copy) args in
      match Util.Array.(CArray.ExtS.rev) args with
      | tt =&gt;
        comp_app compile_fv_elem (compile_lam env) cenv (FVevar evk) args sz
          cont
      end
  | Lconst (kn, u) =&gt; compile_constant env cenv kn u tt sz cont
  | Lind (ind, u) =&gt;
    if Univ.Instance.is_empty u then
      compile_structured_constant cenv (Const_ind ind) sz cont
    else
      comp_app compile_structured_constant compile_universe cenv (Const_ind ind)
        (Univ.Instance.to_array u) sz cont
  | Lsort ((Sorts.SProp | Sorts.Prop | Sorts.Set) as s) =&gt;
    compile_structured_constant cenv (Const_sort s) sz cont
  | Lsort (Sorts.Type u) =&gt;
    match Univ.compact_univ u with
    | (u, s) =&gt;
      let compile_get_univ
        (cenv : comp_env) (idx : Z) (sz : Z) (cont :
        list Cbytecodes.instruction) : list Cbytecodes.instruction :=
        set_max_stack_size sz;
        compile_fv_elem cenv (FVuniv_var idx) sz cont in
      if Util.List.(CList.ExtS.is_empty) s then
        compile_structured_constant cenv (Const_sort (Sorts.sort_of_univ u)) sz
          cont
      else
        comp_app compile_structured_constant compile_get_univ cenv
          (Const_sort (Sorts.sort_of_univ u))
          (Util.Array.(CArray.ExtS.of_list) s) sz cont
    end
  | Llet _id def body =&gt;
    compile_lam env cenv def sz
      (cons Kpush
        (compile_lam env (push_local sz cenv) body (Util.op_plus sz 1)
          (add_pop 1 cont)))
  | Lprod dom codom =&gt;
    let cont1 :=
      cons Kpush
        (compile_lam env cenv dom (Util.op_plus sz 1) (cons Kmakeprod cont)) in
    compile_lam env cenv codom sz cont1
  | Llam ids body =&gt;
    let arity := Util.Array.(CArray.ExtS.length) ids in
    let r_fun := comp_env_fun None arity in
    let lbl_fun := Cbytecodes.Label.create tt in
    let cont_fun :=
      ensure_stack_capacity (compile_lam env r_fun body arity)
        (cons (Kreturn arity) []) in
    Stdlib.op_colon_eq fun_code
      (cons
        (Ksequence (add_grab arity lbl_fun cont_fun)
          (Util.op_exclamation fun_code)) []);
    let fv := fv r_fun in
    compile_fv cenv (fv_rev fv) sz (cons (Kclosure lbl_fun (size fv)) cont)
  | Lapp f args =&gt;
    match f with
    | Lconst (kn, u) =&gt; compile_constant env cenv kn u args sz cont
    | _ =&gt; comp_app (compile_lam env) (compile_lam env) cenv f args sz cont
    end
  | Lfix (rec_args, init) (_decl, types, bodies) =&gt;
    let ndef := Util.Array.(CArray.ExtS.length) types in
    let rfv := Stdlib.ref empty_fv in
    let lbl_types := Util.Array.(CArray.ExtS.make) ndef Cbytecodes.Label.no in
    let lbl_bodies := Util.Array.(CArray.ExtS.make) ndef Cbytecodes.Label.no in
    let env_type := comp_env_fix_type rfv in
    for;
    for;
    let fv := Util.op_exclamation rfv in
    compile_fv cenv (fv_rev fv) sz
      (cons (Kclosurerec (size fv) init lbl_types lbl_bodies) cont)
  | Lcofix init (_decl, types, bodies) =&gt;
    let ndef := Util.Array.(CArray.ExtS.length) types in
    let lbl_types := Util.Array.(CArray.ExtS.make) ndef Cbytecodes.Label.no in
    let lbl_bodies := Util.Array.(CArray.ExtS.make) ndef Cbytecodes.Label.no in
    let rfv := Stdlib.ref empty_fv in
    let env_type := comp_env_cofix_type ndef rfv in
    for;
    for;
    let fv := Util.op_exclamation rfv in
    set_max_stack_size
      (Util.op_plus (Util.op_plus (Util.op_plus sz (size fv)) ndef) 2);
    compile_fv cenv (fv_rev fv) sz
      (cons (Kclosurecofix (size fv) init lbl_types lbl_bodies) cont)
  | Lif t bt bf =&gt;
    match make_branch cont with
    | (branch, cont) =&gt;
      let lbl_true := Cbytecodes.Label.create tt in
      let lbl_false := Cbytecodes.Label.create tt in
      compile_lam env cenv t sz
        (cons (Kswitch (lbl_true, lbl_false) tt)
          (cons (Klabel lbl_false)
            (compile_lam env cenv bf sz
              (cons branch
                (cons (Klabel lbl_true) (compile_lam env cenv bt sz cont))))))
    end
  | Lcase ci rtbl t a branches =&gt;
    let ind := ci_ind ci in
    let mib := Environ.lookup_mind (fst ind) env in
    let oib := Util.Array.(CArray.ExtS.get) (mind_packets mib) (snd ind) in
    let lbl_consts :=
      Util.Array.(CArray.ExtS.make) (mind_nb_constant oib) Cbytecodes.Label.no
      in
    let nallblock := Util.op_plus (mind_nb_args oib) 1 in
    let nconst := Util.Array.(CArray.ExtS.length) (constant_branches branches)
      in
    let nblock :=
      OCaml.Stdlib.min nallblock
        (Util.op_plus Stdlib.Obj.last_non_constant_constructor_tag 1) in
    let lbl_blocks := Util.Array.(CArray.ExtS.make) nblock Cbytecodes.Label.no
      in
    let neblock :=
      OCaml.Stdlib.max 0
        (Util.op_minus nallblock Stdlib.Obj.last_non_constant_constructor_tag)
      in
    let lbl_eblocks := Util.Array.(CArray.ExtS.make) neblock Cbytecodes.Label.no
      in
    match make_branch cont with
    | (branch1, cont) =&gt;
      let fcode :=
        ensure_stack_capacity (compile_lam env cenv t sz)
          (cons (Kpop sz) (cons Kstop [])) in
      match label_code fcode with
      | (lbl_typ, fcode) =&gt;
        Stdlib.op_colon_eq fun_code
          (cons (Ksequence fcode (Util.op_exclamation fun_code)) []);
        let lbl_sw := Cbytecodes.Label.create tt in
        match
          match branch1 with
          | Kreturn k =&gt;
            Int.equal k sz;
            (sz, branch1, true)
          | Kbranch _ =&gt; ((Util.op_plus sz 3), Kjump, false)
          | _ =&gt; false
          end with
        | (sz_b, branch, is_tailcall) =&gt;
          let c := Stdlib.ref cont in
          if nequiv_decb neblock 0 then
            match
              label_code
                (cons Kpush
                  (cons (Kfield 0)
                    (cons (Kswitch lbl_eblocks tt) (Util.op_exclamation c))))
              with
            | (lbl_b, code_b) =&gt;
              Util.Array.(CArray.ExtS.set) lbl_blocks
                Stdlib.Obj.last_non_constant_constructor_tag lbl_b;
              Stdlib.op_colon_eq c code_b
            end
          else
            tt;
          for;
          for;
          let annot :=
            {| ci := ci; rtbl := rtbl; tailcall := is_tailcall;
              max_stack_size :=
                Util.op_minus (Util.op_exclamation max_stack_size) sz |} in
          match
            set_max_stack_size (Util.op_plus sz 3);
            label_code
              (cons (Kmakeswitchblock lbl_typ lbl_sw annot sz)
                (cons branch (Util.op_exclamation c))) with
          | (lbl_accu, code_accu) =&gt;
            Util.Array.(CArray.ExtS.set) lbl_blocks 0 lbl_accu;
            Stdlib.op_colon_eq c
              (cons (Klabel lbl_sw)
                (cons (Kswitch lbl_consts lbl_blocks) code_accu));
            let code_sw :=
              match branch1 with
              | Kbranch lbl =&gt; cons (Kpush_retaddr lbl) (Util.op_exclamation c)
              | _ =&gt; Util.op_exclamation c
              end in
            compile_lam env cenv a sz code_sw
          end
        end
      end
    end
  | Lmakeblock tag args =&gt;
    let arity := Util.Array.(CArray.ExtS.length) args in
    let cont :=
      code_makeblock (Util.op_minus (Util.op_plus sz arity) 1) arity tag cont in
    comp_args (compile_lam env) cenv args sz cont
  | Lprim kn op args =&gt;
    comp_args (compile_lam env) cenv args sz (cons (Kprim op kn) cont)
  end

with compile_get_global
  (cenv : comp_env) (function_parameter : Names.Constant.t * Univ.Instance.t)
  : Z -&gt; (list Cbytecodes.instruction) -&gt; list Cbytecodes.instruction :=
  match function_parameter with
  | (kn, u) =&gt;
    fun sz =&gt;
      fun cont =&gt;
        set_max_stack_size sz;
        if Univ.Instance.is_empty u then
          cons (Kgetglobal kn) cont
        else
          comp_app
            (fun function_parameter =&gt;
              match function_parameter with
              | _ =&gt;
                fun function_parameter =&gt;
                  match function_parameter with
                  | _ =&gt;
                    fun function_parameter =&gt;
                      match function_parameter with
                      | _ =&gt; fun cont =&gt; cons (Kgetglobal kn) cont
                      end
                  end
              end) compile_universe cenv tt (Univ.Instance.to_array u) sz cont
  end

with compile_universe
  (cenv : comp_env) (uni : Univ.Level.t) (sz : Z)
  (cont : list Cbytecodes.instruction) : list Cbytecodes.instruction :=
  set_max_stack_size sz;
  match Univ.Level.var_index uni with
  | None =&gt; compile_structured_constant cenv (Const_univ_level uni) sz cont
  | Some idx =&gt; cons (pos_universe_var idx cenv sz) cont
  end

with compile_constant
  (env : Environ.env) (cenv : comp_env) (kn : Names.Constant.t)
  (u : Univ.Instance.t) (args : array Clambda.lambda) (sz : Z)
  (cont : list Cbytecodes.instruction) : list Cbytecodes.instruction :=
  set_max_stack_size sz;
  if Univ.Instance.is_empty u then
    comp_app
      (fun function_parameter =&gt;
        match function_parameter with
        | _ =&gt;
          fun function_parameter =&gt;
            match function_parameter with
            | _ =&gt; fun sz =&gt; fun cont =&gt; compile_get_global cenv (kn, u) sz cont
            end
        end) (compile_lam env) cenv tt args sz cont
  else
    let compile_arg
      (cenv : comp_env) (constr_or_uni : argument) (sz : Z) (cont :
      list Cbytecodes.instruction) : list Cbytecodes.instruction :=
      match constr_or_uni with
      | ArgLambda t =&gt; compile_lam env cenv t sz cont
      | ArgUniv uni =&gt; compile_universe cenv uni sz cont
      end in
    let u := Univ.Instance.to_array u in
    let lu := Util.Array.(CArray.ExtS.length) u in
    let all :=
      Util.Array.(CArray.ExtS.init)
        (Util.op_plus lu (Util.Array.(CArray.ExtS.length) args))
        (fun i =&gt;
          if OCaml.Stdlib.lt i lu then
            ArgUniv (Util.Array.(CArray.ExtS.get) u i)
          else
            ArgLambda (Util.Array.(CArray.ExtS.get) args (Util.op_minus i lu)))
      in
    comp_app
      (fun function_parameter =&gt;
        match function_parameter with
        | _ =&gt;
          fun function_parameter =&gt;
            match function_parameter with
            | _ =&gt;
              fun function_parameter =&gt;
                match function_parameter with
                | _ =&gt; fun cont =&gt; cons (Kgetglobal kn) cont
                end
            end
        end) compile_arg cenv tt all sz cont.

Definition is_univ_copy (max : Z) (u : Univ.Instance.t) : bool :=
  let u := Univ.Instance.to_array u in
  if equiv_decb (Util.Array.(CArray.ExtS.length) u) max then
    Util.Array.(CArray.ExtS.fold_left_i)
      (fun i =&gt;
        fun acc =&gt;
          fun u =&gt;
            if acc then
              match Univ.Level.var_index u with
              | None =&gt; false
              | Some l =&gt; equiv_decb l i
              end
            else
              false) true u
  else
    false.

Definition dump_bytecode : Stdlib.ref bool := Stdlib.ref false.

Definition dump_bytecodes
  (init : Cbytecodes.bytecodes) (code : Cbytecodes.bytecodes)
  (fvs : list Cbytecodes.fv_elem) : Pp.t :=
  Pp.op_plus_plus
    (Pp.op_plus_plus
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus
            (Pp.op_plus_plus
              (Pp.op_plus_plus
                (Pp.op_plus_plus (Pp.str &quot;code =&quot; % string) (Pp.fnl tt))
                (Cbytecodes.pp_bytecodes init)) (Pp.fnl tt))
            (Cbytecodes.pp_bytecodes code)) (Pp.fnl tt))
        (Pp.str &quot;fv = &quot; % string))
      (Pp.prlist_with_sep
        (fun function_parameter =&gt;
          match function_parameter with
          | tt =&gt; Pp.str &quot;; &quot; % string
          end) Cbytecodes.pp_fv_elem fvs)) (Pp.fnl tt).

Definition compile (fail_on_error : bool) (op_star_o_p_t_star : option Int.t)
  : Environ.env -&gt;
    Constr.t -&gt;
      option
        ((list Cbytecodes.instruction) * (list Cbytecodes.instruction) *
          (array Cbytecodes.fv_elem)) :=
  let universes :=
    match op_star_o_p_t_star with
    | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
    | None =&gt; 0
    end in
  fun env =&gt;
    fun c =&gt;
      init_fun_code tt;
      Cbytecodes.Label.reset_label_counter tt;
      let cont := cons Kstop [] in
      try.

Definition compile_constant_body {A : Type}
  (fail_on_error : bool) (env : Environ.env) (univs : Declarations.universes)
  (function_parameter :
    Declarations.constant_def (Mod_subst.substituted Constr.constr) A)
  : option Cemitcodes.body_code :=
  match function_parameter with
  | Undef _ | OpaqueDef _ | Primitive _ =&gt; Some BCconstant
  | Def sb =&gt;
    let body := Mod_subst.force_constr sb in
    let instance_size :=
      Univ.AUContext.size (Declareops.universes_context univs) in
    match Constr.kind body with
    | _ =&gt;
      let res := compile fail_on_error (Some instance_size) env body in
      Option.map (fun x =&gt; BCdefined (Cemitcodes.to_memory x)) res
    end
  end.

Definition compile_alias (kn : Names.Constant.t) : Cemitcodes.body_code :=
  BCalias (Names.Constant.make1 (Names.Constant.canonical kn)).</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="cemitcodes" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>cemitcodes.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Author: Benjamin Gr√©goire as part of the bytecode-based virtual reduction
   machine, Oct 2004 *)
(* Extension: Arnaud Spiwack (support for native arithmetic), May 2005 *)

open Names
open Constr
open Vmvalues
open Cbytecodes
open Copcodes
open Mod_subst
open CPrimitives

type emitcodes = String.t

external tcode_of_code : Bytes.t -&gt; Vmvalues.tcode = &quot;coq_tcode_of_code&quot;

(* Relocation information *)
type reloc_info =
  | Reloc_annot of annot_switch
  | Reloc_const of structured_constant
  | Reloc_getglobal of Names.Constant.t
  | Reloc_proj_name of Projection.Repr.t

let eq_reloc_info r1 r2 = match r1, r2 with
| Reloc_annot sw1, Reloc_annot sw2 -&gt; eq_annot_switch sw1 sw2
| Reloc_annot _, _ -&gt; false
| Reloc_const c1, Reloc_const c2 -&gt; eq_structured_constant c1 c2
| Reloc_const _, _ -&gt; false
| Reloc_getglobal c1, Reloc_getglobal c2 -&gt; Constant.equal c1 c2
| Reloc_getglobal _, _ -&gt; false
| Reloc_proj_name p1, Reloc_proj_name p2 -&gt; Projection.Repr.equal p1 p2
| Reloc_proj_name _, _ -&gt; false

let hash_reloc_info r =
  let open Hashset.Combine in
  match r with
  | Reloc_annot sw -&gt; combinesmall 1 (hash_annot_switch sw)
  | Reloc_const c -&gt; combinesmall 2 (hash_structured_constant c)
  | Reloc_getglobal c -&gt; combinesmall 3 (Constant.hash c)
  | Reloc_proj_name p -&gt; combinesmall 4 (Projection.Repr.hash p)

module RelocTable = Hashtbl.Make(struct
  type t = reloc_info
  let equal = eq_reloc_info
  let hash = hash_reloc_info
end)

(** We use arrays for on-disk representation. On 32-bit machines, this means we
    can only have a maximum amount of about 4.10^6 relocations, which seems
    quite a lot, but potentially reachable if e.g. compiling big proofs. This
    would prevent VM computing with these terms on 32-bit architectures. Maybe
    we should use a more robust data structure? *)
type patches = {
  reloc_infos : (reloc_info * int array) array;
}

let patch_char4 buff pos c1 c2 c3 c4 = 
  Bytes.unsafe_set buff pos       c1;
  Bytes.unsafe_set buff (pos + 1) c2;
  Bytes.unsafe_set buff (pos + 2) c3;
  Bytes.unsafe_set buff (pos + 3) c4 
  
let patch1 buff pos n =
  patch_char4 buff pos 
    (Char.unsafe_chr n) (Char.unsafe_chr (n asr 8))  (Char.unsafe_chr (n asr 16))
    (Char.unsafe_chr (n asr 24))

let patch_int buff reloc =
  (* copy code *before* patching because of nested evaluations:
     the code we are patching might be called (and thus &quot;concurrently&quot; patched)
     and results in wrong results. Side-effects... *)
  let buff = Bytes.of_string buff in
  let iter (reloc, npos) = Array.iter (fun pos -&gt; patch1 buff pos reloc) npos in
  let () = CArray.iter iter reloc in
  buff

let patch buff pl f =
  (** Order seems important here? *)
  let reloc = CArray.map (fun (r, pos) -&gt; (f r, pos)) pl.reloc_infos in
  let buff = patch_int buff reloc in
  tcode_of_code buff

(* Buffering of bytecode *)

type label_definition =
    Label_defined of int
  | Label_undefined of (int * int) list

type env = {
  mutable out_buffer : Bytes.t;
  mutable out_position : int;
  mutable label_table : label_definition array;
  (* le ieme element de la table = Label_defined n signifie que l'on a
    deja rencontrer le label i et qu'il est a l'offset n.
                                = Label_undefined l signifie que l'on a
    pas encore rencontrer ce label, le premier entier indique ou est l'entier
    a patcher dans la string, le deuxieme son origine  *)
  reloc_info : int list RelocTable.t;
}

let out_word env b1 b2 b3 b4 =
  let p = env.out_position in
  if p &gt;= Bytes.length env.out_buffer then begin
    let len = Bytes.length env.out_buffer in
    let new_len =
      if len &lt;= Sys.max_string_length / 2
      then 2 * len
      else
	if len = Sys.max_string_length
	then invalid_arg &quot;String.create&quot;  (* Pas la bonne exception .... *)
	else Sys.max_string_length in
    let new_buffer = Bytes.create new_len in
    Bytes.blit env.out_buffer 0 new_buffer 0 len;
    env.out_buffer &lt;- new_buffer
  end;
  patch_char4 env.out_buffer p (Char.unsafe_chr b1)
   (Char.unsafe_chr b2) (Char.unsafe_chr b3) (Char.unsafe_chr b4);
  env.out_position &lt;- p + 4

let out env opcode =
  out_word env opcode 0 0 0

let is_immed i = Uint63.le (Uint63.of_int i) Uint63.maxuint31

let out_int env n =
  out_word env n (n asr 8) (n asr 16) (n asr 24)

(* Handling of local labels and backpatching *)

let extend_label_table env needed =
  let new_size = ref(Array.length env.label_table) in
  while needed &gt;= !new_size do new_size := 2 * !new_size done;
  let new_table = Array.make !new_size (Label_undefined []) in
  Array.blit env.label_table 0 new_table 0 (Array.length env.label_table);
  env.label_table &lt;- new_table

let backpatch env (pos, orig) =
  let displ = (env.out_position - orig) asr 2 in
  Bytes.set env.out_buffer  pos    @@ Char.unsafe_chr displ;
  Bytes.set env.out_buffer (pos+1) @@ Char.unsafe_chr (displ asr 8);
  Bytes.set env.out_buffer (pos+2) @@ Char.unsafe_chr (displ asr 16);
  Bytes.set env.out_buffer (pos+3) @@ Char.unsafe_chr (displ asr 24)

let define_label env lbl =
  if lbl &gt;= Array.length env.label_table then extend_label_table env lbl;
  match (env.label_table).(lbl) with
    Label_defined _ -&gt;
      raise(Failure &quot;CEmitcode.define_label&quot;)
  | Label_undefined patchlist -&gt;
      List.iter (fun p -&gt; backpatch env p) patchlist;
      (env.label_table).(lbl) &lt;- Label_defined env.out_position

let out_label_with_orig env orig lbl =
  if lbl &gt;= Array.length env.label_table then extend_label_table env lbl;
  match (env.label_table).(lbl) with
    Label_defined def -&gt;
      out_int env ((def - orig) asr 2)
  | Label_undefined patchlist -&gt;
      (* spiwack: patchlist is supposed to be non-empty all the time
         thus I commented that out. If there is no problem I suggest
         removing it for next release (cur: 8.1) *)
      (*if patchlist = [] then *)
        (env.label_table).(lbl) &lt;-
          Label_undefined((env.out_position, orig) :: patchlist);
      out_int env 0

let out_label env l = out_label_with_orig env env.out_position l

(* Relocation information *)

let enter env info =
  let pos = env.out_position in
  let old = try RelocTable.find env.reloc_info info with Not_found -&gt; [] in
  RelocTable.replace env.reloc_info info (pos :: old)

let slot_for_const env c =
  enter env (Reloc_const c);
  out_int env 0

let slot_for_annot env a =
  enter env (Reloc_annot a);
  out_int env 0

let slot_for_getglobal env p =
  enter env (Reloc_getglobal p);
  out_int env 0

let slot_for_proj_name env p =
  enter env (Reloc_proj_name p);
  out_int env 0

(* Emission of one instruction *)

let nocheck_prim_op = function
  | Int63add -&gt; opADDINT63
  | Int63sub -&gt; opSUBINT63
  | Int63lt  -&gt; opLTINT63
  | Int63le  -&gt; opLEINT63
  | _ -&gt; assert false


let check_prim_op = function
  | Int63head0     -&gt; opCHECKHEAD0INT63
  | Int63tail0     -&gt; opCHECKTAIL0INT63
  | Int63add       -&gt; opCHECKADDINT63
  | Int63sub       -&gt; opCHECKSUBINT63
  | Int63mul       -&gt; opCHECKMULINT63
  | Int63div       -&gt; opCHECKDIVINT63
  | Int63mod       -&gt; opCHECKMODINT63
  | Int63lsr       -&gt; opCHECKLSRINT63
  | Int63lsl       -&gt; opCHECKLSLINT63
  | Int63land      -&gt; opCHECKLANDINT63
  | Int63lor       -&gt; opCHECKLORINT63
  | Int63lxor      -&gt; opCHECKLXORINT63
  | Int63addc      -&gt; opCHECKADDCINT63
  | Int63subc      -&gt; opCHECKSUBCINT63
  | Int63addCarryC -&gt; opCHECKADDCARRYCINT63
  | Int63subCarryC -&gt; opCHECKSUBCARRYCINT63
  | Int63mulc      -&gt; opCHECKMULCINT63
  | Int63diveucl   -&gt; opCHECKDIVEUCLINT63
  | Int63div21     -&gt; opCHECKDIV21INT63
  | Int63addMulDiv -&gt; opCHECKADDMULDIVINT63
  | Int63eq        -&gt; opCHECKEQINT63
  | Int63lt        -&gt; opCHECKLTINT63
  | Int63le        -&gt; opCHECKLEINT63
  | Int63compare   -&gt; opCHECKCOMPAREINT63

let emit_instr env = function
  | Klabel lbl -&gt; define_label env lbl
  | Kacc n -&gt;
      if n &lt; 8 then out env(opACC0 + n) else (out env opACC; out_int env n)
  | Kenvacc n -&gt;
      if n &gt;= 1 &amp;&amp; n &lt;= 4
      then out env(opENVACC1 + n - 1)
      else (out env opENVACC; out_int env n)
  | Koffsetclosure ofs -&gt;
      if Int.equal ofs (-2) || Int.equal ofs 0 || Int.equal ofs 2
      then out env (opOFFSETCLOSURE0 + ofs / 2)
      else (out env opOFFSETCLOSURE; out_int env ofs)
  | Kpush -&gt;
      out env opPUSH
  | Kpop n -&gt;
      out env opPOP; out_int env n
  | Kpush_retaddr lbl -&gt;
      out env opPUSH_RETADDR; out_label env lbl
  | Kapply n -&gt;
      if n &lt;= 4 then out env(opAPPLY1 + n - 1) else (out env opAPPLY; out_int env n)
  | Kappterm(n, sz) -&gt;
      if n &lt; 4 then (out env(opAPPTERM1 + n - 1); out_int env sz)
               else (out env opAPPTERM; out_int env n; out_int env sz)
  | Kreturn n -&gt;
      out env opRETURN; out_int env n
  | Kjump -&gt;
      out env opRETURN; out_int env 0
  | Krestart -&gt;
      out env opRESTART
  | Kgrab n -&gt;
      out env opGRAB; out_int env n
  | Kgrabrec(rec_arg) -&gt;
      out env opGRABREC; out_int env rec_arg
  | Kclosure(lbl, n) -&gt;
      out env opCLOSURE; out_int env n; out_label env lbl
  | Kclosurerec(nfv,init,lbl_types,lbl_bodies) -&gt;
      out env opCLOSUREREC;out_int env (Array.length lbl_bodies);
      out_int env nfv; out_int env init;
      let org = env.out_position in
      Array.iter (out_label_with_orig env org) lbl_types;
      let org = env.out_position in
      Array.iter (out_label_with_orig env org) lbl_bodies
  | Kclosurecofix(nfv,init,lbl_types,lbl_bodies) -&gt;
      out env opCLOSURECOFIX;out_int env (Array.length lbl_bodies);
      out_int env nfv; out_int env init;
      let org = env.out_position in
      Array.iter (out_label_with_orig env org) lbl_types;
      let org = env.out_position in
      Array.iter (out_label_with_orig env org) lbl_bodies
  | Kgetglobal q -&gt;
      out env opGETGLOBAL; slot_for_getglobal env q
  | Kconst (Const_b0 i) when is_immed i -&gt;
      if i &gt;= 0 &amp;&amp; i &lt;= 3
          then out env (opCONST0 + i)
          else (out env opCONSTINT; out_int env i)
  | Kconst c -&gt;
      out env opGETGLOBAL; slot_for_const env c
  | Kmakeblock(n, t) -&gt;
      if Int.equal n 0 then invalid_arg &quot;emit_instr : block size = 0&quot;
      else if n &lt; 4 then (out env(opMAKEBLOCK1 + n - 1); out_int env t)
      else (out env opMAKEBLOCK; out_int env n; out_int env t)
  | Kmakeprod -&gt;
      out env opMAKEPROD
  | Kmakeswitchblock(typlbl,swlbl,annot,sz) -&gt;
      out env opMAKESWITCHBLOCK;
      out_label env typlbl; out_label env swlbl;
      slot_for_annot env annot;out_int env sz
  | Kswitch (tbl_const, tbl_block) -&gt;
      let lenb = Array.length tbl_block in
      let lenc = Array.length tbl_const in
      assert (lenb &lt; 0x100 &amp;&amp; lenc &lt; 0x1000000);
      out env opSWITCH;
      out_word env lenc (lenc asr 8) (lenc asr 16) (lenb);
(*      out_int env (Array.length tbl_const + (Array.length tbl_block lsl 23)); *)
      let org = env.out_position in
      Array.iter (out_label_with_orig env org) tbl_const;
      Array.iter (out_label_with_orig env org) tbl_block
  | Kpushfields n -&gt;
      out env opPUSHFIELDS;out_int env n
  | Kfield n -&gt;
      if n &lt;= 1 then out env (opGETFIELD0+n)
      else (out env opGETFIELD;out_int env n)
  | Ksetfield n -&gt;
      if n &lt;= 1 then out env (opSETFIELD0+n)
      else (out env opSETFIELD;out_int env n)
  | Ksequence _ -&gt; invalid_arg &quot;Cemitcodes.emit_instr&quot;
  | Kproj p -&gt; out env opPROJ; out_int env (Projection.Repr.arg p); slot_for_proj_name env p
  | Kensurestackcapacity size -&gt; out env opENSURESTACKCAPACITY; out_int env size
  | Kbranch lbl -&gt; out env opBRANCH; out_label env lbl
  | Kprim (op,None) -&gt;
      out env (nocheck_prim_op op)

  | Kprim(op,Some (q,_u)) -&gt;
      out env (check_prim_op op);
      slot_for_getglobal env q

  | Kareint 1 -&gt; out env opISINT
  | Kareint 2 -&gt; out env opAREINT2;

  | Kstop -&gt; out env opSTOP

  | Kareint _ -&gt; assert false

(* Emission of a current list and remaining lists of instructions. Include some peephole optimization. *)

let rec emit env insns remaining = match insns with
  | [] -&gt; 
     (match remaining with 
       [] -&gt; () 
     | (first::rest) -&gt; emit env first rest)
  (* Peephole optimizations *)
  | Kpush :: Kacc n :: c -&gt;
      if n &lt; 8 then out env(opPUSHACC0 + n) else (out env opPUSHACC; out_int env n);
      emit env c remaining
  | Kpush :: Kenvacc n :: c -&gt;
      if n &gt;= 1 &amp;&amp; n &lt;= 4
      then out env(opPUSHENVACC1 + n - 1)
      else (out env opPUSHENVACC; out_int env n);
      emit env c remaining
  | Kpush :: Koffsetclosure ofs :: c -&gt;
      if Int.equal ofs (-2) || Int.equal ofs 0 || Int.equal ofs 2
      then out env(opPUSHOFFSETCLOSURE0 + ofs / 2)
      else (out env opPUSHOFFSETCLOSURE; out_int env ofs);
      emit env c remaining
  | Kpush :: Kgetglobal id :: c -&gt;
      out env opPUSHGETGLOBAL; slot_for_getglobal env id; emit env c remaining
  | Kpush :: Kconst (Const_b0 i) :: c when is_immed i -&gt;
      if i &gt;= 0 &amp;&amp; i &lt;= 3
      then out env (opPUSHCONST0 + i)
      else (out env opPUSHCONSTINT; out_int env i);
      emit env c remaining
  | Kpush :: Kconst const :: c -&gt;
      out env opPUSHGETGLOBAL; slot_for_const env const;
      emit env c remaining
  | Kpop n :: Kjump :: c -&gt;
      out env opRETURN; out_int env n; emit env c remaining
  | Ksequence(c1,c2)::c -&gt;
      emit env c1 (c2::c::remaining)
  (* Default case *)
  | instr :: c -&gt;
      emit_instr env instr; emit env c remaining

(* Initialization *)

type to_patch = emitcodes * patches * fv

(* Substitution *)
let subst_strcst s sc =
  match sc with
  | Const_sort _ | Const_b0 _ | Const_univ_level _ | Const_val _ | Const_uint _ -&gt; sc
  | Const_ind ind -&gt; let kn,i = ind in Const_ind (subst_mind s kn, i)

let subst_reloc s ri =
  match ri with
  | Reloc_annot a -&gt;
      let (kn,i) = a.ci.ci_ind in
      let ci = {a.ci with ci_ind = (subst_mind s kn,i)} in
      Reloc_annot {a with ci = ci}
  | Reloc_const sc -&gt; Reloc_const (subst_strcst s sc)
  | Reloc_getglobal kn -&gt; Reloc_getglobal (subst_constant s kn)
  | Reloc_proj_name p -&gt; Reloc_proj_name (subst_proj_repr s p)

let subst_patches subst p =
  let infos = CArray.map (fun (r, pos) -&gt; (subst_reloc subst r, pos)) p.reloc_infos in
  { reloc_infos = infos; }

let subst_to_patch s (code,pl,fv) =
  code, subst_patches s pl, fv

type body_code =
  | BCdefined of to_patch
  | BCalias of Names.Constant.t
  | BCconstant

type to_patch_substituted =
| PBCdefined of to_patch substituted
| PBCalias of Names.Constant.t substituted
| PBCconstant

let from_val = function
| BCdefined tp -&gt; PBCdefined (from_val tp)
| BCalias cu -&gt; PBCalias (from_val cu)
| BCconstant -&gt; PBCconstant

let force = function
| PBCdefined tp -&gt; BCdefined (force subst_to_patch tp)
| PBCalias cu -&gt; BCalias (force subst_constant cu)
| PBCconstant -&gt; BCconstant

let subst_to_patch_subst s = function
| PBCdefined tp -&gt; PBCdefined (subst_substituted s tp)
| PBCalias cu -&gt; PBCalias (subst_substituted s cu)
| PBCconstant -&gt; PBCconstant

let repr_body_code = function
| PBCdefined tp -&gt;
  let (s, tp) = repr_substituted tp in
  (s, BCdefined tp)
| PBCalias cu -&gt;
  let (s, cu) = repr_substituted cu in
  (s, BCalias cu)
| PBCconstant -&gt; (None, BCconstant)

let to_memory (init_code, fun_code, fv) =
  let env = {
    out_buffer = Bytes.create 1024;
    out_position = 0;
    label_table = Array.make 16 (Label_undefined []);
    reloc_info = RelocTable.create 91;
  } in
  emit env init_code [];
  emit env fun_code [];
  (** Later uses of this string are all purely functional *)
  let code = Bytes.sub_string env.out_buffer 0 env.out_position in
  let code = CString.hcons code in
  let fold reloc npos accu = (reloc, Array.of_list npos) :: accu in
  let reloc = RelocTable.fold fold env.reloc_info [] in
  let reloc = { reloc_infos = CArray.of_list reloc } in
  Array.iter (fun lbl -&gt;
    (match lbl with
      Label_defined _ -&gt; assert true
    | Label_undefined patchlist -&gt;
        assert (patchlist = []))) env.label_table;
  (code, reloc, fv)
</pre>
          </div>
          <div class="col-md-6">
            <code>cemitcodes.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Names.

Import Constr.

Import Vmvalues.

Import Cbytecodes.

Import Copcodes.

Import Mod_subst.

Import CPrimitives.

Definition emitcodes := Stdlib.String.t.

Inductive reloc_info : Type :=
| Reloc_annot : Vmvalues.annot_switch -&gt; reloc_info
| Reloc_const : Vmvalues.structured_constant -&gt; reloc_info
| Reloc_getglobal : Names.Constant.t -&gt; reloc_info
| Reloc_proj_name : Names.Projection.Repr.t -&gt; reloc_info.

Definition eq_reloc_info (r1 : reloc_info) (r2 : reloc_info) : bool :=
  match (r1, r2) with
  | (Reloc_annot sw1, Reloc_annot sw2) =&gt; Vmvalues.eq_annot_switch sw1 sw2
  | (Reloc_annot _, _) =&gt; false
  | (Reloc_const c1, Reloc_const c2) =&gt; Vmvalues.eq_structured_constant c1 c2
  | (Reloc_const _, _) =&gt; false
  | (Reloc_getglobal c1, Reloc_getglobal c2) =&gt; Names.Constant.equal c1 c2
  | (Reloc_getglobal _, _) =&gt; false
  | (Reloc_proj_name p1, Reloc_proj_name p2) =&gt;
    Names.Projection.Repr.equal p1 p2
  | (Reloc_proj_name _, _) =&gt; false
  end.

Definition hash_reloc_info (r : reloc_info) : Z :=
  match r with
  | Reloc_annot sw =&gt;
    Hashset.Combine.combinesmall 1 (Vmvalues.hash_annot_switch sw)
  | Reloc_const c =&gt;
    Hashset.Combine.combinesmall 2 (Vmvalues.hash_structured_constant c)
  | Reloc_getglobal c =&gt; Hashset.Combine.combinesmall 3 (Names.Constant.hash c)
  | Reloc_proj_name p =&gt;
    Hashset.Combine.combinesmall 4 (Names.Projection.Repr.hash p)
  end.

Record patches := {
  reloc_infos : array (reloc_info * (array Z)) }.

Definition patch_char4
  (buff : string) (pos : Z) (c1 : ascii) (c2 : ascii) (c3 : ascii) (c4 : ascii)
  : unit :=
  Stdlib.Bytes.unsafe_set buff pos c1;
  Stdlib.Bytes.unsafe_set buff (Z.add pos 1) c2;
  Stdlib.Bytes.unsafe_set buff (Z.add pos 2) c3;
  Stdlib.Bytes.unsafe_set buff (Z.add pos 3) c4.

Definition patch1 (buff : string) (pos : Z) (n : Z) : unit :=
  patch_char4 buff pos (Stdlib.Char.unsafe_chr n)
    (Stdlib.Char.unsafe_chr (Stdlib.asr n 8))
    (Stdlib.Char.unsafe_chr (Stdlib.asr n 16))
    (Stdlib.Char.unsafe_chr (Stdlib.asr n 24)).

Definition patch_int (buff : string) (reloc : array (Z * (array Z))) : string :=
  let buff := Stdlib.Bytes.of_string buff in
  let iter (function_parameter : Z * (array Z)) : unit :=
    match function_parameter with
    | (reloc, npos) =&gt; Stdlib.Array.iter (fun pos =&gt; patch1 buff pos reloc) npos
    end in
  match CArray.(CArray.ExtS.iter) iter reloc with
  | tt =&gt; buff
  end.

Definition patch (buff : string) (pl : patches) (f : reloc_info -&gt; Z)
  : Vmvalues.tcode :=
  let reloc :=
    CArray.(CArray.ExtS.map)
      (fun function_parameter =&gt;
        match function_parameter with
        | (r, pos) =&gt; ((f r), pos)
        end) (reloc_infos pl) in
  let buff := patch_int buff reloc in
  tcode_of_code buff.

Inductive label_definition : Type :=
| Label_defined : Z -&gt; label_definition
| Label_undefined : (list (Z * Z)) -&gt; label_definition.

Record env := {
  out_buffer : Stdlib.Bytes.t;
  out_position : Z;
  label_table : array label_definition;
  reloc_info : RelocTable.t (list Z) }.

Definition out_word (env : env) (b1 : Z) (b2 : Z) (b3 : Z) (b4 : Z) : unit :=
  let p := out_position env in
  if OCaml.Stdlib.ge p (String.length (out_buffer env)) then
    let len := String.length (out_buffer env) in
    let new_len :=
      if OCaml.Stdlib.le len (Z.div Stdlib.Sys.max_string_length 2) then
        Z.mul 2 len
      else
        if equiv_decb len Stdlib.Sys.max_string_length then
          OCaml.Stdlib.invalid_arg &quot;String.create&quot; % string
        else
          Stdlib.Sys.max_string_length in
    let new_buffer := Stdlib.Bytes.create new_len in
    Stdlib.Bytes.blit (out_buffer env) 0 new_buffer 0 len;
    set_field
  else
    tt;
  patch_char4 (out_buffer env) p (Stdlib.Char.unsafe_chr b1)
    (Stdlib.Char.unsafe_chr b2) (Stdlib.Char.unsafe_chr b3)
    (Stdlib.Char.unsafe_chr b4);
  set_field.

Definition out (env : env) (opcode : Z) : unit := out_word env opcode 0 0 0.

Definition is_immed (i : Z) : bool :=
  Uint63.le (Uint63.of_int i) Uint63.maxuint31.

Definition out_int (env : env) (n : Z) : unit :=
  out_word env n (Stdlib.asr n 8) (Stdlib.asr n 16) (Stdlib.asr n 24).

Definition extend_label_table (env : env) (needed : Z) : unit :=
  let new_size := Stdlib.ref (Stdlib.Array.length (label_table env)) in
  while;
  let new_table :=
    Stdlib.Array.make (Stdlib.op_exclamation new_size) (Label_undefined []) in
  Stdlib.Array.blit (label_table env) 0 new_table 0
    (Stdlib.Array.length (label_table env));
  set_field.

Definition backpatch (env : env) (function_parameter : Z * Z) : unit :=
  match function_parameter with
  | (pos, orig) =&gt;
    let displ := Stdlib.asr (Z.sub (out_position env) orig) 2 in
    apply (Stdlib.Bytes.set (out_buffer env) pos) (Stdlib.Char.unsafe_chr displ);
    apply (Stdlib.Bytes.set (out_buffer env) (Z.add pos 1))
      (Stdlib.Char.unsafe_chr (Stdlib.asr displ 8));
    apply (Stdlib.Bytes.set (out_buffer env) (Z.add pos 2))
      (Stdlib.Char.unsafe_chr (Stdlib.asr displ 16));
    apply (Stdlib.Bytes.set (out_buffer env) (Z.add pos 3))
      (Stdlib.Char.unsafe_chr (Stdlib.asr displ 24))
  end.

Definition define_label (env : env) (lbl : Z) : unit :=
  if OCaml.Stdlib.ge lbl (Stdlib.Array.length (label_table env)) then
    extend_label_table env lbl
  else
    tt;
  match Stdlib.Array.get (label_table env) lbl with
  | Label_defined _ =&gt;
    Stdlib.raise (OCaml.Failure &quot;CEmitcode.define_label&quot; % string)
  | Label_undefined patchlist =&gt;
    Stdlib.List.iter (fun p =&gt; backpatch env p) patchlist;
    Stdlib.Array.set (label_table env) lbl (Label_defined (out_position env))
  end.

Definition out_label_with_orig (env : env) (orig : Z) (lbl : Z) : unit :=
  if OCaml.Stdlib.ge lbl (Stdlib.Array.length (label_table env)) then
    extend_label_table env lbl
  else
    tt;
  match Stdlib.Array.get (label_table env) lbl with
  | Label_defined def =&gt; out_int env (Stdlib.asr (Z.sub def orig) 2)
  | Label_undefined patchlist =&gt;
    Stdlib.Array.set (label_table env) lbl
      (Label_undefined (cons ((out_position env), orig) patchlist));
    out_int env 0
  end.

Definition out_label (env : env) (l : Z) : unit :=
  out_label_with_orig env (out_position env) l.

Definition enter (env : env) (info : RelocTable.key) : unit :=
  let pos := out_position env in
  let old := try in
  RelocTable.replace (reloc_info env) info (cons pos old).

Definition slot_for_const (env : env) (c : Vmvalues.structured_constant)
  : unit :=
  enter env (Reloc_const c);
  out_int env 0.

Definition slot_for_annot (env : env) (a : Vmvalues.annot_switch) : unit :=
  enter env (Reloc_annot a);
  out_int env 0.

Definition slot_for_getglobal (env : env) (p : Names.Constant.t) : unit :=
  enter env (Reloc_getglobal p);
  out_int env 0.

Definition slot_for_proj_name (env : env) (p : Names.Projection.Repr.t)
  : unit :=
  enter env (Reloc_proj_name p);
  out_int env 0.

Definition nocheck_prim_op (function_parameter : CPrimitives.t) : Z :=
  match function_parameter with
  | Int63add =&gt; Copcodes.opADDINT63
  | Int63sub =&gt; Copcodes.opSUBINT63
  | Int63lt =&gt; Copcodes.opLTINT63
  | Int63le =&gt; Copcodes.opLEINT63
  | _ =&gt; false
  end.

Definition check_prim_op (function_parameter : CPrimitives.t) : Z :=
  match function_parameter with
  | Int63head0 =&gt; Copcodes.opCHECKHEAD0INT63
  | Int63tail0 =&gt; Copcodes.opCHECKTAIL0INT63
  | Int63add =&gt; Copcodes.opCHECKADDINT63
  | Int63sub =&gt; Copcodes.opCHECKSUBINT63
  | Int63mul =&gt; Copcodes.opCHECKMULINT63
  | Int63div =&gt; Copcodes.opCHECKDIVINT63
  | Int63mod =&gt; Copcodes.opCHECKMODINT63
  | Int63lsr =&gt; Copcodes.opCHECKLSRINT63
  | Int63lsl =&gt; Copcodes.opCHECKLSLINT63
  | Int63land =&gt; Copcodes.opCHECKLANDINT63
  | Int63lor =&gt; Copcodes.opCHECKLORINT63
  | Int63lxor =&gt; Copcodes.opCHECKLXORINT63
  | Int63addc =&gt; Copcodes.opCHECKADDCINT63
  | Int63subc =&gt; Copcodes.opCHECKSUBCINT63
  | Int63addCarryC =&gt; Copcodes.opCHECKADDCARRYCINT63
  | Int63subCarryC =&gt; Copcodes.opCHECKSUBCARRYCINT63
  | Int63mulc =&gt; Copcodes.opCHECKMULCINT63
  | Int63diveucl =&gt; Copcodes.opCHECKDIVEUCLINT63
  | Int63div21 =&gt; Copcodes.opCHECKDIV21INT63
  | Int63addMulDiv =&gt; Copcodes.opCHECKADDMULDIVINT63
  | Int63eq =&gt; Copcodes.opCHECKEQINT63
  | Int63lt =&gt; Copcodes.opCHECKLTINT63
  | Int63le =&gt; Copcodes.opCHECKLEINT63
  | Int63compare =&gt; Copcodes.opCHECKCOMPAREINT63
  end.

Definition emit_instr (env : env) (function_parameter : Cbytecodes.instruction)
  : unit :=
  match function_parameter with
  | Klabel lbl =&gt; define_label env lbl
  | Kacc n =&gt;
    if OCaml.Stdlib.lt n 8 then
      out env (Z.add Copcodes.opACC0 n)
    else
      out env Copcodes.opACC;
      out_int env n
  | Kenvacc n =&gt;
    if andb (OCaml.Stdlib.ge n 1) (OCaml.Stdlib.le n 4) then
      out env (Z.sub (Z.add Copcodes.opENVACC1 n) 1)
    else
      out env Copcodes.opENVACC;
      out_int env n
  | Koffsetclosure ofs =&gt;
    if orb (Int.equal ofs (-2)) (orb (Int.equal ofs 0) (Int.equal ofs 2)) then
      out env (Z.add Copcodes.opOFFSETCLOSURE0 (Z.div ofs 2))
    else
      out env Copcodes.opOFFSETCLOSURE;
      out_int env ofs
  | Kpush =&gt; out env Copcodes.opPUSH
  | Kpop n =&gt;
    out env Copcodes.opPOP;
    out_int env n
  | Kpush_retaddr lbl =&gt;
    out env Copcodes.opPUSH_RETADDR;
    out_label env lbl
  | Kapply n =&gt;
    if OCaml.Stdlib.le n 4 then
      out env (Z.sub (Z.add Copcodes.opAPPLY1 n) 1)
    else
      out env Copcodes.opAPPLY;
      out_int env n
  | Kappterm n sz =&gt;
    if OCaml.Stdlib.lt n 4 then
      out env (Z.sub (Z.add Copcodes.opAPPTERM1 n) 1);
      out_int env sz
    else
      out env Copcodes.opAPPTERM;
      out_int env n;
      out_int env sz
  | Kreturn n =&gt;
    out env Copcodes.opRETURN;
    out_int env n
  | Kjump =&gt;
    out env Copcodes.opRETURN;
    out_int env 0
  | Krestart =&gt; out env Copcodes.opRESTART
  | Kgrab n =&gt;
    out env Copcodes.opGRAB;
    out_int env n
  | Kgrabrec rec_arg =&gt;
    out env Copcodes.opGRABREC;
    out_int env rec_arg
  | Kclosure lbl n =&gt;
    out env Copcodes.opCLOSURE;
    out_int env n;
    out_label env lbl
  | Kclosurerec nfv init lbl_types lbl_bodies =&gt;
    out env Copcodes.opCLOSUREREC;
    out_int env (Stdlib.Array.length lbl_bodies);
    out_int env nfv;
    out_int env init;
    let org := out_position env in
    Stdlib.Array.iter (out_label_with_orig env org) lbl_types;
    let org := out_position env in
    Stdlib.Array.iter (out_label_with_orig env org) lbl_bodies
  | Kclosurecofix nfv init lbl_types lbl_bodies =&gt;
    out env Copcodes.opCLOSURECOFIX;
    out_int env (Stdlib.Array.length lbl_bodies);
    out_int env nfv;
    out_int env init;
    let org := out_position env in
    Stdlib.Array.iter (out_label_with_orig env org) lbl_types;
    let org := out_position env in
    Stdlib.Array.iter (out_label_with_orig env org) lbl_bodies
  | Kgetglobal q =&gt;
    out env Copcodes.opGETGLOBAL;
    slot_for_getglobal env q
  | Kconst (Const_b0 i) =&gt;
    if andb (OCaml.Stdlib.ge i 0) (OCaml.Stdlib.le i 3) then
      out env (Z.add Copcodes.opCONST0 i)
    else
      out env Copcodes.opCONSTINT;
      out_int env i
  | Kconst c =&gt;
    out env Copcodes.opGETGLOBAL;
    slot_for_const env c
  | Kmakeblock n t =&gt;
    if Int.equal n 0 then
      OCaml.Stdlib.invalid_arg &quot;emit_instr : block size = 0&quot; % string
    else
      if OCaml.Stdlib.lt n 4 then
        out env (Z.sub (Z.add Copcodes.opMAKEBLOCK1 n) 1);
        out_int env t
      else
        out env Copcodes.opMAKEBLOCK;
        out_int env n;
        out_int env t
  | Kmakeprod =&gt; out env Copcodes.opMAKEPROD
  | Kmakeswitchblock typlbl swlbl annot sz =&gt;
    out env Copcodes.opMAKESWITCHBLOCK;
    out_label env typlbl;
    out_label env swlbl;
    slot_for_annot env annot;
    out_int env sz
  | Kswitch tbl_const tbl_block =&gt;
    let lenb := Stdlib.Array.length tbl_block in
    let lenc := Stdlib.Array.length tbl_const in
    andb (OCaml.Stdlib.lt lenb 256) (OCaml.Stdlib.lt lenc 16777216);
    out env Copcodes.opSWITCH;
    out_word env lenc (Stdlib.asr lenc 8) (Stdlib.asr lenc 16) lenb;
    let org := out_position env in
    Stdlib.Array.iter (out_label_with_orig env org) tbl_const;
    Stdlib.Array.iter (out_label_with_orig env org) tbl_block
  | Kpushfields n =&gt;
    out env Copcodes.opPUSHFIELDS;
    out_int env n
  | Kfield n =&gt;
    if OCaml.Stdlib.le n 1 then
      out env (Z.add Copcodes.opGETFIELD0 n)
    else
      out env Copcodes.opGETFIELD;
      out_int env n
  | Ksetfield n =&gt;
    if OCaml.Stdlib.le n 1 then
      out env (Z.add Copcodes.opSETFIELD0 n)
    else
      out env Copcodes.opSETFIELD;
      out_int env n
  | Ksequence _ _ =&gt; OCaml.Stdlib.invalid_arg &quot;Cemitcodes.emit_instr&quot; % string
  | Kproj p =&gt;
    out env Copcodes.opPROJ;
    out_int env (Names.Projection.Repr.arg p);
    slot_for_proj_name env p
  | Kensurestackcapacity size =&gt;
    out env Copcodes.opENSURESTACKCAPACITY;
    out_int env size
  | Kbranch lbl =&gt;
    out env Copcodes.opBRANCH;
    out_label env lbl
  | Kprim op None =&gt; out env (nocheck_prim_op op)
  | Kprim op (Some (q, _u)) =&gt;
    out env (check_prim_op op);
    slot_for_getglobal env q
  | Kareint 1 =&gt; out env Copcodes.opISINT
  | Kareint 2 =&gt; out env Copcodes.opAREINT2
  | Kstop =&gt; out env Copcodes.opSTOP
  | Kareint _ =&gt; false
  end.

Fixpoint emit
  (env : env) (insns : Cbytecodes.bytecodes)
  (remaining : list Cbytecodes.bytecodes) : unit :=
  match insns with
  | [] =&gt;
    match remaining with
    | [] =&gt; tt
    | cons first rest =&gt; emit env first rest
    end
  | cons Kpush (cons (Kacc n) c) =&gt;
    if OCaml.Stdlib.lt n 8 then
      out env (Z.add Copcodes.opPUSHACC0 n)
    else
      out env Copcodes.opPUSHACC;
      out_int env n;
    emit env c remaining
  | cons Kpush (cons (Kenvacc n) c) =&gt;
    if andb (OCaml.Stdlib.ge n 1) (OCaml.Stdlib.le n 4) then
      out env (Z.sub (Z.add Copcodes.opPUSHENVACC1 n) 1)
    else
      out env Copcodes.opPUSHENVACC;
      out_int env n;
    emit env c remaining
  | cons Kpush (cons (Koffsetclosure ofs) c) =&gt;
    if orb (Int.equal ofs (-2)) (orb (Int.equal ofs 0) (Int.equal ofs 2)) then
      out env (Z.add Copcodes.opPUSHOFFSETCLOSURE0 (Z.div ofs 2))
    else
      out env Copcodes.opPUSHOFFSETCLOSURE;
      out_int env ofs;
    emit env c remaining
  | cons Kpush (cons (Kgetglobal id) c) =&gt;
    out env Copcodes.opPUSHGETGLOBAL;
    slot_for_getglobal env id;
    emit env c remaining
  | cons Kpush (cons (Kconst const) c) =&gt;
    out env Copcodes.opPUSHGETGLOBAL;
    slot_for_const env const;
    emit env c remaining
  | cons (Kpop n) (cons Kjump c) =&gt;
    out env Copcodes.opRETURN;
    out_int env n;
    emit env c remaining
  | cons (Ksequence c1 c2) c =&gt; emit env c1 (cons c2 (cons c remaining))
  | cons instr c =&gt;
    emit_instr env instr;
    emit env c remaining
  end.

Definition to_patch := emitcodes * patches * Cbytecodes.fv.

Definition subst_strcst
  (s : Mod_subst.substitution) (sc : Vmvalues.structured_constant)
  : Vmvalues.structured_constant :=
  match sc with
  | Const_sort _ | Const_b0 _ | Const_univ_level _ | Const_val _ | Const_uint _
    =&gt; sc
  | Const_ind ind =&gt;
    match ind with
    | (kn, i) =&gt; Const_ind ((Mod_subst.subst_mind s kn), i)
    end
  end.

Definition subst_reloc (s : Mod_subst.substitution) (ri : reloc_info)
  : reloc_info :=
  match ri with
  | Reloc_annot a =&gt;
    match ci_ind (ci a) with
    | (kn, i) =&gt;
      let ci := record in
      Reloc_annot record
    end
  | Reloc_const sc =&gt; Reloc_const (subst_strcst s sc)
  | Reloc_getglobal kn =&gt; Reloc_getglobal (Mod_subst.subst_constant s kn)
  | Reloc_proj_name p =&gt; Reloc_proj_name (Mod_subst.subst_proj_repr s p)
  end.

Definition subst_patches (subst : Mod_subst.substitution) (p : patches)
  : patches :=
  let infos :=
    CArray.(CArray.ExtS.map)
      (fun function_parameter =&gt;
        match function_parameter with
        | (r, pos) =&gt; ((subst_reloc subst r), pos)
        end) (reloc_infos p) in
  {| reloc_infos := infos |}.

Definition subst_to_patch {A B : Type}
  (s : Mod_subst.substitution) (function_parameter : A * patches * B)
  : A * patches * B :=
  match function_parameter with
  | (code, pl, fv) =&gt; (code, (subst_patches s pl), fv)
  end.

Inductive body_code : Type :=
| BCdefined : to_patch -&gt; body_code
| BCalias : Names.Constant.t -&gt; body_code
| BCconstant : body_code.

Inductive to_patch_substituted : Type :=
| PBCdefined : (Mod_subst.substituted to_patch) -&gt; to_patch_substituted
| PBCalias : (Mod_subst.substituted Names.Constant.t) -&gt; to_patch_substituted
| PBCconstant : to_patch_substituted.

Definition from_val (function_parameter : body_code) : to_patch_substituted :=
  match function_parameter with
  | BCdefined tp =&gt; PBCdefined (Mod_subst.from_val tp)
  | BCalias cu =&gt; PBCalias (Mod_subst.from_val cu)
  | BCconstant =&gt; PBCconstant
  end.

Definition force (function_parameter : to_patch_substituted) : body_code :=
  match function_parameter with
  | PBCdefined tp =&gt; BCdefined (Mod_subst.force subst_to_patch tp)
  | PBCalias cu =&gt; BCalias (Mod_subst.force Mod_subst.subst_constant cu)
  | PBCconstant =&gt; BCconstant
  end.

Definition subst_to_patch_subst
  (s : Mod_subst.substitution) (function_parameter : to_patch_substituted)
  : to_patch_substituted :=
  match function_parameter with
  | PBCdefined tp =&gt; PBCdefined (Mod_subst.subst_substituted s tp)
  | PBCalias cu =&gt; PBCalias (Mod_subst.subst_substituted s cu)
  | PBCconstant =&gt; PBCconstant
  end.

Definition repr_body_code (function_parameter : to_patch_substituted)
  : (option (list Mod_subst.substitution)) * body_code :=
  match function_parameter with
  | PBCdefined tp =&gt;
    match Mod_subst.repr_substituted tp with
    | (s, tp) =&gt; (s, (BCdefined tp))
    end
  | PBCalias cu =&gt;
    match Mod_subst.repr_substituted cu with
    | (s, cu) =&gt; (s, (BCalias cu))
    end
  | PBCconstant =&gt; (None, BCconstant)
  end.

Definition to_memory {A : Type}
  (function_parameter : Cbytecodes.bytecodes * Cbytecodes.bytecodes * A)
  : string * patches * A :=
  match function_parameter with
  | (init_code, fun_code, fv) =&gt;
    let env :=
      {| out_buffer := Stdlib.Bytes.create 1024; out_position := 0;
        label_table := Stdlib.Array.make 16 (Label_undefined []);
        reloc_info := RelocTable.create 91 |} in
    emit env init_code [];
    emit env fun_code [];
    let code := Stdlib.Bytes.sub_string (out_buffer env) 0 (out_position env) in
    let code := CString.(CString.ExtS.hcons) code in
    let fold {B C : Type}
      (reloc : B) (npos : list C) (accu : list (B * (array C)))
      : list (B * (array C)) :=
      cons (reloc, (Stdlib.Array.of_list npos)) accu in
    let reloc := RelocTable.fold fold (reloc_info env) [] in
    let reloc := {| reloc_infos := CArray.(CArray.ExtS.of_list) reloc |} in
    Stdlib.Array.iter
      (fun lbl =&gt;
        match lbl with
        | Label_defined _ =&gt; true
        | Label_undefined patchlist =&gt; equiv_decb patchlist []
        end) (label_table env);
    (code, reloc, fv)
  end.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="clambda" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>clambda.ml</code>
            <pre>open Util
open Names
open Esubst
open Term
open Constr
open Declarations
open Vmvalues
open Environ
open Pp

let pr_con sp = str(Names.Label.to_string (Constant.label sp))

type lambda =
  | Lrel          of Name.t * int
  | Lvar          of Id.t
  | Levar         of Evar.t * lambda array
  | Lprod         of lambda * lambda
  | Llam          of Name.t Context.binder_annot array * lambda
  | Llet          of Name.t Context.binder_annot * lambda * lambda
  | Lapp          of lambda * lambda array
  | Lconst        of pconstant
  | Lprim         of pconstant option * CPrimitives.t * lambda array
        (* No check if None *)
  | Lcase         of case_info * reloc_table * lambda * lambda * lam_branches
  | Lif           of lambda * lambda * lambda
  | Lfix          of (int array * int) * fix_decl
  | Lcofix        of int * fix_decl
  | Lint          of int
  | Lmakeblock    of int * lambda array
  | Luint         of Uint63.t
  | Lval          of structured_values
  | Lsort         of Sorts.t
  | Lind          of pinductive
  | Lproj         of Projection.Repr.t * lambda

(* We separate branches for constant and non-constant constructors. If the OCaml
   limitation on non-constant constructors is reached, remaining branches are
   stored in [extra_branches]. *)
and lam_branches =
  { constant_branches : lambda array;
    nonconstant_branches : (Name.t Context.binder_annot array * lambda) array }
(*    extra_branches : (name array * lambda) array } *)

and fix_decl =  Name.t Context.binder_annot array * lambda array * lambda array

(** Printing **)

let pr_annot x = Name.print x.Context.binder_name

let pp_names ids =
  prlist_with_sep (fun _ -&gt; brk(1,1)) pr_annot (Array.to_list ids)

let pp_rel name n =
  Name.print name ++  str &quot;##&quot; ++ int n

let pp_sort s =
  match Sorts.family s with
  | InSet -&gt; str &quot;Set&quot;
  | InProp -&gt; str &quot;Prop&quot;
  | InSProp -&gt; str &quot;SProp&quot;
  | InType -&gt; str &quot;Type&quot;

let rec pp_lam lam =
  match lam with
  | Lrel (id,n) -&gt; pp_rel id n
  | Lvar id -&gt; Id.print id
  | Levar (evk, args) -&gt;
    hov 1 (str &quot;evar(&quot; ++ Evar.print evk ++ str &quot;,&quot; ++ spc () ++
      prlist_with_sep spc pp_lam (Array.to_list args) ++ str &quot;)&quot;)
  | Lprod(dom,codom) -&gt; hov 1
                          (str &quot;forall(&quot; ++
                           pp_lam dom ++
                           str &quot;,&quot; ++ spc() ++
                           pp_lam codom ++
                           str &quot;)&quot;)
  | Llam(ids,body) -&gt; hov 1
                        (str &quot;(fun &quot; ++
                         pp_names ids ++
                         str &quot; =&gt;&quot; ++
                         spc() ++
                         pp_lam body ++
                         str &quot;)&quot;)
  | Llet(id,def,body) -&gt; hov 0
                           (str &quot;let &quot; ++
                            pr_annot id ++
                            str &quot;:=&quot; ++
                            pp_lam def  ++
                            str &quot; in&quot; ++
                            spc() ++
                            pp_lam body)
  | Lapp(f, args) -&gt; hov 1
                       (str &quot;(&quot; ++ pp_lam f ++ spc() ++
                        prlist_with_sep spc pp_lam (Array.to_list args) ++
                        str&quot;)&quot;)
  | Lconst (kn,_) -&gt; pr_con kn
  | Lcase(_ci, _rtbl, t, a, branches) -&gt;
    let ic = ref (-1) in
    let ib = ref 0 in
    v 0 (str&quot;&lt;&quot; ++ pp_lam t ++ str&quot;&gt;&quot; ++ cut() ++
         str &quot;Case&quot; ++ spc () ++ pp_lam a ++ spc() ++ str &quot;of&quot; ++ cut() ++
         v 0
           ((prlist_with_sep (fun _ -&gt; str &quot;&quot;)
               (fun c -&gt;
                  cut () ++ str &quot;| &quot; ++
                  int (incr ic; !ic) ++ str &quot; =&gt; &quot; ++ pp_lam c)
               (Array.to_list branches.constant_branches)) ++
            (prlist_with_sep (fun _ -&gt; str &quot;&quot;)
               (fun (ids,c) -&gt;
                  cut () ++ str &quot;| &quot; ++
                  int (incr ib; !ib) ++ str &quot; &quot; ++
                  pp_names ids ++ str &quot; =&gt; &quot; ++ pp_lam c)
               (Array.to_list branches.nonconstant_branches)))
         ++ cut() ++ str &quot;end&quot;)
  | Lif (t, bt, bf) -&gt;
      v 0 (str &quot;(if &quot; ++ pp_lam t ++
             cut () ++ str &quot;then &quot; ++ pp_lam bt ++
             cut() ++ str &quot;else &quot; ++ pp_lam bf ++ str &quot;)&quot;)
  | Lfix((t,i),(lna,tl,bl)) -&gt;
    let fixl = Array.mapi (fun i id -&gt; (id,t.(i),tl.(i),bl.(i))) lna in
    hov 1
      (str&quot;fix &quot; ++ int i ++ spc() ++  str&quot;{&quot; ++
       v 0
         (prlist_with_sep spc
            (fun (na,i,ty,bd) -&gt;
               pr_annot na ++ str&quot;/&quot; ++ int i ++ str&quot;:&quot; ++
               pp_lam ty ++ cut() ++ str&quot;:=&quot; ++
               pp_lam bd) (Array.to_list fixl)) ++
       str&quot;}&quot;)

  | Lcofix (i,(lna,tl,bl)) -&gt;
    let fixl = Array.mapi (fun i na -&gt; (na,tl.(i),bl.(i))) lna in
    hov 1
      (str&quot;cofix &quot; ++ int i ++ spc() ++  str&quot;{&quot; ++
       v 0
         (prlist_with_sep spc
            (fun (na,ty,bd) -&gt;
               pr_annot na ++ str&quot;:&quot; ++ pp_lam ty ++
               cut() ++ str&quot;:=&quot; ++ pp_lam bd) (Array.to_list fixl)) ++
       str&quot;}&quot;)
  | Lmakeblock(tag, args) -&gt;
    hov 1
      (str &quot;(makeblock &quot; ++ int tag ++ spc() ++
       prlist_with_sep spc pp_lam (Array.to_list args) ++
       str&quot;)&quot;)
  | Luint i -&gt; str (Uint63.to_string i)
  | Lval _ -&gt; str &quot;values&quot;
  | Lsort s -&gt; pp_sort s
  | Lind ((mind,i), _) -&gt; MutInd.print mind ++ str&quot;#&quot; ++ int i
  | Lprim(Some (kn,_u),_op,args) -&gt;
     hov 1
         (str &quot;(PRIM &quot; ++ pr_con kn ++  spc() ++
            prlist_with_sep spc pp_lam  (Array.to_list args) ++
            str&quot;)&quot;)
  | Lprim(None,op,args) -&gt;
     hov 1
         (str &quot;(PRIM_NC &quot; ++ str (CPrimitives.to_string op) ++  spc() ++
            prlist_with_sep spc pp_lam (Array.to_list args) ++
            str&quot;)&quot;)
  | Lproj(p,arg) -&gt;
    hov 1
      (str &quot;(proj &quot; ++ Projection.Repr.print p ++ str &quot;(&quot; ++ pp_lam arg
       ++ str &quot;)&quot;)
  | Lint i -&gt;
    Pp.(str &quot;(int:&quot; ++ int i ++ str &quot;)&quot;)

(*s Constructors *)

let mkLapp f args =
  if Array.length args = 0 then f
  else
    match f with
    | Lapp(f', args') -&gt; Lapp (f', Array.append args' args)
    | _ -&gt; Lapp(f, args)

let mkLlam ids body =
  if Array.length ids = 0 then body
  else
    match body with
    | Llam(ids', body) -&gt; Llam(Array.append ids ids', body)
    | _ -&gt; Llam(ids, body)

let decompose_Llam lam =
  match lam with
  | Llam(ids,body) -&gt; ids, body
  | _ -&gt; [||], lam

(*s Operators on substitution *)
let subst_id = subs_id 0
let lift = subs_lift
let liftn = subs_liftn
let cons v subst = subs_cons([|v|], subst)
let shift subst = subs_shft (1, subst)

(* A generic map function *)

let map_lam_with_binders g f n lam =
  match lam with
  | Lrel _ | Lvar _  | Lconst _ | Lval _ | Lsort _ | Lind _ | Lint _ | Luint _ -&gt; lam
  | Levar (evk, args) -&gt;
    let args' = Array.Smart.map (f n) args in
    if args == args' then lam else Levar (evk, args')
  | Lprod(dom,codom) -&gt;
    let dom' = f n dom in
    let codom' = f n codom in
    if dom == dom' &amp;&amp; codom == codom' then lam else Lprod(dom',codom')
  | Llam(ids,body) -&gt;
    let body' = f (g (Array.length ids) n) body in
    if body == body' then lam else mkLlam ids body'
  | Llet(id,def,body) -&gt;
    let def' = f n def in
    let body' = f (g 1 n) body in
    if body == body' &amp;&amp; def == def' then lam else Llet(id,def',body')
  | Lapp(fct,args) -&gt;
    let fct' = f n fct in
    let args' = Array.Smart.map (f n) args in
    if fct == fct' &amp;&amp; args == args' then lam else mkLapp fct' args'
  | Lcase(ci,rtbl,t,a,branches) -&gt;
    let const = branches.constant_branches in
    let nonconst = branches.nonconstant_branches in
    let t' = f n t in
    let a' = f n a in
    let const' = Array.Smart.map (f n) const in
    let on_b b =
      let (ids,body) = b in
      let body' = f (g (Array.length ids) n) body in
      if body == body' then b else (ids,body') in
    let nonconst' = Array.Smart.map on_b nonconst in
    let branches' =
      if const == const' &amp;&amp; nonconst == nonconst' then
        branches
      else
        { constant_branches = const';
          nonconstant_branches = nonconst' }
    in
    if t == t' &amp;&amp; a == a' &amp;&amp; branches == branches' then lam else
      Lcase(ci,rtbl,t',a',branches')
  | Lif(t,bt,bf) -&gt;
      let t' = f n t in
      let bt' = f n bt in
      let bf' = f n bf in
      if t == t' &amp;&amp; bt == bt' &amp;&amp; bf == bf' then lam else Lif(t',bt',bf')
  | Lfix(init,(ids,ltypes,lbodies)) -&gt;
    let ltypes' = Array.Smart.map (f n) ltypes in
    let lbodies' = Array.Smart.map (f (g (Array.length ids) n)) lbodies in
    if ltypes == ltypes' &amp;&amp; lbodies == lbodies' then lam
    else Lfix(init,(ids,ltypes',lbodies'))
  | Lcofix(init,(ids,ltypes,lbodies)) -&gt;
    let ltypes' = Array.Smart.map (f n) ltypes in
    let lbodies' = Array.Smart.map (f (g (Array.length ids) n)) lbodies in
    if ltypes == ltypes' &amp;&amp; lbodies == lbodies' then lam
    else Lcofix(init,(ids,ltypes',lbodies'))
  | Lmakeblock(tag,args) -&gt;
    let args' = Array.Smart.map (f n) args in
    if args == args' then lam else Lmakeblock(tag,args')
  | Lprim(kn,op,args) -&gt;
    let args' = Array.Smart.map (f n) args in
    if args == args' then lam else Lprim(kn,op,args')
  | Lproj(p,arg) -&gt;
    let arg' = f n arg in
    if arg == arg' then lam else Lproj(p,arg')

(*s Lift and substitution *)


let rec lam_exlift el lam =
  match lam with
  | Lrel(id,i) -&gt;
    let i' = reloc_rel i el in
    if i == i' then lam else Lrel(id,i')
  | _ -&gt; map_lam_with_binders el_liftn lam_exlift el lam

let lam_lift k lam =
  if k = 0 then lam
  else lam_exlift (el_shft k el_id) lam

let lam_subst_rel lam id n subst =
  match expand_rel n subst with
  | Inl(k,v) -&gt; lam_lift k v
  | Inr(n',_) -&gt;
    if n == n' then lam
    else Lrel(id, n')

let rec lam_exsubst subst lam =
  match lam with
  | Lrel(id,i) -&gt; lam_subst_rel lam id i subst
  | _ -&gt; map_lam_with_binders liftn lam_exsubst subst lam

let lam_subst_args subst args =
  if is_subs_id subst then args
  else Array.Smart.map (lam_exsubst subst) args

(** Simplification of lambda expression *)

(* [simplify subst lam] simplify the expression [lam_subst subst lam] *)
(* that is :                                                          *)
(* - Reduce [let] is the definition can be substituted i.e:           *)
(*    - a variable (rel or identifier)                                *)
(*    - a constant                                                    *)
(*    - a structured constant                                         *)
(*    - a function                                                    *)
(* - Transform beta redex into [let] expression                       *)
(* - Move arguments under [let]                                       *)
(* Invariant : Terms in [subst] are already simplified and can be     *)
(*             substituted                                            *)

let can_subst lam =
  match lam with
  | Lrel _ | Lvar _ | Lconst _ | Luint _
  | Lval _ | Lsort _ | Lind _ -&gt; true
  | _ -&gt; false


let can_merge_if bt bf =
  match bt, bf with
  | Llam(_idst,_), Llam(_idsf,_) -&gt; true
  | _ -&gt; false

let merge_if t bt bf =
  let (idst,bodyt) = decompose_Llam bt in
  let (idsf,bodyf) = decompose_Llam bf in
  let nt = Array.length idst in
  let nf = Array.length idsf in
  let common,idst,idsf =
    if nt = nf then idst, [||], [||]
    else
      if nt &lt; nf then idst,[||], Array.sub idsf nt (nf - nt)
      else idsf, Array.sub idst nf (nt - nf), [||] in
  Llam(common,
       Lif(lam_lift (Array.length common) t,
           mkLlam idst bodyt,
           mkLlam idsf bodyf))


let rec simplify subst lam =
  match lam with
  | Lrel(id,i) -&gt; lam_subst_rel lam id i subst

  | Llet(id,def,body) -&gt;
      let def' = simplify subst def in
      if can_subst def' then simplify (cons def' subst) body
      else
        let body' = simplify (lift subst) body in
        if def == def' &amp;&amp; body == body' then lam
        else Llet(id,def',body')

  | Lapp(f,args) -&gt;
      begin match simplify_app subst f subst args with
      | Lapp(f',args') when f == f' &amp;&amp; args == args' -&gt; lam
      | lam' -&gt; lam'
      end

  | Lif(t,bt,bf) -&gt;
      let t' = simplify subst t in
      let bt' = simplify subst bt in
      let bf' = simplify subst bf in
      if can_merge_if bt' bf' then merge_if t' bt' bf'
      else
        if t == t' &amp;&amp; bt == bt' &amp;&amp; bf == bf' then lam
        else Lif(t',bt',bf')
  | _ -&gt; map_lam_with_binders liftn simplify subst lam

and simplify_app substf f substa args =
  match f with
  | Lrel(id, i) -&gt;
    begin match lam_subst_rel f id i substf with
      | Llam(ids, body) -&gt;
        reduce_lapp
          subst_id (Array.to_list ids) body
          substa (Array.to_list args)
      | f' -&gt; mkLapp f' (simplify_args substa args)
    end
  | Llam(ids, body) -&gt;
    reduce_lapp substf (Array.to_list ids) body substa (Array.to_list args)
  | Llet(id, def, body) -&gt;
    let def' = simplify substf def in
    if can_subst def' then
      simplify_app (cons def' substf) body substa args
    else
      Llet(id, def', simplify_app (lift substf) body (shift substa) args)
  | Lapp(f, args') -&gt;
    let args = Array.append
        (lam_subst_args substf args') (lam_subst_args substa args) in
    simplify_app substf f subst_id args
  | _ -&gt; mkLapp (simplify substf f) (simplify_args substa args)

and simplify_args subst args = Array.Smart.map (simplify subst) args

and reduce_lapp substf lids body substa largs =
  match lids, largs with
  | id::lids, a::largs -&gt;
    let a = simplify substa a in
    if can_subst a then
      reduce_lapp (cons a substf) lids body substa largs
    else
      let body = reduce_lapp (lift substf) lids body (shift substa) largs in
      Llet(id, a, body)
  | [], [] -&gt; simplify substf body
  | _::_, _ -&gt;
    Llam(Array.of_list lids, simplify (liftn (List.length lids) substf) body)
  | [], _ -&gt; simplify_app substf body substa (Array.of_list largs)




(* [occurrence kind k lam]:
   If [kind] is [true] return [true] if the variable [k] does not appear in
   [lam], return [false] if the variable appear one time and not
   under a lambda, a fixpoint, a cofixpoint; else raise Not_found.
   If [kind] is [false] return [false] if the variable does not appear in [lam]
   else raise [Not_found]
*)

let rec occurrence k kind lam =
  match lam with
  | Lrel (_,n) -&gt;
    if n = k then
      if kind then false else raise Not_found
    else kind
  | Lvar _  | Lconst _  | Lval _ | Lsort _ | Lind _ | Lint _ | Luint _ -&gt; kind
  | Levar (_, args) -&gt;
    occurrence_args k kind args
  | Lprod(dom, codom) -&gt;
    occurrence k (occurrence k kind dom) codom
  | Llam(ids,body) -&gt;
    let _ = occurrence (k+Array.length ids) false body in kind
  | Llet(_,def,body) -&gt;
    occurrence (k+1) (occurrence k kind def) body
  | Lapp(f, args) -&gt;
    occurrence_args k (occurrence k kind f) args
  | Lprim(_,_,args) | Lmakeblock(_,args) -&gt;
    occurrence_args k kind args
  | Lcase(_ci,_rtbl,t,a,branches) -&gt;
    let kind = occurrence k (occurrence k kind t) a in
    let r = ref kind in
    Array.iter (fun c -&gt; r := occurrence k kind c  &amp;&amp; !r) branches.constant_branches;
    let on_b (ids,c) =
      r := occurrence (k+Array.length ids) kind c &amp;&amp; !r
    in
    Array.iter on_b branches.nonconstant_branches;
    !r
  | Lif (t, bt, bf) -&gt;
      let kind = occurrence k kind t in
      kind &amp;&amp; occurrence k kind bt &amp;&amp; occurrence k kind bf
  | Lfix(_,(ids,ltypes,lbodies))
  | Lcofix(_,(ids,ltypes,lbodies)) -&gt;
    let kind = occurrence_args k kind ltypes in
    let _ = occurrence_args (k+Array.length ids) false lbodies in
    kind
  | Lproj(_,arg) -&gt;
    occurrence k kind arg

and occurrence_args k kind args =
  Array.fold_left (occurrence k) kind args

let occur_once lam =
  try let _ = occurrence 1 true lam in true
  with Not_found -&gt; false

(* [remove_let lam] remove let expression in [lam] if the variable is *)
(* used at most once time in the body, and does not appear under      *)
(* a lambda or a fix or a cofix                                       *)

let rec remove_let subst lam =
  match lam with
  | Lrel(id,i) -&gt; lam_subst_rel lam id i subst
  | Llet(id,def,body) -&gt;
    let def' = remove_let subst def in
    if occur_once body then remove_let (cons def' subst) body
    else
      let body' = remove_let (lift subst) body in
      if def == def' &amp;&amp; body == body' then lam else Llet(id,def',body')
  | _ -&gt; map_lam_with_binders liftn remove_let subst lam


(*s Translation from [constr] to [lambda] *)

(* Translation of constructor *)

(* Limitation due to OCaml's representation of non-constant
  constructors: limited to 245 + 1 (0 tag) cases. *)

exception TooLargeInductive of Pp.t

let max_nb_const = 0x1000000
let max_nb_block = 0x1000000 + Obj.last_non_constant_constructor_tag - 1

let str_max_constructors =
  Format.sprintf
    &quot; which has more than %i constant constructors or more than %i non-constant constructors&quot; max_nb_const max_nb_block

let check_compilable ib =

  if not (ib.mind_nb_args &lt;= max_nb_block &amp;&amp; ib.mind_nb_constant &lt;= max_nb_const) then
    let msg =
      Pp.(str &quot;Cannot compile code for virtual machine as it uses inductive &quot;
          ++ Id.print ib.mind_typename ++ str str_max_constructors)
    in
    raise (TooLargeInductive msg)

let is_value lc =
  match lc with
  | Lval _ | Lint _ | Luint _ -&gt; true
  | _ -&gt; false

let get_value lc =
  match lc with
  | Luint i -&gt; val_of_uint i
  | Lval v -&gt; v
  | Lint i -&gt; val_of_int i
  | _ -&gt; raise Not_found

let make_args start _end =
  Array.init (start - _end + 1) (fun i -&gt; Lrel (Anonymous, start - i))

(* Translation of constructors *)
let expand_constructor tag nparams arity =
  let anon = Context.make_annot Anonymous Sorts.Relevant in (* TODO relevance *)
  let ids = Array.make (nparams + arity) anon in
  if arity = 0 then mkLlam ids (Lint tag)
  else
    let args = make_args arity 1 in
    Llam(ids, Lmakeblock (tag, args))

let makeblock tag nparams arity args =
  let nargs = Array.length args in
  if nparams &gt; 0 || nargs &lt; arity then
    mkLapp (expand_constructor tag nparams arity) args
  else
    (* The constructor is fully applied *)
  if arity = 0 then Lint tag
  else
  if Array.for_all is_value args then
    if tag &lt; Obj.last_non_constant_constructor_tag then
      Lval(val_of_block tag (Array.map get_value args))
    else
      let args = Array.map get_value args in
      let args = Array.append [| val_of_int (tag - Obj.last_non_constant_constructor_tag) |] args in
      Lval(val_of_block Obj.last_non_constant_constructor_tag args)
  else Lmakeblock(tag, args)


(* Compiling constants *)

let rec get_alias env kn =
  let cb = lookup_constant kn env in
  let tps = cb.const_body_code in
  match tps with
  | None -&gt; kn
  | Some tps -&gt;
    (match Cemitcodes.force tps with
     | Cemitcodes.BCalias kn' -&gt; get_alias env kn'
     | _ -&gt; kn)

(* Compilation of primitive *)

let prim kn p args =
  Lprim(Some kn, p, args)

let expand_prim kn op arity =
  (* primitives are always Relevant *)
  let ids = Array.make arity Context.anonR in
  let args = make_args arity 1 in
  Llam(ids, prim kn op args)

let lambda_of_prim kn op args =
  let arity = CPrimitives.arity op in
  if Array.length args &gt;= arity then prim kn op args
  else mkLapp (expand_prim kn op arity) args

(*i Global environment *)

let get_names decl =
  let decl = Array.of_list decl in
  Array.map fst decl


(* Rel Environment *)
module Vect =
struct
  type 'a t = {
    mutable elems : 'a array;
    mutable size : int;
  }

  let make n a = {
    elems = Array.make n a;
    size = 0;
  }

  let extend (v : 'a t) =
    if v.size = Array.length v.elems then
      let new_size = min (2*v.size) Sys.max_array_length in
      if new_size &lt;= v.size then raise (Invalid_argument &quot;Vect.extend&quot;);
      let new_elems = Array.make new_size v.elems.(0) in
      Array.blit v.elems 0 new_elems 0 (v.size);
      v.elems &lt;- new_elems

  let push v a =
    extend v;
    v.elems.(v.size) &lt;- a;
    v.size &lt;- v.size + 1

  let popn (v : 'a t) n =
    v.size &lt;- max 0 (v.size - n)

  let pop v = popn v 1

  let get_last (v : 'a t) n =
    if v.size &lt;= n then raise
        (Invalid_argument &quot;Vect.get:index out of bounds&quot;);
    v.elems.(v.size - n - 1)

end

let dummy_lambda = Lrel(Anonymous, 0)

let empty_args = [||]

module Renv =
struct

  type constructor_info = tag * int * int (* nparam nrealargs *)

  type t = {
    global_env : env;
    name_rel : Name.t Vect.t;
    construct_tbl : (constructor, constructor_info) Hashtbl.t;
  }

  let make env = {
    global_env = env;
    name_rel = Vect.make 16 Anonymous;
    construct_tbl = Hashtbl.create 111
  }

  let push_rel env id = Vect.push env.name_rel id.Context.binder_name

  let push_rels env ids =
    Array.iter (push_rel env) ids

  let pop env = Vect.pop env.name_rel

  let popn env n =
    for _i = 1 to n do pop env done

  let get env n =
    Lrel (Vect.get_last env.name_rel (n-1), n)

  let get_construct_info env c =
    try Hashtbl.find env.construct_tbl c
    with Not_found -&gt;
      let ((mind,j), i) = c in
      let oib = lookup_mind mind env.global_env in
      let oip = oib.mind_packets.(j) in
      check_compilable oip;
      let tag,arity = oip.mind_reloc_tbl.(i-1) in
      let nparams = oib.mind_nparams in
      let r = (tag, nparams, arity) in
      Hashtbl.add env.construct_tbl c r;
      r
end

open Renv

let rec lambda_of_constr env c =
  match Constr.kind c with
  | Meta _ -&gt; raise (Invalid_argument &quot;Cbytegen.lambda_of_constr: Meta&quot;)
  | Evar (evk, args) -&gt;
    let args = lambda_of_args env 0 args in
    Levar (evk, args)

  | Cast (c, _, _) -&gt; lambda_of_constr env c

  | Rel i -&gt; Renv.get env i

  | Var id -&gt; Lvar id

  | Sort s -&gt; Lsort s
  | Ind ind -&gt; Lind ind

  | Prod(id, dom, codom) -&gt;
    let ld = lambda_of_constr env dom in
    Renv.push_rel env id;
    let lc = lambda_of_constr env codom in
    Renv.pop env;
    Lprod(ld, Llam([|id|], lc))

  | Lambda _ -&gt;
    let params, body = decompose_lam c in
    let ids = get_names (List.rev params) in
    Renv.push_rels env ids;
    let lb = lambda_of_constr env body in
    Renv.popn env (Array.length ids);
    mkLlam ids lb

  | LetIn(id, def, _, body) -&gt;
    let ld = lambda_of_constr env def in
    Renv.push_rel env id;
    let lb = lambda_of_constr env body in
    Renv.pop env;
    Llet(id, ld, lb)

  | App(f, args) -&gt; lambda_of_app env f args

  | Const _ -&gt; lambda_of_app env c empty_args

  | Construct _ -&gt;  lambda_of_app env c empty_args

  | Case(ci,t,a,branches) -&gt;
    let ind = ci.ci_ind in
    let mib = lookup_mind (fst ind) env.global_env in
    let oib = mib.mind_packets.(snd ind) in
    let () = check_compilable oib in
    let rtbl = oib.mind_reloc_tbl in


    (* translation of the argument *)
    let la = lambda_of_constr env a in
    (* translation of the type *)
    let lt = lambda_of_constr env t in
    (* translation of branches *)
    let consts = Array.make oib.mind_nb_constant dummy_lambda in
    let blocks = Array.make oib.mind_nb_args ([||],dummy_lambda) in
    for i = 0 to Array.length rtbl - 1 do
      let tag, arity = rtbl.(i) in
      let b = lambda_of_constr env branches.(i) in
      if arity = 0 then consts.(tag) &lt;- b
      else
        let b =
          match b with
          | Llam(ids, body) when Array.length ids = arity -&gt; (ids, body)
          | _ -&gt;
            let anon = Context.make_annot Anonymous Sorts.Relevant in (* TODO relevance *)
            let ids = Array.make arity anon in
            let args = make_args arity 1 in
            let ll = lam_lift arity b in
            (ids, mkLapp  ll args)
        in blocks.(tag-1) &lt;- b
    done;
    let branches =
      { constant_branches = consts;
        nonconstant_branches = blocks }
    in
    Lcase(ci, rtbl, lt, la, branches)

  | Fix(rec_init,(names,type_bodies,rec_bodies)) -&gt;
    let ltypes = lambda_of_args env 0 type_bodies in
    Renv.push_rels env names;
    let lbodies = lambda_of_args env 0 rec_bodies in
    Renv.popn env (Array.length names);
    Lfix(rec_init, (names, ltypes, lbodies))

  | CoFix(init,(names,type_bodies,rec_bodies)) -&gt;
    let rec_bodies = Array.map2 (Reduction.eta_expand env.global_env) rec_bodies type_bodies in
    let ltypes = lambda_of_args env 0 type_bodies in
    Renv.push_rels env names;
    let lbodies = lambda_of_args env 0 rec_bodies in
    Renv.popn env (Array.length names);
    Lcofix(init, (names, ltypes, lbodies))

  | Proj (p,c) -&gt;
    let lc = lambda_of_constr env c in
    Lproj (Projection.repr p,lc)

  | Int i -&gt; Luint i

and lambda_of_app env f args =
  match Constr.kind f with
  | Const (kn,u as c) -&gt;
      let kn = get_alias env.global_env kn in
      let cb = lookup_constant kn env.global_env in
      begin match cb.const_body with
      | Primitive op -&gt; lambda_of_prim (kn,u) op (lambda_of_args env 0 args)
      | Def csubst when cb.const_inline_code -&gt;
          lambda_of_app env (Mod_subst.force_constr csubst) args
      | Def _ | OpaqueDef _ | Undef _ -&gt; mkLapp (Lconst c) (lambda_of_args env 0 args)
      end
  | Construct (c,_) -&gt;
      let tag, nparams, arity = Renv.get_construct_info env c in
      let nargs = Array.length args in
      if nparams &lt; nargs then (* got all parameters *)
        let args = lambda_of_args env nparams args in
        makeblock tag 0 arity args
      else makeblock tag (nparams - nargs) arity empty_args
  | _ -&gt;
      let f = lambda_of_constr env f in
      let args = lambda_of_args env 0 args in
      mkLapp f args

and lambda_of_args env start args =
  let nargs = Array.length args in
  if start &lt; nargs then
    Array.init (nargs - start)
      (fun i -&gt; lambda_of_constr env args.(start + i))
  else empty_args




(*********************************)
let dump_lambda = ref false

let optimize_lambda lam =
  let lam = simplify subst_id lam in
  remove_let subst_id lam

let lambda_of_constr ~optimize genv c =
  let env = Renv.make genv in
  let ids = List.rev_map Context.Rel.Declaration.get_annot (rel_context genv) in
  Renv.push_rels env (Array.of_list ids);
  let lam = lambda_of_constr env c in
  let lam = if optimize then optimize_lambda lam else lam in
  if !dump_lambda then
    Feedback.msg_debug (pp_lam lam);
  lam
</pre>
          </div>
          <div class="col-md-6">
            <code>clambda.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Util.

Import Names.

Import Esubst.

Import Term.

Import Constr.

Import Declarations.

Import Vmvalues.

Import Environ.

Import Pp.

Definition pr_con (sp : Names.Constant.t) : Pp.t :=
  Pp.str (Names.Label.to_string (Names.Constant.label sp)).

Reserved Notation &quot;'fix_decl&quot;.

Inductive lambda : Type :=
| Lrel : Names.Name.t -&gt; Z -&gt; lambda
| Lvar : Names.Id.t -&gt; lambda
| Levar : Evar.t -&gt; (array lambda) -&gt; lambda
| Lprod : lambda -&gt; lambda -&gt; lambda
| Llam : (array (Context.binder_annot Names.Name.t)) -&gt; lambda -&gt; lambda
| Llet : (Context.binder_annot Names.Name.t) -&gt; lambda -&gt; lambda -&gt; lambda
| Lapp : lambda -&gt; (array lambda) -&gt; lambda
| Lconst : Constr.pconstant -&gt; lambda
| Lprim : (option Constr.pconstant) -&gt; CPrimitives.t -&gt; (array lambda) -&gt; lambda
| Lcase : Constr.case_info -&gt; Vmvalues.reloc_table -&gt; lambda -&gt; lambda -&gt;
  lam_branches -&gt; lambda
| Lif : lambda -&gt; lambda -&gt; lambda -&gt; lambda
| Lfix : ((array Z) * Z) -&gt; 'fix_decl -&gt; lambda
| Lcofix : Z -&gt; 'fix_decl -&gt; lambda
| Lint : Z -&gt; lambda
| Lmakeblock : Z -&gt; (array lambda) -&gt; lambda
| Luint : Uint63.t -&gt; lambda
| Lval : Vmvalues.structured_values -&gt; lambda
| Lsort : Sorts.t -&gt; lambda
| Lind : Constr.pinductive -&gt; lambda
| Lproj : Names.Projection.Repr.t -&gt; lambda -&gt; lambda

where &quot;'fix_decl&quot; := (
  (array (Context.binder_annot Names.Name.t)) * (array lambda) * (array lambda)).

Definition fix_decl := 'fix_decl.

Definition pr_annot (x : Context.binder_annot Names.Name.t) : Pp.t :=
  Names.Name.print (Context.binder_name x).

Definition pp_names (ids : array (Context.binder_annot Names.Name.t)) : Pp.t :=
  Pp.prlist_with_sep
    (fun function_parameter =&gt;
      match function_parameter with
      | _ =&gt; Pp.brk (1, 1)
      end) pr_annot (Util.Array.(CArray.ExtS.to_list) ids).

Definition pp_rel (name : Names.Name.t) (n : Z) : Pp.t :=
  Pp.op_plus_plus
    (Pp.op_plus_plus (Names.Name.print name) (Pp.str &quot;##&quot; % string)) (Pp.int n).

Definition pp_sort (s : Sorts.t) : Pp.t :=
  match Sorts.family s with
  | InSet =&gt; Pp.str &quot;Set&quot; % string
  | InProp =&gt; Pp.str &quot;Prop&quot; % string
  | InSProp =&gt; Pp.str &quot;SProp&quot; % string
  | InType =&gt; Pp.str &quot;Type&quot; % string
  end.

Fixpoint pp_lam (lam : lambda) : Pp.t :=
  match lam with
  | Lrel id n =&gt; pp_rel id n
  | Lvar id =&gt; Names.Id.print id
  | Levar evk args =&gt;
    Pp.hov 1
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus
            (Pp.op_plus_plus
              (Pp.op_plus_plus (Pp.str &quot;evar(&quot; % string) (Evar.print evk))
              (Pp.str &quot;,&quot; % string)) (Pp.spc tt))
          (Pp.prlist_with_sep Pp.spc pp_lam
            (Util.Array.(CArray.ExtS.to_list) args))) (Pp.str &quot;)&quot; % string))
  | Lprod dom codom =&gt;
    Pp.hov 1
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus
            (Pp.op_plus_plus
              (Pp.op_plus_plus (Pp.str &quot;forall(&quot; % string) (pp_lam dom))
              (Pp.str &quot;,&quot; % string)) (Pp.spc tt)) (pp_lam codom))
        (Pp.str &quot;)&quot; % string))
  | Llam ids body =&gt;
    Pp.hov 1
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus
            (Pp.op_plus_plus
              (Pp.op_plus_plus (Pp.str &quot;(fun &quot; % string) (pp_names ids))
              (Pp.str &quot; =&gt;&quot; % string)) (Pp.spc tt)) (pp_lam body))
        (Pp.str &quot;)&quot; % string))
  | Llet id def body =&gt;
    Pp.hov 0
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus
            (Pp.op_plus_plus
              (Pp.op_plus_plus
                (Pp.op_plus_plus (Pp.str &quot;let &quot; % string) (pr_annot id))
                (Pp.str &quot;:=&quot; % string)) (pp_lam def)) (Pp.str &quot; in&quot; % string))
          (Pp.spc tt)) (pp_lam body))
  | Lapp f args =&gt;
    Pp.hov 1
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus (Pp.op_plus_plus (Pp.str &quot;(&quot; % string) (pp_lam f))
            (Pp.spc tt))
          (Pp.prlist_with_sep Pp.spc pp_lam
            (Util.Array.(CArray.ExtS.to_list) args))) (Pp.str &quot;)&quot; % string))
  | Lconst (kn, _) =&gt; pr_con kn
  | Lcase _ci _rtbl t a branches =&gt;
    let ic := Stdlib.ref (-1) in
    let ib := Stdlib.ref 0 in
    Pp.v 0
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus
            (Pp.op_plus_plus
              (Pp.op_plus_plus
                (Pp.op_plus_plus
                  (Pp.op_plus_plus
                    (Pp.op_plus_plus
                      (Pp.op_plus_plus
                        (Pp.op_plus_plus
                          (Pp.op_plus_plus
                            (Pp.op_plus_plus (Pp.str &quot;&lt;&quot; % string) (pp_lam t))
                            (Pp.str &quot;&gt;&quot; % string)) (Pp.cut tt))
                        (Pp.str &quot;Case&quot; % string)) (Pp.spc tt)) (pp_lam a))
                  (Pp.spc tt)) (Pp.str &quot;of&quot; % string)) (Pp.cut tt))
            (Pp.v 0
              (Pp.op_plus_plus
                (Pp.prlist_with_sep
                  (fun function_parameter =&gt;
                    match function_parameter with
                    | _ =&gt; Pp.str &quot;&quot; % string
                    end)
                  (fun c =&gt;
                    Pp.op_plus_plus
                      (Pp.op_plus_plus
                        (Pp.op_plus_plus
                          (Pp.op_plus_plus (Pp.cut tt) (Pp.str &quot;| &quot; % string))
                          (Pp.int
                            (Stdlib.incr ic;
                            Util.op_exclamation ic))) (Pp.str &quot; =&gt; &quot; % string))
                      (pp_lam c))
                  (Util.Array.(CArray.ExtS.to_list) (constant_branches branches)))
                (Pp.prlist_with_sep
                  (fun function_parameter =&gt;
                    match function_parameter with
                    | _ =&gt; Pp.str &quot;&quot; % string
                    end)
                  (fun function_parameter =&gt;
                    match function_parameter with
                    | (ids, c) =&gt;
                      Pp.op_plus_plus
                        (Pp.op_plus_plus
                          (Pp.op_plus_plus
                            (Pp.op_plus_plus
                              (Pp.op_plus_plus
                                (Pp.op_plus_plus (Pp.cut tt)
                                  (Pp.str &quot;| &quot; % string))
                                (Pp.int
                                  (Stdlib.incr ib;
                                  Util.op_exclamation ib)))
                              (Pp.str &quot; &quot; % string)) (pp_names ids))
                          (Pp.str &quot; =&gt; &quot; % string)) (pp_lam c)
                    end)
                  (Util.Array.(CArray.ExtS.to_list)
                    (nonconstant_branches branches)))))) (Pp.cut tt))
        (Pp.str &quot;end&quot; % string))
  | Lif t bt bf =&gt;
    Pp.v 0
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus
            (Pp.op_plus_plus
              (Pp.op_plus_plus
                (Pp.op_plus_plus
                  (Pp.op_plus_plus
                    (Pp.op_plus_plus (Pp.str &quot;(if &quot; % string) (pp_lam t))
                    (Pp.cut tt)) (Pp.str &quot;then &quot; % string)) (pp_lam bt))
              (Pp.cut tt)) (Pp.str &quot;else &quot; % string)) (pp_lam bf))
        (Pp.str &quot;)&quot; % string))
  | Lfix (t, i) (lna, tl, bl) =&gt;
    let fixl :=
      Util.Array.(CArray.ExtS.mapi)
        (fun i =&gt;
          fun id =&gt;
            (id, (Util.Array.(CArray.ExtS.get) t i),
              (Util.Array.(CArray.ExtS.get) tl i),
              (Util.Array.(CArray.ExtS.get) bl i))) lna in
    Pp.hov 1
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus
            (Pp.op_plus_plus
              (Pp.op_plus_plus (Pp.str &quot;fix &quot; % string) (Pp.int i)) (Pp.spc tt))
            (Pp.str &quot;{&quot; % string))
          (Pp.v 0
            (Pp.prlist_with_sep Pp.spc
              (fun function_parameter =&gt;
                match function_parameter with
                | (na, i, ty, bd) =&gt;
                  Pp.op_plus_plus
                    (Pp.op_plus_plus
                      (Pp.op_plus_plus
                        (Pp.op_plus_plus
                          (Pp.op_plus_plus
                            (Pp.op_plus_plus
                              (Pp.op_plus_plus (pr_annot na)
                                (Pp.str &quot;/&quot; % string)) (Pp.int i))
                            (Pp.str &quot;:&quot; % string)) (pp_lam ty)) (Pp.cut tt))
                      (Pp.str &quot;:=&quot; % string)) (pp_lam bd)
                end) (Util.Array.(CArray.ExtS.to_list) fixl))))
        (Pp.str &quot;}&quot; % string))
  | Lcofix i (lna, tl, bl) =&gt;
    let fixl :=
      Util.Array.(CArray.ExtS.mapi)
        (fun i =&gt;
          fun na =&gt;
            (na, (Util.Array.(CArray.ExtS.get) tl i),
              (Util.Array.(CArray.ExtS.get) bl i))) lna in
    Pp.hov 1
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus
            (Pp.op_plus_plus
              (Pp.op_plus_plus (Pp.str &quot;cofix &quot; % string) (Pp.int i))
              (Pp.spc tt)) (Pp.str &quot;{&quot; % string))
          (Pp.v 0
            (Pp.prlist_with_sep Pp.spc
              (fun function_parameter =&gt;
                match function_parameter with
                | (na, ty, bd) =&gt;
                  Pp.op_plus_plus
                    (Pp.op_plus_plus
                      (Pp.op_plus_plus
                        (Pp.op_plus_plus
                          (Pp.op_plus_plus (pr_annot na) (Pp.str &quot;:&quot; % string))
                          (pp_lam ty)) (Pp.cut tt)) (Pp.str &quot;:=&quot; % string))
                    (pp_lam bd)
                end) (Util.Array.(CArray.ExtS.to_list) fixl))))
        (Pp.str &quot;}&quot; % string))
  | Lmakeblock tag args =&gt;
    Pp.hov 1
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus
            (Pp.op_plus_plus (Pp.str &quot;(makeblock &quot; % string) (Pp.int tag))
            (Pp.spc tt))
          (Pp.prlist_with_sep Pp.spc pp_lam
            (Util.Array.(CArray.ExtS.to_list) args))) (Pp.str &quot;)&quot; % string))
  | Luint i =&gt; Pp.str (Uint63.to_string i)
  | Lval _ =&gt; Pp.str &quot;values&quot; % string
  | Lsort s =&gt; pp_sort s
  | Lind ((mind, i), _) =&gt;
    Pp.op_plus_plus
      (Pp.op_plus_plus (Names.MutInd.print mind) (Pp.str &quot;#&quot; % string))
      (Pp.int i)
  | Lprim (Some (kn, _u)) _op args =&gt;
    Pp.hov 1
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus
            (Pp.op_plus_plus (Pp.str &quot;(PRIM &quot; % string) (pr_con kn)) (Pp.spc tt))
          (Pp.prlist_with_sep Pp.spc pp_lam
            (Util.Array.(CArray.ExtS.to_list) args))) (Pp.str &quot;)&quot; % string))
  | Lprim None op args =&gt;
    Pp.hov 1
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus
            (Pp.op_plus_plus (Pp.str &quot;(PRIM_NC &quot; % string)
              (Pp.str (CPrimitives.to_string op))) (Pp.spc tt))
          (Pp.prlist_with_sep Pp.spc pp_lam
            (Util.Array.(CArray.ExtS.to_list) args))) (Pp.str &quot;)&quot; % string))
  | Lproj p arg =&gt;
    Pp.hov 1
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus
            (Pp.op_plus_plus (Pp.str &quot;(proj &quot; % string)
              (Names.Projection.Repr.print p)) (Pp.str &quot;(&quot; % string))
          (pp_lam arg)) (Pp.str &quot;)&quot; % string))
  | Lint i =&gt;
    Pp.op_plus_plus (Pp.op_plus_plus (Pp.str &quot;(int:&quot; % string) (Pp.int i))
      (Pp.str &quot;)&quot; % string)
  end.

Definition mkLapp (f : lambda) (args : array lambda) : lambda :=
  if equiv_decb (Util.Array.(CArray.ExtS.length) args) 0 then
    f
  else
    match f with
    | Lapp f' args' =&gt; Lapp f' (Util.Array.(CArray.ExtS.append) args' args)
    | _ =&gt; Lapp f args
    end.

Definition mkLlam
  (ids : array (Context.binder_annot Names.Name.t)) (body : lambda) : lambda :=
  if equiv_decb (Util.Array.(CArray.ExtS.length) ids) 0 then
    body
  else
    match body with
    | Llam ids' body =&gt; Llam (Util.Array.(CArray.ExtS.append) ids ids') body
    | _ =&gt; Llam ids body
    end.

Definition decompose_Llam (lam : lambda)
  : (array (Context.binder_annot Names.Name.t)) * lambda :=
  match lam with
  | Llam ids body =&gt; (ids, body)
  | _ =&gt; (tt, lam)
  end.

Definition subst_id : Esubst.subs lambda := Esubst.subs_id 0.

Definition lift {A : Type} : (Esubst.subs A) -&gt; Esubst.subs A :=
  Esubst.subs_lift.

Definition liftn {A : Type} : Z -&gt; (Esubst.subs A) -&gt; Esubst.subs A :=
  Esubst.subs_liftn.

Definition cons {A : Type} (v : A) (subst : Esubst.subs A) : Esubst.subs A :=
  Esubst.subs_cons ((v), subst).

Definition shift {A : Type} (subst : Esubst.subs A) : Esubst.subs A :=
  Esubst.subs_shft (1, subst).

Definition map_lam_with_binders {A : Type}
  (g : Z -&gt; A -&gt; A) (f : A -&gt; lambda -&gt; lambda) (n : A) (lam : lambda)
  : lambda :=
  match lam with
  | Lrel _ _ | Lvar _ | Lconst _ | Lval _ | Lsort _ | Lind _ | Lint _ | Luint _
    =&gt; lam
  | Levar evk args =&gt;
    let args' := Util.Array.Smart.map (f n) args in
    if Stdlib.op_eq_eq args args' then
      lam
    else
      Levar evk args'
  | Lprod dom codom =&gt;
    let dom' := f n dom in
    let codom' := f n codom in
    if andb (Stdlib.op_eq_eq dom dom') (Stdlib.op_eq_eq codom codom') then
      lam
    else
      Lprod dom' codom'
  | Llam ids body =&gt;
    let body' := f (g (Util.Array.(CArray.ExtS.length) ids) n) body in
    if Stdlib.op_eq_eq body body' then
      lam
    else
      mkLlam ids body'
  | Llet id def body =&gt;
    let def' := f n def in
    let body' := f (g 1 n) body in
    if andb (Stdlib.op_eq_eq body body') (Stdlib.op_eq_eq def def') then
      lam
    else
      Llet id def' body'
  | Lapp fct args =&gt;
    let fct' := f n fct in
    let args' := Util.Array.Smart.map (f n) args in
    if andb (Stdlib.op_eq_eq fct fct') (Stdlib.op_eq_eq args args') then
      lam
    else
      mkLapp fct' args'
  | Lcase ci rtbl t a branches =&gt;
    let const := constant_branches branches in
    let nonconst := nonconstant_branches branches in
    let t' := f n t in
    let a' := f n a in
    let const' := Util.Array.Smart.map (f n) const in
    let on_b {B : Type} (b : (array B) * lambda) : (array B) * lambda :=
      match b with
      | (ids, body) =&gt;
        let body' := f (g (Util.Array.(CArray.ExtS.length) ids) n) body in
        if Stdlib.op_eq_eq body body' then
          b
        else
          (ids, body')
      end in
    let nonconst' := Util.Array.Smart.map on_b nonconst in
    let branches' :=
      if
        andb (Stdlib.op_eq_eq const const') (Stdlib.op_eq_eq nonconst nonconst')
        then
        branches
      else
        {| constant_branches := const'; nonconstant_branches := nonconst' |} in
    if
      andb (Stdlib.op_eq_eq t t')
        (andb (Stdlib.op_eq_eq a a') (Stdlib.op_eq_eq branches branches')) then
      lam
    else
      Lcase ci rtbl t' a' branches'
  | Lif t bt bf =&gt;
    let t' := f n t in
    let bt' := f n bt in
    let bf' := f n bf in
    if
      andb (Stdlib.op_eq_eq t t')
        (andb (Stdlib.op_eq_eq bt bt') (Stdlib.op_eq_eq bf bf')) then
      lam
    else
      Lif t' bt' bf'
  | Lfix init (ids, ltypes, lbodies) =&gt;
    let ltypes' := Util.Array.Smart.map (f n) ltypes in
    let lbodies' :=
      Util.Array.Smart.map (f (g (Util.Array.(CArray.ExtS.length) ids) n))
        lbodies in
    if andb (Stdlib.op_eq_eq ltypes ltypes') (Stdlib.op_eq_eq lbodies lbodies')
      then
      lam
    else
      Lfix init (ids, ltypes', lbodies')
  | Lcofix init (ids, ltypes, lbodies) =&gt;
    let ltypes' := Util.Array.Smart.map (f n) ltypes in
    let lbodies' :=
      Util.Array.Smart.map (f (g (Util.Array.(CArray.ExtS.length) ids) n))
        lbodies in
    if andb (Stdlib.op_eq_eq ltypes ltypes') (Stdlib.op_eq_eq lbodies lbodies')
      then
      lam
    else
      Lcofix init (ids, ltypes', lbodies')
  | Lmakeblock tag args =&gt;
    let args' := Util.Array.Smart.map (f n) args in
    if Stdlib.op_eq_eq args args' then
      lam
    else
      Lmakeblock tag args'
  | Lprim kn op args =&gt;
    let args' := Util.Array.Smart.map (f n) args in
    if Stdlib.op_eq_eq args args' then
      lam
    else
      Lprim kn op args'
  | Lproj p arg =&gt;
    let arg' := f n arg in
    if Stdlib.op_eq_eq arg arg' then
      lam
    else
      Lproj p arg'
  end.

Fixpoint lam_exlift (el : Esubst.lift) (lam : lambda) : lambda :=
  match lam with
  | Lrel id i =&gt;
    let i' := Esubst.reloc_rel i el in
    if Stdlib.op_eq_eq i i' then
      lam
    else
      Lrel id i'
  | _ =&gt; map_lam_with_binders Esubst.el_liftn lam_exlift el lam
  end.

Definition lam_lift (k : Z) (lam : lambda) : lambda :=
  if equiv_decb k 0 then
    lam
  else
    lam_exlift (Esubst.el_shft k Esubst.el_id) lam.

Definition lam_subst_rel
  (lam : lambda) (id : Names.Name.t) (n : Z) (subst : Esubst.subs lambda)
  : lambda :=
  match Esubst.expand_rel n subst with
  | Inl (k, v) =&gt; lam_lift k v
  | Inr (n', _) =&gt;
    if Stdlib.op_eq_eq n n' then
      lam
    else
      Lrel id n'
  end.

Fixpoint lam_exsubst (subst : Esubst.subs lambda) (lam : lambda) : lambda :=
  match lam with
  | Lrel id i =&gt; lam_subst_rel lam id i subst
  | _ =&gt; map_lam_with_binders liftn lam_exsubst subst lam
  end.

Definition lam_subst_args (subst : Esubst.subs lambda) (args : array lambda)
  : array lambda :=
  if Esubst.is_subs_id subst then
    args
  else
    Util.Array.Smart.map (lam_exsubst subst) args.

Definition can_subst (lam : lambda) : bool :=
  match lam with
  | Lrel _ _ | Lvar _ | Lconst _ | Luint _ | Lval _ | Lsort _ | Lind _ =&gt; true
  | _ =&gt; false
  end.

Definition can_merge_if (bt : lambda) (bf : lambda) : bool :=
  match (bt, bf) with
  | (Llam _idst _, Llam _idsf _) =&gt; true
  | _ =&gt; false
  end.

Definition merge_if (t : lambda) (bt : lambda) (bf : lambda) : lambda :=
  match decompose_Llam bt with
  | (idst, bodyt) =&gt;
    match decompose_Llam bf with
    | (idsf, bodyf) =&gt;
      let nt := Util.Array.(CArray.ExtS.length) idst in
      let nf := Util.Array.(CArray.ExtS.length) idsf in
      match
        if equiv_decb nt nf then
          (idst, tt, tt)
        else
          if OCaml.Stdlib.lt nt nf then
            (idst, tt,
              (Util.Array.(CArray.ExtS.sub) idsf nt (Util.op_minus nf nt)))
          else
            (idsf, (Util.Array.(CArray.ExtS.sub) idst nf (Util.op_minus nt nf)),
              tt) with
      | (common, idst, idsf) =&gt;
        Llam common
          (Lif (lam_lift (Util.Array.(CArray.ExtS.length) common) t)
            (mkLlam idst bodyt) (mkLlam idsf bodyf))
      end
    end
  end.

Fixpoint simplify (subst : Esubst.subs lambda) (lam : lambda) : lambda :=
  match lam with
  | Lrel id i =&gt; lam_subst_rel lam id i subst
  | Llet id def body =&gt;
    let def' := simplify subst def in
    if can_subst def' then
      simplify (cons def' subst) body
    else
      let body' := simplify (lift subst) body in
      if andb (Stdlib.op_eq_eq def def') (Stdlib.op_eq_eq body body') then
        lam
      else
        Llet id def' body'
  | Lapp f args =&gt;
    match simplify_app subst f subst args with
    | lam' =&gt; lam'
    end
  | Lif t bt bf =&gt;
    let t' := simplify subst t in
    let bt' := simplify subst bt in
    let bf' := simplify subst bf in
    if can_merge_if bt' bf' then
      merge_if t' bt' bf'
    else
      if
        andb (Stdlib.op_eq_eq t t')
          (andb (Stdlib.op_eq_eq bt bt') (Stdlib.op_eq_eq bf bf')) then
        lam
      else
        Lif t' bt' bf'
  | _ =&gt; map_lam_with_binders liftn simplify subst lam
  end

with simplify_app
  (substf : Esubst.subs lambda) (f : lambda) (substa : Esubst.subs lambda)
  (args : array lambda) : lambda :=
  match f with
  | Lrel id i =&gt;
    match lam_subst_rel f id i substf with
    | Llam ids body =&gt;
      reduce_lapp subst_id (Util.Array.(CArray.ExtS.to_list) ids) body substa
        (Util.Array.(CArray.ExtS.to_list) args)
    | f' =&gt; mkLapp f' (simplify_args substa args)
    end
  | Llam ids body =&gt;
    reduce_lapp substf (Util.Array.(CArray.ExtS.to_list) ids) body substa
      (Util.Array.(CArray.ExtS.to_list) args)
  | Llet id def body =&gt;
    let def' := simplify substf def in
    if can_subst def' then
      simplify_app (cons def' substf) body substa args
    else
      Llet id def' (simplify_app (lift substf) body (shift substa) args)
  | Lapp f args' =&gt;
    let args :=
      Util.Array.(CArray.ExtS.append) (lam_subst_args substf args')
        (lam_subst_args substa args) in
    simplify_app substf f subst_id args
  | _ =&gt; mkLapp (simplify substf f) (simplify_args substa args)
  end

with simplify_args (subst : Esubst.subs lambda) (args : array lambda)
  : array lambda := Util.Array.Smart.map (simplify subst) args

with reduce_lapp
  (substf : Esubst.subs lambda)
  (lids : list (Context.binder_annot Names.Name.t)) (body : lambda)
  (substa : Esubst.subs lambda) (largs : list lambda) : lambda :=
  match (lids, largs) with
  | (cons id lids, cons a largs) =&gt;
    let a := simplify substa a in
    if can_subst a then
      reduce_lapp (cons a substf) lids body substa largs
    else
      let body := reduce_lapp (lift substf) lids body (shift substa) largs in
      Llet id a body
  | ([], []) =&gt; simplify substf body
  | (cons _ _, _) =&gt;
    Llam (Util.Array.(CArray.ExtS.of_list) lids)
      (simplify (liftn (Util.List.(CList.ExtS.length) lids) substf) body)
  | ([], _) =&gt;
    simplify_app substf body substa (Util.Array.(CArray.ExtS.of_list) largs)
  end.

Fixpoint occurrence (k : Z) (kind : bool) (lam : lambda) : bool :=
  match lam with
  | Lrel _ n =&gt;
    if equiv_decb n k then
      if kind then
        false
      else
        Stdlib.raise OCaml.Not_found
    else
      kind
  | Lvar _ | Lconst _ | Lval _ | Lsort _ | Lind _ | Lint _ | Luint _ =&gt; kind
  | Levar _ args =&gt; occurrence_args k kind args
  | Lprod dom codom =&gt; occurrence k (occurrence k kind dom) codom
  | Llam ids body =&gt;
    match
      occurrence (Util.op_plus k (Util.Array.(CArray.ExtS.length) ids)) false
        body with
    | _ =&gt; kind
    end
  | Llet _ def body =&gt;
    occurrence (Util.op_plus k 1) (occurrence k kind def) body
  | Lapp f args =&gt; occurrence_args k (occurrence k kind f) args
  | Lprim _ _ args | Lmakeblock _ args =&gt; occurrence_args k kind args
  | Lcase _ci _rtbl t a branches =&gt;
    let kind := occurrence k (occurrence k kind t) a in
    let r := Stdlib.ref kind in
    Util.Array.(CArray.ExtS.iter)
      (fun c =&gt;
        Stdlib.op_colon_eq r
          (andb (occurrence k kind c) (Util.op_exclamation r)))
      (constant_branches branches);
    let on_b {A : Type} (function_parameter : (array A) * lambda) : unit :=
      match function_parameter with
      | (ids, c) =&gt;
        Stdlib.op_colon_eq r
          (andb
            (occurrence (Util.op_plus k (Util.Array.(CArray.ExtS.length) ids))
              kind c) (Util.op_exclamation r))
      end in
    Util.Array.(CArray.ExtS.iter) on_b (nonconstant_branches branches);
    Util.op_exclamation r
  | Lif t bt bf =&gt;
    let kind := occurrence k kind t in
    andb kind (andb (occurrence k kind bt) (occurrence k kind bf))
  | Lfix _ (ids, ltypes, lbodies) | Lcofix _ (ids, ltypes, lbodies) =&gt;
    let kind := occurrence_args k kind ltypes in
    match
      occurrence_args (Util.op_plus k (Util.Array.(CArray.ExtS.length) ids))
        false lbodies with
    | _ =&gt; kind
    end
  | Lproj _ arg =&gt; occurrence k kind arg
  end

with occurrence_args (k : Z) (kind : bool) (args : array lambda) : bool :=
  Util.Array.(CArray.ExtS.fold_left) (occurrence k) kind args.

Definition occur_once (lam : lambda) : bool := try.

Fixpoint remove_let (subst : Esubst.subs lambda) (lam : lambda) : lambda :=
  match lam with
  | Lrel id i =&gt; lam_subst_rel lam id i subst
  | Llet id def body =&gt;
    let def' := remove_let subst def in
    if occur_once body then
      remove_let (cons def' subst) body
    else
      let body' := remove_let (lift subst) body in
      if andb (Stdlib.op_eq_eq def def') (Stdlib.op_eq_eq body body') then
        lam
      else
        Llet id def' body'
  | _ =&gt; map_lam_with_binders liftn remove_let subst lam
  end.

Definition max_nb_const : Z := 16777216.

Definition max_nb_block : Z :=
  Util.op_minus
    (Util.op_plus 16777216 Stdlib.Obj.last_non_constant_constructor_tag) 1.

Definition str_max_constructors : string :=
  Stdlib.Format.sprintf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.String_literal &quot; which has more than &quot; % string
        (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
          CamlinternalFormatBasics.No_padding
          CamlinternalFormatBasics.No_precision
          (CamlinternalFormatBasics.String_literal
            &quot; constant constructors or more than &quot; % string
            (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
              CamlinternalFormatBasics.No_padding
              CamlinternalFormatBasics.No_precision
              (CamlinternalFormatBasics.String_literal
                &quot; non-constant constructors&quot; % string
                CamlinternalFormatBasics.End_of_format)))))
      &quot; which has more than %i constant constructors or more than %i non-constant constructors&quot;
        % string) max_nb_const max_nb_block.

Definition check_compilable (ib : Declarations.one_inductive_body) : unit :=
  if
    negb
      (andb (OCaml.Stdlib.le (mind_nb_args ib) max_nb_block)
        (OCaml.Stdlib.le (mind_nb_constant ib) max_nb_const)) then
    let msg :=
      Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.str
            &quot;Cannot compile code for virtual machine as it uses inductive &quot; %
              string) (Names.Id.print (mind_typename ib)))
        (Pp.str str_max_constructors) in
    Stdlib.raise (TooLargeInductive msg)
  else
    tt.

Definition is_value (lc : lambda) : bool :=
  match lc with
  | Lval _ | Lint _ | Luint _ =&gt; true
  | _ =&gt; false
  end.

Definition get_value (lc : lambda) : Vmvalues.structured_values :=
  match lc with
  | Luint i =&gt; Vmvalues.val_of_uint i
  | Lval v =&gt; v
  | Lint i =&gt; Vmvalues.val_of_int i
  | _ =&gt; Stdlib.raise OCaml.Not_found
  end.

Definition make_args (start : Z) (_end : Z) : array lambda :=
  Util.Array.(CArray.ExtS.init) (Util.op_plus (Util.op_minus start _end) 1)
    (fun i =&gt; Lrel Anonymous (Util.op_minus start i)).

Definition expand_constructor (tag : Z) (nparams : Z) (arity : Z) : lambda :=
  let anon := Context.make_annot Anonymous Sorts.Relevant in
  let ids := Util.Array.(CArray.ExtS.make) (Util.op_plus nparams arity) anon in
  if equiv_decb arity 0 then
    mkLlam ids (Lint tag)
  else
    let args := make_args arity 1 in
    Llam ids (Lmakeblock tag args).

Definition makeblock
  (tag : Vmvalues.tag) (nparams : Z) (arity : Z) (args : array lambda)
  : lambda :=
  let nargs := Util.Array.(CArray.ExtS.length) args in
  if orb (OCaml.Stdlib.gt nparams 0) (OCaml.Stdlib.lt nargs arity) then
    mkLapp (expand_constructor tag nparams arity) args
  else
    if equiv_decb arity 0 then
      Lint tag
    else
      if Util.Array.(CArray.ExtS.for_all) is_value args then
        if OCaml.Stdlib.lt tag Stdlib.Obj.last_non_constant_constructor_tag then
          Lval
            (Vmvalues.val_of_block tag
              (Util.Array.(CArray.ExtS.map) get_value args))
        else
          let args := Util.Array.(CArray.ExtS.map) get_value args in
          let args :=
            Util.Array.(CArray.ExtS.append)
              ((Vmvalues.val_of_int
                (Util.op_minus tag Stdlib.Obj.last_non_constant_constructor_tag)))
              args in
          Lval
            (Vmvalues.val_of_block Stdlib.Obj.last_non_constant_constructor_tag
              args)
      else
        Lmakeblock tag args.

Fixpoint get_alias (env : Environ.env) (kn : Names.Constant.t)
  : Names.Constant.t :=
  let cb := Environ.lookup_constant kn env in
  let tps := const_body_code cb in
  match tps with
  | None =&gt; kn
  | Some tps =&gt;
    match Cemitcodes.force tps with
    | Cemitcodes.BCalias kn' =&gt; get_alias env kn'
    | _ =&gt; kn
    end
  end.

Definition prim
  (kn : Constr.pconstant) (p : CPrimitives.t) (args : array lambda) : lambda :=
  Lprim (Some kn) p args.

Definition expand_prim (kn : Constr.pconstant) (op : CPrimitives.t) (arity : Z)
  : lambda :=
  let ids := Util.Array.(CArray.ExtS.make) arity Context.anonR in
  let args := make_args arity 1 in
  Llam ids (prim kn op args).

Definition lambda_of_prim
  (kn : Constr.pconstant) (op : CPrimitives.t) (args : array lambda) : lambda :=
  let arity := CPrimitives.arity op in
  if OCaml.Stdlib.ge (Util.Array.(CArray.ExtS.length) args) arity then
    prim kn op args
  else
    mkLapp (expand_prim kn op arity) args.

Definition get_names {A B : Type} (decl : list (A * B)) : array A :=
  let decl := Util.Array.(CArray.ExtS.of_list) decl in
  Util.Array.(CArray.ExtS.map) fst decl.

Module Vect.
  Record t {a : Type} := {
    elems : array a;
    size : Z }.
  Arguments t : clear implicits.
  
  Definition make {A : Type} (n : Z) (a : A) : t A :=
    {| elems := Util.Array.(CArray.ExtS.make) n a; size := 0 |}.
  
  Definition extend {a : Type} (v : t a) : unit :=
    if equiv_decb (size v) (Util.Array.(CArray.ExtS.length) (elems v)) then
      let new_size :=
        OCaml.Stdlib.min (Z.mul 2 (size v)) Stdlib.Sys.max_array_length in
      if OCaml.Stdlib.le new_size (size v) then
        Stdlib.raise (OCaml.Invalid_argument &quot;Vect.extend&quot; % string)
      else
        tt;
      let new_elems :=
        Util.Array.(CArray.ExtS.make) new_size
          (Util.Array.(CArray.ExtS.get) (elems v) 0) in
      Util.Array.(CArray.ExtS.blit) (elems v) 0 new_elems 0 (size v);
      set_field
    else
      tt.
  
  Definition push {A : Type} (v : t A) (a : A) : unit :=
    extend v;
    Util.Array.(CArray.ExtS.set) (elems v) (size v) a;
    set_field.
  
  Definition popn {a : Type} (v : t a) (n : Z) : unit := set_field.
  
  Definition pop {A : Type} (v : t A) : unit := popn v 1.
  
  Definition get_last {a : Type} (v : t a) (n : Z) : a :=
    if OCaml.Stdlib.le (size v) n then
      Stdlib.raise
        (OCaml.Invalid_argument &quot;Vect.get:index out of bounds&quot; % string)
    else
      tt;
    Util.Array.(CArray.ExtS.get) (elems v)
      (Util.op_minus (Util.op_minus (size v) n) 1).
End Vect.

Definition dummy_lambda : lambda := Lrel Anonymous 0.

Definition empty_args {A : Type} : array A := tt.

Module Renv.
  Definition constructor_info := Vmvalues.tag * Z * Z.
  
  Record t := {
    global_env : Environ.env;
    name_rel : Vect.t Names.Name.t;
    construct_tbl : Stdlib.Hashtbl.t Names.constructor constructor_info }.
  
  Definition make (env : Environ.env) : t :=
    {| global_env := env; name_rel := Vect.make 16 Anonymous;
      construct_tbl := Stdlib.Hashtbl.create None 111 |}.
  
  Definition push_rel (env : t) (id : Context.binder_annot Names.Name.t)
    : unit := Vect.push (name_rel env) (Context.binder_name id).
  
  Definition push_rels
    (env : t) (ids : array (Context.binder_annot Names.Name.t)) : unit :=
    Util.Array.(CArray.ExtS.iter) (push_rel env) ids.
  
  Definition pop (env : t) : unit := Vect.pop (name_rel env).
  
  Definition popn (env : t) (n : Z) : unit := for.
  
  Definition get (env : t) (n : Z) : lambda :=
    Lrel (Vect.get_last (name_rel env) (Util.op_minus n 1)) n.
  
  Definition get_construct_info (env : t) (c : Names.constructor)
    : constructor_info := try.
End Renv.

Import Renv.

Fixpoint lambda_of_constr (env : Renv.t) (c : Constr.constr) : lambda :=
  match Constr.kind c with
  | Meta _ =&gt;
    Stdlib.raise
      (OCaml.Invalid_argument &quot;Cbytegen.lambda_of_constr: Meta&quot; % string)
  | Evar (evk, args) =&gt;
    let args := lambda_of_args env 0 args in
    Levar evk args
  | Cast c _ _ =&gt; lambda_of_constr env c
  | Rel i =&gt; Renv.get env i
  | Var id =&gt; Lvar id
  | Sort s =&gt; Lsort s
  | Ind ind =&gt; Lind ind
  | Prod id dom codom =&gt;
    let ld := lambda_of_constr env dom in
    Renv.push_rel env id;
    let lc := lambda_of_constr env codom in
    Renv.pop env;
    Lprod ld (Llam (id) lc)
  | Lambda _ _ _ =&gt;
    match Term.decompose_lam c with
    | (params, body) =&gt;
      let ids := get_names (Util.List.(CList.ExtS.rev) params) in
      Renv.push_rels env ids;
      let lb := lambda_of_constr env body in
      Renv.popn env (Util.Array.(CArray.ExtS.length) ids);
      mkLlam ids lb
    end
  | LetIn id def _ body =&gt;
    let ld := lambda_of_constr env def in
    Renv.push_rel env id;
    let lb := lambda_of_constr env body in
    Renv.pop env;
    Llet id ld lb
  | App f args =&gt; lambda_of_app env f args
  | Const _ =&gt; lambda_of_app env c empty_args
  | Construct _ =&gt; lambda_of_app env c empty_args
  | Case ci t a branches =&gt;
    let ind := ci_ind ci in
    let mib := Environ.lookup_mind (fst ind) (global_env env) in
    let oib := Util.Array.(CArray.ExtS.get) (mind_packets mib) (snd ind) in
    match check_compilable oib with
    | tt =&gt;
      let rtbl := mind_reloc_tbl oib in
      let la := lambda_of_constr env a in
      let lt := lambda_of_constr env t in
      let consts :=
        Util.Array.(CArray.ExtS.make) (mind_nb_constant oib) dummy_lambda in
      let blocks :=
        Util.Array.(CArray.ExtS.make) (mind_nb_args oib) (tt, dummy_lambda) in
      for;
      let branches :=
        {| constant_branches := consts; nonconstant_branches := blocks |} in
      Lcase ci rtbl lt la branches
    end
  | Fix (rec_init, (names, type_bodies, rec_bodies)) =&gt;
    let ltypes := lambda_of_args env 0 type_bodies in
    Renv.push_rels env names;
    let lbodies := lambda_of_args env 0 rec_bodies in
    Renv.popn env (Util.Array.(CArray.ExtS.length) names);
    Lfix rec_init (names, ltypes, lbodies)
  | CoFix (init, (names, type_bodies, rec_bodies)) =&gt;
    let rec_bodies :=
      Util.Array.(CArray.ExtS.map2) (Reduction.eta_expand (global_env env))
        rec_bodies type_bodies in
    let ltypes := lambda_of_args env 0 type_bodies in
    Renv.push_rels env names;
    let lbodies := lambda_of_args env 0 rec_bodies in
    Renv.popn env (Util.Array.(CArray.ExtS.length) names);
    Lcofix init (names, ltypes, lbodies)
  | Proj p c =&gt;
    let lc := lambda_of_constr env c in
    Lproj (Names.Projection.repr p) lc
  | Int i =&gt; Luint i
  end

with lambda_of_app
  (env : Renv.t) (f : Constr.constr) (args : array Constr.constr) : lambda :=
  match Constr.kind f with
  | Const ((kn, u) as c) =&gt;
    let kn := get_alias (global_env env) kn in
    let cb := Environ.lookup_constant kn (global_env env) in
    match const_body cb with
    | Primitive op =&gt; lambda_of_prim (kn, u) op (lambda_of_args env 0 args)
    | Def _ | OpaqueDef _ | Undef _ =&gt;
      mkLapp (Lconst c) (lambda_of_args env 0 args)
    end
  | Construct (c, _) =&gt;
    match Renv.get_construct_info env c with
    | (tag, nparams, arity) =&gt;
      let nargs := Util.Array.(CArray.ExtS.length) args in
      if OCaml.Stdlib.lt nparams nargs then
        let args := lambda_of_args env nparams args in
        makeblock tag 0 arity args
      else
        makeblock tag (Util.op_minus nparams nargs) arity empty_args
    end
  | _ =&gt;
    let f := lambda_of_constr env f in
    let args := lambda_of_args env 0 args in
    mkLapp f args
  end

with lambda_of_args (env : Renv.t) (start : Z) (args : array Constr.constr)
  : array lambda :=
  let nargs := Util.Array.(CArray.ExtS.length) args in
  if OCaml.Stdlib.lt start nargs then
    Util.Array.(CArray.ExtS.init) (Util.op_minus nargs start)
      (fun i =&gt;
        lambda_of_constr env
          (Util.Array.(CArray.ExtS.get) args (Util.op_plus start i)))
  else
    empty_args.

Definition dump_lambda : Stdlib.ref bool := Stdlib.ref false.

Definition optimize_lambda (lam : lambda) : lambda :=
  let lam := simplify subst_id lam in
  remove_let subst_id lam.

Definition lambda_of_constr
  (optimize : bool) (genv : Environ.env) (c : Constr.constr) : lambda :=
  let env := Renv.make genv in
  let ids :=
    Util.List.(CList.ExtS.rev_map) Context.Rel.Declaration.get_annot
      (Environ.rel_context genv) in
  Renv.push_rels env (Util.Array.(CArray.ExtS.of_list) ids);
  let lam := lambda_of_constr env c in
  let lam :=
    if optimize then
      optimize_lambda lam
    else
      lam in
  if Util.op_exclamation dump_lambda then
    Feedback.msg_debug None (pp_lam lam)
  else
    tt;
  lam.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="context" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>context.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Jean-Christophe Filli√¢tre out of names.ml as part of the
   rebuilding of Coq around a purely functional abstract type-checker,
   Aug 1999 *)
(* Miscellaneous extensions, restructurations and bug-fixes by Hugo
   Herbelin and Bruno Barras *)

(* This file defines types and combinators regarding indexes-based and
   names-based contexts *)

(** The modules defined below represent a {e local context}
    as defined by Chapter 4 in the Reference Manual:

    A {e local context} is an ordered list of of {e local declarations}
    of names that we call {e variables}.

    A {e local declaration} of some variable can be either:
    - a {e local assumption}, or
    - a {e local definition}.
*)

open Util
open Names

type 'a binder_annot = { binder_name : 'a; binder_relevance : Sorts.relevance }

let eq_annot eq {binder_name=na1;binder_relevance=r1} {binder_name=na2;binder_relevance=r2} =
  eq na1 na2 &amp;&amp; Sorts.relevance_equal r1 r2

let hash_annot h {binder_name=n;binder_relevance=r} =
  Hashset.Combine.combinesmall (Sorts.relevance_hash r) (h n)

let map_annot f {binder_name=na;binder_relevance} =
  {binder_name=f na;binder_relevance}

let make_annot x r = {binder_name=x;binder_relevance=r}

let binder_name x = x.binder_name
let binder_relevance x = x.binder_relevance

let annotR x = make_annot x Sorts.Relevant

let nameR x = annotR (Name x)
let anonR = annotR Anonymous

(** Representation of contexts that can capture anonymous as well as non-anonymous variables.
    Individual declarations are then designated by de Bruijn indexes. *)
module Rel =
struct
  (** Representation of {e local declarations}. *)
  module Declaration =
  struct
    (* local declaration *)
    type ('constr, 'types) pt =
      | LocalAssum of Name.t binder_annot * 'types            (** name, type *)
      | LocalDef of Name.t binder_annot * 'constr * 'types   (** name, value, type *)

    let get_annot = function
      | LocalAssum (na,_) | LocalDef (na,_,_) -&gt; na

    (** Return the name bound by a given declaration. *)
    let get_name x = (get_annot x).binder_name

    (** Return [Some value] for local-declarations and [None] for local-assumptions. *)
    let get_value = function
      | LocalAssum _ -&gt; None
      | LocalDef (_,v,_) -&gt; Some v
                                 
    (** Return the type of the name bound by a given declaration. *)
    let get_type = function
      | LocalAssum (_,ty)
      | LocalDef (_,_,ty) -&gt; ty

    let get_relevance x = (get_annot x).binder_relevance

    (** Set the name that is bound by a given declaration. *)
    let set_name na = function
      | LocalAssum (x,ty) -&gt; LocalAssum ({x with binder_name=na}, ty)
      | LocalDef (x,v,ty) -&gt; LocalDef ({x with binder_name=na}, v, ty)

    (** Set the type of the bound variable in a given declaration. *)
    let set_type ty = function
      | LocalAssum (na,_) -&gt; LocalAssum (na, ty)
      | LocalDef (na,v,_) -&gt; LocalDef (na, v, ty)

    (** Return [true] iff a given declaration is a local assumption. *)
    let is_local_assum = function
      | LocalAssum _ -&gt; true
      | LocalDef _ -&gt; false

    (** Return [true] iff a given declaration is a local definition. *)
    let is_local_def = function
      | LocalAssum _ -&gt; false
      | LocalDef _ -&gt; true

    (** Check whether any term in a given declaration satisfies a given predicate. *)
    let exists f = function
      | LocalAssum (_, ty) -&gt; f ty
      | LocalDef (_, v, ty) -&gt; f v || f ty

      (** Check whether all terms in a given declaration satisfy a given predicate. *)
    let for_all f = function
      | LocalAssum (_, ty) -&gt; f ty
      | LocalDef (_, v, ty) -&gt; f v &amp;&amp; f ty

    (** Check whether the two given declarations are equal. *)
    let equal eq decl1 decl2 =
      match decl1, decl2 with
      | LocalAssum (n1,ty1), LocalAssum (n2, ty2) -&gt;
          eq_annot Name.equal n1 n2 &amp;&amp; eq ty1 ty2
      | LocalDef (n1,v1,ty1), LocalDef (n2,v2,ty2) -&gt;
          eq_annot Name.equal n1 n2 &amp;&amp; eq v1 v2 &amp;&amp; eq ty1 ty2
      | _ -&gt;
          false

    (** Map the name bound by a given declaration. *)
    let map_name f x =
      let na = get_name x in
      let na' = f na in
      if na == na' then x else set_name na' x

    (** For local assumptions, this function returns the original local assumptions.
        For local definitions, this function maps the value in the local definition. *)
    let map_value f = function
      | LocalAssum _ as decl -&gt; decl
      | LocalDef (na, v, t) as decl -&gt;
          let v' = f v in
          if v == v' then decl else LocalDef (na, v', t)

    (** Map the type of the name bound by a given declaration. *)
    let map_type f = function
      | LocalAssum (na, ty) as decl -&gt;
          let ty' = f ty in
          if ty == ty' then decl else LocalAssum (na, ty')
      | LocalDef (na, v, ty) as decl -&gt;
          let ty' = f ty in
          if ty == ty' then decl else LocalDef (na, v, ty')

    (** Map all terms in a given declaration. *)
    let map_constr f = function
      | LocalAssum (na, ty) as decl -&gt;
          let ty' = f ty in
          if ty == ty' then decl else LocalAssum (na, ty')
      | LocalDef (na, v, ty) as decl -&gt;
          let v' = f v in
          let ty' = f ty in
          if v == v' &amp;&amp; ty == ty' then decl else LocalDef (na, v', ty')

    let map_constr_het f = function
      | LocalAssum (na, ty) -&gt;
          let ty' = f ty in
          LocalAssum (na, ty')
      | LocalDef (na, v, ty) -&gt;
          let v' = f v in
          let ty' = f ty in
          LocalDef (na, v', ty')

    (** Perform a given action on all terms in a given declaration. *)
    let iter_constr f = function
      | LocalAssum (_,ty) -&gt; f ty
      | LocalDef (_,v,ty) -&gt; f v; f ty

    (** Reduce all terms in a given declaration to a single value. *)
    let fold_constr f decl acc =
      match decl with
      | LocalAssum (_n,ty) -&gt; f ty acc
      | LocalDef (_n,v,ty) -&gt; f ty (f v acc)

    let to_tuple = function
      | LocalAssum (na, ty) -&gt; na, None, ty
      | LocalDef (na, v, ty) -&gt; na, Some v, ty

    let drop_body = function
      | LocalAssum _ as d -&gt; d
      | LocalDef (na, _v, ty) -&gt; LocalAssum (na, ty)

  end

  (** Rel-context is represented as a list of declarations.
      Inner-most declarations are at the beginning of the list.
      Outer-most declarations are at the end of the list. *)
  type ('constr, 'types) pt = ('constr, 'types) Declaration.pt list

  (** empty rel-context *)
  let empty = []

  (** Return a new rel-context enriched by with a given inner-most declaration. *)
  let add d ctx = d :: ctx

  (** Return the number of {e local declarations} in a given context. *)
  let length = List.length

  (** [extended_rel_list n Œì] builds an instance [args] such that [Œì,Œî ‚ä¢ args:Œì]
      with n = |Œî| and with the local definitions of [Œì] skipped in
      [args]. Example: for [x:T,y:=c,z:U] and [n]=2, it gives [Rel 5, Rel 3]. *)
  let nhyps ctx =
    let open Declaration in
    let rec nhyps acc = function
      | [] -&gt; acc
      | LocalAssum _ :: hyps -&gt; nhyps (succ acc) hyps
      | LocalDef _ :: hyps -&gt; nhyps acc hyps
    in
    nhyps 0 ctx

  (** Return a declaration designated by a given de Bruijn index.
      @raise Not_found if the designated de Bruijn index is not present in the designated rel-context. *)
  let rec lookup n ctx =
    match n, ctx with
    | 1, decl :: _ -&gt; decl
    | n, _ :: sign -&gt; lookup (n-1) sign
    | _, []        -&gt; raise Not_found

  (** Check whether given two rel-contexts are equal. *)
  let equal eq l = List.equal (fun c -&gt; Declaration.equal eq c) l

  (** Map all terms in a given rel-context. *)
  let map f = List.Smart.map (Declaration.map_constr f)

  (** Perform a given action on every declaration in a given rel-context. *)
  let iter f = List.iter (Declaration.iter_constr f)

  (** Reduce all terms in a given rel-context to a single value.
      Innermost declarations are processed first. *)
  let fold_inside f ~init = List.fold_left f init

  (** Reduce all terms in a given rel-context to a single value.
      Outermost declarations are processed first. *)
  let fold_outside f l ~init = List.fold_right f l init

  (** Map a given rel-context to a list where each {e local assumption} is mapped to [true]
      and each {e local definition} is mapped to [false]. *)
  let to_tags l =
    let rec aux l = function
      | [] -&gt; l
      | Declaration.LocalDef _ :: ctx -&gt; aux (true::l) ctx
      | Declaration.LocalAssum _ :: ctx -&gt; aux (false::l) ctx
    in aux [] l

  let drop_bodies l = List.Smart.map Declaration.drop_body l

  (** [extended_list n Œì] builds an instance [args] such that [Œì,Œî ‚ä¢ args:Œì]
      with n = |Œî| and with the {e local definitions} of [Œì] skipped in
      [args]. Example: for [x:T, y:=c, z:U] and [n]=2, it gives [Rel 5, Rel 3]. *)
  let to_extended_list mk n l =
    let rec reln l p = function
      | Declaration.LocalAssum _ :: hyps -&gt; reln (mk (n+p) :: l) (p+1) hyps
      | Declaration.LocalDef _ :: hyps -&gt; reln l (p+1) hyps
      | [] -&gt; l
    in
    reln [] 1 l

  (** [extended_vect n Œì] does the same, returning instead an array. *)
  let to_extended_vect mk n hyps = Array.of_list (to_extended_list mk n hyps)
end

(** This module represents contexts that can capture non-anonymous variables.
    Individual declarations are then designated by the identifiers they bind. *)
module Named =
struct
  (** Representation of {e local declarations}. *)
  module Declaration =
  struct
    (** local declaration *)
    type ('constr, 'types) pt =
      | LocalAssum of Id.t binder_annot * 'types             (** identifier, type *)
      | LocalDef of Id.t binder_annot * 'constr * 'types    (** identifier, value, type *)

    let get_annot = function
      | LocalAssum (na,_) | LocalDef (na,_,_) -&gt; na

    (** Return the identifier bound by a given declaration. *)
    let get_id x = (get_annot x).binder_name

    (** Return [Some value] for local-declarations and [None] for local-assumptions. *)
    let get_value = function
      | LocalAssum _ -&gt; None
      | LocalDef (_,v,_) -&gt; Some v

    (** Return the type of the name bound by a given declaration. *)
    let get_type = function
      | LocalAssum (_,ty)
      | LocalDef (_,_,ty) -&gt; ty

    let get_relevance x = (get_annot x).binder_relevance

    (** Set the identifier that is bound by a given declaration. *)
    let set_id id =
      let set x = {x with binder_name = id} in
      function
      | LocalAssum (x,ty) -&gt; LocalAssum (set x, ty)
      | LocalDef (x, v, ty) -&gt; LocalDef (set x, v, ty)

    (** Set the type of the bound variable in a given declaration. *)
    let set_type ty = function
      | LocalAssum (id,_) -&gt; LocalAssum (id, ty)
      | LocalDef (id,v,_) -&gt; LocalDef (id, v, ty)

    (** Return [true] iff a given declaration is a local assumption. *)
    let is_local_assum = function
      | LocalAssum _ -&gt; true
      | LocalDef _ -&gt; false

    (** Return [true] iff a given declaration is a local definition. *)
    let is_local_def = function
      | LocalDef _ -&gt; true
      | LocalAssum _ -&gt; false

    (** Check whether any term in a given declaration satisfies a given predicate. *)
    let exists f = function
      | LocalAssum (_, ty) -&gt; f ty
      | LocalDef (_, v, ty) -&gt; f v || f ty

    (** Check whether all terms in a given declaration satisfy a given predicate. *)
    let for_all f = function
      | LocalAssum (_, ty) -&gt; f ty
      | LocalDef (_, v, ty) -&gt; f v &amp;&amp; f ty

    (** Check whether the two given declarations are equal. *)
    let equal eq decl1 decl2 =
      match decl1, decl2 with
      | LocalAssum (id1, ty1), LocalAssum (id2, ty2) -&gt;
          eq_annot Id.equal id1 id2 &amp;&amp; eq ty1 ty2
      | LocalDef (id1, v1, ty1), LocalDef (id2, v2, ty2) -&gt;
          eq_annot Id.equal id1 id2 &amp;&amp; eq v1 v2 &amp;&amp; eq ty1 ty2
      | _ -&gt;
          false

    (** Map the identifier bound by a given declaration. *)
    let map_id f x =
      let id = get_id x in
      let id' = f id in
      if id == id' then x else set_id id' x

    (** For local assumptions, this function returns the original local assumptions.
        For local definitions, this function maps the value in the local definition. *)
    let map_value f = function
      | LocalAssum _ as decl -&gt; decl
      | LocalDef (na, v, t) as decl -&gt;
          let v' = f v in
          if v == v' then decl else LocalDef (na, v', t)

    (** Map the type of the name bound by a given declaration. *)
    let map_type f = function
      | LocalAssum (id, ty) as decl -&gt;
          let ty' = f ty in
          if ty == ty' then decl else LocalAssum (id, ty')
      | LocalDef (id, v, ty) as decl -&gt;
          let ty' = f ty in
          if ty == ty' then decl else LocalDef (id, v, ty')

    (** Map all terms in a given declaration. *)
    let map_constr f = function
      | LocalAssum (id, ty) as decl -&gt;
          let ty' = f ty in
          if ty == ty' then decl else LocalAssum (id, ty')
      | LocalDef (id, v, ty) as decl -&gt;
          let v' = f v in
          let ty' = f ty in
          if v == v' &amp;&amp; ty == ty' then decl else LocalDef (id, v', ty')

    (** Perform a given action on all terms in a given declaration. *)
    let iter_constr f = function
      | LocalAssum (_, ty) -&gt; f ty
      | LocalDef (_, v, ty) -&gt; f v; f ty

    (** Reduce all terms in a given declaration to a single value. *)
    let fold_constr f decl a =
      match decl with
      | LocalAssum (_, ty) -&gt; f ty a
      | LocalDef (_, v, ty) -&gt; a |&gt; f v |&gt; f ty

    let to_tuple = function
      | LocalAssum (id, ty) -&gt; id, None, ty
      | LocalDef (id, v, ty) -&gt; id, Some v, ty

    let of_tuple = function
      | id, None, ty -&gt; LocalAssum (id, ty)
      | id, Some v, ty -&gt; LocalDef (id, v, ty)

    let drop_body = function
      | LocalAssum _ as d -&gt; d
      | LocalDef (id, _v, ty) -&gt; LocalAssum (id, ty)

    let of_rel_decl f = function
      | Rel.Declaration.LocalAssum (na,t) -&gt;
          LocalAssum (map_annot f na, t)
      | Rel.Declaration.LocalDef (na,v,t) -&gt;
          LocalDef (map_annot f na, v, t)

    let to_rel_decl =
      let name x = {binder_name=Name x.binder_name;binder_relevance=x.binder_relevance} in
      function
      | LocalAssum (id,t) -&gt;
          Rel.Declaration.LocalAssum (name id, t)
      | LocalDef (id,v,t) -&gt;
          Rel.Declaration.LocalDef (name id,v,t)
  end

  (** Named-context is represented as a list of declarations.
      Inner-most declarations are at the beginning of the list.
      Outer-most declarations are at the end of the list. *)
  type ('constr, 'types) pt = ('constr, 'types) Declaration.pt list

  (** empty named-context *)
  let empty = []

  (** empty named-context *)
  let add d ctx = d :: ctx

  (** Return the number of {e local declarations} in a given named-context. *)
  let length = List.length

(** Return a declaration designated by a given identifier
    @raise Not_found if the designated identifier is not present in the designated named-context. *)
  let rec lookup id = function
    | decl :: _ when Id.equal id (Declaration.get_id decl) -&gt; decl
    | _ :: sign -&gt; lookup id sign
    | [] -&gt; raise Not_found

  (** Check whether given two named-contexts are equal. *)
  let equal eq l = List.equal (fun c -&gt; Declaration.equal eq c) l

  (** Map all terms in a given named-context. *)
  let map f = List.Smart.map (Declaration.map_constr f)

  (** Perform a given action on every declaration in a given named-context. *)
  let iter f = List.iter (Declaration.iter_constr f)

  (** Reduce all terms in a given named-context to a single value.
      Innermost declarations are processed first. *)
  let fold_inside f ~init = List.fold_left f init

  (** Reduce all terms in a given named-context to a single value.
      Outermost declarations are processed first. *)
  let fold_outside f l ~init = List.fold_right f l init

  (** Return the set of all identifiers bound in a given named-context. *)
  let to_vars l =
    List.fold_left (fun accu decl -&gt; Id.Set.add (Declaration.get_id decl) accu) Id.Set.empty l

  let drop_bodies l = List.Smart.map Declaration.drop_body l

  (** [instance_from_named_context Œ©] builds an instance [args] such
      that [Œ© ‚ä¢ args:Œ©] where [Œ©] is a named context and with the local
      definitions of [Œ©] skipped. Example: for [id1:T,id2:=c,id3:U], it
      gives [Var id1, Var id3]. All [idj] are supposed distinct. *)
  let to_instance mk l =
    let filter = function
      | Declaration.LocalAssum (id, _) -&gt; Some (mk id.binder_name)
      | _ -&gt; None
    in
    List.map_filter filter l
end

module Compacted =
  struct
    module Declaration =
      struct
        type ('constr, 'types) pt =
          | LocalAssum of Id.t binder_annot list * 'types
          | LocalDef of Id.t binder_annot list * 'constr * 'types

        let map_constr f = function
          | LocalAssum (ids, ty) as decl -&gt;
             let ty' = f ty in
             if ty == ty' then decl else LocalAssum (ids, ty')
          | LocalDef (ids, c, ty) as decl -&gt;
             let ty' = f ty in
             let c' = f c in
             if c == c' &amp;&amp; ty == ty' then decl else LocalDef (ids,c',ty')

        let of_named_decl = function
          | Named.Declaration.LocalAssum (id,t) -&gt;
              LocalAssum ([id],t)
          | Named.Declaration.LocalDef (id,v,t) -&gt;
              LocalDef ([id],v,t)

        let to_named_context = function
          | LocalAssum (ids, t) -&gt;
             List.map (fun id -&gt; Named.Declaration.LocalAssum (id,t)) ids
          | LocalDef (ids, v, t) -&gt;
             List.map (fun id -&gt; Named.Declaration.LocalDef (id,v,t)) ids
      end

    type ('constr, 'types) pt = ('constr, 'types) Declaration.pt list

    let fold f l ~init = List.fold_right f l init
  end
</pre>
          </div>
          <div class="col-md-6">
            <code>context.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Util.

Import Names.

Record binder_annot {a : Type} := {
  binder_name : a;
  binder_relevance : Sorts.relevance }.
Arguments binder_annot : clear implicits.

Definition eq_annot {A B : Type}
  (eq : A -&gt; B -&gt; bool) (function_parameter : binder_annot A)
  : (binder_annot B) -&gt; bool :=
  match function_parameter with
  | {| binder_name := na1; binder_relevance := r1 |} =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | {| binder_name := na2; binder_relevance := r2 |} =&gt;
        andb (eq na1 na2) (Sorts.relevance_equal r1 r2)
      end
  end.

Definition hash_annot {A : Type}
  (h : A -&gt; Z) (function_parameter : binder_annot A) : Z :=
  match function_parameter with
  | {| binder_name := n; binder_relevance := r |} =&gt;
    Hashset.Combine.combinesmall (Sorts.relevance_hash r) (h n)
  end.

Definition map_annot {A B : Type}
  (f : A -&gt; B) (function_parameter : binder_annot A) : binder_annot B :=
  match function_parameter with
  | {| binder_name := na; binder_relevance := binder_relevance |} =&gt;
    {| binder_name := f na; binder_relevance := binder_relevance |}
  end.

Definition make_annot {A : Type} (x : A) (r : Sorts.relevance)
  : binder_annot A := {| binder_name := x; binder_relevance := r |}.

Definition binder_name {A : Type} (x : binder_annot A) : A := binder_name x.

Definition binder_relevance {A : Type} (x : binder_annot A) : Sorts.relevance :=
  binder_relevance x.

Definition annotR {A : Type} (x : A) : binder_annot A :=
  make_annot x Sorts.Relevant.

Definition nameR (x : Names.Id.t) : binder_annot Names.name := annotR (Name x).

Definition anonR : binder_annot Names.name := annotR Anonymous.

Module Rel.
  Module Declaration.
    Inductive pt (constr types : Type) : Type :=
    | LocalAssum : (binder_annot Names.Name.t) -&gt; types -&gt; pt constr types
    | LocalDef : (binder_annot Names.Name.t) -&gt; constr -&gt; types -&gt;
      pt constr types.
    
    Arguments LocalAssum {_ _}.
    Arguments LocalDef {_ _}.
    
    Definition get_annot {A B : Type} (function_parameter : pt A B)
      : binder_annot Names.Name.t :=
      match function_parameter with
      | LocalAssum na _ | LocalDef na _ _ =&gt; na
      end.
    
    Definition get_name {A B : Type} (x : pt A B) : Names.Name.t :=
      binder_name (get_annot x).
    
    Definition get_value {A B : Type} (function_parameter : pt A B)
      : option A :=
      match function_parameter with
      | LocalAssum _ _ =&gt; None
      | LocalDef _ v _ =&gt; Some v
      end.
    
    Definition get_type {A B : Type} (function_parameter : pt A B) : B :=
      match function_parameter with
      | LocalAssum _ ty | LocalDef _ _ ty =&gt; ty
      end.
    
    Definition get_relevance {A B : Type} (x : pt A B) : Sorts.relevance :=
      binder_relevance (get_annot x).
    
    Definition set_name {A B : Type}
      (na : Names.Name.t) (function_parameter : pt A B) : pt A B :=
      match function_parameter with
      | LocalAssum x ty =&gt; LocalAssum record ty
      | LocalDef x v ty =&gt; LocalDef record v ty
      end.
    
    Definition set_type {A B C : Type} (ty : A) (function_parameter : pt B C)
      : pt B A :=
      match function_parameter with
      | LocalAssum na _ =&gt; LocalAssum na ty
      | LocalDef na v _ =&gt; LocalDef na v ty
      end.
    
    Definition is_local_assum {A B : Type} (function_parameter : pt A B)
      : bool :=
      match function_parameter with
      | LocalAssum _ _ =&gt; true
      | LocalDef _ _ _ =&gt; false
      end.
    
    Definition is_local_def {A B : Type} (function_parameter : pt A B) : bool :=
      match function_parameter with
      | LocalAssum _ _ =&gt; false
      | LocalDef _ _ _ =&gt; true
      end.
    
    Definition _exists {A : Type} (f : A -&gt; bool) (function_parameter : pt A A)
      : bool :=
      match function_parameter with
      | LocalAssum _ ty =&gt; f ty
      | LocalDef _ v ty =&gt; orb (f v) (f ty)
      end.
    
    Definition for_all {A : Type} (f : A -&gt; bool) (function_parameter : pt A A)
      : bool :=
      match function_parameter with
      | LocalAssum _ ty =&gt; f ty
      | LocalDef _ v ty =&gt; andb (f v) (f ty)
      end.
    
    Definition equal {A B : Type}
      (eq : A -&gt; B -&gt; bool) (decl1 : pt A A) (decl2 : pt B B) : bool :=
      match (decl1, decl2) with
      | (LocalAssum n1 ty1, LocalAssum n2 ty2) =&gt;
        andb (eq_annot Names.Name.equal n1 n2) (eq ty1 ty2)
      | (LocalDef n1 v1 ty1, LocalDef n2 v2 ty2) =&gt;
        andb (eq_annot Names.Name.equal n1 n2) (andb (eq v1 v2) (eq ty1 ty2))
      | _ =&gt; false
      end.
    
    Definition map_name {A B : Type}
      (f : Names.Name.t -&gt; Names.Name.t) (x : pt A B) : pt A B :=
      let na := get_name x in
      let na' := f na in
      if Stdlib.op_eq_eq na na' then
        x
      else
        set_name na' x.
    
    Definition map_value {A B : Type} (f : A -&gt; A) (function_parameter : pt A B)
      : pt A B :=
      match function_parameter with
      | (LocalAssum _ _) as decl =&gt; decl
      | (LocalDef na v t) as decl =&gt;
        let v' := f v in
        if Stdlib.op_eq_eq v v' then
          decl
        else
          LocalDef na v' t
      end.
    
    Definition map_type {A B : Type} (f : A -&gt; A) (function_parameter : pt B A)
      : pt B A :=
      match function_parameter with
      | (LocalAssum na ty) as decl =&gt;
        let ty' := f ty in
        if Stdlib.op_eq_eq ty ty' then
          decl
        else
          LocalAssum na ty'
      | (LocalDef na v ty) as decl =&gt;
        let ty' := f ty in
        if Stdlib.op_eq_eq ty ty' then
          decl
        else
          LocalDef na v ty'
      end.
    
    Definition map_constr {A : Type} (f : A -&gt; A) (function_parameter : pt A A)
      : pt A A :=
      match function_parameter with
      | (LocalAssum na ty) as decl =&gt;
        let ty' := f ty in
        if Stdlib.op_eq_eq ty ty' then
          decl
        else
          LocalAssum na ty'
      | (LocalDef na v ty) as decl =&gt;
        let v' := f v in
        let ty' := f ty in
        if andb (Stdlib.op_eq_eq v v') (Stdlib.op_eq_eq ty ty') then
          decl
        else
          LocalDef na v' ty'
      end.
    
    Definition map_constr_het {A B : Type}
      (f : A -&gt; B) (function_parameter : pt A A) : pt B B :=
      match function_parameter with
      | LocalAssum na ty =&gt;
        let ty' := f ty in
        LocalAssum na ty'
      | LocalDef na v ty =&gt;
        let v' := f v in
        let ty' := f ty in
        LocalDef na v' ty'
      end.
    
    Definition iter_constr {A : Type}
      (f : A -&gt; unit) (function_parameter : pt A A) : unit :=
      match function_parameter with
      | LocalAssum _ ty =&gt; f ty
      | LocalDef _ v ty =&gt;
        f v;
        f ty
      end.
    
    Definition fold_constr {A B : Type}
      (f : A -&gt; B -&gt; B) (decl : pt A A) (acc : B) : B :=
      match decl with
      | LocalAssum _n ty =&gt; f ty acc
      | LocalDef _n v ty =&gt; f ty (f v acc)
      end.
    
    Definition to_tuple {A B : Type} (function_parameter : pt A B)
      : (binder_annot Names.Name.t) * (option A) * B :=
      match function_parameter with
      | LocalAssum na ty =&gt; (na, None, ty)
      | LocalDef na v ty =&gt; (na, (Some v), ty)
      end.
    
    Definition drop_body {A B C : Type} (function_parameter : pt A B)
      : pt C B :=
      match function_parameter with
      | (LocalAssum _ _) as d =&gt; d
      | LocalDef na _v ty =&gt; LocalAssum na ty
      end.
  End Declaration.
  
  Definition pt (constr types : Type) := list (Declaration.pt constr types).
  
  Definition empty {A : Type} : list A := [].
  
  Definition add {A : Type} (d : A) (ctx : list A) : list A := cons d ctx.
  
  Definition length {A : Type} : (list A) -&gt; Z := Util.List.(CList.ExtS.length).
  
  Definition nhyps {A B : Type} (ctx : list (Declaration.pt A B)) : Z :=
    let fix nhyps {C D : Type}
      (acc : Z) (function_parameter : list (Declaration.pt C D)) : Z :=
      match function_parameter with
      | [] =&gt; acc
      | cons (LocalAssum _ _) hyps =&gt; nhyps (Z.succ acc) hyps
      | cons (LocalDef _ _ _) hyps =&gt; nhyps acc hyps
      end in
    nhyps 0 ctx.
  
  Fixpoint lookup {A : Type} (n : Z) (ctx : list A) : A :=
    match (n, ctx) with
    | (1, cons decl _) =&gt; decl
    | (n, cons _ sign) =&gt; lookup (Util.op_minus n 1) sign
    | (_, []) =&gt; Stdlib.raise OCaml.Not_found
    end.
  
  Definition equal {A : Type}
    (eq : A -&gt; A -&gt; bool) (l : list (Declaration.pt A A))
    : (list (Declaration.pt A A)) -&gt; bool :=
    Util.List.(CList.ExtS.equal) (fun c =&gt; Declaration.equal eq c) l.
  
  Definition map {A : Type} (f : A -&gt; A)
    : (list (Declaration.pt A A)) -&gt; list (Declaration.pt A A) :=
    Util.List.Smart.map (Declaration.map_constr f).
  
  Definition iter {A : Type} (f : A -&gt; unit)
    : (list (Declaration.pt A A)) -&gt; unit :=
    Util.List.(CList.ExtS.iter) (Declaration.iter_constr f).
  
  Definition fold_inside {A B : Type} (f : A -&gt; B -&gt; A) (init : A)
    : (list B) -&gt; A := Util.List.(CList.ExtS.fold_left) f init.
  
  Definition fold_outside {A B : Type} (f : A -&gt; B -&gt; B) (l : list A) (init : B)
    : B := Util.List.(CList.ExtS.fold_right) f l init.
  
  Definition to_tags {A B : Type} (l : list (Declaration.pt A B)) : list bool :=
    let fix aux {C D : Type}
      (l : list bool) (function_parameter : list (Declaration.pt C D))
      : list bool :=
      match function_parameter with
      | [] =&gt; l
      | cons (Declaration.LocalDef _ _ _) ctx =&gt; aux (cons true l) ctx
      | cons (Declaration.LocalAssum _ _) ctx =&gt; aux (cons false l) ctx
      end in
    aux [] l.
  
  Definition drop_bodies {A B : Type} (l : list (Declaration.pt A B))
    : list (Declaration.pt A B) := Util.List.Smart.map Declaration.drop_body l.
  
  Definition to_extended_list {A B C : Type}
    (mk : Z -&gt; A) (n : Z) (l : list (Declaration.pt B C)) : list A :=
    let fix reln {D E : Type}
      (l : list A) (p : Z) (function_parameter : list (Declaration.pt D E))
      : list A :=
      match function_parameter with
      | cons (Declaration.LocalAssum _ _) hyps =&gt;
        reln (cons (mk (Util.op_plus n p)) l) (Util.op_plus p 1) hyps
      | cons (Declaration.LocalDef _ _ _) hyps =&gt; reln l (Util.op_plus p 1) hyps
      | [] =&gt; l
      end in
    reln [] 1 l.
  
  Definition to_extended_vect {A B C : Type}
    (mk : Z -&gt; A) (n : Z) (hyps : list (Declaration.pt B C)) : array A :=
    Util.Array.(CArray.ExtS.of_list) (to_extended_list mk n hyps).
End Rel.

Module Named.
  Module Declaration.
    Inductive pt (constr types : Type) : Type :=
    | LocalAssum : (binder_annot Names.Id.t) -&gt; types -&gt; pt constr types
    | LocalDef : (binder_annot Names.Id.t) -&gt; constr -&gt; types -&gt; pt constr types.
    
    Arguments LocalAssum {_ _}.
    Arguments LocalDef {_ _}.
    
    Definition get_annot {A B : Type} (function_parameter : pt A B)
      : binder_annot Names.Id.t :=
      match function_parameter with
      | LocalAssum na _ | LocalDef na _ _ =&gt; na
      end.
    
    Definition get_id {A B : Type} (x : pt A B) : Names.Id.t :=
      binder_name (get_annot x).
    
    Definition get_value {A B : Type} (function_parameter : pt A B)
      : option A :=
      match function_parameter with
      | LocalAssum _ _ =&gt; None
      | LocalDef _ v _ =&gt; Some v
      end.
    
    Definition get_type {A B : Type} (function_parameter : pt A B) : B :=
      match function_parameter with
      | LocalAssum _ ty | LocalDef _ _ ty =&gt; ty
      end.
    
    Definition get_relevance {A B : Type} (x : pt A B) : Sorts.relevance :=
      binder_relevance (get_annot x).
    
    Definition set_id {A B : Type} (id : Names.Id.t) : (pt A B) -&gt; pt A B :=
      let set {C : Type} (x : binder_annot C) : binder_annot Names.Id.t :=
        record in
      fun function_parameter =&gt;
        match function_parameter with
        | LocalAssum x ty =&gt; LocalAssum (set x) ty
        | LocalDef x v ty =&gt; LocalDef (set x) v ty
        end.
    
    Definition set_type {A B C : Type} (ty : A) (function_parameter : pt B C)
      : pt B A :=
      match function_parameter with
      | LocalAssum id _ =&gt; LocalAssum id ty
      | LocalDef id v _ =&gt; LocalDef id v ty
      end.
    
    Definition is_local_assum {A B : Type} (function_parameter : pt A B)
      : bool :=
      match function_parameter with
      | LocalAssum _ _ =&gt; true
      | LocalDef _ _ _ =&gt; false
      end.
    
    Definition is_local_def {A B : Type} (function_parameter : pt A B) : bool :=
      match function_parameter with
      | LocalDef _ _ _ =&gt; true
      | LocalAssum _ _ =&gt; false
      end.
    
    Definition _exists {A : Type} (f : A -&gt; bool) (function_parameter : pt A A)
      : bool :=
      match function_parameter with
      | LocalAssum _ ty =&gt; f ty
      | LocalDef _ v ty =&gt; orb (f v) (f ty)
      end.
    
    Definition for_all {A : Type} (f : A -&gt; bool) (function_parameter : pt A A)
      : bool :=
      match function_parameter with
      | LocalAssum _ ty =&gt; f ty
      | LocalDef _ v ty =&gt; andb (f v) (f ty)
      end.
    
    Definition equal {A B : Type}
      (eq : A -&gt; B -&gt; bool) (decl1 : pt A A) (decl2 : pt B B) : bool :=
      match (decl1, decl2) with
      | (LocalAssum id1 ty1, LocalAssum id2 ty2) =&gt;
        andb (eq_annot Names.Id.equal id1 id2) (eq ty1 ty2)
      | (LocalDef id1 v1 ty1, LocalDef id2 v2 ty2) =&gt;
        andb (eq_annot Names.Id.equal id1 id2) (andb (eq v1 v2) (eq ty1 ty2))
      | _ =&gt; false
      end.
    
    Definition map_id {A B : Type} (f : Names.Id.t -&gt; Names.Id.t) (x : pt A B)
      : pt A B :=
      let id := get_id x in
      let id' := f id in
      if Stdlib.op_eq_eq id id' then
        x
      else
        set_id id' x.
    
    Definition map_value {A B : Type} (f : A -&gt; A) (function_parameter : pt A B)
      : pt A B :=
      match function_parameter with
      | (LocalAssum _ _) as decl =&gt; decl
      | (LocalDef na v t) as decl =&gt;
        let v' := f v in
        if Stdlib.op_eq_eq v v' then
          decl
        else
          LocalDef na v' t
      end.
    
    Definition map_type {A B : Type} (f : A -&gt; A) (function_parameter : pt B A)
      : pt B A :=
      match function_parameter with
      | (LocalAssum id ty) as decl =&gt;
        let ty' := f ty in
        if Stdlib.op_eq_eq ty ty' then
          decl
        else
          LocalAssum id ty'
      | (LocalDef id v ty) as decl =&gt;
        let ty' := f ty in
        if Stdlib.op_eq_eq ty ty' then
          decl
        else
          LocalDef id v ty'
      end.
    
    Definition map_constr {A : Type} (f : A -&gt; A) (function_parameter : pt A A)
      : pt A A :=
      match function_parameter with
      | (LocalAssum id ty) as decl =&gt;
        let ty' := f ty in
        if Stdlib.op_eq_eq ty ty' then
          decl
        else
          LocalAssum id ty'
      | (LocalDef id v ty) as decl =&gt;
        let v' := f v in
        let ty' := f ty in
        if andb (Stdlib.op_eq_eq v v') (Stdlib.op_eq_eq ty ty') then
          decl
        else
          LocalDef id v' ty'
      end.
    
    Definition iter_constr {A : Type}
      (f : A -&gt; unit) (function_parameter : pt A A) : unit :=
      match function_parameter with
      | LocalAssum _ ty =&gt; f ty
      | LocalDef _ v ty =&gt;
        f v;
        f ty
      end.
    
    Definition fold_constr {A B : Type}
      (f : A -&gt; B -&gt; B) (decl : pt A A) (a : B) : B :=
      match decl with
      | LocalAssum _ ty =&gt; f ty a
      | LocalDef _ v ty =&gt;
        OCaml.Stdlib.reverse_apply (OCaml.Stdlib.reverse_apply a (f v)) (f ty)
      end.
    
    Definition to_tuple {A B : Type} (function_parameter : pt A B)
      : (binder_annot Names.Id.t) * (option A) * B :=
      match function_parameter with
      | LocalAssum id ty =&gt; (id, None, ty)
      | LocalDef id v ty =&gt; (id, (Some v), ty)
      end.
    
    Definition of_tuple {A B : Type}
      (function_parameter : (binder_annot Names.Id.t) * (option A) * B)
      : pt A B :=
      match function_parameter with
      | (id, None, ty) =&gt; LocalAssum id ty
      | (id, Some v, ty) =&gt; LocalDef id v ty
      end.
    
    Definition drop_body {A B C : Type} (function_parameter : pt A B)
      : pt C B :=
      match function_parameter with
      | (LocalAssum _ _) as d =&gt; d
      | LocalDef id _v ty =&gt; LocalAssum id ty
      end.
    
    Definition of_rel_decl {A B : Type}
      (f : Names.Name.t -&gt; Names.Id.t)
      (function_parameter : Rel.Declaration.pt A B) : pt A B :=
      match function_parameter with
      | Rel.Declaration.LocalAssum na t =&gt; LocalAssum (map_annot f na) t
      | Rel.Declaration.LocalDef na v t =&gt; LocalDef (map_annot f na) v t
      end.
    
    Definition to_rel_decl {A B : Type} : (pt A B) -&gt; Rel.Declaration.pt A B :=
      let name (x : binder_annot Names.Id.t) : binder_annot Names.name :=
        {| binder_name := Name (binder_name x);
          binder_relevance := binder_relevance x |} in
      fun function_parameter =&gt;
        match function_parameter with
        | LocalAssum id t =&gt; Rel.Declaration.LocalAssum (name id) t
        | LocalDef id v t =&gt; Rel.Declaration.LocalDef (name id) v t
        end.
  End Declaration.
  
  Definition pt (constr types : Type) := list (Declaration.pt constr types).
  
  Definition empty {A : Type} : list A := [].
  
  Definition add {A : Type} (d : A) (ctx : list A) : list A := cons d ctx.
  
  Definition length {A : Type} : (list A) -&gt; Z := Util.List.(CList.ExtS.length).
  
  Fixpoint lookup {A B : Type}
    (id : Names.Id.t) (function_parameter : list (Declaration.pt A B))
    : Declaration.pt A B :=
    match function_parameter with
    | cons decl _ =&gt; decl
    | cons _ sign =&gt; lookup id sign
    | [] =&gt; Stdlib.raise OCaml.Not_found
    end.
  
  Definition equal {A : Type}
    (eq : A -&gt; A -&gt; bool) (l : list (Declaration.pt A A))
    : (list (Declaration.pt A A)) -&gt; bool :=
    Util.List.(CList.ExtS.equal) (fun c =&gt; Declaration.equal eq c) l.
  
  Definition map {A : Type} (f : A -&gt; A)
    : (list (Declaration.pt A A)) -&gt; list (Declaration.pt A A) :=
    Util.List.Smart.map (Declaration.map_constr f).
  
  Definition iter {A : Type} (f : A -&gt; unit)
    : (list (Declaration.pt A A)) -&gt; unit :=
    Util.List.(CList.ExtS.iter) (Declaration.iter_constr f).
  
  Definition fold_inside {A B : Type} (f : A -&gt; B -&gt; A) (init : A)
    : (list B) -&gt; A := Util.List.(CList.ExtS.fold_left) f init.
  
  Definition fold_outside {A B : Type} (f : A -&gt; B -&gt; B) (l : list A) (init : B)
    : B := Util.List.(CList.ExtS.fold_right) f l init.
  
  Definition to_vars {A B : Type} (l : list (Declaration.pt A B))
    : Names.Id.Set.t :=
    Util.List.(CList.ExtS.fold_left)
      (fun accu =&gt; fun decl =&gt; Names.Id.Set.add (Declaration.get_id decl) accu)
      Names.Id.Set.empty l.
  
  Definition drop_bodies {A B : Type} (l : list (Declaration.pt A B))
    : list (Declaration.pt A B) := Util.List.Smart.map Declaration.drop_body l.
  
  Definition to_instance {A B C : Type}
    (mk : Names.Id.t -&gt; A) (l : list (Declaration.pt B C)) : list A :=
    let filter {D E : Type} (function_parameter : Declaration.pt D E)
      : option A :=
      match function_parameter with
      | Declaration.LocalAssum id _ =&gt; Some (mk (binder_name id))
      | _ =&gt; None
      end in
    Util.List.(CList.ExtS.map_filter) filter l.
End Named.

Module Compacted.
  Module Declaration.
    Inductive pt (constr types : Type) : Type :=
    | LocalAssum : (list (binder_annot Names.Id.t)) -&gt; types -&gt; pt constr types
    | LocalDef : (list (binder_annot Names.Id.t)) -&gt; constr -&gt; types -&gt;
      pt constr types.
    
    Arguments LocalAssum {_ _}.
    Arguments LocalDef {_ _}.
    
    Definition map_constr {A : Type} (f : A -&gt; A) (function_parameter : pt A A)
      : pt A A :=
      match function_parameter with
      | (LocalAssum ids ty) as decl =&gt;
        let ty' := f ty in
        if Stdlib.op_eq_eq ty ty' then
          decl
        else
          LocalAssum ids ty'
      | (LocalDef ids c ty) as decl =&gt;
        let ty' := f ty in
        let c' := f c in
        if andb (Stdlib.op_eq_eq c c') (Stdlib.op_eq_eq ty ty') then
          decl
        else
          LocalDef ids c' ty'
      end.
    
    Definition of_named_decl {A B : Type}
      (function_parameter : Named.Declaration.pt A B) : pt A B :=
      match function_parameter with
      | Named.Declaration.LocalAssum id t =&gt; LocalAssum (cons id []) t
      | Named.Declaration.LocalDef id v t =&gt; LocalDef (cons id []) v t
      end.
    
    Definition to_named_context {A B : Type} (function_parameter : pt A B)
      : list (Named.Declaration.pt A B) :=
      match function_parameter with
      | LocalAssum ids t =&gt;
        Util.List.(CList.ExtS.map) (fun id =&gt; Named.Declaration.LocalAssum id t)
          ids
      | LocalDef ids v t =&gt;
        Util.List.(CList.ExtS.map) (fun id =&gt; Named.Declaration.LocalDef id v t)
          ids
      end.
  End Declaration.
  
  Definition pt (constr types : Type) := list (Declaration.pt constr types).
  
  Definition fold {A B : Type} (f : A -&gt; B -&gt; B) (l : list A) (init : B) : B :=
    Util.List.(CList.ExtS.fold_right) f l init.
End Compacted.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="conv_oracle" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>conv_oracle.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Bruno Barras as part of the rewriting of the conversion
   algorithm, Nov 2001 *)

open Names

(* Priority for the expansion of constant in the conversion test.
 * Higher levels means that the expansion is less prioritary.
 * (And Expand stands for -oo, and Opaque +oo.)
 * The default value is [Level 100].
 *)
type level = Expand | Level of int | Opaque
let default = Level 0
let is_default = function
| Level 0 -&gt; true
| _ -&gt; false
let transparent = default
let is_transparent = function
| Level 0 -&gt; true
| _ -&gt; false

type oracle = {
  var_opacity : level Id.Map.t;
  cst_opacity : level Cmap.t;
  var_trstate : Id.Pred.t;
  cst_trstate : Cpred.t;
}

let empty = {
  var_opacity = Id.Map.empty;
  cst_opacity = Cmap.empty;
  var_trstate = Id.Pred.full;
  cst_trstate = Cpred.full;
}

let get_strategy { var_opacity; cst_opacity; _ } f = function
  | VarKey id -&gt;
      (try Id.Map.find id var_opacity
      with Not_found -&gt; default)
  | ConstKey c -&gt;
      (try Cmap.find (f c) cst_opacity
      with Not_found -&gt; default)
  | RelKey _ -&gt; Expand

let set_strategy ({ var_opacity; cst_opacity; _ } as oracle) k l =
  match k with
  | VarKey id -&gt;
    let var_opacity =
      if is_default l then Id.Map.remove id var_opacity
      else Id.Map.add id l var_opacity
    in
    let var_trstate = match l with
    | Opaque -&gt; Id.Pred.remove id oracle.var_trstate
    | _ -&gt; Id.Pred.add id oracle.var_trstate
    in
    { oracle with var_opacity; var_trstate; }
  | ConstKey c -&gt;
    let cst_opacity =
      if is_default l then Cmap.remove c cst_opacity
      else Cmap.add c l cst_opacity
    in
    let cst_trstate = match l with
    | Opaque -&gt; Cpred.remove c oracle.cst_trstate
    | _ -&gt; Cpred.add c oracle.cst_trstate
    in
    { oracle with cst_opacity; cst_trstate; }
  | RelKey _ -&gt; CErrors.user_err Pp.(str &quot;set_strategy: RelKey&quot;)

let fold_strategy f { var_opacity; cst_opacity; _ } accu =
  let fvar id lvl accu = f (VarKey id) lvl accu in
  let fcst cst lvl accu = f (ConstKey cst) lvl accu in
  let accu = Id.Map.fold fvar var_opacity accu in
  Cmap.fold fcst cst_opacity accu

let get_transp_state { var_trstate; cst_trstate; _ } =
  { TransparentState.tr_var = var_trstate; tr_cst = cst_trstate }

let dep_order l2r k1 k2 = match k1, k2 with
| RelKey _, RelKey _ -&gt; l2r
| RelKey _, (VarKey _ | ConstKey _) -&gt; true
| VarKey _, RelKey _ -&gt; false
| VarKey _, VarKey _ -&gt; l2r
| VarKey _, ConstKey _ -&gt; true
| ConstKey _, (RelKey _ | VarKey _) -&gt; false
| ConstKey _, ConstKey _ -&gt; l2r

(* Unfold the first constant only if it is &quot;more transparent&quot; than the
   second one. In case of tie, use the recommended default. *)
let oracle_order f o l2r k1 k2 =
  match get_strategy o f k1, get_strategy o f k2 with
  | Expand, Expand -&gt; dep_order l2r k1 k2
  | Expand, (Opaque | Level _) -&gt; true
  | (Opaque | Level _), Expand -&gt; false
  | Opaque, Opaque -&gt; dep_order l2r k1 k2
  | Level _, Opaque -&gt; true
  | Opaque, Level _ -&gt; false
  | Level n1, Level n2 -&gt;
     if Int.equal n1 n2 then dep_order l2r k1 k2
     else n1 &lt; n2

let get_strategy o = get_strategy o (fun x -&gt; x)
</pre>
          </div>
          <div class="col-md-6">
            <code>conv_oracle.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Names.

Inductive level : Type :=
| Expand : level
| Level : Z -&gt; level
| Opaque : level.

Definition default : level := Level 0.

Definition is_default (function_parameter : level) : bool :=
  match function_parameter with
  | Level 0 =&gt; true
  | _ =&gt; false
  end.

Definition transparent : level := default.

Definition is_transparent (function_parameter : level) : bool :=
  match function_parameter with
  | Level 0 =&gt; true
  | _ =&gt; false
  end.

Record oracle := {
  var_opacity : Names.Id.Map.t level;
  cst_opacity : Names.Cmap.t level;
  var_trstate : Names.Id.Pred.t;
  cst_trstate : Names.Cpred.t }.

Definition empty : oracle :=
  {| var_opacity := Names.Id.Map.empty; cst_opacity := Names.Cmap.empty;
    var_trstate := Names.Id.Pred.full; cst_trstate := Names.Cpred.full |}.

Definition get_strategy {A : Type} (function_parameter : oracle)
  : (A -&gt; Names.Cmap.key) -&gt; (Names.tableKey A) -&gt; level :=
  match function_parameter with
  | {| var_opacity := var_opacity; cst_opacity := cst_opacity |} =&gt;
    fun f =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | VarKey id =&gt; try
        | ConstKey c =&gt; try
        | RelKey _ =&gt; Expand
        end
  end.

Definition set_strategy (function_parameter : oracle)
  : (Names.tableKey Names.Cmap.key) -&gt; level -&gt; oracle :=
  match function_parameter with
  | {| var_opacity := var_opacity; cst_opacity := cst_opacity |} as oracle =&gt;
    fun k =&gt;
      fun l =&gt;
        match k with
        | VarKey id =&gt;
          let var_opacity :=
            if is_default l then
              Names.Id.Map.remove id var_opacity
            else
              Names.Id.Map.add id l var_opacity in
          let var_trstate :=
            match l with
            | Opaque =&gt; Names.Id.Pred.remove id (var_trstate oracle)
            | _ =&gt; Names.Id.Pred.add id (var_trstate oracle)
            end in
          record
        | ConstKey c =&gt;
          let cst_opacity :=
            if is_default l then
              Names.Cmap.remove c cst_opacity
            else
              Names.Cmap.add c l cst_opacity in
          let cst_trstate :=
            match l with
            | Opaque =&gt; Names.Cpred.remove c (cst_trstate oracle)
            | _ =&gt; Names.Cpred.add c (cst_trstate oracle)
            end in
          record
        | RelKey _ =&gt;
          CErrors.user_err None None (Pp.str &quot;set_strategy: RelKey&quot; % string)
        end
  end.

Definition fold_strategy {A : Type}
  (f : (Names.tableKey Names.Cmap.key) -&gt; level -&gt; A -&gt; A)
  (function_parameter : oracle) : A -&gt; A :=
  match function_parameter with
  | {| var_opacity := var_opacity; cst_opacity := cst_opacity |} =&gt;
    fun accu =&gt;
      let fvar (id : Names.Id.t) (lvl : level) (accu : A) : A :=
        f (VarKey id) lvl accu in
      let fcst (cst : Names.Cmap.key) (lvl : level) (accu : A) : A :=
        f (ConstKey cst) lvl accu in
      let accu := Names.Id.Map.fold fvar var_opacity accu in
      Names.Cmap.fold fcst cst_opacity accu
  end.

Definition get_transp_state (function_parameter : oracle)
  : TransparentState.t :=
  match function_parameter with
  | {| var_trstate := var_trstate; cst_trstate := cst_trstate |} =&gt;
    {| TransparentState.tr_var := var_trstate;
      TransparentState.tr_cst := cst_trstate |}
  end.

Definition dep_order {A B : Type}
  (l2r : bool) (k1 : Names.tableKey A) (k2 : Names.tableKey B) : bool :=
  match (k1, k2) with
  | (RelKey _, RelKey _) =&gt; l2r
  | (RelKey _, VarKey _ | ConstKey _) =&gt; true
  | (VarKey _, RelKey _) =&gt; false
  | (VarKey _, VarKey _) =&gt; l2r
  | (VarKey _, ConstKey _) =&gt; true
  | (ConstKey _, RelKey _ | VarKey _) =&gt; false
  | (ConstKey _, ConstKey _) =&gt; l2r
  end.

Definition oracle_order {A : Type}
  (f : A -&gt; Names.Cmap.key) (o : oracle) (l2r : bool) (k1 : Names.tableKey A)
  (k2 : Names.tableKey A) : bool :=
  match ((get_strategy o f k1), (get_strategy o f k2)) with
  | (Expand, Expand) =&gt; dep_order l2r k1 k2
  | (Expand, Opaque | Level _) =&gt; true
  | (Opaque | Level _, Expand) =&gt; false
  | (Opaque, Opaque) =&gt; dep_order l2r k1 k2
  | (Level _, Opaque) =&gt; true
  | (Opaque, Level _) =&gt; false
  | (Level n1, Level n2) =&gt;
    if Int.equal n1 n2 then
      dep_order l2r k1 k2
    else
      OCaml.Stdlib.lt n1 n2
  end.

Definition get_strategy (o : oracle)
  : (Names.tableKey Names.Cmap.key) -&gt; level := get_strategy o (fun x =&gt; x).</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="cooking" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>cooking.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Jean-Christophe Filli√¢tre out of V6.3 file constants.ml
   as part of the rebuilding of Coq around a purely functional
   abstract type-checker, Nov 1999 *)

(* This module implements kernel-level discharching of local
   declarations over global constants and inductive types *)

open Util
open Names
open Term
open Constr
open Declarations
open Univ
open Context

module NamedDecl = Context.Named.Declaration
module RelDecl = Context.Rel.Declaration

(*s Cooking the constants. *)

type my_global_reference =
  | ConstRef of Constant.t
  | IndRef of inductive
  | ConstructRef of constructor

module RefHash =
struct
  type t = my_global_reference
  let equal gr1 gr2 = match gr1, gr2 with
  | ConstRef c1, ConstRef c2 -&gt; Constant.SyntacticOrd.equal c1 c2
  | IndRef i1, IndRef i2 -&gt; eq_syntactic_ind i1 i2
  | ConstructRef c1, ConstructRef c2 -&gt; eq_syntactic_constructor c1 c2
  | _ -&gt; false
  open Hashset.Combine
  let hash = function
  | ConstRef c -&gt; combinesmall 1 (Constant.SyntacticOrd.hash c)
  | IndRef i -&gt; combinesmall 2 (ind_syntactic_hash i)
  | ConstructRef c -&gt; combinesmall 3 (constructor_syntactic_hash c)
end

module RefTable = Hashtbl.Make(RefHash)

let instantiate_my_gr gr u =
  match gr with
  | ConstRef c -&gt; mkConstU (c, u)
  | IndRef i -&gt; mkIndU (i, u)
  | ConstructRef c -&gt; mkConstructU (c, u)

let share cache r (cstl,knl) =
  try RefTable.find cache r
  with Not_found -&gt;
  let (u,l) =
    match r with
    | IndRef (kn,_i) -&gt;
        Mindmap.find kn knl
    | ConstructRef ((kn,_i),_j) -&gt;
        Mindmap.find kn knl
    | ConstRef cst -&gt;
        Cmap.find cst cstl in
  let c = (u, Array.map mkVar l) in
  RefTable.add cache r c;
  c

let share_univs cache r u l =
  let (u', args) = share cache r l in
    mkApp (instantiate_my_gr r (Instance.append u' u), args)

let update_case_info cache ci modlist =
  try
    let (_u,l) = share cache (IndRef ci.ci_ind) modlist in
    { ci with ci_npar = ci.ci_npar + Array.length l }
  with Not_found -&gt;
    ci

let is_empty_modlist (cm, mm) =
  Cmap.is_empty cm &amp;&amp; Mindmap.is_empty mm

let expmod_constr cache modlist c =
  let share_univs = share_univs cache in
  let update_case_info = update_case_info cache in
  let rec substrec c =
    match kind c with
      | Case (ci,p,t,br) -&gt;
	  Constr.map substrec (mkCase (update_case_info ci modlist,p,t,br))

      | Ind (ind,u) -&gt;
	  (try
	    share_univs (IndRef ind) u modlist
	   with
	    | Not_found -&gt; Constr.map substrec c)

      | Construct (cstr,u) -&gt;
	  (try
	     share_univs (ConstructRef cstr) u modlist
	   with
	    | Not_found -&gt; Constr.map substrec c)

      | Const (cst,u) -&gt;
	  (try
	    share_univs (ConstRef cst) u modlist
	   with
	    | Not_found -&gt; Constr.map substrec c)

      | Proj (p, c') -&gt;
        let map cst npars =
          let _, newpars = Mindmap.find cst (snd modlist) in
          (cst, npars + Array.length newpars)
        in
        let p' = try Projection.map_npars map p with Not_found -&gt; p in
        let c'' = substrec c' in
        if p == p' &amp;&amp; c' == c'' then c else mkProj (p', c'')

  | _ -&gt; Constr.map substrec c

  in
  if is_empty_modlist modlist then c
  else substrec c

(** Transforms a named context into a rel context. Also returns the list of
    variables [id1 ... idn] that need to be replaced by [Rel 1 ... Rel n] to
    abstract a term that lived in that context. *)
let abstract_context hyps =
  let fold decl (ctx, subst) =
    let id, decl = match decl with
    | NamedDecl.LocalDef (id, b, t) -&gt;
      let b = Vars.subst_vars subst b in
      let t = Vars.subst_vars subst t in
      id, RelDecl.LocalDef (map_annot Name.mk_name id, b, t)
    | NamedDecl.LocalAssum (id, t) -&gt;
      let t = Vars.subst_vars subst t in
      id, RelDecl.LocalAssum (map_annot Name.mk_name id, t)
    in
    (decl :: ctx, id.binder_name :: subst)
  in
  Context.Named.fold_outside fold hyps ~init:([], [])

let abstract_constant_type t (hyps, subst) =
  let t = Vars.subst_vars subst t in
  List.fold_left (fun c d -&gt; mkProd_wo_LetIn d c) t hyps

let abstract_constant_body c (hyps, subst) =
  let c = Vars.subst_vars subst c in
  it_mkLambda_or_LetIn c hyps

type recipe = { from : Opaqueproof.opaque constant_body; info : Opaqueproof.cooking_info }
type inline = bool

type 'opaque result = {
  cook_body : (constr Mod_subst.substituted, 'opaque) constant_def;
  cook_type : types;
  cook_universes : universes;
  cook_relevance : Sorts.relevance;
  cook_inline : inline;
  cook_context : Id.Set.t option;
}

let expmod_constr_subst cache modlist subst c =
  let subst = Univ.make_instance_subst subst in
  let c = expmod_constr cache modlist c in
    Vars.subst_univs_level_constr subst c

let discharge_abstract_universe_context subst abs_ctx auctx =
  (** Given a named instance [subst := u‚ÇÄ ... u‚Çô‚Çã‚ÇÅ] together with an abstract
      context [auctx0 := 0 ... n - 1 |= C{0, ..., n - 1}] of the same length,
      and another abstract context relative to the former context
      [auctx := 0 ... m - 1 |= C'{u‚ÇÄ, ..., u‚Çô‚Çã‚ÇÅ, 0, ..., m - 1}],
      construct the lifted abstract universe context
      [0 ... n - 1 n ... n + m - 1 |=
        C{0, ... n - 1} ‚à™
        C'{0, ..., n - 1, n, ..., n + m - 1} ]
      together with the instance
      [u‚ÇÄ ... u‚Çô‚Çã‚ÇÅ Var(0) ... Var (m - 1)].
  *)
  if (Univ.Instance.is_empty subst) then
    (** Still need to take the union for the constraints between globals *)
    subst, (AUContext.union abs_ctx auctx)
  else
    let open Univ in
    let ainst = make_abstract_instance auctx in
    let subst = Instance.append subst ainst in
    let substf = make_instance_subst subst in
    let auctx = Univ.subst_univs_level_abstract_universe_context substf auctx in
    subst, (AUContext.union abs_ctx auctx)

let lift_univs cb subst auctx0 =
  match cb.const_universes with
  | Monomorphic ctx -&gt;
    assert (AUContext.is_empty auctx0);
    subst, (Monomorphic ctx)
  | Polymorphic auctx -&gt;
    let subst, auctx = discharge_abstract_universe_context subst auctx0 auctx in
    subst, (Polymorphic auctx)

let cook_constr { Opaqueproof.modlist ; abstract } (c, priv) =
  let cache = RefTable.create 13 in
  let abstract, usubst, abs_ctx = abstract in
  let usubst, priv = match priv with
  | Opaqueproof.PrivateMonomorphic () -&gt;
    let () = assert (AUContext.is_empty abs_ctx) in
    let () = assert (Instance.is_empty usubst) in
    usubst, priv
  | Opaqueproof.PrivatePolymorphic (univs, ctx) -&gt;
    let ainst = Instance.of_array (Array.init univs Level.var) in
    let usubst = Instance.append usubst ainst in
    let ctx = on_snd (Univ.subst_univs_level_constraints (Univ.make_instance_subst usubst)) ctx in
    let univs = univs + AUContext.size abs_ctx in
    usubst, Opaqueproof.PrivatePolymorphic (univs, ctx)
  in
  let expmod = expmod_constr_subst cache modlist usubst in
  let hyps = Context.Named.map expmod abstract in
  let hyps = abstract_context hyps in
  let c = abstract_constant_body (expmod c) hyps in
  (c, priv)

let cook_constr infos c =
  let fold info c = cook_constr info c in
  List.fold_right fold infos c

let cook_constant { from = cb; info } =
  let { Opaqueproof.modlist; abstract } = info in
  let cache = RefTable.create 13 in
  let abstract, usubst, abs_ctx = abstract in
  let usubst, univs = lift_univs cb usubst abs_ctx in
  let expmod = expmod_constr_subst cache modlist usubst in
  let hyps0 = Context.Named.map expmod abstract in
  let hyps = abstract_context hyps0 in
  let map c = abstract_constant_body (expmod c) hyps in
  let body = match cb.const_body with
  | Undef _ as x -&gt; x
  | Def cs -&gt; Def (Mod_subst.from_val (map (Mod_subst.force_constr cs)))
  | OpaqueDef o -&gt;
    OpaqueDef (Opaqueproof.discharge_opaque info o)
  | Primitive _ -&gt; CErrors.anomaly (Pp.str &quot;Primitives cannot be cooked&quot;)
  in
  let const_hyps = Id.Set.diff (Context.Named.to_vars cb.const_hyps) (Context.Named.to_vars hyps0) in
  let typ = abstract_constant_type (expmod cb.const_type) hyps in
  {
    cook_body = body;
    cook_type = typ;
    cook_universes = univs;
    cook_relevance = cb.const_relevance;
    cook_inline = cb.const_inline_code;
    cook_context = Some const_hyps;
  }

(* let cook_constant_key = CProfile.declare_profile &quot;cook_constant&quot; *)
(* let cook_constant = CProfile.profile2 cook_constant_key cook_constant *)

(********************************)
(* Discharging mutual inductive *)

(* Replace

     Var(y1)..Var(yq):C1..Cq |- Ij:Bj
     Var(y1)..Var(yq):C1..Cq; I1..Ip:B1..Bp |- ci : Ti

   by

     |- Ij: (y1..yq:C1..Cq)Bj
     I1..Ip:(B1 y1..yq)..(Bp y1..yq) |- ci : (y1..yq:C1..Cq)Ti[Ij:=(Ij y1..yq)]
*)

let it_mkNamedProd_wo_LetIn b d =
  List.fold_left (fun c d -&gt; mkNamedProd_wo_LetIn d c) b d

let abstract_inductive decls nparamdecls inds =
  let open Entries in
  let ntyp = List.length inds in
  let ndecls = Context.Named.length decls in
  let args = Context.Named.to_instance mkVar (List.rev decls) in
  let args = Array.of_list args in
  let subs = List.init ntyp (fun k -&gt; lift ndecls (mkApp(mkRel (k+1),args))) in
  let inds' =
    List.map
      (function (tname,arity,template,cnames,lc) -&gt;
        let lc' = List.map (Vars.substl subs) lc in
        let lc'' = List.map (fun b -&gt; it_mkNamedProd_wo_LetIn b decls) lc' in
        let arity' = it_mkNamedProd_wo_LetIn arity decls in
        (tname,arity',template,cnames,lc''))
        inds in
  let nparamdecls' = nparamdecls + Array.length args in
(* To be sure to be the same as before, should probably be moved to cook_inductive *)
  let params' = let (_,arity,_,_,_) = List.hd inds' in
                let (params,_) = decompose_prod_n_assum nparamdecls' arity in
    params
  in
  let ind'' =
  List.map
    (fun (a,arity,template,c,lc) -&gt;
      let _, short_arity = decompose_prod_n_assum nparamdecls' arity in
      let shortlc =
        List.map (fun c -&gt; snd (decompose_prod_n_assum nparamdecls' c)) lc in
      { mind_entry_typename = a;
        mind_entry_arity = short_arity;
        mind_entry_template = template;
        mind_entry_consnames = c;
        mind_entry_lc = shortlc })
    inds'
  in (params',ind'')

let refresh_polymorphic_type_of_inductive (_,mip) =
  match mip.mind_arity with
  | RegularArity s -&gt; s.mind_user_arity, false
  | TemplateArity ar -&gt;
    let ctx = List.rev mip.mind_arity_ctxt in
      mkArity (List.rev ctx, Sorts.sort_of_univ ar.template_level), true

let dummy_variance = let open Entries in function
  | Monomorphic_entry _ -&gt; assert false
  | Polymorphic_entry (_,uctx) -&gt; Array.make (Univ.UContext.size uctx) Univ.Variance.Irrelevant

let cook_inductive { Opaqueproof.modlist; abstract } mib =
  let open Entries in
  let (section_decls, subst, abs_uctx) = abstract in
  let nparamdecls = Context.Rel.length mib.mind_params_ctxt in
  let subst, ind_univs =
    match mib.mind_universes with
    | Monomorphic ctx -&gt; Univ.empty_level_subst, Monomorphic_entry ctx
    | Polymorphic auctx -&gt;
      let subst, auctx = discharge_abstract_universe_context subst abs_uctx auctx in
      let subst = Univ.make_instance_subst subst in
      let nas = Univ.AUContext.names auctx in
      let auctx = Univ.AUContext.repr auctx in
      subst, Polymorphic_entry (nas, auctx)
  in
  let variance = match mib.mind_variance with
    | None -&gt; None
    | Some _ -&gt; Some (dummy_variance ind_univs)
  in
  let cache = RefTable.create 13 in
  let discharge c = Vars.subst_univs_level_constr subst (expmod_constr cache modlist c) in
  let inds =
    Array.map_to_list
      (fun mip -&gt;
        let ty, template = refresh_polymorphic_type_of_inductive (mib,mip) in
        let arity = discharge ty in
        let lc = Array.map discharge mip.mind_user_lc  in
          (mip.mind_typename,
           arity, template,
           Array.to_list mip.mind_consnames,
           Array.to_list lc))
      mib.mind_packets in
  let section_decls' = Context.Named.map discharge section_decls in
  let (params',inds') = abstract_inductive section_decls' nparamdecls inds in
  let record = match mib.mind_record with
    | PrimRecord info -&gt;
      Some (Some (Array.map (fun (x,_,_,_) -&gt; x) info))
    | FakeRecord -&gt; Some None
    | NotRecord -&gt; None
  in
  { mind_entry_record = record;
    mind_entry_finite = mib.mind_finite;
    mind_entry_params = params';
    mind_entry_inds = inds';
    mind_entry_private = mib.mind_private;
    mind_entry_variance = variance;
    mind_entry_universes = ind_univs
  }

let expmod_constr modlist c = expmod_constr (RefTable.create 13) modlist c
</pre>
          </div>
          <div class="col-md-6">
            <code>cooking.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Util.

Import Names.

Import Term.

Import Constr.

Import Declarations.

Import Univ.

Import Context.

Inductive my_global_reference : Type :=
| ConstRef : Names.Constant.t -&gt; my_global_reference
| IndRef : Names.inductive -&gt; my_global_reference
| ConstructRef : Names.constructor -&gt; my_global_reference.

Module RefHash.
  Definition t := my_global_reference.
  
  Definition equal (gr1 : my_global_reference) (gr2 : my_global_reference)
    : bool :=
    match (gr1, gr2) with
    | (ConstRef c1, ConstRef c2) =&gt; Names.Constant.SyntacticOrd.equal c1 c2
    | (IndRef i1, IndRef i2) =&gt; Names.eq_syntactic_ind i1 i2
    | (ConstructRef c1, ConstructRef c2) =&gt; Names.eq_syntactic_constructor c1 c2
    | _ =&gt; false
    end.
  
  Import Hashset.Combine.
  
  Definition hash (function_parameter : my_global_reference) : Z :=
    match function_parameter with
    | ConstRef c =&gt;
      Hashset.Combine.combinesmall 1 (Names.Constant.SyntacticOrd.hash c)
    | IndRef i =&gt; Hashset.Combine.combinesmall 2 (Names.ind_syntactic_hash i)
    | ConstructRef c =&gt;
      Hashset.Combine.combinesmall 3 (Names.constructor_syntactic_hash c)
    end.
End RefHash.

Definition instantiate_my_gr (gr : my_global_reference) (u : Univ.Instance.t)
  : Constr.constr :=
  match gr with
  | ConstRef c =&gt; Constr.mkConstU (c, u)
  | IndRef i =&gt; Constr.mkIndU (i, u)
  | ConstructRef c =&gt; Constr.mkConstructU (c, u)
  end.

Definition share {A : Type}
  (cache : RefTable.t (A * (array Constr.constr))) (r : RefTable.key)
  (function_parameter :
    (Names.Cmap.t (A * (array Names.Id.t))) *
      (Names.Mindmap.t (A * (array Names.Id.t)))) : A * (array Constr.constr) :=
  match function_parameter with
  | (cstl, knl) =&gt; try
  end.

Definition share_univs
  (cache : RefTable.t (Univ.Instance.t * (array Constr.constr)))
  (r : RefTable.key) (u : Univ.Instance.t)
  (l :
    (Names.Cmap.t (Univ.Instance.t * (array Names.Id.t))) *
      (Names.Mindmap.t (Univ.Instance.t * (array Names.Id.t))))
  : Constr.constr :=
  match share cache r l with
  | (u', args) =&gt;
    Constr.mkApp ((instantiate_my_gr r (Univ.Instance.append u' u)), args)
  end.

Definition update_case_info {A : Type}
  (cache : RefTable.t (A * (array Constr.constr))) (ci : Constr.case_info)
  (modlist :
    (Names.Cmap.t (A * (array Names.Id.t))) *
      (Names.Mindmap.t (A * (array Names.Id.t)))) : Constr.case_info := try.

Definition is_empty_modlist {A B : Type}
  (function_parameter : (Names.Cmap.t A) * (Names.Mindmap.t B)) : bool :=
  match function_parameter with
  | (cm, mm) =&gt; andb (Names.Cmap.is_empty cm) (Names.Mindmap.is_empty mm)
  end.

Definition expmod_constr
  (cache : RefTable.t (Univ.Instance.t * (array Constr.constr)))
  (modlist :
    (Names.Cmap.t (Univ.Instance.t * (array Names.Id.t))) *
      (Names.Mindmap.t (Univ.Instance.t * (array Names.Id.t))))
  (c : Constr.constr) : Constr.constr :=
  let share_univs := share_univs cache in
  let update_case_info := update_case_info cache in
  let fix substrec (c : Constr.constr) : Constr.constr :=
    match Constr.kind c with
    | Case ci p t br =&gt;
      Constr.map substrec
        (Constr.mkCase ((update_case_info ci modlist), p, t, br))
    | Ind (ind, u) =&gt; try
    | Construct (cstr, u) =&gt; try
    | Const (cst, u) =&gt; try
    | Proj p c' =&gt;
      let map (cst : Names.Mindmap.key) (npars : Z) : Names.Mindmap.key * Z :=
        match Names.Mindmap.find cst (snd modlist) with
        | (_, newpars) =&gt;
          (cst, (Util.op_plus npars (Util.Array.(CArray.ExtS.length) newpars)))
        end in
      let p' := try in
      let c'' := substrec c' in
      if andb (Stdlib.op_eq_eq p p') (Stdlib.op_eq_eq c' c'') then
        c
      else
        Constr.mkProj (p', c'')
    | _ =&gt; Constr.map substrec c
    end in
  if is_empty_modlist modlist then
    c
  else
    substrec c.

Definition abstract_context
  (hyps : Context.Named.pt Constr.constr Constr.constr)
  : (list (RelDecl.pt Constr.constr Constr.constr)) * (list Names.Id.t) :=
  let fold
    (decl : NamedDecl.pt Constr.constr Constr.constr) (function_parameter :
    (list (RelDecl.pt Constr.constr Constr.constr)) * (list Names.Id.t))
    : (list (RelDecl.pt Constr.constr Constr.constr)) * (list Names.Id.t) :=
    match function_parameter with
    | (ctx, subst) =&gt;
      match
        match decl with
        | NamedDecl.LocalDef id b t =&gt;
          let b := Vars.subst_vars subst b in
          let t := Vars.subst_vars subst t in
          (id, (RelDecl.LocalDef (Context.map_annot Names.Name.mk_name id) b t))
        | NamedDecl.LocalAssum id t =&gt;
          let t := Vars.subst_vars subst t in
          (id, (RelDecl.LocalAssum (Context.map_annot Names.Name.mk_name id) t))
        end with
      | (id, decl) =&gt; ((cons decl ctx), (cons (binder_name id) subst))
      end
    end in
  Context.Named.fold_outside fold hyps ([], []).

Definition abstract_constant_type
  (t : Constr.constr)
  (function_parameter : (list Constr.rel_declaration) * (list Names.Id.t))
  : Constr.types :=
  match function_parameter with
  | (hyps, subst) =&gt;
    let t := Vars.subst_vars subst t in
    Util.List.(CList.ExtS.fold_left)
      (fun c =&gt; fun d =&gt; Term.mkProd_wo_LetIn d c) t hyps
  end.

Definition abstract_constant_body
  (c : Constr.constr)
  (function_parameter : Constr.rel_context * (list Names.Id.t))
  : Constr.constr :=
  match function_parameter with
  | (hyps, subst) =&gt;
    let c := Vars.subst_vars subst c in
    Term.it_mkLambda_or_LetIn c hyps
  end.

Record recipe := {
  from : Declarations.constant_body Opaqueproof.opaque;
  info : Opaqueproof.cooking_info }.

Definition inline := bool.

Record result {opaque : Type} := {
  cook_body :
    Declarations.constant_def (Mod_subst.substituted Constr.constr) opaque;
  cook_type : Constr.types;
  cook_universes : Declarations.universes;
  cook_relevance : Sorts.relevance;
  cook_inline : inline;
  cook_context : option Names.Id.Set.t }.
Arguments result : clear implicits.

Definition expmod_constr_subst
  (cache : RefTable.t (Univ.Instance.t * (array Constr.constr)))
  (modlist :
    (Names.Cmap.t (Univ.Instance.t * (array Names.Id.t))) *
      (Names.Mindmap.t (Univ.Instance.t * (array Names.Id.t))))
  (subst : Univ.Instance.t) (c : Constr.constr) : Constr.constr :=
  let subst := Univ.make_instance_subst subst in
  let c := expmod_constr cache modlist c in
  Vars.subst_univs_level_constr subst c.

Definition discharge_abstract_universe_context
  (subst : Univ.Instance.t) (abs_ctx : Univ.AUContext.t)
  (auctx : Univ.AUContext.t) : Univ.Instance.t * Univ.AUContext.t :=
  if Univ.Instance.is_empty subst then
    (subst, (Univ.AUContext.union abs_ctx auctx))
  else
    let ainst := Univ.make_abstract_instance auctx in
    let subst := Univ.Instance.append subst ainst in
    let substf := Univ.make_instance_subst subst in
    let auctx := Univ.subst_univs_level_abstract_universe_context substf auctx
      in
    (subst, (Univ.AUContext.union abs_ctx auctx)).

Definition lift_univs {A : Type}
  (cb : Declarations.constant_body A) (subst : Univ.Instance.t)
  (auctx0 : Univ.AUContext.t) : Univ.Instance.t * Declarations.universes :=
  match const_universes cb with
  | Monomorphic ctx =&gt;
    Univ.AUContext.is_empty auctx0;
    (subst, (Monomorphic ctx))
  | Polymorphic auctx =&gt;
    match discharge_abstract_universe_context subst auctx0 auctx with
    | (subst, auctx) =&gt; (subst, (Polymorphic auctx))
    end
  end.

Definition cook_constr (function_parameter : Opaqueproof.cooking_info)
  : (Constr.constr * (Opaqueproof.delayed_universes unit)) -&gt;
    Constr.constr * (Opaqueproof.delayed_universes unit) :=
  match function_parameter with
  | {| Opaqueproof.modlist := modlist; Opaqueproof.abstract := abstract |} =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (c, priv) =&gt;
        let cache := RefTable.create 13 in
        match abstract with
        | (abstract, usubst, abs_ctx) =&gt;
          match
            match priv with
            | Opaqueproof.PrivateMonomorphic tt =&gt;
              match Univ.AUContext.is_empty abs_ctx with
              | tt =&gt;
                match Univ.Instance.is_empty usubst with
                | tt =&gt; (usubst, priv)
                end
              end
            | Opaqueproof.PrivatePolymorphic univs ctx =&gt;
              let ainst :=
                Univ.Instance.of_array
                  (Util.Array.(CArray.ExtS.init) univs Univ.Level.var) in
              let usubst := Univ.Instance.append usubst ainst in
              let ctx :=
                Util.on_snd
                  (Univ.subst_univs_level_constraints
                    (Univ.make_instance_subst usubst)) ctx in
              let univs := Util.op_plus univs (Univ.AUContext.size abs_ctx) in
              (usubst, (Opaqueproof.PrivatePolymorphic univs ctx))
            end with
          | (usubst, priv) =&gt;
            let expmod := expmod_constr_subst cache modlist usubst in
            let hyps := Context.Named.map expmod abstract in
            let hyps := abstract_context hyps in
            let c := abstract_constant_body (expmod c) hyps in
            (c, priv)
          end
        end
      end
  end.

Definition cook_constr
  (infos : list Opaqueproof.cooking_info)
  (c : Constr.constr * (Opaqueproof.delayed_universes unit))
  : Constr.constr * (Opaqueproof.delayed_universes unit) :=
  let fold
    (info : Opaqueproof.cooking_info) (c :
    Constr.constr * (Opaqueproof.delayed_universes unit))
    : Constr.constr * (Opaqueproof.delayed_universes unit) :=
    cook_constr info c in
  Util.List.(CList.ExtS.fold_right) fold infos c.

Definition cook_constant (function_parameter : recipe)
  : result Opaqueproof.opaque :=
  match function_parameter with
  | {| from := cb; info := info |} =&gt;
    match info with
    | {| Opaqueproof.modlist := modlist; Opaqueproof.abstract := abstract |} =&gt;
      let cache := RefTable.create 13 in
      match abstract with
      | (abstract, usubst, abs_ctx) =&gt;
        match lift_univs cb usubst abs_ctx with
        | (usubst, univs) =&gt;
          let expmod := expmod_constr_subst cache modlist usubst in
          let hyps0 := Context.Named.map expmod abstract in
          let hyps := abstract_context hyps0 in
          let map (c : Constr.constr) : Constr.constr :=
            abstract_constant_body (expmod c) hyps in
          let body :=
            match const_body cb with
            | (Undef _) as x =&gt; x
            | Def cs =&gt;
              Def (Mod_subst.from_val (map (Mod_subst.force_constr cs)))
            | OpaqueDef o =&gt; OpaqueDef (Opaqueproof.discharge_opaque info o)
            | Primitive _ =&gt;
              CErrors.anomaly None None
                (Pp.str &quot;Primitives cannot be cooked&quot; % string)
            end in
          let const_hyps :=
            Names.Id.Set.diff (Context.Named.to_vars (const_hyps cb))
              (Context.Named.to_vars hyps0) in
          let typ := abstract_constant_type (expmod (const_type cb)) hyps in
          {| cook_body := body; cook_type := typ; cook_universes := univs;
            cook_relevance := const_relevance cb;
            cook_inline := const_inline_code cb; cook_context := Some const_hyps
            |}
        end
      end
    end
  end.

Definition it_mkNamedProd_wo_LetIn
  (b : Constr.types) (d : list Constr.named_declaration) : Constr.types :=
  Util.List.(CList.ExtS.fold_left)
    (fun c =&gt; fun d =&gt; Term.mkNamedProd_wo_LetIn d c) b d.

Definition abstract_inductive
  (decls : Context.Named.pt Constr.constr Constr.types) (nparamdecls : Z)
  (inds :
    list
      (Names.Id.t * Constr.types * bool * (list Names.Id.t) *
        (list Constr.constr)))
  : Constr.rel_context * (list Entries.one_inductive_entry) :=
  let ntyp := Util.List.(CList.ExtS.length) inds in
  let ndecls := Context.Named.length decls in
  let args :=
    Context.Named.to_instance Constr.mkVar (Util.List.(CList.ExtS.rev) decls) in
  let args := Util.Array.(CArray.ExtS.of_list) args in
  let subs :=
    Util.List.(CList.ExtS.init) ntyp
      (fun k =&gt;
        Constr.lift ndecls
          (Constr.mkApp ((Constr.mkRel (Util.op_plus k 1)), args))) in
  let inds' :=
    Util.List.(CList.ExtS.map)
      (fun function_parameter =&gt;
        match function_parameter with
        | (tname, arity, template, cnames, lc) =&gt;
          let lc' := Util.List.(CList.ExtS.map) (Vars.substl subs) lc in
          let lc'' :=
            Util.List.(CList.ExtS.map)
              (fun b =&gt; it_mkNamedProd_wo_LetIn b decls) lc' in
          let arity' := it_mkNamedProd_wo_LetIn arity decls in
          (tname, arity', template, cnames, lc'')
        end) inds in
  let nparamdecls' :=
    Util.op_plus nparamdecls (Util.Array.(CArray.ExtS.length) args) in
  let params' :=
    match Util.List.(CList.ExtS.hd) inds' with
    | (_, arity, _, _, _) =&gt;
      match Term.decompose_prod_n_assum nparamdecls' arity with
      | (params, _) =&gt; params
      end
    end in
  let ind'' :=
    Util.List.(CList.ExtS.map)
      (fun function_parameter =&gt;
        match function_parameter with
        | (a, arity, template, c, lc) =&gt;
          match Term.decompose_prod_n_assum nparamdecls' arity with
          | (_, short_arity) =&gt;
            let shortlc :=
              Util.List.(CList.ExtS.map)
                (fun c =&gt; snd (Term.decompose_prod_n_assum nparamdecls' c)) lc
              in
            {| mind_entry_typename := a; mind_entry_arity := short_arity;
              mind_entry_template := template; mind_entry_consnames := c;
              mind_entry_lc := shortlc |}
          end
        end) inds' in
  (params', ind'').

Definition refresh_polymorphic_type_of_inductive {A : Type}
  (function_parameter : A * Declarations.one_inductive_body)
  : Constr.types * bool :=
  match function_parameter with
  | (_, mip) =&gt;
    match mind_arity mip with
    | RegularArity s =&gt; ((mind_user_arity s), false)
    | TemplateArity ar =&gt;
      let ctx := Util.List.(CList.ExtS.rev) (mind_arity_ctxt mip) in
      ((Term.mkArity
        ((Util.List.(CList.ExtS.rev) ctx),
          (Sorts.sort_of_univ (template_level ar)))), true)
    end
  end.

Definition dummy_variance (function_parameter : Entries.universes_entry)
  : array Univ.Variance.t :=
  match function_parameter with
  | Monomorphic_entry _ =&gt; false
  | Polymorphic_entry _ uctx =&gt;
    Util.Array.(CArray.ExtS.make) (Univ.UContext.size uctx)
      Univ.Variance.Irrelevant
  end.

Definition cook_inductive (function_parameter : Opaqueproof.cooking_info)
  : Declarations.mutual_inductive_body -&gt; Entries.mutual_inductive_entry :=
  match function_parameter with
  | {| Opaqueproof.modlist := modlist; Opaqueproof.abstract := abstract |} =&gt;
    fun mib =&gt;
      match abstract with
      | (section_decls, subst, abs_uctx) =&gt;
        let nparamdecls := Context.Rel.length (mind_params_ctxt mib) in
        match
          match mind_universes mib with
          | Monomorphic ctx =&gt; (Univ.empty_level_subst, (Monomorphic_entry ctx))
          | Polymorphic auctx =&gt;
            match discharge_abstract_universe_context subst abs_uctx auctx with
            | (subst, auctx) =&gt;
              let subst := Univ.make_instance_subst subst in
              let nas := Univ.AUContext.names auctx in
              let auctx := Univ.AUContext.repr auctx in
              (subst, (Polymorphic_entry nas auctx))
            end
          end with
        | (subst, ind_univs) =&gt;
          let variance :=
            match mind_variance mib with
            | None =&gt; None
            | Some _ =&gt; Some (dummy_variance ind_univs)
            end in
          let cache := RefTable.create 13 in
          let discharge (c : Constr.constr) : Constr.constr :=
            Vars.subst_univs_level_constr subst (expmod_constr cache modlist c)
            in
          let inds :=
            Util.Array.(CArray.ExtS.map_to_list)
              (fun mip =&gt;
                match refresh_polymorphic_type_of_inductive (mib, mip) with
                | (ty, template) =&gt;
                  let arity := discharge ty in
                  let lc :=
                    Util.Array.(CArray.ExtS.map) discharge (mind_user_lc mip) in
                  ((mind_typename mip), arity, template,
                    (Util.Array.(CArray.ExtS.to_list) (mind_consnames mip)),
                    (Util.Array.(CArray.ExtS.to_list) lc))
                end) (mind_packets mib) in
          let section_decls' := Context.Named.map discharge section_decls in
          match abstract_inductive section_decls' nparamdecls inds with
          | (params', inds') =&gt;
            let record :=
              match mind_record mib with
              | PrimRecord info =&gt;
                Some
                  (Some
                    (Util.Array.(CArray.ExtS.map)
                      (fun function_parameter =&gt;
                        match function_parameter with
                        | (x, _, _, _) =&gt; x
                        end) info))
              | FakeRecord =&gt; Some None
              | NotRecord =&gt; None
              end in
            {| mind_entry_record := record;
              mind_entry_finite := mind_finite mib;
              mind_entry_params := params'; mind_entry_inds := inds';
              mind_entry_universes := ind_univs;
              mind_entry_variance := variance;
              mind_entry_private := mind_private mib |}
          end
        end
      end
  end.

Definition expmod_constr
  (modlist :
    (Names.Cmap.t (Univ.Instance.t * (array Names.Id.t))) *
      (Names.Mindmap.t (Univ.Instance.t * (array Names.Id.t))))
  (c : Constr.constr) : Constr.constr :=
  expmod_constr (RefTable.create 13) modlist c.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="csymtable" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>csymtable.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Bruno Barras for Benjamin Gr√©goire as part of the
   bytecode-based reduction machine, Oct 2004 *)
(* Bug fix #1419 by Jean-Marc Notin, Mar 2007 *)

(* This file manages the table of global symbols for the bytecode machine *)

open Util
open Names
open Vmvalues
open Cemitcodes
open Cbytecodes
open Declarations
open Environ
open Cbytegen

module NamedDecl = Context.Named.Declaration
module RelDecl = Context.Rel.Declaration

external eval_tcode : tcode -&gt; atom array -&gt; vm_global -&gt; values array -&gt; values = &quot;coq_eval_tcode&quot;

type global_data = { mutable glob_len : int; mutable glob_val : values array }

(*******************)
(* Linkage du code *)
(*******************)

(* Table des globaux *)

(* [global_data] contient les valeurs des constantes globales
   (axiomes,definitions), les annotations des switch et les structured
   constant *)
let global_data = {
  glob_len = 0;
  glob_val = Array.make 4096 crazy_val;
}

let get_global_data () = Vmvalues.vm_global global_data.glob_val

let realloc_global_data n =
  let n = min (2 * n + 0x100) Sys.max_array_length in
  let ans = Array.make n crazy_val in
  let src = global_data.glob_val in
  let () = Array.blit src 0 ans 0 (Array.length src) in
  global_data.glob_val &lt;- ans

let check_global_data n =
  if n &gt;= Array.length global_data.glob_val then realloc_global_data n

let set_global v =
  let n = global_data.glob_len in
  check_global_data n;
  global_data.glob_val.(n) &lt;- v;
  global_data.glob_len &lt;- global_data.glob_len + 1;
  n

(* table pour les structured_constant et les annotations des switchs *)

module SConstTable = Hashtbl.Make (struct
  type t = structured_constant
  let equal = eq_structured_constant
  let hash = hash_structured_constant
end)

module AnnotTable = Hashtbl.Make (struct
  type t = annot_switch
  let equal = eq_annot_switch
  let hash = hash_annot_switch
end)

module ProjNameTable = Hashtbl.Make (Projection.Repr)

let str_cst_tbl : int SConstTable.t = SConstTable.create 31

let annot_tbl : int AnnotTable.t = AnnotTable.create 31
    (* (annot_switch * int) Hashtbl.t  *)

let proj_name_tbl : int ProjNameTable.t = ProjNameTable.create 31

(*************************************************************)
(*** Mise a jour des valeurs des variables et des constantes *)
(*************************************************************)

exception NotEvaluated

let key rk =
  match !rk with
  | None -&gt; raise NotEvaluated
  | Some k -&gt;
      try CEphemeron.get k
      with CEphemeron.InvalidKey -&gt; raise NotEvaluated

(************************)
(* traduction des patch *)

(* slot_for_*, calcul la valeur de l'objet, la place
   dans la table global, rend sa position dans la table *)

let slot_for_str_cst key =
  try SConstTable.find str_cst_tbl key
  with Not_found -&gt;
    let n = set_global (val_of_str_const key) in
    SConstTable.add str_cst_tbl key n;
    n

let slot_for_annot key =
  try AnnotTable.find annot_tbl key
  with Not_found -&gt;
    let n =  set_global (val_of_annot_switch key) in
    AnnotTable.add annot_tbl key n;
    n

let slot_for_proj_name key =
  try ProjNameTable.find proj_name_tbl key
  with Not_found -&gt;
    let n =  set_global (val_of_proj_name key) in
    ProjNameTable.add proj_name_tbl key n;
    n

let rec slot_for_getglobal env kn =
  let (cb,(_,rk)) = lookup_constant_key kn env in
  try key rk
  with NotEvaluated -&gt;
(*    Pp.msgnl(str&quot;not yet evaluated&quot;);*)
    let pos =
      match cb.const_body_code with
      | None -&gt; set_global (val_of_constant kn)
      | Some code -&gt;
	 match Cemitcodes.force code with
	 | BCdefined(code,pl,fv) -&gt;
           let v = eval_to_patch env (code,pl,fv) in
           set_global v
	 | BCalias kn' -&gt; slot_for_getglobal env kn'
	 | BCconstant -&gt; set_global (val_of_constant kn)
    in
(*Pp.msgnl(str&quot;value stored at: &quot;++int pos);*)
    rk := Some (CEphemeron.create pos);
    pos

and slot_for_fv env fv =
  let fill_fv_cache cache id v_of_id env_of_id b =
    let v,d =
      match b with
      | None -&gt; v_of_id id, Id.Set.empty
      | Some c -&gt;
          val_of_constr (env_of_id id env) c,
          Environ.global_vars_set env c in
    build_lazy_val cache (v, d); v in
  let val_of_rel i = val_of_rel (nb_rel env - i) in
  let idfun _ x = x in
  match fv with
  | FVnamed id -&gt;
      let nv = lookup_named_val id env in
      begin match force_lazy_val nv with
      | None -&gt;
         env |&gt; lookup_named id |&gt; NamedDecl.get_value |&gt; fill_fv_cache nv id val_of_named idfun
      | Some (v, _) -&gt; v
      end
  | FVrel i -&gt;
      let rv = lookup_rel_val i env in
      begin match force_lazy_val rv with
      | None -&gt;
        env |&gt; lookup_rel i |&gt; RelDecl.get_value |&gt; fill_fv_cache rv i val_of_rel env_of_rel
      | Some (v, _) -&gt; v
      end
  | FVevar evk -&gt; val_of_evar evk
  | FVuniv_var _idu -&gt;
    assert false

and eval_to_patch env (buff,pl,fv) =
  let slots = function
    | Reloc_annot a -&gt; slot_for_annot a
    | Reloc_const sc -&gt; slot_for_str_cst sc
    | Reloc_getglobal kn -&gt; slot_for_getglobal env kn
    | Reloc_proj_name p -&gt; slot_for_proj_name p
  in
  let tc = patch buff pl slots in
  let vm_env = Array.map (slot_for_fv env) fv in
  eval_tcode tc (get_atom_rel ()) (vm_global global_data.glob_val) vm_env

and val_of_constr env c =
  match compile ~fail_on_error:true env c with
  | Some v -&gt; eval_to_patch env (to_memory v)
  | None -&gt; assert false

let set_transparent_const _kn = () (* !?! *)
let set_opaque_const _kn = () (* !?! *)
</pre>
          </div>
          <div class="col-md-6">
            <code>csymtable.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Util.

Import Names.

Import Vmvalues.

Import Cemitcodes.

Import Cbytecodes.

Import Declarations.

Import Environ.

Import Cbytegen.

Record global_data := {
  glob_len : Z;
  glob_val : array Vmvalues.values }.

Definition global_data : global_data :=
  {| glob_len := 0;
    glob_val := Util.Array.(CArray.ExtS.make) 4096 Vmvalues.crazy_val |}.

Definition get_global_data (function_parameter : unit) : Vmvalues.vm_global :=
  match function_parameter with
  | tt =&gt; Vmvalues.vm_global (glob_val global_data)
  end.

Definition realloc_global_data (n : Z) : unit :=
  let n :=
    OCaml.Stdlib.min (Util.op_plus (Z.mul 2 n) 256) Stdlib.Sys.max_array_length
    in
  let ans := Util.Array.(CArray.ExtS.make) n Vmvalues.crazy_val in
  let src := glob_val global_data in
  match
    Util.Array.(CArray.ExtS.blit) src 0 ans 0
      (Util.Array.(CArray.ExtS.length) src) with
  | tt =&gt; set_field
  end.

Definition check_global_data (n : Z) : unit :=
  if OCaml.Stdlib.ge n (Util.Array.(CArray.ExtS.length) (glob_val global_data))
    then
    realloc_global_data n
  else
    tt.

Definition set_global (v : Vmvalues.values) : Z :=
  let n := glob_len global_data in
  check_global_data n;
  Util.Array.(CArray.ExtS.set) (glob_val global_data) n v;
  set_field;
  n.

Definition str_cst_tbl : SConstTable.t Z := SConstTable.create 31.

Definition annot_tbl : AnnotTable.t Z := AnnotTable.create 31.

Definition proj_name_tbl : ProjNameTable.t Z := ProjNameTable.create 31.

Definition key {A : Type} (rk : Stdlib.ref (option (CEphemeron.key A))) : A :=
  match Util.op_exclamation rk with
  | None =&gt; Stdlib.raise NotEvaluated
  | Some k =&gt; try
  end.

Definition slot_for_str_cst (key : SConstTable.key) : Z := try.

Definition slot_for_annot (key : AnnotTable.key) : Z := try.

Definition slot_for_proj_name (key : ProjNameTable.key) : Z := try.

Fixpoint slot_for_getglobal (env : Environ.env) (kn : Names.Constant.t) : Z :=
  match Environ.lookup_constant_key kn env with
  | (cb, (_, rk)) =&gt; try
  end

with slot_for_fv (env : Environ.env) (fv : Cbytecodes.fv_elem)
  : Vmvalues.values :=
  let fill_fv_cache {A : Type}
    (cache : Environ.lazy_val) (id : A) (v_of_id : A -&gt; Vmvalues.values)
    (env_of_id : A -&gt; Environ.env -&gt; Environ.env) (b : option Constr.constr)
    : Vmvalues.values :=
    match
      match b with
      | None =&gt; ((v_of_id id), Names.Id.Set.empty)
      | Some c =&gt;
        ((val_of_constr (env_of_id id env) c), (Environ.global_vars_set env c))
      end with
    | (v, d) =&gt;
      Environ.build_lazy_val cache (v, d);
      v
    end in
  let val_of_rel (i : Z) : Vmvalues.values :=
    Vmvalues.val_of_rel (Util.op_minus (Environ.nb_rel env) i) in
  let idfun {A B : Type} (function_parameter : A) : B -&gt; B :=
    match function_parameter with
    | _ =&gt; fun x =&gt; x
    end in
  match fv with
  | FVnamed id =&gt;
    let nv := Environ.lookup_named_val id env in
    match Environ.force_lazy_val nv with
    | None =&gt;
      OCaml.Stdlib.reverse_apply
        (OCaml.Stdlib.reverse_apply
          (OCaml.Stdlib.reverse_apply env (Environ.lookup_named id))
          NamedDecl.get_value) (fill_fv_cache nv id Vmvalues.val_of_named idfun)
    | Some (v, _) =&gt; v
    end
  | FVrel i =&gt;
    let rv := Environ.lookup_rel_val i env in
    match Environ.force_lazy_val rv with
    | None =&gt;
      OCaml.Stdlib.reverse_apply
        (OCaml.Stdlib.reverse_apply
          (OCaml.Stdlib.reverse_apply env (Environ.lookup_rel i))
          RelDecl.get_value) (fill_fv_cache rv i val_of_rel Environ.env_of_rel)
    | Some (v, _) =&gt; v
    end
  | FVevar evk =&gt; Vmvalues.val_of_evar evk
  | FVuniv_var _idu =&gt; false
  end

with eval_to_patch
  (env : Environ.env)
  (function_parameter :
    Cemitcodes.emitcodes * Cemitcodes.patches * Cbytecodes.fv)
  : Vmvalues.values :=
  match function_parameter with
  | (buff, pl, fv) =&gt;
    let slots (function_parameter : Cemitcodes.reloc_info) : Z :=
      match function_parameter with
      | Reloc_annot a =&gt; slot_for_annot a
      | Reloc_const sc =&gt; slot_for_str_cst sc
      | Reloc_getglobal kn =&gt; slot_for_getglobal env kn
      | Reloc_proj_name p =&gt; slot_for_proj_name p
      end in
    let tc := Cemitcodes.patch buff pl slots in
    let vm_env := Util.Array.(CArray.ExtS.map) (slot_for_fv env) fv in
    eval_tcode tc (Vmvalues.get_atom_rel tt)
      (Vmvalues.vm_global (glob_val global_data)) vm_env
  end

with val_of_constr (env : Environ.env) (c : Constr.constr) : Vmvalues.values :=
  match Cbytegen.compile true None env c with
  | Some v =&gt; eval_to_patch env (Cemitcodes.to_memory v)
  | None =&gt; false
  end.

Definition set_transparent_const {A : Type} (_kn : A) : unit := tt.

Definition set_opaque_const {A : Type} (_kn : A) : unit := tt.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="declarations" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>declarations.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Constr

(** This module defines the internal representation of global
   declarations. This includes global constants/axioms, mutual
   inductive definitions, modules and module types *)

type set_predicativity = ImpredicativeSet | PredicativeSet

type engagement = set_predicativity

(** {6 Representation of constants (Definition/Axiom) } *)

(** Non-universe polymorphic mode polymorphism (Coq 8.2+): inductives
    and constants hiding inductives are implicitly polymorphic when
    applied to parameters, on the universes appearing in the whnf of
    their parameters and their conclusion, in a template style.
    
    In truly universe polymorphic mode, we always use RegularArity.
*)

type template_arity = {
  template_param_levels : Univ.Level.t option list;
  template_level : Univ.Universe.t;
}

type ('a, 'b) declaration_arity = 
  | RegularArity of 'a
  | TemplateArity of 'b

(** Inlining level of parameters at functor applications.
    None means no inlining *)

type inline = int option

(** A constant can have no body (axiom/parameter), or a
    transparent body, or an opaque one *)

(* Global declarations (i.e. constants) can be either: *)
type ('a, 'opaque) constant_def =
  | Undef of inline                       (** a global assumption *)
  | Def of 'a                             (** or a transparent global definition *)
  | OpaqueDef of 'opaque                  (** or an opaque global definition *)
  | Primitive of CPrimitives.t            (** or a primitive operation *)

type universes =
  | Monomorphic of Univ.ContextSet.t
  | Polymorphic of Univ.AUContext.t

(** The [typing_flags] are instructions to the type-checker which
    modify its behaviour. The typing flags used in the type-checking
    of a constant are tracked in their {!constant_body} so that they
    can be displayed to the user. *)
type typing_flags = {
  check_guarded : bool;
  (** If [false] then fixed points and co-fixed points are assumed to
      be total. *)

  check_positive : bool;
  (** If [false] then inductive types are assumed positive and co-inductive
      types are assumed productive. *)

  check_universes : bool;
  (** If [false] universe constraints are not checked *)

  conv_oracle : Conv_oracle.oracle;
  (** Unfolding strategies for conversion *)

  share_reduction : bool;
  (** Use by-need reduction algorithm *)

  enable_VM : bool;
  (** If [false], all VM conversions fall back to interpreted ones *)

  enable_native_compiler : bool;
  (** If [false], all native conversions fall back to VM ones *)

  indices_matter: bool;
  (** The universe of an inductive type must be above that of its indices. *)

  check_template : bool;
  (* If [false] then we don't check that the universes template-polymorphic
     inductive parameterize on are necessarily local and unbounded from below.
     This potentially introduces inconsistencies. *)
}

(* some contraints are in constant_constraints, some other may be in
 * the OpaqueDef *)
type 'opaque constant_body = {
    const_hyps : Constr.named_context; (** New: younger hyp at top *)
    const_body : (Constr.t Mod_subst.substituted, 'opaque) constant_def;
    const_type : types;
    const_relevance : Sorts.relevance;
    const_body_code : Cemitcodes.to_patch_substituted option;
    const_universes : universes;
    const_inline_code : bool;
    const_typing_flags : typing_flags; (** The typing options which
                                           were used for
                                           type-checking. *)
}

(** {6 Representation of mutual inductive types in the kernel } *)

type recarg =
  | Norec
  | Mrec of inductive
  | Imbr of inductive

type wf_paths = recarg Rtree.t

(**
{v
   Inductive I1 (params) : U1 := c11 : T11 | ... | c1p1 : T1p1
   ...
   with      In (params) : Un := cn1 : Tn1 | ... | cnpn : Tnpn
v}
*)

(** Record information:
    If the type is not a record, then NotRecord
    If the type is a non-primitive record, then FakeRecord
    If it is a primitive record, for every type in the block, we get:
    - The identifier for the binder name of the record in primitive projections.
    - The constants associated to each projection.
    - The projection types (under parameters).

    The kernel does not exploit the difference between [NotRecord] and
    [FakeRecord]. It is mostly used by extraction, and should be extruded from
    the kernel at some point.
*)

type record_info =
| NotRecord
| FakeRecord
| PrimRecord of (Id.t * Label.t array * Sorts.relevance array * types array) array

type regular_inductive_arity = {
  mind_user_arity : types;
  mind_sort : Sorts.t;
}

type inductive_arity = (regular_inductive_arity, template_arity) declaration_arity

type one_inductive_body = {
(** {8 Primitive datas } *)

    mind_typename : Id.t; (** Name of the type: [Ii] *)

    mind_arity_ctxt : Constr.rel_context; (** Arity context of [Ii] with parameters: [forall params, Ui] *)

    mind_arity : inductive_arity; (** Arity sort and original user arity *)

    mind_consnames : Id.t array; (** Names of the constructors: [cij] *)

    mind_user_lc : types array;
 (** Types of the constructors with parameters:  [forall params, Tij],
     where the Ik are replaced by de Bruijn index in the
     context I1:forall params, U1 ..  In:forall params, Un *)

(** {8 Derived datas } *)

    mind_nrealargs : int; (** Number of expected real arguments of the type (no let, no params) *)

    mind_nrealdecls : int; (** Length of realargs context (with let, no params) *)

    mind_kelim : Sorts.family; (** Highest allowed elimination sort *)

    mind_nf_lc : (rel_context * types) array; (** Head normalized constructor types so that their conclusion exposes the inductive type *)

    mind_consnrealargs : int array;
 (** Number of expected proper arguments of the constructors (w/o params) *)

    mind_consnrealdecls : int array;
 (** Length of the signature of the constructors (with let, w/o params) *)

    mind_recargs : wf_paths; (** Signature of recursive arguments in the constructors *)

    mind_relevance : Sorts.relevance;

(** {8 Datas for bytecode compilation } *)

    mind_nb_constant : int; (** number of constant constructor *)

    mind_nb_args : int; (** number of no constant constructor *)

    mind_reloc_tbl :  Vmvalues.reloc_table;
  }

type recursivity_kind =
  | Finite (** = inductive *)
  | CoFinite (** = coinductive *)
  | BiFinite (** = non-recursive, like in &quot;Record&quot; definitions *)

type mutual_inductive_body = {

    mind_packets : one_inductive_body array;  (** The component of the mutual inductive block *)

    mind_record : record_info; (** The record information *)

    mind_finite : recursivity_kind;  (** Whether the type is inductive or coinductive *)

    mind_ntypes : int;  (** Number of types in the block *)

    mind_hyps : Constr.named_context;  (** Section hypotheses on which the block depends *)

    mind_nparams : int;  (** Number of expected parameters including non-uniform ones (i.e. length of mind_params_ctxt w/o let-in) *)

    mind_nparams_rec : int;  (** Number of recursively uniform (i.e. ordinary) parameters *)

    mind_params_ctxt : Constr.rel_context;  (** The context of parameters (includes let-in declaration) *)

    mind_universes : universes; (** Information about monomorphic/polymorphic/cumulative inductives and their universes *)

    mind_variance : Univ.Variance.t array option; (** Variance info, [None] when non-cumulative. *)

    mind_private : bool option; (** allow pattern-matching: Some true ok, Some false blocked *)

    mind_typing_flags : typing_flags; (** typing flags at the time of the inductive creation *)
}

(** {6 Module declarations } *)

(** Functor expressions are forced to be on top of other expressions *)

type ('ty,'a) functorize =
  | NoFunctor of 'a
  | MoreFunctor of MBId.t * 'ty * ('ty,'a) functorize

(** The fully-algebraic module expressions : names, applications, 'with ...'.
    They correspond to the user entries of non-interactive modules.
    They will be later expanded into module structures in [Mod_typing],
    and won't play any role into the kernel after that : they are kept
    only for short module printing and for extraction. *)

type with_declaration =
  | WithMod of Id.t list * ModPath.t
  | WithDef of Id.t list * (constr * Univ.AUContext.t option)

type module_alg_expr =
  | MEident of ModPath.t
  | MEapply of module_alg_expr * ModPath.t
  | MEwith of module_alg_expr * with_declaration

(** A component of a module structure *)

type structure_field_body =
  | SFBconst of Opaqueproof.opaque constant_body
  | SFBmind of mutual_inductive_body
  | SFBmodule of module_body
  | SFBmodtype of module_type_body

(** A module structure is a list of labeled components.

    Note : we may encounter now (at most) twice the same label in
    a [structure_body], once for a module ([SFBmodule] or [SFBmodtype])
    and once for an object ([SFBconst] or [SFBmind]) *)

and structure_body = (Label.t * structure_field_body) list

(** A module signature is a structure, with possibly functors on top of it *)

and module_signature = (module_type_body,structure_body) functorize

(** A module expression is an algebraic expression, possibly functorized. *)

and module_expression = (module_type_body,module_alg_expr) functorize

and module_implementation =
  | Abstract (** no accessible implementation *)
  | Algebraic of module_expression (** non-interactive algebraic expression *)
  | Struct of module_signature (** interactive body *)
  | FullStruct (** special case of [Struct] : the body is exactly [mod_type] *)

and 'a generic_module_body =
  { mod_mp : ModPath.t; (** absolute path of the module *)
    mod_expr : 'a; (** implementation *)
    mod_type : module_signature; (** expanded type *)
    mod_type_alg : module_expression option; (** algebraic type *)
    mod_constraints : Univ.ContextSet.t; (**
      set of all universes constraints in the module  *)
    mod_delta : Mod_subst.delta_resolver; (**
      quotiented set of equivalent constants and inductive names *)
    mod_retroknowledge : 'a module_retroknowledge }

(** For a module, there are five possible situations:
    - [Declare Module M : T] then [mod_expr = Abstract; mod_type_alg = Some T]
    - [Module M := E] then [mod_expr = Algebraic E; mod_type_alg = None]
    - [Module M : T := E] then [mod_expr = Algebraic E; mod_type_alg = Some T]
    - [Module M. ... End M] then [mod_expr = FullStruct; mod_type_alg = None]
    - [Module M : T. ... End M] then [mod_expr = Struct; mod_type_alg = Some T]
    And of course, all these situations may be functors or not. *)

and module_body = module_implementation generic_module_body

(** A [module_type_body] is just a [module_body] with no implementation and
    also an empty [mod_retroknowledge]. Its [mod_type_alg] contains
    the algebraic definition of this module type, or [None]
    if it has been built interactively. *)

and module_type_body = unit generic_module_body

and _ module_retroknowledge =
| ModBodyRK :
  Retroknowledge.action list -&gt; module_implementation module_retroknowledge
| ModTypeRK : unit module_retroknowledge

(** Extra invariants :

    - No [MEwith] inside a [mod_expr] implementation : the 'with' syntax
      is only supported for module types

    - A module application is atomic, for instance ((M N) P) :
      * the head of [MEapply] can only be another [MEapply] or a [MEident]
      * the argument of [MEapply] is now directly forced to be a [ModPath.t].
*)
</pre>
          </div>
          <div class="col-md-6">
            <code>declarations.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Names.

Import Constr.

Inductive set_predicativity : Type :=
| ImpredicativeSet : set_predicativity
| PredicativeSet : set_predicativity.

Definition engagement := set_predicativity.

Record template_arity := {
  template_param_levels : list (option Univ.Level.t);
  template_level : Univ.Universe.t }.

Inductive declaration_arity (a b : Type) : Type :=
| RegularArity : a -&gt; declaration_arity a b
| TemplateArity : b -&gt; declaration_arity a b.

Arguments RegularArity {_ _}.
Arguments TemplateArity {_ _}.

Definition inline := option Z.

Inductive constant_def (a opaque : Type) : Type :=
| Undef : inline -&gt; constant_def a opaque
| Def : a -&gt; constant_def a opaque
| OpaqueDef : opaque -&gt; constant_def a opaque
| Primitive : CPrimitives.t -&gt; constant_def a opaque.

Arguments Undef {_ _}.
Arguments Def {_ _}.
Arguments OpaqueDef {_ _}.
Arguments Primitive {_ _}.

Inductive universes : Type :=
| Monomorphic : Univ.ContextSet.t -&gt; universes
| Polymorphic : Univ.AUContext.t -&gt; universes.

Record typing_flags := {
  check_guarded : bool;
  check_positive : bool;
  check_universes : bool;
  conv_oracle : Conv_oracle.oracle;
  share_reduction : bool;
  enable_VM : bool;
  enable_native_compiler : bool;
  indices_matter : bool;
  check_template : bool }.

Record constant_body {opaque : Type} := {
  const_hyps : Constr.named_context;
  const_body : constant_def (Mod_subst.substituted Constr.t) opaque;
  const_type : Constr.types;
  const_relevance : Sorts.relevance;
  const_body_code : option Cemitcodes.to_patch_substituted;
  const_universes : universes;
  const_inline_code : bool;
  const_typing_flags : typing_flags }.
Arguments constant_body : clear implicits.

Inductive recarg : Type :=
| Norec : recarg
| Mrec : Names.inductive -&gt; recarg
| Imbr : Names.inductive -&gt; recarg.

Definition wf_paths := Rtree.t recarg.

Inductive record_info : Type :=
| NotRecord : record_info
| FakeRecord : record_info
| PrimRecord :
  (array
    (Names.Id.t * (array Names.Label.t) * (array Sorts.relevance) *
      (array Constr.types))) -&gt; record_info.

Record regular_inductive_arity := {
  mind_user_arity : Constr.types;
  mind_sort : Sorts.t }.

Definition inductive_arity :=
  declaration_arity regular_inductive_arity template_arity.

Record one_inductive_body := {
  mind_typename : Names.Id.t;
  mind_arity_ctxt : Constr.rel_context;
  mind_arity : inductive_arity;
  mind_consnames : array Names.Id.t;
  mind_user_lc : array Constr.types;
  mind_nrealargs : Z;
  mind_nrealdecls : Z;
  mind_kelim : Sorts.family;
  mind_nf_lc : array (Constr.rel_context * Constr.types);
  mind_consnrealargs : array Z;
  mind_consnrealdecls : array Z;
  mind_recargs : wf_paths;
  mind_relevance : Sorts.relevance;
  mind_nb_constant : Z;
  mind_nb_args : Z;
  mind_reloc_tbl : Vmvalues.reloc_table }.

Inductive recursivity_kind : Type :=
| Finite : recursivity_kind
| CoFinite : recursivity_kind
| BiFinite : recursivity_kind.

Record mutual_inductive_body := {
  mind_packets : array one_inductive_body;
  mind_record : record_info;
  mind_finite : recursivity_kind;
  mind_ntypes : Z;
  mind_hyps : Constr.named_context;
  mind_nparams : Z;
  mind_nparams_rec : Z;
  mind_params_ctxt : Constr.rel_context;
  mind_universes : universes;
  mind_variance : option (array Univ.Variance.t);
  mind_private : option bool;
  mind_typing_flags : typing_flags }.

Inductive functorize (ty a : Type) : Type :=
| NoFunctor : a -&gt; functorize ty a
| MoreFunctor : Names.MBId.t -&gt; ty -&gt; (functorize ty a) -&gt; functorize ty a.

Arguments NoFunctor {_ _}.
Arguments MoreFunctor {_ _}.

Inductive with_declaration : Type :=
| WithMod : (list Names.Id.t) -&gt; Names.ModPath.t -&gt; with_declaration
| WithDef : (list Names.Id.t) -&gt; (Constr.constr * (option Univ.AUContext.t)) -&gt;
  with_declaration.

Inductive module_alg_expr : Type :=
| MEident : Names.ModPath.t -&gt; module_alg_expr
| MEapply : module_alg_expr -&gt; Names.ModPath.t -&gt; module_alg_expr
| MEwith : module_alg_expr -&gt; with_declaration -&gt; module_alg_expr.

Reserved Notation &quot;'structure_body&quot;.
Reserved Notation &quot;'module_signature&quot;.
Reserved Notation &quot;'module_expression&quot;.
Reserved Notation &quot;'module_body&quot;.
Reserved Notation &quot;'module_type_body&quot;.

Inductive structure_field_body : Type :=
| SFBconst : (constant_body Opaqueproof.opaque) -&gt; structure_field_body
| SFBmind : mutual_inductive_body -&gt; structure_field_body
| SFBmodule : 'module_body -&gt; structure_field_body
| SFBmodtype : 'module_type_body -&gt; structure_field_body

with module_implementation : Type :=
| Abstract : module_implementation
| Algebraic : 'module_expression -&gt; module_implementation
| Struct : 'module_signature -&gt; module_implementation
| FullStruct : module_implementation

with module_retroknowledge : forall (_ : Type), Type :=
| ModBodyRK : (list Retroknowledge.action) -&gt;
  module_retroknowledge module_implementation
| ModTypeRK : module_retroknowledge unit

where &quot;'structure_body&quot; := ( list (Names.Label.t * structure_field_body))

and &quot;'module_signature&quot; := ( functorize 'module_type_body 'structure_body)

and &quot;'module_expression&quot; := ( functorize 'module_type_body module_alg_expr)

and &quot;'module_body&quot; := ( generic_module_body module_implementation)

and &quot;'module_type_body&quot; := ( generic_module_body unit).

Definition structure_body := 'structure_body.
Definition module_signature := 'module_signature.
Definition module_expression := 'module_expression.
Definition module_body := 'module_body.
Definition module_type_body := 'module_type_body.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="declareops" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>declareops.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Declarations
open Mod_subst
open Util

module RelDecl = Context.Rel.Declaration

(** Operations concernings types in [Declarations] :
    [constant_body], [mutual_inductive_body], [module_body] ... *)

let safe_flags oracle = {
  check_guarded = true;
  check_positive = true;
  check_universes = true;
  conv_oracle = oracle;
  share_reduction = true;
  enable_VM = true;
  enable_native_compiler = true;
  indices_matter = true;
  check_template = true;
}

(** {6 Arities } *)

let subst_decl_arity f g sub ar = 
  match ar with
  | RegularArity x -&gt; 
    let x' = f sub x in 
      if x' == x then ar
      else RegularArity x'
  | TemplateArity x -&gt; 
    let x' = g sub x in 
      if x' == x then ar
      else TemplateArity x'

let map_decl_arity f g = function
  | RegularArity a -&gt; RegularArity (f a)
  | TemplateArity a -&gt; TemplateArity (g a)

let hcons_template_arity ar =
  { template_param_levels = ar.template_param_levels;
      (* List.Smart.map (Option.Smart.map Univ.hcons_univ_level) ar.template_param_levels; *)
    template_level = Univ.hcons_univ ar.template_level }

let universes_context = function
  | Monomorphic _ -&gt; Univ.AUContext.empty
  | Polymorphic ctx -&gt; ctx

let abstract_universes = function
  | Entries.Monomorphic_entry ctx -&gt;
    Univ.empty_level_subst, Monomorphic ctx
  | Entries.Polymorphic_entry (nas, ctx) -&gt;
    let (inst, auctx) = Univ.abstract_universes nas ctx in
    let inst = Univ.make_instance_subst inst in
    (inst, Polymorphic auctx)

(** {6 Constants } *)

let constant_is_polymorphic cb =
  match cb.const_universes with
  | Monomorphic _ -&gt; false
  | Polymorphic _ -&gt; true


let constant_has_body cb = match cb.const_body with
  | Undef _ | Primitive _ -&gt; false
  | Def _ | OpaqueDef _ -&gt; true

let constant_polymorphic_context cb =
  universes_context cb.const_universes

let is_opaque cb = match cb.const_body with
  | OpaqueDef _ -&gt; true
  | Undef _ | Def _ | Primitive _ -&gt; false

(** {7 Constant substitutions } *)

let subst_rel_declaration sub =
  RelDecl.map_constr (subst_mps sub)

let subst_rel_context sub = List.Smart.map (subst_rel_declaration sub)

let subst_const_type sub arity =
  if is_empty_subst sub then arity
  else subst_mps sub arity

(** No need here to check for physical equality after substitution,
    at least for Def due to the delayed substitution [subst_constr_subst]. *)
let subst_const_def sub def = match def with
  | Undef _ | Primitive _ -&gt; def
  | Def c -&gt; Def (subst_constr sub c)
  | OpaqueDef o -&gt; OpaqueDef (Opaqueproof.subst_opaque sub o)

let subst_const_body sub cb =
  assert (List.is_empty cb.const_hyps); (* we're outside sections *)
  if is_empty_subst sub then cb
  else
    let body' = subst_const_def sub cb.const_body in
    let type' = subst_const_type sub cb.const_type in
    if body' == cb.const_body &amp;&amp; type' == cb.const_type
    then cb
    else
      { const_hyps = [];
        const_body = body';
        const_type = type';
        const_body_code =
          Option.map (Cemitcodes.subst_to_patch_subst sub) cb.const_body_code;
        const_universes = cb.const_universes;
        const_relevance = cb.const_relevance;
        const_inline_code = cb.const_inline_code;
        const_typing_flags = cb.const_typing_flags }

(** {7 Hash-consing of constants } *)

(** This hash-consing is currently quite partial : we only
    share internal fields (e.g. constr), and not the records
    themselves. But would it really bring substantial gains ? *)

let hcons_rel_decl =
  RelDecl.map_name Names.Name.hcons %&gt; RelDecl.map_value Constr.hcons %&gt; RelDecl.map_type Constr.hcons

let hcons_rel_context l = List.Smart.map hcons_rel_decl l

let hcons_const_def = function
  | Undef inl -&gt; Undef inl
  | Primitive p -&gt; Primitive p
  | Def l_constr -&gt;
    let constr = force_constr l_constr in
    Def (from_val (Constr.hcons constr))
  | OpaqueDef _ as x -&gt; x (* hashconsed when turned indirect *)

let hcons_universes cbu =
  match cbu with
  | Monomorphic ctx -&gt;
    Monomorphic (Univ.hcons_universe_context_set ctx)
  | Polymorphic ctx -&gt;
    Polymorphic (Univ.hcons_abstract_universe_context ctx)

let hcons_const_body cb =
  { cb with
    const_body = hcons_const_def cb.const_body;
    const_type = Constr.hcons cb.const_type;
    const_universes = hcons_universes cb.const_universes;
  }

(** {6 Inductive types } *)

let eq_recarg r1 r2 = match r1, r2 with
| Norec, Norec -&gt; true
| Mrec i1, Mrec i2 -&gt; Names.eq_ind i1 i2
| Imbr i1, Imbr i2 -&gt; Names.eq_ind i1 i2
| _ -&gt; false

let subst_recarg sub r = match r with
  | Norec -&gt; r
  | Mrec (kn,i) -&gt;
    let kn' = subst_mind sub kn in
    if kn==kn' then r else Mrec (kn',i)
  | Imbr (kn,i) -&gt;
    let kn' = subst_mind sub kn in
    if kn==kn' then r else Imbr (kn',i)

let mk_norec = Rtree.mk_node Norec [||]

let mk_paths r recargs =
  Rtree.mk_node r
    (Array.map (fun l -&gt; Rtree.mk_node Norec (Array.of_list l)) recargs)

let dest_recarg p = fst (Rtree.dest_node p)

(* dest_subterms returns the sizes of each argument of each constructor of
   an inductive object of size [p]. This should never be done for Norec,
   because the number of sons does not correspond to the number of
   constructors.
 *)
let dest_subterms p =
  let (ra,cstrs) = Rtree.dest_node p in
  assert (match ra with Norec -&gt; false | _ -&gt; true);
  Array.map (fun t -&gt; Array.to_list (snd (Rtree.dest_node t))) cstrs

let recarg_length p j =
  let (_,cstrs) = Rtree.dest_node p in
  Array.length (snd (Rtree.dest_node cstrs.(j-1)))

let subst_wf_paths sub p = Rtree.Smart.map (subst_recarg sub) p

(** {7 Substitution of inductive declarations } *)

let subst_regular_ind_arity sub s =
  let uar' = subst_mps sub s.mind_user_arity in
    if uar' == s.mind_user_arity then s 
    else { mind_user_arity = uar'; mind_sort = s.mind_sort }

let subst_template_ind_arity _sub s = s

(* FIXME records *)
let subst_ind_arity =
  subst_decl_arity subst_regular_ind_arity subst_template_ind_arity

let subst_mind_packet sub mbp =
  { mind_consnames = mbp.mind_consnames;
    mind_consnrealdecls = mbp.mind_consnrealdecls;
    mind_consnrealargs = mbp.mind_consnrealargs;
    mind_typename = mbp.mind_typename;
    mind_nf_lc = Array.Smart.map (fun (ctx, c) -&gt; Context.Rel.map (subst_mps sub) ctx, subst_mps sub c) mbp.mind_nf_lc;
    mind_arity_ctxt = subst_rel_context sub mbp.mind_arity_ctxt;
    mind_arity = subst_ind_arity sub mbp.mind_arity;
    mind_user_lc = Array.Smart.map (subst_mps sub) mbp.mind_user_lc;
    mind_nrealargs = mbp.mind_nrealargs;
    mind_nrealdecls = mbp.mind_nrealdecls;
    mind_kelim = mbp.mind_kelim;
    mind_recargs = subst_wf_paths sub mbp.mind_recargs (*wf_paths*);
    mind_relevance = mbp.mind_relevance;
    mind_nb_constant = mbp.mind_nb_constant;
    mind_nb_args = mbp.mind_nb_args;
    mind_reloc_tbl = mbp.mind_reloc_tbl }

let subst_mind_record sub r = match r with
| NotRecord -&gt; NotRecord
| FakeRecord -&gt; FakeRecord
| PrimRecord infos -&gt;
  let map (id, ps, rs, pb as info) =
    let pb' = Array.Smart.map (subst_mps sub) pb in
    if pb' == pb then info
    else (id, ps, rs, pb')
  in
  let infos' = Array.Smart.map map infos in
  if infos' == infos then r else PrimRecord infos'

let subst_mind_body sub mib =
  { mind_record = subst_mind_record sub mib.mind_record ;
    mind_finite = mib.mind_finite ;
    mind_ntypes = mib.mind_ntypes ;
    mind_hyps = (match mib.mind_hyps with [] -&gt; [] | _ -&gt; assert false);
    mind_nparams = mib.mind_nparams;
    mind_nparams_rec = mib.mind_nparams_rec;
    mind_params_ctxt =
      Context.Rel.map (subst_mps sub) mib.mind_params_ctxt;
    mind_packets = Array.Smart.map (subst_mind_packet sub) mib.mind_packets ;
    mind_universes = mib.mind_universes;
    mind_variance = mib.mind_variance;
    mind_private = mib.mind_private;
    mind_typing_flags = mib.mind_typing_flags;
  }

let inductive_polymorphic_context mib =
  universes_context mib.mind_universes

let inductive_is_polymorphic mib =
  match mib.mind_universes with
  | Monomorphic _ -&gt; false
  | Polymorphic _ctx -&gt; true

let inductive_is_cumulative mib =
  Option.has_some mib.mind_variance

let inductive_make_projection ind mib ~proj_arg =
  match mib.mind_record with
  | NotRecord | FakeRecord -&gt; None
  | PrimRecord infos -&gt;
    let _, labs, _, _ = infos.(snd ind) in
    Some (Names.Projection.Repr.make ind
            ~proj_npars:mib.mind_nparams
            ~proj_arg
            labs.(proj_arg))

let inductive_make_projections ind mib =
  match mib.mind_record with
  | NotRecord | FakeRecord -&gt; None
  | PrimRecord infos -&gt;
    let _, labs, _, _ = infos.(snd ind) in
    let projs = Array.mapi (fun proj_arg lab -&gt;
        Names.Projection.Repr.make ind ~proj_npars:mib.mind_nparams ~proj_arg lab)
        labs
    in
    Some projs

let relevance_of_projection_repr mib p =
  let _mind,i = Names.Projection.Repr.inductive p in
  match mib.mind_record with
  | NotRecord | FakeRecord -&gt;
    CErrors.anomaly ~label:&quot;relevance_of_projection&quot; Pp.(str &quot;not a projection&quot;)
  | PrimRecord infos -&gt;
    let _,_,rs,_ = infos.(i) in
    rs.(Names.Projection.Repr.arg p)

(** {6 Hash-consing of inductive declarations } *)

let hcons_regular_ind_arity a =
  { mind_user_arity = Constr.hcons a.mind_user_arity;
    mind_sort = Sorts.hcons a.mind_sort }

(** Just as for constants, this hash-consing is quite partial *)

let hcons_ind_arity =
  map_decl_arity hcons_regular_ind_arity hcons_template_arity

(** Substitution of inductive declarations *)

let hcons_mind_packet oib =
  let user = Array.Smart.map Constr.hcons oib.mind_user_lc in
  let map (ctx, c) = Context.Rel.map Constr.hcons ctx, Constr.hcons c in
  let nf = Array.Smart.map map oib.mind_nf_lc in
  { oib with
    mind_typename = Names.Id.hcons oib.mind_typename;
    mind_arity_ctxt = hcons_rel_context oib.mind_arity_ctxt;
    mind_arity = hcons_ind_arity oib.mind_arity;
    mind_consnames = Array.Smart.map Names.Id.hcons oib.mind_consnames;
    mind_user_lc = user;
    mind_nf_lc = nf }

let hcons_mind mib =
  { mib with
    mind_packets = Array.Smart.map hcons_mind_packet mib.mind_packets;
    mind_params_ctxt = hcons_rel_context mib.mind_params_ctxt;
    mind_universes = hcons_universes mib.mind_universes }

(** Hashconsing of modules *)

let hcons_functorize hty he hself f = match f with
| NoFunctor e -&gt;
  let e' = he e in
  if e == e' then f else NoFunctor e'
| MoreFunctor (mid, ty, nf) -&gt;
  (** FIXME *)
  let mid' = mid in
  let ty' = hty ty in
  let nf' = hself nf in
  if mid == mid' &amp;&amp; ty == ty' &amp;&amp; nf == nf' then f
  else MoreFunctor (mid, ty', nf')

let hcons_module_alg_expr me = me

let rec hcons_structure_field_body sb = match sb with
| SFBconst cb -&gt;
  let cb' = hcons_const_body cb in
  if cb == cb' then sb else SFBconst cb'
| SFBmind mib -&gt;
  let mib' = hcons_mind mib in
  if mib == mib' then sb else SFBmind mib'
| SFBmodule mb -&gt;
  let mb' = hcons_module_body mb in
  if mb == mb' then sb else SFBmodule mb'
| SFBmodtype mb -&gt;
  let mb' = hcons_module_type mb in
  if mb == mb' then sb else SFBmodtype mb'

and hcons_structure_body sb =
  (** FIXME *)
  let map (l, sfb as fb) =
    let l' = Names.Label.hcons l in
    let sfb' = hcons_structure_field_body sfb in
    if l == l' &amp;&amp; sfb == sfb' then fb else (l', sfb')
  in
  List.Smart.map map sb

and hcons_module_signature ms =
  hcons_functorize hcons_module_type hcons_structure_body hcons_module_signature ms

and hcons_module_expression me =
  hcons_functorize hcons_module_type hcons_module_alg_expr hcons_module_expression me

and hcons_module_implementation mip = match mip with
| Abstract -&gt; Abstract
| Algebraic me -&gt;
  let me' = hcons_module_expression me in
  if me == me' then mip else Algebraic me'
| Struct ms -&gt;
  let ms' = hcons_module_signature ms in
  if ms == ms' then mip else Struct ms
| FullStruct -&gt; FullStruct

and hcons_generic_module_body :
  'a. ('a -&gt; 'a) -&gt; 'a generic_module_body -&gt; 'a generic_module_body =
  fun hcons_impl mb -&gt;
  let mp' = mb.mod_mp in
  let expr' = hcons_impl mb.mod_expr in
  let type' = hcons_module_signature mb.mod_type in
  let type_alg' = mb.mod_type_alg in
  let constraints' = Univ.hcons_universe_context_set mb.mod_constraints in
  let delta' = mb.mod_delta in
  let retroknowledge' = mb.mod_retroknowledge in

  if
    mb.mod_mp == mp' &amp;&amp;
    mb.mod_expr == expr' &amp;&amp;
    mb.mod_type == type' &amp;&amp;
    mb.mod_type_alg == type_alg' &amp;&amp;
    mb.mod_constraints == constraints' &amp;&amp;
    mb.mod_delta == delta' &amp;&amp;
    mb.mod_retroknowledge == retroknowledge'
  then mb
  else {
    mod_mp = mp';
    mod_expr = expr';
    mod_type = type';
    mod_type_alg = type_alg';
    mod_constraints = constraints';
    mod_delta = delta';
    mod_retroknowledge = retroknowledge';
  }

and hcons_module_body mb =
  hcons_generic_module_body hcons_module_implementation mb

and hcons_module_type mb =
  hcons_generic_module_body (fun () -&gt; ()) mb
</pre>
          </div>
          <div class="col-md-6">
            <code>declareops.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Declarations.

Import Mod_subst.

Import Util.

Definition safe_flags (oracle : Conv_oracle.oracle)
  : Declarations.typing_flags :=
  {| check_guarded := true; check_positive := true; check_universes := true;
    conv_oracle := oracle; share_reduction := true; enable_VM := true;
    enable_native_compiler := true; indices_matter := true;
    check_template := true |}.

Definition subst_decl_arity {A B C : Type}
  (f : A -&gt; B -&gt; B) (g : A -&gt; C -&gt; C) (sub : A)
  (ar : Declarations.declaration_arity B C)
  : Declarations.declaration_arity B C :=
  match ar with
  | RegularArity x =&gt;
    let x' := f sub x in
    if Stdlib.op_eq_eq x' x then
      ar
    else
      RegularArity x'
  | TemplateArity x =&gt;
    let x' := g sub x in
    if Stdlib.op_eq_eq x' x then
      ar
    else
      TemplateArity x'
  end.

Definition map_decl_arity {A B C D : Type}
  (f : A -&gt; B) (g : C -&gt; D)
  (function_parameter : Declarations.declaration_arity A C)
  : Declarations.declaration_arity B D :=
  match function_parameter with
  | RegularArity a =&gt; RegularArity (f a)
  | TemplateArity a =&gt; TemplateArity (g a)
  end.

Definition hcons_template_arity (ar : Declarations.template_arity)
  : Declarations.template_arity :=
  {| template_param_levels := template_param_levels ar;
    template_level := Univ.hcons_univ (template_level ar) |}.

Definition universes_context (function_parameter : Declarations.universes)
  : Univ.AUContext.t :=
  match function_parameter with
  | Monomorphic _ =&gt; Univ.AUContext.empty
  | Polymorphic ctx =&gt; ctx
  end.

Definition abstract_universes (function_parameter : Entries.universes_entry)
  : Univ.universe_level_subst * Declarations.universes :=
  match function_parameter with
  | Entries.Monomorphic_entry ctx =&gt; (Univ.empty_level_subst, (Monomorphic ctx))
  | Entries.Polymorphic_entry nas ctx =&gt;
    match Univ.abstract_universes nas ctx with
    | (inst, auctx) =&gt;
      let inst := Univ.make_instance_subst inst in
      (inst, (Polymorphic auctx))
    end
  end.

Definition constant_is_polymorphic {A : Type}
  (cb : Declarations.constant_body A) : bool :=
  match const_universes cb with
  | Monomorphic _ =&gt; false
  | Polymorphic _ =&gt; true
  end.

Definition constant_has_body {A : Type} (cb : Declarations.constant_body A)
  : bool :=
  match const_body cb with
  | Undef _ | Primitive _ =&gt; false
  | Def _ | OpaqueDef _ =&gt; true
  end.

Definition constant_polymorphic_context {A : Type}
  (cb : Declarations.constant_body A) : Univ.AUContext.t :=
  universes_context (const_universes cb).

Definition is_opaque {A : Type} (cb : Declarations.constant_body A) : bool :=
  match const_body cb with
  | OpaqueDef _ =&gt; true
  | Undef _ | Def _ | Primitive _ =&gt; false
  end.

Definition subst_rel_declaration (sub : Mod_subst.substitution)
  : (RelDecl.pt Constr.constr Constr.constr) -&gt;
    RelDecl.pt Constr.constr Constr.constr :=
  RelDecl.map_constr (Mod_subst.subst_mps sub).

Definition subst_rel_context (sub : Mod_subst.substitution)
  : (list (RelDecl.pt Constr.constr Constr.constr)) -&gt;
    list (RelDecl.pt Constr.constr Constr.constr) :=
  Util.List.Smart.map (subst_rel_declaration sub).

Definition subst_const_type
  (sub : Mod_subst.substitution) (arity : Constr.constr) : Constr.constr :=
  if Mod_subst.is_empty_subst sub then
    arity
  else
    Mod_subst.subst_mps sub arity.

Definition subst_const_def
  (sub : Mod_subst.substitution)
  (def :
    Declarations.constant_def (Mod_subst.substituted Constr.constr)
      Opaqueproof.opaque)
  : Declarations.constant_def (Mod_subst.substituted Constr.constr)
    Opaqueproof.opaque :=
  match def with
  | Undef _ | Primitive _ =&gt; def
  | Def c =&gt; Def (Mod_subst.subst_constr sub c)
  | OpaqueDef o =&gt; OpaqueDef (Opaqueproof.subst_opaque sub o)
  end.

Definition subst_const_body
  (sub : Mod_subst.substitution)
  (cb : Declarations.constant_body Opaqueproof.opaque)
  : Declarations.constant_body Opaqueproof.opaque :=
  Util.List.(CList.ExtS.is_empty) (const_hyps cb);
  if Mod_subst.is_empty_subst sub then
    cb
  else
    let body' := subst_const_def sub (const_body cb) in
    let type' := subst_const_type sub (const_type cb) in
    if
      andb (Stdlib.op_eq_eq body' (const_body cb))
        (Stdlib.op_eq_eq type' (const_type cb)) then
      cb
    else
      {| const_hyps := []; const_body := body'; const_type := type';
        const_relevance := const_relevance cb;
        const_body_code :=
          Option.map (Cemitcodes.subst_to_patch_subst sub) (const_body_code cb);
        const_universes := const_universes cb;
        const_inline_code := const_inline_code cb;
        const_typing_flags := const_typing_flags cb |}.

Definition hcons_rel_decl
  : (RelDecl.pt Constr.constr Constr.constr) -&gt;
    RelDecl.pt Constr.constr Constr.constr :=
  Util.op_percent_gt
    (Util.op_percent_gt (RelDecl.map_name Names.Name.hcons)
      (RelDecl.map_value Constr.hcons)) (RelDecl.map_type Constr.hcons).

Definition hcons_rel_context (l : list (RelDecl.pt Constr.constr Constr.constr))
  : list (RelDecl.pt Constr.constr Constr.constr) :=
  Util.List.Smart.map hcons_rel_decl l.

Definition hcons_const_def {A : Type}
  (function_parameter :
    Declarations.constant_def (Mod_subst.substituted Constr.constr) A)
  : Declarations.constant_def (Mod_subst.substituted Constr.constr) A :=
  match function_parameter with
  | Undef inl =&gt; Undef inl
  | Primitive p =&gt; Primitive p
  | Def l_constr =&gt;
    let constr := Mod_subst.force_constr l_constr in
    Def (Mod_subst.from_val (Constr.hcons constr))
  | (OpaqueDef _) as x =&gt; x
  end.

Definition hcons_universes (cbu : Declarations.universes)
  : Declarations.universes :=
  match cbu with
  | Monomorphic ctx =&gt; Monomorphic (Univ.hcons_universe_context_set ctx)
  | Polymorphic ctx =&gt; Polymorphic (Univ.hcons_abstract_universe_context ctx)
  end.

Definition hcons_const_body {A : Type} (cb : Declarations.constant_body A)
  : Declarations.constant_body A := record.

Definition eq_recarg (r1 : Declarations.recarg) (r2 : Declarations.recarg)
  : bool :=
  match (r1, r2) with
  | (Norec, Norec) =&gt; true
  | (Mrec i1, Mrec i2) =&gt; Names.eq_ind i1 i2
  | (Imbr i1, Imbr i2) =&gt; Names.eq_ind i1 i2
  | _ =&gt; false
  end.

Definition subst_recarg (sub : Mod_subst.substitution) (r : Declarations.recarg)
  : Declarations.recarg :=
  match r with
  | Norec =&gt; r
  | Mrec (kn, i) =&gt;
    let kn' := Mod_subst.subst_mind sub kn in
    if Stdlib.op_eq_eq kn kn' then
      r
    else
      Mrec (kn', i)
  | Imbr (kn, i) =&gt;
    let kn' := Mod_subst.subst_mind sub kn in
    if Stdlib.op_eq_eq kn kn' then
      r
    else
      Imbr (kn', i)
  end.

Definition mk_norec : Rtree.t Declarations.recarg := Rtree.mk_node Norec tt.

Definition mk_paths
  (r : Declarations.recarg)
  (recargs : array (list (Rtree.t Declarations.recarg)))
  : Rtree.t Declarations.recarg :=
  Rtree.mk_node r
    (Util.Array.(CArray.ExtS.map)
      (fun l =&gt; Rtree.mk_node Norec (Util.Array.(CArray.ExtS.of_list) l))
      recargs).

Definition dest_recarg {A : Type} (p : Rtree.t A) : A := fst (Rtree.dest_node p).

Definition dest_subterms (p : Rtree.t Declarations.recarg)
  : array (list (Rtree.t Declarations.recarg)) :=
  match Rtree.dest_node p with
  | (ra, cstrs) =&gt;
    match ra with
    | Norec =&gt; false
    | _ =&gt; true
    end;
    Util.Array.(CArray.ExtS.map)
      (fun t =&gt; Util.Array.(CArray.ExtS.to_list) (snd (Rtree.dest_node t)))
      cstrs
  end.

Definition recarg_length {A : Type} (p : Rtree.t A) (j : Z) : Z :=
  match Rtree.dest_node p with
  | (_, cstrs) =&gt;
    Util.Array.(CArray.ExtS.length)
      (snd
        (Rtree.dest_node
          (Util.Array.(CArray.ExtS.get) cstrs (Util.op_minus j 1))))
  end.

Definition subst_wf_paths
  (sub : Mod_subst.substitution) (p : Rtree.t Declarations.recarg)
  : Rtree.t Declarations.recarg := Rtree.Smart.map (subst_recarg sub) p.

Definition subst_regular_ind_arity
  (sub : Mod_subst.substitution) (s : Declarations.regular_inductive_arity)
  : Declarations.regular_inductive_arity :=
  let uar' := Mod_subst.subst_mps sub (mind_user_arity s) in
  if Stdlib.op_eq_eq uar' (mind_user_arity s) then
    s
  else
    {| mind_user_arity := uar'; mind_sort := mind_sort s |}.

Definition subst_template_ind_arity {A B : Type} (_sub : A) (s : B) : B := s.

Definition subst_ind_arity
  : Mod_subst.substitution -&gt;
    (Declarations.declaration_arity Declarations.regular_inductive_arity
      Declarations.template_arity) -&gt;
      Declarations.declaration_arity Declarations.regular_inductive_arity
        Declarations.template_arity :=
  subst_decl_arity subst_regular_ind_arity subst_template_ind_arity.

Definition subst_mind_packet
  (sub : Mod_subst.substitution) (mbp : Declarations.one_inductive_body)
  : Declarations.one_inductive_body :=
  {| mind_typename := mind_typename mbp;
    mind_arity_ctxt := subst_rel_context sub (mind_arity_ctxt mbp);
    mind_arity := subst_ind_arity sub (mind_arity mbp);
    mind_consnames := mind_consnames mbp;
    mind_user_lc :=
      Util.Array.Smart.map (Mod_subst.subst_mps sub) (mind_user_lc mbp);
    mind_nrealargs := mind_nrealargs mbp;
    mind_nrealdecls := mind_nrealdecls mbp; mind_kelim := mind_kelim mbp;
    mind_nf_lc :=
      Util.Array.Smart.map
        (fun function_parameter =&gt;
          match function_parameter with
          | (ctx, c) =&gt;
            ((Context.Rel.map (Mod_subst.subst_mps sub) ctx),
              (Mod_subst.subst_mps sub c))
          end) (mind_nf_lc mbp); mind_consnrealargs := mind_consnrealargs mbp;
    mind_consnrealdecls := mind_consnrealdecls mbp;
    mind_recargs := subst_wf_paths sub (mind_recargs mbp);
    mind_relevance := mind_relevance mbp;
    mind_nb_constant := mind_nb_constant mbp; mind_nb_args := mind_nb_args mbp;
    mind_reloc_tbl := mind_reloc_tbl mbp |}.

Definition subst_mind_record
  (sub : Mod_subst.substitution) (r : Declarations.record_info)
  : Declarations.record_info :=
  match r with
  | NotRecord =&gt; NotRecord
  | FakeRecord =&gt; FakeRecord
  | PrimRecord infos =&gt;
    let map {A B C : Type}
      (function_parameter : A * B * C * (array Constr.constr))
      : A * B * C * (array Constr.constr) :=
      match function_parameter with
      | (id, ps, rs, pb) as info =&gt;
        let pb' := Util.Array.Smart.map (Mod_subst.subst_mps sub) pb in
        if Stdlib.op_eq_eq pb' pb then
          info
        else
          (id, ps, rs, pb')
      end in
    let infos' := Util.Array.Smart.map map infos in
    if Stdlib.op_eq_eq infos' infos then
      r
    else
      PrimRecord infos'
  end.

Definition subst_mind_body
  (sub : Mod_subst.substitution) (mib : Declarations.mutual_inductive_body)
  : Declarations.mutual_inductive_body :=
  {|
    mind_packets :=
      Util.Array.Smart.map (subst_mind_packet sub) (mind_packets mib);
    mind_record := subst_mind_record sub (mind_record mib);
    mind_finite := mind_finite mib; mind_ntypes := mind_ntypes mib;
    mind_hyps :=
      match mind_hyps mib with
      | [] =&gt; []
      | _ =&gt; false
      end; mind_nparams := mind_nparams mib;
    mind_nparams_rec := mind_nparams_rec mib;
    mind_params_ctxt :=
      Context.Rel.map (Mod_subst.subst_mps sub) (mind_params_ctxt mib);
    mind_universes := mind_universes mib; mind_variance := mind_variance mib;
    mind_private := mind_private mib; mind_typing_flags := mind_typing_flags mib
    |}.

Definition inductive_polymorphic_context
  (mib : Declarations.mutual_inductive_body) : Univ.AUContext.t :=
  universes_context (mind_universes mib).

Definition inductive_is_polymorphic (mib : Declarations.mutual_inductive_body)
  : bool :=
  match mind_universes mib with
  | Monomorphic _ =&gt; false
  | Polymorphic _ctx =&gt; true
  end.

Definition inductive_is_cumulative (mib : Declarations.mutual_inductive_body)
  : bool := Option.has_some (mind_variance mib).

Definition inductive_make_projection
  (ind : Names.inductive) (mib : Declarations.mutual_inductive_body)
  (proj_arg : Z) : option Names.Projection.Repr.t :=
  match mind_record mib with
  | NotRecord | FakeRecord =&gt; None
  | PrimRecord infos =&gt;
    match Util.Array.(CArray.ExtS.get) infos (snd ind) with
    | (_, labs, _, _) =&gt;
      Some
        (Names.Projection.Repr.make ind (mind_nparams mib) proj_arg
          (Util.Array.(CArray.ExtS.get) labs proj_arg))
    end
  end.

Definition inductive_make_projections
  (ind : Names.inductive) (mib : Declarations.mutual_inductive_body)
  : option (array Names.Projection.Repr.t) :=
  match mind_record mib with
  | NotRecord | FakeRecord =&gt; None
  | PrimRecord infos =&gt;
    match Util.Array.(CArray.ExtS.get) infos (snd ind) with
    | (_, labs, _, _) =&gt;
      let projs :=
        Util.Array.(CArray.ExtS.mapi)
          (fun proj_arg =&gt;
            fun lab =&gt;
              Names.Projection.Repr.make ind (mind_nparams mib) proj_arg lab)
          labs in
      Some projs
    end
  end.

Definition relevance_of_projection_repr
  (mib : Declarations.mutual_inductive_body) (p : Names.Projection.Repr.t)
  : Sorts.relevance :=
  match Names.Projection.Repr.inductive p with
  | (_mind, i) =&gt;
    match mind_record mib with
    | NotRecord | FakeRecord =&gt;
      CErrors.anomaly None (Some &quot;relevance_of_projection&quot; % string)
        (Pp.str &quot;not a projection&quot; % string)
    | PrimRecord infos =&gt;
      match Util.Array.(CArray.ExtS.get) infos i with
      | (_, _, rs, _) =&gt;
        Util.Array.(CArray.ExtS.get) rs (Names.Projection.Repr.arg p)
      end
    end
  end.

Definition hcons_regular_ind_arity (a : Declarations.regular_inductive_arity)
  : Declarations.regular_inductive_arity :=
  {| mind_user_arity := Constr.hcons (mind_user_arity a);
    mind_sort := Sorts.hcons (mind_sort a) |}.

Definition hcons_ind_arity
  : (Declarations.declaration_arity Declarations.regular_inductive_arity
    Declarations.template_arity) -&gt;
    Declarations.declaration_arity Declarations.regular_inductive_arity
      Declarations.template_arity :=
  map_decl_arity hcons_regular_ind_arity hcons_template_arity.

Definition hcons_mind_packet (oib : Declarations.one_inductive_body)
  : Declarations.one_inductive_body :=
  let user := Util.Array.Smart.map Constr.hcons (mind_user_lc oib) in
  let map
    (function_parameter :
    (Context.Rel.pt Constr.constr Constr.constr) * Constr.constr)
    : (Context.Rel.pt Constr.constr Constr.constr) * Constr.constr :=
    match function_parameter with
    | (ctx, c) =&gt; ((Context.Rel.map Constr.hcons ctx), (Constr.hcons c))
    end in
  let nf := Util.Array.Smart.map map (mind_nf_lc oib) in
  record.

Definition hcons_mind (mib : Declarations.mutual_inductive_body)
  : Declarations.mutual_inductive_body := record.

Definition hcons_functorize {A B : Type}
  (hty : A -&gt; A) (he : B -&gt; B)
  (hself : (Declarations.functorize A B) -&gt; Declarations.functorize A B)
  (f : Declarations.functorize A B) : Declarations.functorize A B :=
  match f with
  | NoFunctor e =&gt;
    let e' := he e in
    if Stdlib.op_eq_eq e e' then
      f
    else
      NoFunctor e'
  | MoreFunctor mid ty nf =&gt;
    let mid' := mid in
    let ty' := hty ty in
    let nf' := hself nf in
    if
      andb (Stdlib.op_eq_eq mid mid')
        (andb (Stdlib.op_eq_eq ty ty') (Stdlib.op_eq_eq nf nf')) then
      f
    else
      MoreFunctor mid ty' nf'
  end.

Definition hcons_module_alg_expr {A : Type} (me : A) : A := me.

Fixpoint hcons_structure_field_body (sb : Declarations.structure_field_body)
  : Declarations.structure_field_body :=
  match sb with
  | SFBconst cb =&gt;
    let cb' := hcons_const_body cb in
    if Stdlib.op_eq_eq cb cb' then
      sb
    else
      SFBconst cb'
  | SFBmind mib =&gt;
    let mib' := hcons_mind mib in
    if Stdlib.op_eq_eq mib mib' then
      sb
    else
      SFBmind mib'
  | SFBmodule mb =&gt;
    let mb' := hcons_module_body mb in
    if Stdlib.op_eq_eq mb mb' then
      sb
    else
      SFBmodule mb'
  | SFBmodtype mb =&gt;
    let mb' := hcons_module_type mb in
    if Stdlib.op_eq_eq mb mb' then
      sb
    else
      SFBmodtype mb'
  end

with hcons_structure_body (sb : Declarations.structure_body)
  : Declarations.structure_body :=
  let map
    (function_parameter : Names.Label.t * Declarations.structure_field_body)
    : Names.Label.t * Declarations.structure_field_body :=
    match function_parameter with
    | (l, sfb) as fb =&gt;
      let l' := Names.Label.hcons l in
      let sfb' := hcons_structure_field_body sfb in
      if andb (Stdlib.op_eq_eq l l') (Stdlib.op_eq_eq sfb sfb') then
        fb
      else
        (l', sfb')
    end in
  Util.List.Smart.map map sb

with hcons_module_signature (ms : Declarations.module_signature)
  : Declarations.module_signature :=
  hcons_functorize hcons_module_type hcons_structure_body hcons_module_signature
    ms

with hcons_module_expression
  (me :
    Declarations.functorize Declarations.module_type_body
      Declarations.module_alg_expr)
  : Declarations.functorize Declarations.module_type_body
    Declarations.module_alg_expr :=
  hcons_functorize hcons_module_type hcons_module_alg_expr
    hcons_module_expression me

with hcons_module_implementation (mip : Declarations.module_implementation)
  : Declarations.module_implementation :=
  match mip with
  | Abstract =&gt; Abstract
  | Algebraic me =&gt;
    let me' := hcons_module_expression me in
    if Stdlib.op_eq_eq me me' then
      mip
    else
      Algebraic me'
  | Struct ms =&gt;
    let ms' := hcons_module_signature ms in
    if Stdlib.op_eq_eq ms ms' then
      mip
    else
      Struct ms
  | FullStruct =&gt; FullStruct
  end

with hcons_generic_module_body {a : Type}
  (hcons_impl : a -&gt; a) (mb : Declarations.generic_module_body a)
  : Declarations.generic_module_body a :=
  let mp' := mod_mp mb in
  let expr' := hcons_impl (mod_expr mb) in
  let type' := hcons_module_signature (mod_type mb) in
  let type_alg' := mod_type_alg mb in
  let constraints' := Univ.hcons_universe_context_set (mod_constraints mb) in
  let delta' := mod_delta mb in
  let retroknowledge' := mod_retroknowledge mb in
  if
    andb (Stdlib.op_eq_eq (mod_mp mb) mp')
      (andb (Stdlib.op_eq_eq (mod_expr mb) expr')
        (andb (Stdlib.op_eq_eq (mod_type mb) type')
          (andb (Stdlib.op_eq_eq (mod_type_alg mb) type_alg')
            (andb (Stdlib.op_eq_eq (mod_constraints mb) constraints')
              (andb (Stdlib.op_eq_eq (mod_delta mb) delta')
                (Stdlib.op_eq_eq (mod_retroknowledge mb) retroknowledge'))))))
    then
    mb
  else
    {| mod_mp := mp'; mod_expr := expr'; mod_type := type';
      mod_type_alg := type_alg'; mod_constraints := constraints';
      mod_delta := delta'; mod_retroknowledge := retroknowledge' |}

with hcons_module_body (mb : Declarations.module_body)
  : Declarations.module_body :=
  hcons_generic_module_body hcons_module_implementation mb

with hcons_module_type (mb : Declarations.module_type_body)
  : Declarations.module_type_body :=
  hcons_generic_module_body
    (fun function_parameter =&gt;
      match function_parameter with
      | tt =&gt; tt
      end) mb.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="entries" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>entries.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Constr

(** This module defines the entry types for global declarations. This
   information is entered in the environments. This includes global
   constants/axioms, mutual inductive definitions, modules and module
   types *)

type universes_entry =
  | Monomorphic_entry of Univ.ContextSet.t
  | Polymorphic_entry of Name.t array * Univ.UContext.t

type 'a in_universes_entry = 'a * universes_entry

(** {6 Declaration of inductive types. } *)

(** Assume the following definition in concrete syntax:
{v Inductive I1 (x1:X1) ... (xn:Xn) : A1 := c11 : T11 | ... | c1n1 : T1n1
...
with      Ip (x1:X1) ... (xn:Xn) : Ap := cp1 : Tp1 | ... | cpnp : Tpnp. v}

then, in i{^ th} block, [mind_entry_params] is [xn:Xn;...;x1:X1];
[mind_entry_arity] is [Ai], defined in context [x1:X1;...;xn:Xn];
[mind_entry_lc] is [Ti1;...;Tini], defined in context [[A'1;...;A'p;x1:X1;...;xn:Xn]] where [A'i] is [Ai] generalized over [[x1:X1;...;xn:Xn]].
*)

type one_inductive_entry = {
  mind_entry_typename : Id.t;
  mind_entry_arity : constr;
  mind_entry_template : bool; (* Use template polymorphism *)
  mind_entry_consnames : Id.t list;
  mind_entry_lc : constr list }

type mutual_inductive_entry = {
  mind_entry_record : (Id.t array option) option;
  (** Some (Some ids): primitive records with ids the binder name of each
      record in their respective projections. Not used by the kernel.
      Some None: non-primitive record *)
  mind_entry_finite : Declarations.recursivity_kind;
  mind_entry_params : Constr.rel_context;
  mind_entry_inds : one_inductive_entry list;
  mind_entry_universes : universes_entry;
  mind_entry_variance : Univ.Variance.t array option;
  (* universe constraints and the constraints for subtyping of
     inductive types in the block. *)
  mind_entry_private : bool option;
}

(** {6 Constants (Definition/Axiom) } *)

type definition_entry = {
  const_entry_body : constr;
  (* List of section variables *)
  const_entry_secctx : Id.Set.t option;
  (* State id on which the completion of type checking is reported *)
  const_entry_feedback : Stateid.t option;
  const_entry_type : types option;
  const_entry_universes : universes_entry;
  const_entry_inline_code : bool }

type section_def_entry = {
  secdef_body : constr;
  secdef_secctx : Id.Set.t option;
  secdef_feedback : Stateid.t option;
  secdef_type : types option;
}

type 'a opaque_entry = {
  opaque_entry_body   : 'a;
  (* List of section variables *)
  opaque_entry_secctx : Id.Set.t;
  (* State id on which the completion of type checking is reported *)
  opaque_entry_feedback : Stateid.t option;
  opaque_entry_type        : types;
  opaque_entry_universes   : universes_entry;
}

type inline = int option (* inlining level, None for no inlining *)

type parameter_entry = 
    Id.Set.t option * types in_universes_entry * inline

type primitive_entry = {
  prim_entry_type : types option;
  prim_entry_univs : Univ.ContextSet.t; (* always monomorphic *)
  prim_entry_content : CPrimitives.op_or_type;
}

type 'a proof_output = constr Univ.in_universe_context_set * 'a
type 'a const_entry_body = 'a proof_output Future.computation

type constant_entry =
  | DefinitionEntry : definition_entry -&gt; constant_entry
  | ParameterEntry : parameter_entry -&gt; constant_entry
  | PrimitiveEntry : primitive_entry -&gt; constant_entry

(** {6 Modules } *)

type module_struct_entry = Declarations.module_alg_expr

type module_params_entry =
  (MBId.t * module_struct_entry) list (** older first *)

type module_type_entry = module_params_entry * module_struct_entry

type module_entry =
  | MType of module_params_entry * module_struct_entry
  | MExpr of
      module_params_entry * module_struct_entry * module_struct_entry option
</pre>
          </div>
          <div class="col-md-6">
            <code>entries.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Names.

Import Constr.

Inductive universes_entry : Type :=
| Monomorphic_entry : Univ.ContextSet.t -&gt; universes_entry
| Polymorphic_entry : (array Names.Name.t) -&gt; Univ.UContext.t -&gt; universes_entry.

Definition in_universes_entry (a : Type) := a * universes_entry.

Record one_inductive_entry := {
  mind_entry_typename : Names.Id.t;
  mind_entry_arity : Constr.constr;
  mind_entry_template : bool;
  mind_entry_consnames : list Names.Id.t;
  mind_entry_lc : list Constr.constr }.

Record mutual_inductive_entry := {
  mind_entry_record : option (option (array Names.Id.t));
  mind_entry_finite : Declarations.recursivity_kind;
  mind_entry_params : Constr.rel_context;
  mind_entry_inds : list one_inductive_entry;
  mind_entry_universes : universes_entry;
  mind_entry_variance : option (array Univ.Variance.t);
  mind_entry_private : option bool }.

Record definition_entry := {
  const_entry_body : Constr.constr;
  const_entry_secctx : option Names.Id.Set.t;
  const_entry_feedback : option Stateid.t;
  const_entry_type : option Constr.types;
  const_entry_universes : universes_entry;
  const_entry_inline_code : bool }.

Record section_def_entry := {
  secdef_body : Constr.constr;
  secdef_secctx : option Names.Id.Set.t;
  secdef_feedback : option Stateid.t;
  secdef_type : option Constr.types }.

Record opaque_entry {a : Type} := {
  opaque_entry_body : a;
  opaque_entry_secctx : Names.Id.Set.t;
  opaque_entry_feedback : option Stateid.t;
  opaque_entry_type : Constr.types;
  opaque_entry_universes : universes_entry }.
Arguments opaque_entry : clear implicits.

Definition inline := option Z.

Definition parameter_entry :=
  (option Names.Id.Set.t) * (in_universes_entry Constr.types) * inline.

Record primitive_entry := {
  prim_entry_type : option Constr.types;
  prim_entry_univs : Univ.ContextSet.t;
  prim_entry_content : CPrimitives.op_or_type }.

Definition proof_output (a : Type) :=
  (Univ.in_universe_context_set Constr.constr) * a.

Definition const_entry_body (a : Type) := Future.computation (proof_output a).

Inductive constant_entry : Type :=
| DefinitionEntry : definition_entry -&gt; constant_entry
| ParameterEntry : parameter_entry -&gt; constant_entry
| PrimitiveEntry : primitive_entry -&gt; constant_entry.

Definition module_struct_entry := Declarations.module_alg_expr.

Definition module_params_entry := list (Names.MBId.t * module_struct_entry).

Definition module_type_entry := module_params_entry * module_struct_entry.

Inductive module_entry : Type :=
| MType : module_params_entry -&gt; module_struct_entry -&gt; module_entry
| MExpr : module_params_entry -&gt; module_struct_entry -&gt;
  (option module_struct_entry) -&gt; module_entry.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="environ" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>environ.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Author: Jean-Christophe Filli√¢tre as part of the rebuilding of Coq
   around a purely functional abstract type-checker, Aug 1999 *)
(* Cleaning and lightening of the kernel by Bruno Barras, Nov 2001 *)
(* Flag for predicativity of Set by Hugo Herbelin in Oct 2003 *)
(* Support for virtual machine by Benjamin Gr√©goire in Oct 2004 *)
(* Support for retroknowledge by Arnaud Spiwack in May 2007 *)
(* Support for assumption dependencies by Arnaud Spiwack in May 2007 *)

(* Miscellaneous maintenance by Bruno Barras, Hugo Herbelin, Jean-Marc
   Notin, Matthieu Sozeau *)

(* This file defines the type of environments on which the
   type-checker works, together with simple related functions *)

open CErrors
open Util
open Names
open Constr
open Vars
open Declarations
open Context.Rel.Declaration

module NamedDecl = Context.Named.Declaration

(* The type of environments. *)

(* The key attached to each constant is used by the VM to retrieve previous *)
(* evaluations of the constant. It is essentially an index in the symbols table *)
(* used by the VM. *)
type key = int CEphemeron.key option ref

(** Linking information for the native compiler. *)

type link_info =
  | Linked of string
  | LinkedInteractive of string
  | NotLinked

type constant_key = Opaqueproof.opaque constant_body * (link_info ref * key)

type mind_key = mutual_inductive_body * link_info ref

module Globals = struct

  type view =
    { constants : constant_key Cmap_env.t
    ; inductives : mind_key Mindmap_env.t
    ; modules : module_body MPmap.t
    ; modtypes : module_type_body MPmap.t
    }

  type t = view

  let view x = x
end

type stratification = {
  env_universes : UGraph.t;
  env_sprop_allowed : bool;
  env_universes_lbound : Univ.Level.t;
  env_engagement : engagement
}

type val_kind =
    | VKvalue of (Vmvalues.values * Id.Set.t) CEphemeron.key
    | VKnone

type lazy_val = val_kind ref

let force_lazy_val vk = match !vk with
| VKnone -&gt; None
| VKvalue v -&gt; try Some (CEphemeron.get v) with CEphemeron.InvalidKey -&gt; None

let dummy_lazy_val () = ref VKnone
let build_lazy_val vk key = vk := VKvalue (CEphemeron.create key)

type named_context_val = {
  env_named_ctx : Constr.named_context;
  env_named_map : (Constr.named_declaration * lazy_val) Id.Map.t;
}

type rel_context_val = {
  env_rel_ctx : Constr.rel_context;
  env_rel_map : (Constr.rel_declaration * lazy_val) Range.t;
}

type env = {
  env_globals       : Globals.t;
  env_named_context : named_context_val; (* section variables *)
  env_rel_context   : rel_context_val;
  env_nb_rel        : int;
  env_stratification : stratification;
  env_typing_flags  : typing_flags;
  retroknowledge : Retroknowledge.retroknowledge;
  indirect_pterms : Opaqueproof.opaquetab;
  native_symbols : Nativevalues.symbols DPmap.t;
}

let empty_named_context_val = {
  env_named_ctx = [];
  env_named_map = Id.Map.empty;
}

let empty_rel_context_val = {
  env_rel_ctx = [];
  env_rel_map = Range.empty;
}

let empty_env = {
  env_globals =
    { Globals.constants = Cmap_env.empty
    ; inductives = Mindmap_env.empty
    ; modules = MPmap.empty
    ; modtypes = MPmap.empty
    };
  env_named_context = empty_named_context_val;
  env_rel_context = empty_rel_context_val;
  env_nb_rel = 0;
  env_stratification = {
    env_universes = UGraph.initial_universes;
    env_sprop_allowed = false;
    env_universes_lbound = Univ.Level.set;
    env_engagement = PredicativeSet };
  env_typing_flags = Declareops.safe_flags Conv_oracle.empty;
  retroknowledge = Retroknowledge.empty;
  indirect_pterms = Opaqueproof.empty_opaquetab;
  native_symbols = DPmap.empty;
}


(* Rel context *)

let push_rel_context_val d ctx = {
  env_rel_ctx = Context.Rel.add d ctx.env_rel_ctx;
  env_rel_map = Range.cons (d, ref VKnone) ctx.env_rel_map;
}

let match_rel_context_val ctx = match ctx.env_rel_ctx with
| [] -&gt; None
| decl :: rem -&gt;
  let (_, lval) = Range.hd ctx.env_rel_map in
  let ctx = { env_rel_ctx = rem; env_rel_map = Range.tl ctx.env_rel_map } in
  Some (decl, lval, ctx)

let push_rel d env =
    { env with
      env_rel_context = push_rel_context_val d env.env_rel_context;
      env_nb_rel = env.env_nb_rel + 1 }

let lookup_rel n env =
  try fst (Range.get env.env_rel_context.env_rel_map (n - 1))
  with Invalid_argument _ -&gt; raise Not_found

let lookup_rel_val n env =
  try snd (Range.get env.env_rel_context.env_rel_map (n - 1))
  with Invalid_argument _ -&gt; raise Not_found

let rel_skipn n ctx = {
  env_rel_ctx = Util.List.skipn n ctx.env_rel_ctx;
  env_rel_map = Range.skipn n ctx.env_rel_map;
}

let env_of_rel n env =
  { env with
    env_rel_context = rel_skipn n env.env_rel_context;
    env_nb_rel = env.env_nb_rel - n
  }

(* Named context *)

let push_named_context_val_val d rval ctxt =
(*   assert (not (Id.Map.mem (NamedDecl.get_id d) ctxt.env_named_map)); *)
  {
    env_named_ctx = Context.Named.add d ctxt.env_named_ctx;
    env_named_map = Id.Map.add (NamedDecl.get_id d) (d, rval) ctxt.env_named_map;
  }

let push_named_context_val d ctxt =
  push_named_context_val_val d (ref VKnone) ctxt

let match_named_context_val c = match c.env_named_ctx with
| [] -&gt; None
| decl :: ctx -&gt;
  let (_, v) = Id.Map.find (NamedDecl.get_id decl) c.env_named_map in
  let map = Id.Map.remove (NamedDecl.get_id decl) c.env_named_map in
  let cval = { env_named_ctx = ctx; env_named_map = map } in
  Some (decl, v, cval)

let map_named_val f ctxt =
  let open Context.Named.Declaration in
  let fold accu d =
    let d' = f d in
    let accu =
      if d == d' then accu
      else Id.Map.modify (get_id d) (fun _ (_, v) -&gt; (d', v)) accu
    in
    (accu, d')
  in
  let map, ctx = List.fold_left_map fold ctxt.env_named_map ctxt.env_named_ctx in
  if map == ctxt.env_named_map then ctxt
  else { env_named_ctx = ctx; env_named_map = map }

let push_named d env =
  {env with env_named_context = push_named_context_val d env.env_named_context}

let lookup_named id env =
  fst (Id.Map.find id env.env_named_context.env_named_map)

let lookup_named_val id env =
  snd(Id.Map.find id env.env_named_context.env_named_map)

let lookup_named_ctxt id ctxt =
  fst (Id.Map.find id ctxt.env_named_map)

let fold_constants f env acc =
  Cmap_env.fold (fun c (body,_) acc -&gt; f c body acc) env.env_globals.Globals.constants acc

let fold_inductives f env acc =
  Mindmap_env.fold (fun c (body,_) acc -&gt; f c body acc) env.env_globals.Globals.inductives acc

(* Global constants *)

let lookup_constant_key kn env =
  Cmap_env.find kn env.env_globals.Globals.constants

let lookup_constant kn env =
  fst (Cmap_env.find kn env.env_globals.Globals.constants)

(* Mutual Inductives *)
let lookup_mind kn env =
  fst (Mindmap_env.find kn env.env_globals.Globals.inductives)

let mind_context env mind =
  let mib = lookup_mind mind env in
  Declareops.inductive_polymorphic_context mib

let lookup_mind_key kn env =
  Mindmap_env.find kn env.env_globals.Globals.inductives

let oracle env = env.env_typing_flags.conv_oracle
let set_oracle env o =
  let env_typing_flags = { env.env_typing_flags with conv_oracle = o } in
  { env with env_typing_flags }

let engagement env = env.env_stratification.env_engagement
let typing_flags env = env.env_typing_flags

let is_impredicative_set env = 
  match engagement env with
  | ImpredicativeSet -&gt; true
  | _ -&gt; false

let is_impredicative_sort env = function
  | Sorts.SProp | Sorts.Prop -&gt; true
  | Sorts.Set -&gt; is_impredicative_set env
  | Sorts.Type _ -&gt; false

let is_impredicative_univ env u = is_impredicative_sort env (Sorts.sort_of_univ u)

let type_in_type env = not (typing_flags env).check_universes
let deactivated_guard env = not (typing_flags env).check_guarded

let indices_matter env = env.env_typing_flags.indices_matter
let check_template env = env.env_typing_flags.check_template

let universes env = env.env_stratification.env_universes
let universes_lbound env = env.env_stratification.env_universes_lbound

let set_universes_lbound env lbound =
  let env_stratification = { env.env_stratification with env_universes_lbound = lbound } in
  { env with env_stratification }

let named_context env = env.env_named_context.env_named_ctx
let named_context_val env = env.env_named_context
let rel_context env = env.env_rel_context.env_rel_ctx
let opaque_tables env = env.indirect_pterms
let set_opaque_tables env indirect_pterms = { env with indirect_pterms }

let empty_context env =
  match env.env_rel_context.env_rel_ctx, env.env_named_context.env_named_ctx with
  | [], [] -&gt; true
  | _ -&gt; false

(* Rel context *)
let evaluable_rel n env =
  is_local_def (lookup_rel n env)

let nb_rel env = env.env_nb_rel

let push_rel_context ctxt x = Context.Rel.fold_outside push_rel ctxt ~init:x

let push_rec_types (lna,typarray,_) env =
  let ctxt = Array.map2_i (fun i na t -&gt; LocalAssum (na, lift i t)) lna typarray in
  Array.fold_left (fun e assum -&gt; push_rel assum e) env ctxt

let fold_rel_context f env ~init =
  let rec fold_right env =
    match match_rel_context_val env.env_rel_context with
    | None -&gt; init
    | Some (rd, _, rc) -&gt;
	let env =
	  { env with
	    env_rel_context = rc;
	    env_nb_rel = env.env_nb_rel - 1 } in
	f env rd (fold_right env)
  in fold_right env

(* Named context *)

let named_context_of_val c = c.env_named_ctx

let ids_of_named_context_val c = Id.Map.domain c.env_named_map

let empty_named_context = Context.Named.empty

let push_named_context = List.fold_right push_named

let val_of_named_context ctxt =
  List.fold_right push_named_context_val ctxt empty_named_context_val


let eq_named_context_val c1 c2 =
   c1 == c2 || Context.Named.equal Constr.equal (named_context_of_val c1) (named_context_of_val c2)

(* A local const is evaluable if it is defined  *)

let named_type id env =
  let open Context.Named.Declaration in
  get_type (lookup_named id env)

let named_body id env =
  let open Context.Named.Declaration in
  get_value (lookup_named id env)

let evaluable_named id env =
  match named_body id env with
  | Some _      -&gt; true
  | _          -&gt; false

let reset_with_named_context ctxt env =
  { env with
    env_named_context = ctxt;
    env_rel_context = empty_rel_context_val;
    env_nb_rel = 0 }

let reset_context = reset_with_named_context empty_named_context_val

let pop_rel_context n env =
  let rec skip n ctx =
    if Int.equal n 0 then ctx
    else match match_rel_context_val ctx with
    | None -&gt; invalid_arg &quot;List.skipn&quot;
    | Some (_, _, ctx) -&gt; skip (pred n) ctx
  in
  let ctxt = env.env_rel_context in
  { env with
    env_rel_context = skip n ctxt;
    env_nb_rel = env.env_nb_rel - n }

let fold_named_context f env ~init =
  let rec fold_right env =
    match match_named_context_val env.env_named_context with
    | None -&gt; init
    | Some (d, _v, rem) -&gt;
	let env =
	  reset_with_named_context rem env in
	f env d (fold_right env)
  in fold_right env

let fold_named_context_reverse f ~init env =
  Context.Named.fold_inside f ~init:init (named_context env)


(* Universe constraints *)

let map_universes f env =
  let s = env.env_stratification in
    { env with env_stratification =
	 { s with env_universes = f s.env_universes } }

let add_constraints c env =
  if Univ.Constraint.is_empty c then env
  else map_universes (UGraph.merge_constraints c) env

let check_constraints c env =
  UGraph.check_constraints c env.env_stratification.env_universes

let push_constraints_to_env (_,univs) env =
  add_constraints univs env

let add_universes ~lbound ~strict ctx g =
  let g = Array.fold_left
            (fun g v -&gt; UGraph.add_universe ~lbound ~strict v g)
	    g (Univ.Instance.to_array (Univ.UContext.instance ctx))
  in
    UGraph.merge_constraints (Univ.UContext.constraints ctx) g
			   
let push_context ?(strict=false) ctx env =
  map_universes (add_universes ~lbound:(universes_lbound env) ~strict ctx) env

let add_universes_set ~lbound ~strict ctx g =
  let g = Univ.LSet.fold
            (* Be lenient, module typing reintroduces universes and constraints due to includes *)
            (fun v g -&gt; try UGraph.add_universe ~lbound ~strict v g with UGraph.AlreadyDeclared -&gt; g)
	    (Univ.ContextSet.levels ctx) g
  in UGraph.merge_constraints (Univ.ContextSet.constraints ctx) g

let push_context_set ?(strict=false) ctx env =
  map_universes (add_universes_set ~lbound:(universes_lbound env) ~strict ctx) env

let push_subgraph (levels,csts) env =
  let lbound = universes_lbound env in
  let add_subgraph g =
    let newg = Univ.LSet.fold (fun v g -&gt; UGraph.add_universe ~lbound ~strict:false v g) levels g in
    let newg = UGraph.merge_constraints csts newg in
    (if not (Univ.Constraint.is_empty csts) then
       let restricted = UGraph.constraints_for ~kept:(UGraph.domain g) newg in
       (if not (UGraph.check_constraints restricted g) then
          CErrors.anomaly Pp.(str &quot;Local constraints imply new transitive constraints.&quot;)));
    newg
  in
  map_universes add_subgraph env

let set_engagement c env = (* Unsafe *)
  { env with env_stratification =
    { env.env_stratification with env_engagement = c } }

(* It's convenient to use [{flags with foo = bar}] so we're smart wrt to it. *)
let same_flags {
     check_guarded;
     check_positive;
     check_universes;
     conv_oracle;
     indices_matter;
     share_reduction;
     enable_VM;
     enable_native_compiler;
     check_template;
  } alt =
  check_guarded == alt.check_guarded &amp;&amp;
  check_positive == alt.check_positive &amp;&amp;
  check_universes == alt.check_universes &amp;&amp;
  conv_oracle == alt.conv_oracle &amp;&amp;
  indices_matter == alt.indices_matter &amp;&amp;
  share_reduction == alt.share_reduction &amp;&amp;
  enable_VM == alt.enable_VM &amp;&amp;
  enable_native_compiler == alt.enable_native_compiler &amp;&amp;
  check_template == alt.check_template
[@warning &quot;+9&quot;]

let set_typing_flags c env = (* Unsafe *)
  if same_flags env.env_typing_flags c then env
  else { env with env_typing_flags = c }

let make_sprop_cumulative = map_universes UGraph.make_sprop_cumulative

let set_allow_sprop b env =
  { env with env_stratification =
    { env.env_stratification with env_sprop_allowed = b } }

let sprop_allowed env = env.env_stratification.env_sprop_allowed

(* Global constants *)

let no_link_info = NotLinked

let add_constant_key kn cb linkinfo env =
  let new_constants =
    Cmap_env.add kn (cb,(ref linkinfo, ref None)) env.env_globals.Globals.constants in
  let new_globals =
    { env.env_globals with
        Globals.constants = new_constants } in
  { env with env_globals = new_globals }

let add_constant kn cb env =
  add_constant_key kn cb no_link_info env

(* constant_type gives the type of a constant *)
let constant_type env (kn,u) =
  let cb = lookup_constant kn env in
  let uctx = Declareops.constant_polymorphic_context cb in
  let csts = Univ.AUContext.instantiate u uctx in
  (subst_instance_constr u cb.const_type, csts)

type const_evaluation_result =
  | NoBody
  | Opaque
  | IsPrimitive of CPrimitives.t

exception NotEvaluableConst of const_evaluation_result

let constant_value_and_type env (kn, u) =
  let cb = lookup_constant kn env in
  let uctx = Declareops.constant_polymorphic_context cb in
  let cst = Univ.AUContext.instantiate u uctx in
  let b' = match cb.const_body with
    | Def l_body -&gt; Some (subst_instance_constr u (Mod_subst.force_constr l_body))
    | OpaqueDef _ -&gt; None
    | Undef _ | Primitive _ -&gt; None
  in
  b', subst_instance_constr u cb.const_type, cst

(* These functions should be called under the invariant that [env] 
   already contains the constraints corresponding to the constant 
   application. *)

(* constant_type gives the type of a constant *)
let constant_type_in env (kn,u) =
  let cb = lookup_constant kn env in
  subst_instance_constr u cb.const_type

let constant_value_in env (kn,u) =
  let cb = lookup_constant kn env in
  match cb.const_body with
    | Def l_body -&gt; 
      let b = Mod_subst.force_constr l_body in
	subst_instance_constr u b
    | OpaqueDef _ -&gt; raise (NotEvaluableConst Opaque)
    | Undef _ -&gt; raise (NotEvaluableConst NoBody)
    | Primitive p -&gt; raise (NotEvaluableConst (IsPrimitive p))

let constant_opt_value_in env cst =
  try Some (constant_value_in env cst)
  with NotEvaluableConst _ -&gt; None

(* A global const is evaluable if it is defined and not opaque *)
let evaluable_constant kn env =
  let cb = lookup_constant kn env in
    match cb.const_body with
    | Def _ -&gt; true
    | OpaqueDef _ -&gt; false
    | Undef _ | Primitive _ -&gt; false

let is_primitive env c =
  let cb = lookup_constant c env in
  match cb.Declarations.const_body with
  | Declarations.Primitive _ -&gt; true
  | _ -&gt; false

let polymorphic_constant cst env =
  Declareops.constant_is_polymorphic (lookup_constant cst env)

let polymorphic_pconstant (cst,u) env =
  if Univ.Instance.is_empty u then false
  else polymorphic_constant cst env

let type_in_type_constant cst env =
  not (lookup_constant cst env).const_typing_flags.check_universes

let lookup_projection p env =
  let mind,i = Projection.inductive p in
  let mib = lookup_mind mind env in
  (if not (Int.equal mib.mind_nparams (Projection.npars p))
   then anomaly ~label:&quot;lookup_projection&quot; Pp.(str &quot;Bad number of parameters on projection.&quot;));
  match mib.mind_record with
  | NotRecord | FakeRecord -&gt; anomaly ~label:&quot;lookup_projection&quot; Pp.(str &quot;not a projection&quot;)
  | PrimRecord infos -&gt;
    let _,_,_,typs = infos.(i) in
    typs.(Projection.arg p)

let get_projection env ind ~proj_arg =
  let mib = lookup_mind (fst ind) env in
  Declareops.inductive_make_projection ind mib ~proj_arg

let get_projections env ind =
  let mib = lookup_mind (fst ind) env in
  Declareops.inductive_make_projections ind mib

(* Mutual Inductives *)
let polymorphic_ind (mind,_i) env =
  Declareops.inductive_is_polymorphic (lookup_mind mind env)

let polymorphic_pind (ind,u) env =
  if Univ.Instance.is_empty u then false
  else polymorphic_ind ind env

let type_in_type_ind (mind,_i) env =
  not (lookup_mind mind env).mind_typing_flags.check_universes

let template_checked_ind (mind,_i) env =
  (lookup_mind mind env).mind_typing_flags.check_template

let template_polymorphic_ind (mind,i) env =
  match (lookup_mind mind env).mind_packets.(i).mind_arity with 
  | TemplateArity _ -&gt; true
  | RegularArity _ -&gt; false

let template_polymorphic_variables (mind,i) env =
  match (lookup_mind mind env).mind_packets.(i).mind_arity with
  | TemplateArity { Declarations.template_param_levels = l; _ } -&gt;
    List.map_filter (fun level -&gt; level) l
  | RegularArity _ -&gt; []

let template_polymorphic_pind (ind,u) env =
  if not (Univ.Instance.is_empty u) then false
  else template_polymorphic_ind ind env
  
let add_mind_key kn (_mind, _ as mind_key) env =
  let new_inds = Mindmap_env.add kn mind_key env.env_globals.Globals.inductives in
  let new_globals =
    { env.env_globals with
        Globals.inductives = new_inds; } in
  { env with env_globals = new_globals }

let add_mind kn mib env =
  let li = ref no_link_info in add_mind_key kn (mib, li) env

(* Lookup of section variables *)

let lookup_constant_variables c env =
  let cmap = lookup_constant c env in
  Context.Named.to_vars cmap.const_hyps

let lookup_inductive_variables (kn,_i) env =
  let mis = lookup_mind kn env in
  Context.Named.to_vars mis.mind_hyps

let lookup_constructor_variables (ind,_) env =
  lookup_inductive_variables ind env

(* Universes *)
let constant_context env c =
  let cb = lookup_constant c env in
  Declareops.constant_polymorphic_context cb

let universes_of_global env r =
  let open GlobRef in
    match r with
    | VarRef _ -&gt; Univ.AUContext.empty
    | ConstRef c -&gt; constant_context env c
    | IndRef (mind,_) | ConstructRef ((mind,_),_) -&gt;
      let mib = lookup_mind mind env in
      Declareops.inductive_polymorphic_context mib

(* Returns the list of global variables in a term *)

let vars_of_global env gr =
  let open GlobRef in
  match gr with
  | VarRef id -&gt; Id.Set.singleton id
  | ConstRef kn -&gt; lookup_constant_variables kn env
  | IndRef ind -&gt; lookup_inductive_variables ind env
  | ConstructRef cstr -&gt; lookup_constructor_variables cstr env

let global_vars_set env constr =
  let rec filtrec acc c =
    match destRef c with
    | gr, _ -&gt;
      Id.Set.union (vars_of_global env gr) acc
    | exception DestKO -&gt; Constr.fold filtrec acc c
  in
  filtrec Id.Set.empty constr


(* [keep_hyps env ids] keeps the part of the section context of [env] which
   contains the variables of the set [ids], and recursively the variables
   contained in the types of the needed variables. *)

let really_needed env needed =
  let open! Context.Named.Declaration in
  Context.Named.fold_inside
    (fun need decl -&gt;
      if Id.Set.mem (get_id decl) need then
        let globc =
          match decl with
            | LocalAssum _ -&gt; Id.Set.empty
            | LocalDef (_,c,_) -&gt; global_vars_set env c in
        Id.Set.union
          (global_vars_set env (get_type decl))
          (Id.Set.union globc need)
      else need)
    ~init:needed
    (named_context env)

let keep_hyps env needed =
  let open Context.Named.Declaration in
  let really_needed = really_needed env needed in
  Context.Named.fold_outside
    (fun d nsign -&gt;
      if Id.Set.mem (get_id d) really_needed then Context.Named.add d nsign
      else nsign)
    (named_context env)
    ~init:empty_named_context

(* Modules *)

let add_modtype mtb env =
  let mp = mtb.mod_mp in
  let new_modtypes = MPmap.add mp mtb env.env_globals.Globals.modtypes in
  let new_globals = { env.env_globals with Globals.modtypes = new_modtypes } in
  { env with env_globals = new_globals }

let shallow_add_module mb env =
  let mp = mb.mod_mp in
  let new_mods = MPmap.add mp mb env.env_globals.Globals.modules in
  let new_globals = { env.env_globals with Globals.modules = new_mods } in
  { env with env_globals = new_globals }

let lookup_module mp env =
    MPmap.find mp env.env_globals.Globals.modules


let lookup_modtype mp env =
  MPmap.find mp env.env_globals.Globals.modtypes

(*s Judgments. *)

type ('constr, 'types) punsafe_judgment = {
  uj_val : 'constr;
  uj_type : 'types }

let on_judgment f j = { uj_val = f j.uj_val; uj_type = f j.uj_type }
let on_judgment_value f j = { j with uj_val = f j.uj_val }
let on_judgment_type f j = { j with uj_type = f j.uj_type }

type unsafe_judgment = (constr, types) punsafe_judgment

let make_judge v tj =
  { uj_val = v;
    uj_type = tj }

let j_val j = j.uj_val
let j_type j = j.uj_type

type 'types punsafe_type_judgment = {
  utj_val : 'types;
  utj_type : Sorts.t }

type unsafe_type_judgment = types punsafe_type_judgment

exception Hyp_not_found

let apply_to_hyp ctxt id f =
  let open Context.Named.Declaration in
  let rec aux rtail ctxt =
    match match_named_context_val ctxt with
    | Some (d, v, ctxt) -&gt;
	if Id.equal (get_id d) id then
          push_named_context_val_val (f ctxt.env_named_ctx d rtail) v ctxt
	else
	  let ctxt' = aux (d::rtail) ctxt in
	  push_named_context_val_val d v ctxt'
    | None -&gt; raise Hyp_not_found
  in aux [] ctxt

(* To be used in Logic.clear_hyps *)
let remove_hyps ids check_context check_value ctxt =
  let rec remove_hyps ctxt = match match_named_context_val ctxt with
  | None -&gt; empty_named_context_val, false
  | Some (d, v, rctxt) -&gt;
     let open Context.Named.Declaration in
    let (ans, seen) = remove_hyps rctxt in
    if Id.Set.mem (get_id d) ids then (ans, true)
    else if not seen then ctxt, false
    else
      let rctxt' = ans in
      let d' = check_context d in
      let v' = check_value v in
      if d == d' &amp;&amp; v == v' &amp;&amp; rctxt == rctxt' then
        ctxt, true
      else push_named_context_val_val d' v' rctxt', true
  in
  fst (remove_hyps ctxt)

(* A general request *)

let is_polymorphic env r =
  let open Names.GlobRef in
  match r with
  | VarRef _id -&gt; false
  | ConstRef c -&gt; polymorphic_constant c env
  | IndRef ind -&gt; polymorphic_ind ind env
  | ConstructRef cstr -&gt; polymorphic_ind (inductive_of_constructor cstr) env

let is_template_polymorphic env r =
  let open Names.GlobRef in
  match r with
  | VarRef _id -&gt; false
  | ConstRef _c -&gt; false
  | IndRef ind -&gt; template_polymorphic_ind ind env
  | ConstructRef cstr -&gt; template_polymorphic_ind (inductive_of_constructor cstr) env

let get_template_polymorphic_variables env r =
  let open Names.GlobRef in
  match r with
  | VarRef _id -&gt; []
  | ConstRef _c -&gt; []
  | IndRef ind -&gt; template_polymorphic_variables ind env
  | ConstructRef cstr -&gt; template_polymorphic_variables (inductive_of_constructor cstr) env

let is_template_checked env r =
  let open Names.GlobRef in
  match r with
  | VarRef _id -&gt; false
  | ConstRef _c -&gt; false
  | IndRef ind -&gt; template_checked_ind ind env
  | ConstructRef cstr -&gt; template_checked_ind (inductive_of_constructor cstr) env

let is_type_in_type env r =
  let open Names.GlobRef in
  match r with
  | VarRef _id -&gt; false
  | ConstRef c -&gt; type_in_type_constant c env
  | IndRef ind -&gt; type_in_type_ind ind env
  | ConstructRef cstr -&gt; type_in_type_ind (inductive_of_constructor cstr) env

let set_retroknowledge env r = { env with retroknowledge = r }

let set_native_symbols env native_symbols = { env with native_symbols }
let add_native_symbols dir syms env =
  { env with native_symbols = DPmap.add dir syms env.native_symbols }
</pre>
          </div>
          <div class="col-md-6">
            <code>environ.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import CErrors.

Import Util.

Import Names.

Import Constr.

Import Vars.

Import Declarations.

Import Context.Rel.Declaration.

Definition key := Stdlib.ref (option (CEphemeron.key Z)).

Inductive link_info : Type :=
| Linked : string -&gt; link_info
| LinkedInteractive : string -&gt; link_info
| NotLinked : link_info.

Definition constant_key :=
  (Declarations.constant_body Opaqueproof.opaque) *
    ((Stdlib.ref link_info) * key).

Definition mind_key :=
  Declarations.mutual_inductive_body * (Stdlib.ref link_info).

Module Globals.
  Record view := {
    constants : Names.Cmap_env.t constant_key;
    inductives : Names.Mindmap_env.t mind_key;
    modules : Names.MPmap.t Declarations.module_body;
    modtypes : Names.MPmap.t Declarations.module_type_body }.
  
  Definition t := view.
  
  Definition view {A : Type} (x : A) : A := x.
End Globals.

Record stratification := {
  env_universes : UGraph.t;
  env_sprop_allowed : bool;
  env_universes_lbound : Univ.Level.t;
  env_engagement : Declarations.engagement }.

Inductive val_kind : Type :=
| VKvalue : (CEphemeron.key (Vmvalues.values * Names.Id.Set.t)) -&gt; val_kind
| VKnone : val_kind.

Definition lazy_val := Stdlib.ref val_kind.

Definition force_lazy_val (vk : Stdlib.ref val_kind)
  : option (Vmvalues.values * Names.Id.Set.t) :=
  match Util.op_exclamation vk with
  | VKnone =&gt; None
  | VKvalue v =&gt; try
  end.

Definition dummy_lazy_val (function_parameter : unit) : Stdlib.ref val_kind :=
  match function_parameter with
  | tt =&gt; Stdlib.ref VKnone
  end.

Definition build_lazy_val
  (vk : Stdlib.ref val_kind) (key : Vmvalues.values * Names.Id.Set.t) : unit :=
  Stdlib.op_colon_eq vk (VKvalue (CEphemeron.create key)).

Record named_context_val := {
  env_named_ctx : Constr.named_context;
  env_named_map : Names.Id.Map.t (Constr.named_declaration * lazy_val) }.

Record rel_context_val := {
  env_rel_ctx : Constr.rel_context;
  env_rel_map : Range.t (Constr.rel_declaration * lazy_val) }.

Record env := {
  env_globals : Globals.t;
  env_named_context : named_context_val;
  env_rel_context : rel_context_val;
  env_nb_rel : Z;
  env_stratification : stratification;
  env_typing_flags : Declarations.typing_flags;
  retroknowledge : Retroknowledge.retroknowledge;
  indirect_pterms : Opaqueproof.opaquetab;
  native_symbols : Names.DPmap.t Nativevalues.symbols }.

Definition empty_named_context_val : named_context_val :=
  {| env_named_ctx := []; env_named_map := Names.Id.Map.empty |}.

Definition empty_rel_context_val : rel_context_val :=
  {| env_rel_ctx := []; env_rel_map := Range.empty |}.

Definition empty_env : env :=
  {|
    env_globals :=
      {| Globals.constants := Names.Cmap_env.empty;
        Globals.inductives := Names.Mindmap_env.empty;
        Globals.modules := Names.MPmap.empty;
        Globals.modtypes := Names.MPmap.empty |};
    env_named_context := empty_named_context_val;
    env_rel_context := empty_rel_context_val; env_nb_rel := 0;
    env_stratification :=
      {| env_universes := UGraph.initial_universes; env_sprop_allowed := false;
        env_universes_lbound := Univ.Level.set; env_engagement := PredicativeSet
        |}; env_typing_flags := Declareops.safe_flags Conv_oracle.empty;
    retroknowledge := Retroknowledge.empty;
    indirect_pterms := Opaqueproof.empty_opaquetab;
    native_symbols := Names.DPmap.empty |}.

Definition push_rel_context_val
  (d : Constr.rel_declaration) (ctx : rel_context_val) : rel_context_val :=
  {| env_rel_ctx := Context.Rel.add d (env_rel_ctx ctx);
    env_rel_map := Range.cons (d, (Stdlib.ref VKnone)) (env_rel_map ctx) |}.

Definition match_rel_context_val (ctx : rel_context_val)
  : option (Constr.rel_declaration * lazy_val * rel_context_val) :=
  match env_rel_ctx ctx with
  | [] =&gt; None
  | cons decl rem =&gt;
    match Range.hd (env_rel_map ctx) with
    | (_, lval) =&gt;
      let ctx :=
        {| env_rel_ctx := rem; env_rel_map := Range.tl (env_rel_map ctx) |} in
      Some (decl, lval, ctx)
    end
  end.

Definition push_rel (d : Constr.rel_declaration) (env : env) : env := record.

Definition lookup_rel (n : Z) (env : env) : Constr.rel_declaration := try.

Definition lookup_rel_val (n : Z) (env : env) : lazy_val := try.

Definition rel_skipn (n : Z) (ctx : rel_context_val) : rel_context_val :=
  {| env_rel_ctx := Util.List.(CList.ExtS.skipn) n (env_rel_ctx ctx);
    env_rel_map := Range.skipn n (env_rel_map ctx) |}.

Definition env_of_rel (n : Z) (env : env) : env := record.

Definition push_named_context_val_val
  (d : NamedDecl.pt Constr.constr Constr.types) (rval : lazy_val)
  (ctxt : named_context_val) : named_context_val :=
  {| env_named_ctx := Context.Named.add d (env_named_ctx ctxt);
    env_named_map :=
      Names.Id.Map.add (NamedDecl.get_id d) (d, rval) (env_named_map ctxt) |}.

Definition push_named_context_val
  (d : NamedDecl.pt Constr.constr Constr.types) (ctxt : named_context_val)
  : named_context_val := push_named_context_val_val d (Stdlib.ref VKnone) ctxt.

Definition match_named_context_val (c : named_context_val)
  : option (Constr.named_declaration * lazy_val * named_context_val) :=
  match env_named_ctx c with
  | [] =&gt; None
  | cons decl ctx =&gt;
    match Names.Id.Map.find (NamedDecl.get_id decl) (env_named_map c) with
    | (_, v) =&gt;
      let map := Names.Id.Map.remove (NamedDecl.get_id decl) (env_named_map c)
        in
      let cval := {| env_named_ctx := ctx; env_named_map := map |} in
      Some (decl, v, cval)
    end
  end.

Definition map_named_val
  (f : Constr.named_declaration -&gt; Constr.named_declaration)
  (ctxt : named_context_val) : named_context_val :=
  let fold {A : Type}
    (accu : Names.Id.Map.t (Constr.named_declaration * A)) (d :
    Constr.named_declaration)
    : (Names.Id.Map.t (Constr.named_declaration * A)) * Constr.named_declaration :=
    let d' := f d in
    let accu :=
      if Stdlib.op_eq_eq d d' then
        accu
      else
        Names.Id.Map.modify (Context.Named.Declaration.get_id d)
          (fun function_parameter =&gt;
            match function_parameter with
            | _ =&gt;
              fun function_parameter =&gt;
                match function_parameter with
                | (_, v) =&gt; (d', v)
                end
            end) accu in
    (accu, d') in
  match
    Util.List.(CList.ExtS.fold_left_map) fold (env_named_map ctxt)
      (env_named_ctx ctxt) with
  | (map, ctx) =&gt;
    if Stdlib.op_eq_eq map (env_named_map ctxt) then
      ctxt
    else
      {| env_named_ctx := ctx; env_named_map := map |}
  end.

Definition push_named (d : NamedDecl.pt Constr.constr Constr.types) (env : env)
  : env := record.

Definition lookup_named (id : Names.Id.Map.key) (env : env)
  : Constr.named_declaration :=
  fst (Names.Id.Map.find id (env_named_map (env_named_context env))).

Definition lookup_named_val (id : Names.Id.Map.key) (env : env) : lazy_val :=
  snd (Names.Id.Map.find id (env_named_map (env_named_context env))).

Definition lookup_named_ctxt (id : Names.Id.Map.key) (ctxt : named_context_val)
  : Constr.named_declaration := fst (Names.Id.Map.find id (env_named_map ctxt)).

Definition fold_constants {A : Type}
  (f :
    Names.Cmap_env.key -&gt;
      (Declarations.constant_body Opaqueproof.opaque) -&gt; A -&gt; A) (env : env)
  (acc : A) : A :=
  Names.Cmap_env.fold
    (fun c =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | (body, _) =&gt; fun acc =&gt; f c body acc
        end) (Globals.constants (env_globals env)) acc.

Definition fold_inductives {A : Type}
  (f : Names.Mindmap_env.key -&gt; Declarations.mutual_inductive_body -&gt; A -&gt; A)
  (env : env) (acc : A) : A :=
  Names.Mindmap_env.fold
    (fun c =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | (body, _) =&gt; fun acc =&gt; f c body acc
        end) (Globals.inductives (env_globals env)) acc.

Definition lookup_constant_key (kn : Names.Cmap_env.key) (env : env)
  : constant_key := Names.Cmap_env.find kn (Globals.constants (env_globals env)).

Definition lookup_constant (kn : Names.Cmap_env.key) (env : env)
  : Declarations.constant_body Opaqueproof.opaque :=
  fst (Names.Cmap_env.find kn (Globals.constants (env_globals env))).

Definition lookup_mind (kn : Names.Mindmap_env.key) (env : env)
  : Declarations.mutual_inductive_body :=
  fst (Names.Mindmap_env.find kn (Globals.inductives (env_globals env))).

Definition mind_context (env : env) (mind : Names.Mindmap_env.key)
  : Univ.AUContext.t :=
  let mib := lookup_mind mind env in
  Declareops.inductive_polymorphic_context mib.

Definition lookup_mind_key (kn : Names.Mindmap_env.key) (env : env)
  : mind_key := Names.Mindmap_env.find kn (Globals.inductives (env_globals env)).

Definition oracle (env : env) : Conv_oracle.oracle :=
  conv_oracle (env_typing_flags env).

Definition set_oracle (env : env) (o : Conv_oracle.oracle) : env :=
  let env_typing_flags := record in
  record.

Definition engagement (env : env) : Declarations.engagement :=
  env_engagement (env_stratification env).

Definition typing_flags (env : env) : Declarations.typing_flags :=
  env_typing_flags env.

Definition is_impredicative_set (env : env) : bool :=
  match engagement env with
  | ImpredicativeSet =&gt; true
  | _ =&gt; false
  end.

Definition is_impredicative_sort (env : env) (function_parameter : Sorts.t)
  : bool :=
  match function_parameter with
  | Sorts.SProp | Sorts.Prop =&gt; true
  | Sorts.Set =&gt; is_impredicative_set env
  | Sorts.Type _ =&gt; false
  end.

Definition is_impredicative_univ (env : env) (u : Univ.Universe.t) : bool :=
  is_impredicative_sort env (Sorts.sort_of_univ u).

Definition type_in_type (env : env) : bool :=
  negb (check_universes (typing_flags env)).

Definition deactivated_guard (env : env) : bool :=
  negb (check_guarded (typing_flags env)).

Definition indices_matter (env : env) : bool :=
  indices_matter (env_typing_flags env).

Definition check_template (env : env) : bool :=
  check_template (env_typing_flags env).

Definition universes (env : env) : UGraph.t :=
  env_universes (env_stratification env).

Definition universes_lbound (env : env) : Univ.Level.t :=
  env_universes_lbound (env_stratification env).

Definition set_universes_lbound (env : env) (lbound : Univ.Level.t) : env :=
  let env_stratification := record in
  record.

Definition named_context (env : env) : Constr.named_context :=
  env_named_ctx (env_named_context env).

Definition named_context_val (env : env) : named_context_val :=
  env_named_context env.

Definition rel_context (env : env) : Constr.rel_context :=
  env_rel_ctx (env_rel_context env).

Definition opaque_tables (env : env) : Opaqueproof.opaquetab :=
  indirect_pterms env.

Definition set_opaque_tables
  (env : env) (indirect_pterms : Opaqueproof.opaquetab) : env := record.

Definition empty_context (env : env) : bool :=
  match
    ((env_rel_ctx (env_rel_context env)),
      (env_named_ctx (env_named_context env))) with
  | ([], []) =&gt; true
  | _ =&gt; false
  end.

Definition evaluable_rel (n : Z) (env : env) : bool :=
  Context.Rel.Declaration.is_local_def (lookup_rel n env).

Definition nb_rel (env : env) : Z := env_nb_rel env.

Definition push_rel_context
  (ctxt : Context.Rel.pt Constr.constr Constr.types) (x : env) : env :=
  Context.Rel.fold_outside push_rel ctxt x.

Definition push_rec_types {A : Type}
  (function_parameter :
    (array (Context.binder_annot Names.Name.t)) * (array Constr.constr) * A)
  : env -&gt; env :=
  match function_parameter with
  | (lna, typarray, _) =&gt;
    fun env =&gt;
      let ctxt :=
        Util.Array.(CArray.ExtS.map2_i)
          (fun i =&gt; fun na =&gt; fun t =&gt; LocalAssum na (Vars.lift i t)) lna
          typarray in
      Util.Array.(CArray.ExtS.fold_left)
        (fun e =&gt; fun assum =&gt; push_rel assum e) env ctxt
  end.

Definition fold_rel_context {A : Type}
  (f : env -&gt; Constr.rel_declaration -&gt; A -&gt; A) (env : env) (init : A) : A :=
  let fix fold_right (env : env) : A :=
    match match_rel_context_val (env_rel_context env) with
    | None =&gt; init
    | Some (rd, _, rc) =&gt;
      let env := record in
      f env rd (fold_right env)
    end in
  fold_right env.

Definition named_context_of_val (c : named_context_val)
  : Constr.named_context := env_named_ctx c.

Definition ids_of_named_context_val (c : named_context_val) : Names.Id.Set.t :=
  Names.Id.Map.domain (env_named_map c).

Definition empty_named_context {A B : Type} : Context.Named.pt A B :=
  Context.Named.empty.

Definition push_named_context
  : (list (NamedDecl.pt Constr.constr Constr.types)) -&gt; env -&gt; env :=
  Util.List.(CList.ExtS.fold_right) push_named.

Definition val_of_named_context
  (ctxt : list (NamedDecl.pt Constr.constr Constr.types)) : named_context_val :=
  Util.List.(CList.ExtS.fold_right) push_named_context_val ctxt
    empty_named_context_val.

Definition eq_named_context_val
  (c1 : named_context_val) (c2 : named_context_val) : bool :=
  orb (Stdlib.op_eq_eq c1 c2)
    (Context.Named.equal Constr.equal (named_context_of_val c1)
      (named_context_of_val c2)).

Definition named_type (id : Names.Id.Map.key) (env : env) : Constr.types :=
  Context.Named.Declaration.get_type (lookup_named id env).

Definition named_body (id : Names.Id.Map.key) (env : env)
  : option Constr.constr :=
  Context.Named.Declaration.get_value (lookup_named id env).

Definition evaluable_named (id : Names.Id.Map.key) (env : env) : bool :=
  match named_body id env with
  | Some _ =&gt; true
  | _ =&gt; false
  end.

Definition reset_with_named_context (ctxt : named_context_val) (env : env)
  : env := record.

Definition reset_context : env -&gt; env :=
  reset_with_named_context empty_named_context_val.

Definition pop_rel_context (n : Int.t) (env : env) : env :=
  let fix skip (n : Int.t) (ctx : rel_context_val) : rel_context_val :=
    if Int.equal n 0 then
      ctx
    else
      match match_rel_context_val ctx with
      | None =&gt; OCaml.Stdlib.invalid_arg &quot;List.skipn&quot; % string
      | Some (_, _, ctx) =&gt; skip (Z.pred n) ctx
      end in
  let ctxt := env_rel_context env in
  record.

Definition fold_named_context {A : Type}
  (f : env -&gt; Constr.named_declaration -&gt; A -&gt; A) (env : env) (init : A) : A :=
  let fix fold_right (env : env) : A :=
    match match_named_context_val (env_named_context env) with
    | None =&gt; init
    | Some (d, _v, rem) =&gt;
      let env := reset_with_named_context rem env in
      f env d (fold_right env)
    end in
  fold_right env.

Definition fold_named_context_reverse {A : Type}
  (f : A -&gt; (Context.Named.Declaration.pt Constr.constr Constr.types) -&gt; A)
  (init : A) (env : env) : A :=
  Context.Named.fold_inside f init (named_context env).

Definition map_universes (f : UGraph.t -&gt; UGraph.t) (env : env) : env :=
  let s := env_stratification env in
  record.

Definition add_constraints (c : Univ.Constraint.t) (env : env) : env :=
  if Univ.Constraint.is_empty c then
    env
  else
    map_universes (UGraph.merge_constraints c) env.

Definition check_constraints (c : Univ.Constraint.t) (env : env) : bool :=
  UGraph.check_constraints c (env_universes (env_stratification env)).

Definition push_constraints_to_env {A : Type}
  (function_parameter : A * Univ.Constraint.t) : env -&gt; env :=
  match function_parameter with
  | (_, univs) =&gt; fun env =&gt; add_constraints univs env
  end.

Definition add_universes
  (lbound : Univ.Level.t) (strict : bool) (ctx : Univ.UContext.t) (g : UGraph.t)
  : UGraph.t :=
  let g :=
    Util.Array.(CArray.ExtS.fold_left)
      (fun g =&gt; fun v =&gt; UGraph.add_universe v lbound strict g) g
      (Univ.Instance.to_array (Univ.UContext.instance ctx)) in
  UGraph.merge_constraints (Univ.UContext.constraints ctx) g.

Definition push_context (op_star_o_p_t_star : option bool)
  : Univ.UContext.t -&gt; env -&gt; env :=
  let strict :=
    match op_star_o_p_t_star with
    | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
    | None =&gt; false
    end in
  fun ctx =&gt;
    fun env =&gt;
      map_universes (add_universes (universes_lbound env) strict ctx) env.

Definition add_universes_set
  (lbound : Univ.Level.t) (strict : bool) (ctx : Univ.ContextSet.t)
  (g : UGraph.t) : UGraph.t :=
  let g := Univ.LSet.fold (fun v =&gt; fun g =&gt; try) (Univ.ContextSet.levels ctx) g
    in
  UGraph.merge_constraints (Univ.ContextSet.constraints ctx) g.

Definition push_context_set (op_star_o_p_t_star : option bool)
  : Univ.ContextSet.t -&gt; env -&gt; env :=
  let strict :=
    match op_star_o_p_t_star with
    | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
    | None =&gt; false
    end in
  fun ctx =&gt;
    fun env =&gt;
      map_universes (add_universes_set (universes_lbound env) strict ctx) env.

Definition push_subgraph (function_parameter : Univ.LSet.t * Univ.Constraint.t)
  : env -&gt; env :=
  match function_parameter with
  | (levels, csts) =&gt;
    fun env =&gt;
      let lbound := universes_lbound env in
      let add_subgraph (g : UGraph.t) : UGraph.t :=
        let newg :=
          Univ.LSet.fold
            (fun v =&gt; fun g =&gt; UGraph.add_universe v lbound false g) levels g in
        let newg := UGraph.merge_constraints csts newg in
        if negb (Univ.Constraint.is_empty csts) then
          let restricted := UGraph.constraints_for (UGraph.domain g) newg in
          if negb (UGraph.check_constraints restricted g) then
            CErrors.anomaly None None
              (Pp.str
                &quot;Local constraints imply new transitive constraints.&quot; % string)
          else
            tt
        else
          tt;
        newg in
      map_universes add_subgraph env
  end.

Definition set_engagement (c : Declarations.engagement) (env : env) : env :=
  record.

Definition same_flags (function_parameter : Declarations.typing_flags)
  : Declarations.typing_flags -&gt; bool :=
  match function_parameter with
  | {|
    check_guarded := check_guarded;
      check_positive := check_positive;
      check_universes := check_universes;
      conv_oracle := conv_oracle;
      share_reduction := share_reduction;
      enable_VM := enable_VM;
      enable_native_compiler := enable_native_compiler;
      indices_matter := indices_matter;
      check_template := check_template
      |} =&gt;
    fun alt =&gt;
      andb (Stdlib.op_eq_eq check_guarded (check_guarded alt))
        (andb (Stdlib.op_eq_eq check_positive (check_positive alt))
          (andb (Stdlib.op_eq_eq check_universes (check_universes alt))
            (andb (Stdlib.op_eq_eq conv_oracle (conv_oracle alt))
              (andb (Stdlib.op_eq_eq indices_matter (indices_matter alt))
                (andb (Stdlib.op_eq_eq share_reduction (share_reduction alt))
                  (andb (Stdlib.op_eq_eq enable_VM (enable_VM alt))
                    (andb
                      (Stdlib.op_eq_eq enable_native_compiler
                        (enable_native_compiler alt))
                      (Stdlib.op_eq_eq check_template (check_template alt)))))))))
  end.

Definition set_typing_flags (c : Declarations.typing_flags) (env : env) : env :=
  if same_flags (env_typing_flags env) c then
    env
  else
    record.

Definition make_sprop_cumulative : env -&gt; env :=
  map_universes UGraph.make_sprop_cumulative.

Definition set_allow_sprop (b : bool) (env : env) : env := record.

Definition sprop_allowed (env : env) : bool :=
  env_sprop_allowed (env_stratification env).

Definition no_link_info : link_info := NotLinked.

Definition add_constant_key
  (kn : Names.Cmap_env.key) (cb : Declarations.constant_body Opaqueproof.opaque)
  (linkinfo : link_info) (env : env) : env :=
  let new_constants :=
    Names.Cmap_env.add kn (cb, ((Stdlib.ref linkinfo), (Stdlib.ref None)))
      (Globals.constants (env_globals env)) in
  let new_globals := record in
  record.

Definition add_constant
  (kn : Names.Cmap_env.key) (cb : Declarations.constant_body Opaqueproof.opaque)
  (env : env) : env := add_constant_key kn cb no_link_info env.

Definition constant_type
  (env : env) (function_parameter : Names.Cmap_env.key * Univ.Instance.t)
  : Constr.constr * Univ.Constraint.t :=
  match function_parameter with
  | (kn, u) =&gt;
    let cb := lookup_constant kn env in
    let uctx := Declareops.constant_polymorphic_context cb in
    let csts := Univ.AUContext.instantiate u uctx in
    ((Vars.subst_instance_constr u (const_type cb)), csts)
  end.

Inductive const_evaluation_result : Type :=
| NoBody : const_evaluation_result
| Opaque : const_evaluation_result
| IsPrimitive : CPrimitives.t -&gt; const_evaluation_result.

Definition constant_value_and_type
  (env : env) (function_parameter : Names.Cmap_env.key * Univ.Instance.t)
  : (option Constr.constr) * Constr.constr * Univ.Constraint.t :=
  match function_parameter with
  | (kn, u) =&gt;
    let cb := lookup_constant kn env in
    let uctx := Declareops.constant_polymorphic_context cb in
    let cst := Univ.AUContext.instantiate u uctx in
    let b' :=
      match const_body cb with
      | Def l_body =&gt;
        Some (Vars.subst_instance_constr u (Mod_subst.force_constr l_body))
      | OpaqueDef _ =&gt; None
      | Undef _ | Primitive _ =&gt; None
      end in
    (b', (Vars.subst_instance_constr u (const_type cb)), cst)
  end.

Definition constant_type_in
  (env : env) (function_parameter : Names.Cmap_env.key * Univ.Instance.t)
  : Constr.constr :=
  match function_parameter with
  | (kn, u) =&gt;
    let cb := lookup_constant kn env in
    Vars.subst_instance_constr u (const_type cb)
  end.

Definition constant_value_in
  (env : env) (function_parameter : Names.Cmap_env.key * Univ.Instance.t)
  : Constr.constr :=
  match function_parameter with
  | (kn, u) =&gt;
    let cb := lookup_constant kn env in
    match const_body cb with
    | Def l_body =&gt;
      let b := Mod_subst.force_constr l_body in
      Vars.subst_instance_constr u b
    | OpaqueDef _ =&gt; Stdlib.raise (NotEvaluableConst Opaque)
    | Undef _ =&gt; Stdlib.raise (NotEvaluableConst NoBody)
    | Primitive p =&gt; Stdlib.raise (NotEvaluableConst (IsPrimitive p))
    end
  end.

Definition constant_opt_value_in
  (env : env) (cst : Names.Cmap_env.key * Univ.Instance.t)
  : option Constr.constr := try.

Definition evaluable_constant (kn : Names.Cmap_env.key) (env : env) : bool :=
  let cb := lookup_constant kn env in
  match const_body cb with
  | Def _ =&gt; true
  | OpaqueDef _ =&gt; false
  | Undef _ | Primitive _ =&gt; false
  end.

Definition is_primitive (env : env) (c : Names.Cmap_env.key) : bool :=
  let cb := lookup_constant c env in
  match Declarations.const_body cb with
  | Declarations.Primitive _ =&gt; true
  | _ =&gt; false
  end.

Definition polymorphic_constant (cst : Names.Cmap_env.key) (env : env) : bool :=
  Declareops.constant_is_polymorphic (lookup_constant cst env).

Definition polymorphic_pconstant
  (function_parameter : Names.Cmap_env.key * Univ.Instance.t) : env -&gt; bool :=
  match function_parameter with
  | (cst, u) =&gt;
    fun env =&gt;
      if Univ.Instance.is_empty u then
        false
      else
        polymorphic_constant cst env
  end.

Definition type_in_type_constant (cst : Names.Cmap_env.key) (env : env)
  : bool :=
  negb (check_universes (const_typing_flags (lookup_constant cst env))).

Definition lookup_projection (p : Names.Projection.t) (env : env)
  : Constr.types :=
  match Names.Projection.inductive p with
  | (mind, i) =&gt;
    let mib := lookup_mind mind env in
    if negb (Int.equal (mind_nparams mib) (Names.Projection.npars p)) then
      CErrors.anomaly None (Some &quot;lookup_projection&quot; % string)
        (Pp.str &quot;Bad number of parameters on projection.&quot; % string)
    else
      tt;
    match mind_record mib with
    | NotRecord | FakeRecord =&gt;
      CErrors.anomaly None (Some &quot;lookup_projection&quot; % string)
        (Pp.str &quot;not a projection&quot; % string)
    | PrimRecord infos =&gt;
      match Util.Array.(CArray.ExtS.get) infos i with
      | (_, _, _, typs) =&gt;
        Util.Array.(CArray.ExtS.get) typs (Names.Projection.arg p)
      end
    end
  end.

Definition get_projection (env : env) (ind : Names.inductive) (proj_arg : Z)
  : option Names.Projection.Repr.t :=
  let mib := lookup_mind (fst ind) env in
  Declareops.inductive_make_projection ind mib proj_arg.

Definition get_projections (env : env) (ind : Names.inductive)
  : option (array Names.Projection.Repr.t) :=
  let mib := lookup_mind (fst ind) env in
  Declareops.inductive_make_projections ind mib.

Definition polymorphic_ind {A : Type}
  (function_parameter : Names.Mindmap_env.key * A) : env -&gt; bool :=
  match function_parameter with
  | (mind, _i) =&gt;
    fun env =&gt; Declareops.inductive_is_polymorphic (lookup_mind mind env)
  end.

Definition polymorphic_pind {A : Type}
  (function_parameter : (Names.Mindmap_env.key * A) * Univ.Instance.t)
  : env -&gt; bool :=
  match function_parameter with
  | (ind, u) =&gt;
    fun env =&gt;
      if Univ.Instance.is_empty u then
        false
      else
        polymorphic_ind ind env
  end.

Definition type_in_type_ind {A : Type}
  (function_parameter : Names.Mindmap_env.key * A) : env -&gt; bool :=
  match function_parameter with
  | (mind, _i) =&gt;
    fun env =&gt; negb (check_universes (mind_typing_flags (lookup_mind mind env)))
  end.

Definition template_checked_ind {A : Type}
  (function_parameter : Names.Mindmap_env.key * A) : env -&gt; bool :=
  match function_parameter with
  | (mind, _i) =&gt;
    fun env =&gt; check_template (mind_typing_flags (lookup_mind mind env))
  end.

Definition template_polymorphic_ind
  (function_parameter : Names.Mindmap_env.key * Z) : env -&gt; bool :=
  match function_parameter with
  | (mind, i) =&gt;
    fun env =&gt;
      match
        mind_arity
          (Util.Array.(CArray.ExtS.get) (mind_packets (lookup_mind mind env)) i)
        with
      | TemplateArity _ =&gt; true
      | RegularArity _ =&gt; false
      end
  end.

Definition template_polymorphic_variables
  (function_parameter : Names.Mindmap_env.key * Z) : env -&gt; list Univ.Level.t :=
  match function_parameter with
  | (mind, i) =&gt;
    fun env =&gt;
      match
        mind_arity
          (Util.Array.(CArray.ExtS.get) (mind_packets (lookup_mind mind env)) i)
        with
      | TemplateArity {| Declarations.template_param_levels := l |} =&gt;
        Util.List.(CList.ExtS.map_filter) (fun level =&gt; level) l
      | RegularArity _ =&gt; []
      end
  end.

Definition template_polymorphic_pind
  (function_parameter : (Names.Mindmap_env.key * Z) * Univ.Instance.t)
  : env -&gt; bool :=
  match function_parameter with
  | (ind, u) =&gt;
    fun env =&gt;
      if negb (Univ.Instance.is_empty u) then
        false
      else
        template_polymorphic_ind ind env
  end.

Definition add_mind_key
  (kn : Names.Mindmap_env.key)
  (function_parameter :
    Declarations.mutual_inductive_body * (Stdlib.ref link_info)) : env -&gt; env :=
  match function_parameter with
  | (_mind, _) as mind_key =&gt;
    fun env =&gt;
      let new_inds :=
        Names.Mindmap_env.add kn mind_key (Globals.inductives (env_globals env))
        in
      let new_globals := record in
      record
  end.

Definition add_mind
  (kn : Names.Mindmap_env.key) (mib : Declarations.mutual_inductive_body)
  (env : env) : env :=
  let li := Stdlib.ref no_link_info in
  add_mind_key kn (mib, li) env.

Definition lookup_constant_variables (c : Names.Cmap_env.key) (env : env)
  : Names.Id.Set.t :=
  let cmap := lookup_constant c env in
  Context.Named.to_vars (const_hyps cmap).

Definition lookup_inductive_variables {A : Type}
  (function_parameter : Names.Mindmap_env.key * A) : env -&gt; Names.Id.Set.t :=
  match function_parameter with
  | (kn, _i) =&gt;
    fun env =&gt;
      let mis := lookup_mind kn env in
      Context.Named.to_vars (mind_hyps mis)
  end.

Definition lookup_constructor_variables {A B : Type}
  (function_parameter : (Names.Mindmap_env.key * A) * B)
  : env -&gt; Names.Id.Set.t :=
  match function_parameter with
  | (ind, _) =&gt; fun env =&gt; lookup_inductive_variables ind env
  end.

Definition constant_context (env : env) (c : Names.Cmap_env.key)
  : Univ.AUContext.t :=
  let cb := lookup_constant c env in
  Declareops.constant_polymorphic_context cb.

Definition universes_of_global (env : env) (r : Names.GlobRef.t)
  : Univ.AUContext.t :=
  match r with
  | VarRef _ =&gt; Univ.AUContext.empty
  | ConstRef c =&gt; constant_context env c
  | IndRef (mind, _) | ConstructRef ((mind, _), _) =&gt;
    let mib := lookup_mind mind env in
    Declareops.inductive_polymorphic_context mib
  end.

Definition vars_of_global (env : env) (gr : Names.GlobRef.t) : Names.Id.Set.t :=
  match gr with
  | VarRef id =&gt; Names.Id.Set.singleton id
  | ConstRef kn =&gt; lookup_constant_variables kn env
  | IndRef ind =&gt; lookup_inductive_variables ind env
  | ConstructRef cstr =&gt; lookup_constructor_variables cstr env
  end.

Definition global_vars_set (env : env) (constr : Constr.constr)
  : Names.Id.Set.t :=
  let fix filtrec (acc : Names.Id.Set.t) (c : Constr.constr) : Names.Id.Set.t :=
    match Constr.destRef c with
    | (gr, _) =&gt; Names.Id.Set.union (vars_of_global env gr) acc
    end in
  filtrec Names.Id.Set.empty constr.

Definition really_needed (env : env) (needed : Names.Id.Set.t)
  : Names.Id.Set.t :=
  Context.Named.fold_inside
    (fun need =&gt;
      fun decl =&gt;
        if Names.Id.Set.mem (Context.Named.Declaration.get_id decl) need then
          let globc :=
            match decl with
            | LocalAssum _ _ =&gt; Names.Id.Set.empty
            | LocalDef _ c _ =&gt; global_vars_set env c
            end in
          Names.Id.Set.union
            (global_vars_set env (Context.Named.Declaration.get_type decl))
            (Names.Id.Set.union globc need)
        else
          need) needed (named_context env).

Definition keep_hyps (env : env) (needed : Names.Id.Set.t)
  : Context.Named.pt Constr.constr Constr.types :=
  let really_needed := really_needed env needed in
  Context.Named.fold_outside
    (fun d =&gt;
      fun nsign =&gt;
        if Names.Id.Set.mem (Context.Named.Declaration.get_id d) really_needed
          then
          Context.Named.add d nsign
        else
          nsign) (named_context env) empty_named_context.

Definition add_modtype (mtb : Declarations.module_type_body) (env : env)
  : env :=
  let mp := mod_mp mtb in
  let new_modtypes :=
    Names.MPmap.add mp mtb (Globals.modtypes (env_globals env)) in
  let new_globals := record in
  record.

Definition shallow_add_module (mb : Declarations.module_body) (env : env)
  : env :=
  let mp := mod_mp mb in
  let new_mods := Names.MPmap.add mp mb (Globals.modules (env_globals env)) in
  let new_globals := record in
  record.

Definition lookup_module (mp : Names.MPmap.key) (env : env)
  : Declarations.module_body :=
  Names.MPmap.find mp (Globals.modules (env_globals env)).

Definition lookup_modtype (mp : Names.MPmap.key) (env : env)
  : Declarations.module_type_body :=
  Names.MPmap.find mp (Globals.modtypes (env_globals env)).

Record punsafe_judgment {constr types : Type} := {
  uj_val : constr;
  uj_type : types }.
Arguments punsafe_judgment : clear implicits.

Definition on_judgment {A B : Type} (f : A -&gt; B) (j : punsafe_judgment A A)
  : punsafe_judgment B B :=
  {| uj_val := f (uj_val j); uj_type := f (uj_type j) |}.

Definition on_judgment_value {A B C : Type}
  (f : A -&gt; B) (j : punsafe_judgment A C) : punsafe_judgment B C := record.

Definition on_judgment_type {A B C : Type}
  (f : A -&gt; B) (j : punsafe_judgment C A) : punsafe_judgment C B := record.

Definition unsafe_judgment := punsafe_judgment Constr.constr Constr.types.

Definition make_judge {A B : Type} (v : A) (tj : B) : punsafe_judgment A B :=
  {| uj_val := v; uj_type := tj |}.

Definition j_val {A B : Type} (j : punsafe_judgment A B) : A := uj_val j.

Definition j_type {A B : Type} (j : punsafe_judgment A B) : B := uj_type j.

Record punsafe_type_judgment {types : Type} := {
  utj_val : types;
  utj_type : Sorts.t }.
Arguments punsafe_type_judgment : clear implicits.

Definition unsafe_type_judgment := punsafe_type_judgment Constr.types.

Definition apply_to_hyp
  (ctxt : named_context_val) (id : Names.Id.t)
  (f :
    Constr.named_context -&gt;
      Constr.named_declaration -&gt;
        (list Constr.named_declaration) -&gt;
          NamedDecl.pt Constr.constr Constr.types) : named_context_val :=
  let fix aux (rtail : list Constr.named_declaration) (ctxt : named_context_val)
    : named_context_val :=
    match match_named_context_val ctxt with
    | Some (d, v, ctxt) =&gt;
      if Names.Id.equal (Context.Named.Declaration.get_id d) id then
        push_named_context_val_val (f (env_named_ctx ctxt) d rtail) v ctxt
      else
        let ctxt' := aux (cons d rtail) ctxt in
        push_named_context_val_val d v ctxt'
    | None =&gt; Stdlib.raise Hyp_not_found
    end in
  aux [] ctxt.

Definition remove_hyps
  (ids : Names.Id.Set.t)
  (check_context : Constr.named_declaration -&gt; Constr.named_declaration)
  (check_value : lazy_val -&gt; lazy_val) (ctxt : named_context_val)
  : named_context_val :=
  let fix remove_hyps (ctxt : named_context_val) : named_context_val * bool :=
    match match_named_context_val ctxt with
    | None =&gt; (empty_named_context_val, false)
    | Some (d, v, rctxt) =&gt;
      match remove_hyps rctxt with
      | (ans, seen) =&gt;
        if Names.Id.Set.mem (Context.Named.Declaration.get_id d) ids then
          (ans, true)
        else
          if negb seen then
            (ctxt, false)
          else
            let rctxt' := ans in
            let d' := check_context d in
            let v' := check_value v in
            if
              andb (Stdlib.op_eq_eq d d')
                (andb (Stdlib.op_eq_eq v v') (Stdlib.op_eq_eq rctxt rctxt'))
              then
              (ctxt, true)
            else
              ((push_named_context_val_val d' v' rctxt'), true)
      end
    end in
  fst (remove_hyps ctxt).

Definition is_polymorphic (env : env) (r : Names.GlobRef.t) : bool :=
  match r with
  | VarRef _id =&gt; false
  | ConstRef c =&gt; polymorphic_constant c env
  | IndRef ind =&gt; polymorphic_ind ind env
  | ConstructRef cstr =&gt;
    polymorphic_ind (Names.inductive_of_constructor cstr) env
  end.

Definition is_template_polymorphic (env : env) (r : Names.GlobRef.t) : bool :=
  match r with
  | VarRef _id =&gt; false
  | ConstRef _c =&gt; false
  | IndRef ind =&gt; template_polymorphic_ind ind env
  | ConstructRef cstr =&gt;
    template_polymorphic_ind (Names.inductive_of_constructor cstr) env
  end.

Definition get_template_polymorphic_variables (env : env) (r : Names.GlobRef.t)
  : list Univ.Level.t :=
  match r with
  | VarRef _id =&gt; []
  | ConstRef _c =&gt; []
  | IndRef ind =&gt; template_polymorphic_variables ind env
  | ConstructRef cstr =&gt;
    template_polymorphic_variables (Names.inductive_of_constructor cstr) env
  end.

Definition is_template_checked (env : env) (r : Names.GlobRef.t) : bool :=
  match r with
  | VarRef _id =&gt; false
  | ConstRef _c =&gt; false
  | IndRef ind =&gt; template_checked_ind ind env
  | ConstructRef cstr =&gt;
    template_checked_ind (Names.inductive_of_constructor cstr) env
  end.

Definition is_type_in_type (env : env) (r : Names.GlobRef.t) : bool :=
  match r with
  | VarRef _id =&gt; false
  | ConstRef c =&gt; type_in_type_constant c env
  | IndRef ind =&gt; type_in_type_ind ind env
  | ConstructRef cstr =&gt;
    type_in_type_ind (Names.inductive_of_constructor cstr) env
  end.

Definition set_retroknowledge (env : env) (r : Retroknowledge.retroknowledge)
  : env := record.

Definition set_native_symbols
  (env : env) (native_symbols : Names.DPmap.t Nativevalues.symbols) : env :=
  record.

Definition add_native_symbols
  (dir : Names.DPmap.key) (syms : Nativevalues.symbols) (env : env) : env :=
  record.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="esubst" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>esubst.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Bruno Barras for Coq V7.0, Mar 2001 *)

(* Support for explicit substitutions *)

open Util

(*********************)
(*      Lifting      *)
(*********************)

(* Explicit lifts and basic operations *)
(* Invariant to preserve in this module: no lift contains two consecutive
    [ELSHFT] nor two consecutive [ELLFT]. *)
type lift =
  | ELID
  | ELSHFT of lift * int (* ELSHFT(l,n) == lift of n, then apply lift l *)
  | ELLFT of int * lift  (* ELLFT(n,l)  == apply l to de Bruijn &gt; n *)
                         (*                 i.e under n binders *)

let el_id = ELID

(* compose a relocation of magnitude n *)
let el_shft_rec n = function
  | ELSHFT(el,k) -&gt; ELSHFT(el,k+n)
  | el           -&gt; ELSHFT(el,n)
let el_shft n el = if Int.equal n 0 then el else el_shft_rec n el

(* cross n binders *)
let el_liftn_rec n = function
  | ELID        -&gt; ELID
  | ELLFT(k,el) -&gt; ELLFT(n+k, el)
  | el          -&gt; ELLFT(n, el)
let el_liftn n el = if Int.equal n 0 then el else el_liftn_rec n el

let el_lift el = el_liftn_rec 1 el

(* relocation of de Bruijn n in an explicit lift *)
let rec reloc_rel n = function
  | ELID -&gt; n
  | ELLFT(k,el) -&gt;
      if n &lt;= k then n else (reloc_rel (n-k) el) + k
  | ELSHFT(el,k) -&gt; (reloc_rel (n+k) el)

let rec is_lift_id = function
  | ELID -&gt; true
  | ELSHFT(e,n) -&gt; Int.equal n 0 &amp;&amp; is_lift_id e
  | ELLFT (_,e) -&gt; is_lift_id e

(*********************)
(*  Substitutions    *)
(*********************)

(* (bounded) explicit substitutions of type 'a *)
type 'a subs =
  | ESID of int            (* ESID(n)    = %n END   bounded identity *)
  | CONS of 'a array * 'a subs
                           (* CONS([|t1..tn|],S)  =
                              (S.t1...tn)    parallel substitution
                              beware of the order *)
  | SHIFT of int * 'a subs (* SHIFT(n,S) = (^n o S) terms in S are relocated *)
                           (*                        with n vars *)
  | LIFT of int * 'a subs  (* LIFT(n,S) = (%n S) stands for ((^n o S).n...1) *)

(* operations of subs: collapses constructors when possible.
 * Needn't be recursive if we always use these functions
 *)

let subs_id i = ESID i

let subs_cons(x,s) = if Int.equal (Array.length x) 0 then s else CONS(x,s)

let subs_liftn n = function
  | ESID p        -&gt; ESID (p+n) (* bounded identity lifted extends by p *)
  | LIFT (p,lenv) -&gt; LIFT (p+n, lenv)
  | lenv          -&gt; LIFT (n,lenv)

let subs_lift a = subs_liftn 1 a
let subs_liftn n a = if Int.equal n 0 then a else subs_liftn n a

let subs_shft = function
  | (0, s)            -&gt; s
  | (n, SHIFT (k,s1)) -&gt; SHIFT (k+n, s1)
  | (n, s)            -&gt; SHIFT (n,s)
let subs_shft s = if Int.equal (fst s) 0 then snd s else subs_shft s

let subs_shift_cons = function
  (0, s, t)           -&gt; CONS(t,s)
| (k, SHIFT(n,s1), t) -&gt; CONS(t,SHIFT(k+n, s1))
| (k, s, t)           -&gt; CONS(t,SHIFT(k, s));;

(* Tests whether a substitution is equal to the identity *)
let rec is_subs_id = function
    ESID _     -&gt; true
  | LIFT(_,s)  -&gt; is_subs_id s
  | SHIFT(0,s) -&gt; is_subs_id s
  | CONS(x,s)  -&gt; Int.equal (Array.length x) 0 &amp;&amp; is_subs_id s
  | _          -&gt; false

(* Expands de Bruijn k in the explicit substitution subs
 * lams accumulates de shifts to perform when retrieving the i-th value
 * the rules used are the following:
 *
 *    [id]k       --&gt; k
 *    [S.t]1      --&gt; t
 *    [S.t]k      --&gt; [S](k-1)  if k &gt; 1
 *    [^n o S] k  --&gt; [^n]([S]k)
 *    [(%n S)] k  --&gt; k         if k &lt;= n
 *    [(%n S)] k  --&gt; [^n]([S](k-n))
 *
 * the result is (Inr (k+lams,p)) when the variable is just relocated
 * where p is None if the variable points inside subs and Some(k) if the
 * variable points k bindings beyond subs.
 *)
let rec exp_rel lams k subs =
  match subs with
    | CONS (def,_) when k &lt;= Array.length def
                           -&gt; Inl(lams,def.(Array.length def - k))
    | CONS (v,l)           -&gt; exp_rel lams (k - Array.length v) l
    | LIFT (n,_) when k&lt;=n -&gt; Inr(lams+k,None)
    | LIFT (n,l)           -&gt; exp_rel (n+lams) (k-n) l
    | SHIFT (n,s)          -&gt; exp_rel (n+lams) k s
    | ESID n when k&lt;=n     -&gt; Inr(lams+k,None)
    | ESID n               -&gt; Inr(lams+k,Some (k-n))

let expand_rel k subs = exp_rel 0 k subs

let rec subs_map f = function
| ESID _ as s -&gt; s
| CONS (x, s) -&gt; CONS (Array.map f x, subs_map f s)
| SHIFT (n, s) -&gt; SHIFT (n, subs_map f s)
| LIFT (n, s) -&gt; LIFT (n, subs_map f s)

let rec lift_subst mk_cl s1 s2 = match s1 with
| ELID -&gt; subs_map (fun c -&gt; mk_cl ELID c) s2
| ELSHFT(s, k) -&gt; subs_shft(k, lift_subst mk_cl s s2)
| ELLFT (k, s) -&gt;
  match s2 with
  | CONS(x,s') -&gt;
      CONS(CArray.Fun1.map mk_cl s1 x, lift_subst mk_cl s1 s')
  | ESID n -&gt; lift_subst mk_cl s (ESID (n + k))
  | SHIFT(k',s') -&gt;
      if k&lt;k'
      then subs_shft(k, lift_subst mk_cl s (subs_shft(k'-k, s')))
      else subs_shft(k', lift_subst mk_cl (el_liftn (k-k') s) s')
  | LIFT(k',s') -&gt;
      if k&lt;k'
      then subs_liftn k (lift_subst mk_cl s (subs_liftn (k'-k) s'))
      else subs_liftn k' (lift_subst mk_cl (el_liftn (k-k') s) s')

let rec comp mk_cl s1 s2 =
  match (s1, s2) with
    | _, ESID _ -&gt; s1
    | ESID _, _ -&gt; s2
    | SHIFT(k,s), _ -&gt; subs_shft(k, comp mk_cl s s2)
    | _, CONS(x,s') -&gt;
        CONS(Array.Fun1.map (fun s t -&gt; mk_cl(s,t)) s1 x, comp mk_cl s1 s')
    | CONS(x,s), SHIFT(k,s') -&gt;
        let lg = Array.length x in
        if k == lg then comp mk_cl s s'
        else if k &gt; lg then comp mk_cl s (SHIFT(k-lg, s'))
        else comp mk_cl (CONS(Array.sub x 0 (lg-k), s)) s'
    | CONS(x,s), LIFT(k,s') -&gt;
        let lg = Array.length x in
        if k == lg then CONS(x, comp mk_cl s s')
        else if k &gt; lg then CONS(x, comp mk_cl s (LIFT(k-lg, s')))
        else
          CONS(Array.sub x (lg-k) k,
               comp mk_cl (CONS(Array.sub x 0 (lg-k),s)) s')
    | LIFT(k,s), SHIFT(k',s') -&gt;
        if k&lt;k'
        then subs_shft(k, comp mk_cl s (subs_shft(k'-k, s')))
        else subs_shft(k', comp mk_cl (subs_liftn (k-k') s) s')
    | LIFT(k,s), LIFT(k',s') -&gt;
        if k&lt;k'
        then subs_liftn k (comp mk_cl s (subs_liftn (k'-k) s'))
        else subs_liftn k' (comp mk_cl (subs_liftn (k-k') s) s')
</pre>
          </div>
          <div class="col-md-6">
            <code>esubst.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Util.

Inductive lift : Type :=
| ELID : lift
| ELSHFT : lift -&gt; Z -&gt; lift
| ELLFT : Z -&gt; lift -&gt; lift.

Definition el_id : lift := ELID.

Definition el_shft_rec (n : Z) (function_parameter : lift) : lift :=
  match function_parameter with
  | ELSHFT el k =&gt; ELSHFT el (Util.op_plus k n)
  | el =&gt; ELSHFT el n
  end.

Definition el_shft (n : Int.t) (el : lift) : lift :=
  if Int.equal n 0 then
    el
  else
    el_shft_rec n el.

Definition el_liftn_rec (n : Z) (function_parameter : lift) : lift :=
  match function_parameter with
  | ELID =&gt; ELID
  | ELLFT k el =&gt; ELLFT (Util.op_plus n k) el
  | el =&gt; ELLFT n el
  end.

Definition el_liftn (n : Int.t) (el : lift) : lift :=
  if Int.equal n 0 then
    el
  else
    el_liftn_rec n el.

Definition el_lift (el : lift) : lift := el_liftn_rec 1 el.

Fixpoint reloc_rel (n : Z) (function_parameter : lift) : Z :=
  match function_parameter with
  | ELID =&gt; n
  | ELLFT k el =&gt;
    if OCaml.Stdlib.le n k then
      n
    else
      Util.op_plus (reloc_rel (Util.op_minus n k) el) k
  | ELSHFT el k =&gt; reloc_rel (Util.op_plus n k) el
  end.

Fixpoint is_lift_id (function_parameter : lift) : bool :=
  match function_parameter with
  | ELID =&gt; true
  | ELSHFT e n =&gt; andb (Int.equal n 0) (is_lift_id e)
  | ELLFT _ e =&gt; is_lift_id e
  end.

Inductive subs (a : Type) : Type :=
| ESID : Z -&gt; subs a
| CONS : (array a) -&gt; (subs a) -&gt; subs a
| SHIFT : Z -&gt; (subs a) -&gt; subs a
| LIFT : Z -&gt; (subs a) -&gt; subs a.

Arguments ESID {_}.
Arguments CONS {_}.
Arguments SHIFT {_}.
Arguments LIFT {_}.

Definition subs_id {A : Type} (i : Z) : subs A := ESID i.

Definition subs_cons {A : Type} (function_parameter : (array A) * (subs A))
  : subs A :=
  match function_parameter with
  | (x, s) =&gt;
    if Int.equal (Util.Array.(CArray.ExtS.length) x) 0 then
      s
    else
      CONS x s
  end.

Definition subs_liftn {A : Type} (n : Z) (function_parameter : subs A)
  : subs A :=
  match function_parameter with
  | ESID p =&gt; ESID (Util.op_plus p n)
  | LIFT p lenv =&gt; LIFT (Util.op_plus p n) lenv
  | lenv =&gt; LIFT n lenv
  end.

Definition subs_lift {A : Type} (a : subs A) : subs A := subs_liftn 1 a.

Definition subs_liftn {A : Type} (n : Int.t) (a : subs A) : subs A :=
  if Int.equal n 0 then
    a
  else
    subs_liftn n a.

Definition subs_shft {A : Type} (function_parameter : Z * (subs A)) : subs A :=
  match function_parameter with
  | (0, s) =&gt; s
  | (n, SHIFT k s1) =&gt; SHIFT (Util.op_plus k n) s1
  | (n, s) =&gt; SHIFT n s
  end.

Definition subs_shft {A : Type} (s : Int.t * (subs A)) : subs A :=
  if Int.equal (fst s) 0 then
    snd s
  else
    subs_shft s.

Definition subs_shift_cons {A : Type}
  (function_parameter : Z * (subs A) * (array A)) : subs A :=
  match function_parameter with
  | (0, s, t) =&gt; CONS t s
  | (k, SHIFT n s1, t) =&gt; CONS t (SHIFT (Util.op_plus k n) s1)
  | (k, s, t) =&gt; CONS t (SHIFT k s)
  end.

Fixpoint is_subs_id {A : Type} (function_parameter : subs A) : bool :=
  match function_parameter with
  | ESID _ =&gt; true
  | LIFT _ s =&gt; is_subs_id s
  | SHIFT 0 s =&gt; is_subs_id s
  | CONS x s =&gt;
    andb (Int.equal (Util.Array.(CArray.ExtS.length) x) 0) (is_subs_id s)
  | _ =&gt; false
  end.

Fixpoint exp_rel {A : Type} (lams : Z) (k : Z) (subs : subs A)
  : Util.union (Z * A) (Z * (option Z)) :=
  match subs with
  | CONS v l =&gt;
    exp_rel lams (Util.op_minus k (Util.Array.(CArray.ExtS.length) v)) l
  | LIFT n l =&gt; exp_rel (Util.op_plus n lams) (Util.op_minus k n) l
  | SHIFT n s =&gt; exp_rel (Util.op_plus n lams) k s
  | ESID n =&gt; Inr ((Util.op_plus lams k), (Some (Util.op_minus k n)))
  end.

Definition expand_rel {A : Type} (k : Z) (subs : subs A)
  : Util.union (Z * A) (Z * (option Z)) := exp_rel 0 k subs.

Fixpoint subs_map {A B : Type} (f : A -&gt; B) (function_parameter : subs A)
  : subs B :=
  match function_parameter with
  | (ESID _) as s =&gt; s
  | CONS x s =&gt; CONS (Util.Array.(CArray.ExtS.map) f x) (subs_map f s)
  | SHIFT n s =&gt; SHIFT n (subs_map f s)
  | LIFT n s =&gt; LIFT n (subs_map f s)
  end.

Fixpoint lift_subst {A B : Type}
  (mk_cl : lift -&gt; A -&gt; B) (s1 : lift) (s2 : subs A) : subs B :=
  match s1 with
  | ELID =&gt; subs_map (fun c =&gt; mk_cl ELID c) s2
  | ELSHFT s k =&gt; subs_shft (k, (lift_subst mk_cl s s2))
  | ELLFT k s =&gt;
    match s2 with
    | CONS x s' =&gt; CONS (CArray.Fun1.map mk_cl s1 x) (lift_subst mk_cl s1 s')
    | ESID n =&gt; lift_subst mk_cl s (ESID (Util.op_plus n k))
    | SHIFT k' s' =&gt;
      if OCaml.Stdlib.lt k k' then
        subs_shft
          (k, (lift_subst mk_cl s (subs_shft ((Util.op_minus k' k), s'))))
      else
        subs_shft (k', (lift_subst mk_cl (el_liftn (Util.op_minus k k') s) s'))
    | LIFT k' s' =&gt;
      if OCaml.Stdlib.lt k k' then
        subs_liftn k (lift_subst mk_cl s (subs_liftn (Util.op_minus k' k) s'))
      else
        subs_liftn k' (lift_subst mk_cl (el_liftn (Util.op_minus k k') s) s')
    end
  end.

Fixpoint comp {A : Type}
  (mk_cl : ((subs A) * A) -&gt; A) (s1 : subs A) (s2 : subs A) : subs A :=
  match (s1, s2) with
  | (_, ESID _) =&gt; s1
  | (ESID _, _) =&gt; s2
  | (SHIFT k s, _) =&gt; subs_shft (k, (comp mk_cl s s2))
  | (_, CONS x s') =&gt;
    CONS (Util.Array.Fun1.map (fun s =&gt; fun t =&gt; mk_cl (s, t)) s1 x)
      (comp mk_cl s1 s')
  | (CONS x s, SHIFT k s') =&gt;
    let lg := Util.Array.(CArray.ExtS.length) x in
    if Stdlib.op_eq_eq k lg then
      comp mk_cl s s'
    else
      if OCaml.Stdlib.gt k lg then
        comp mk_cl s (SHIFT (Util.op_minus k lg) s')
      else
        comp mk_cl
          (CONS (Util.Array.(CArray.ExtS.sub) x 0 (Util.op_minus lg k)) s) s'
  | (CONS x s, LIFT k s') =&gt;
    let lg := Util.Array.(CArray.ExtS.length) x in
    if Stdlib.op_eq_eq k lg then
      CONS x (comp mk_cl s s')
    else
      if OCaml.Stdlib.gt k lg then
        CONS x (comp mk_cl s (LIFT (Util.op_minus k lg) s'))
      else
        CONS (Util.Array.(CArray.ExtS.sub) x (Util.op_minus lg k) k)
          (comp mk_cl
            (CONS (Util.Array.(CArray.ExtS.sub) x 0 (Util.op_minus lg k)) s) s')
  | (LIFT k s, SHIFT k' s') =&gt;
    if OCaml.Stdlib.lt k k' then
      subs_shft (k, (comp mk_cl s (subs_shft ((Util.op_minus k' k), s'))))
    else
      subs_shft (k', (comp mk_cl (subs_liftn (Util.op_minus k k') s) s'))
  | (LIFT k s, LIFT k' s') =&gt;
    if OCaml.Stdlib.lt k k' then
      subs_liftn k (comp mk_cl s (subs_liftn (Util.op_minus k' k) s'))
    else
      subs_liftn k' (comp mk_cl (subs_liftn (Util.op_minus k k') s) s')
  end.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="evar" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>evar.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

type t = int

let repr x = x
let unsafe_of_int x = x
let compare = Int.compare
let equal = Int.equal
let hash = Int.hash
let print x = Pp.(str &quot;?X&quot; ++ int x)

module Set = Int.Set
module Map = Int.Map
</pre>
          </div>
          <div class="col-md-6">
            <code>evar.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Definition t := Z.

Definition repr {A : Type} (x : A) : A := x.

Definition unsafe_of_int {A : Type} (x : A) : A := x.

Definition compare : Int.t -&gt; Int.t -&gt; Z := Int.compare.

Definition equal : Int.t -&gt; Int.t -&gt; bool := Int.equal.

Definition hash : Int.t -&gt; Z := Int.hash.

Definition print (x : Z) : Pp.t :=
  Pp.op_plus_plus (Pp.str &quot;?X&quot; % string) (Pp.int x).</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="genOpcodeFiles" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>genOpcodeFiles.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(** List of opcodes.

    It is used to generate the [coq_instruct.h], [coq_jumptbl.h] and
    [copcodes.ml] files.

    If adding an instruction, DON'T FORGET TO UPDATE coq_fix_code.c
    with the arity of the instruction and maybe coq_tcode_of_code.
*)
let opcodes =
  [|
    &quot;ACC0&quot;;
    &quot;ACC1&quot;;
    &quot;ACC2&quot;;
    &quot;ACC3&quot;;
    &quot;ACC4&quot;;
    &quot;ACC5&quot;;
    &quot;ACC6&quot;;
    &quot;ACC7&quot;;
    &quot;ACC&quot;;
    &quot;PUSH&quot;;
    &quot;PUSHACC0&quot;;
    &quot;PUSHACC1&quot;;
    &quot;PUSHACC2&quot;;
    &quot;PUSHACC3&quot;;
    &quot;PUSHACC4&quot;;
    &quot;PUSHACC5&quot;;
    &quot;PUSHACC6&quot;;
    &quot;PUSHACC7&quot;;
    &quot;PUSHACC&quot;;
    &quot;POP&quot;;
    &quot;ENVACC1&quot;;
    &quot;ENVACC2&quot;;
    &quot;ENVACC3&quot;;
    &quot;ENVACC4&quot;;
    &quot;ENVACC&quot;;
    &quot;PUSHENVACC1&quot;;
    &quot;PUSHENVACC2&quot;;
    &quot;PUSHENVACC3&quot;;
    &quot;PUSHENVACC4&quot;;
    &quot;PUSHENVACC&quot;;
    &quot;PUSH_RETADDR&quot;;
    &quot;APPLY&quot;;
    &quot;APPLY1&quot;;
    &quot;APPLY2&quot;;
    &quot;APPLY3&quot;;
    &quot;APPLY4&quot;;
    &quot;APPTERM&quot;;
    &quot;APPTERM1&quot;;
    &quot;APPTERM2&quot;;
    &quot;APPTERM3&quot;;
    &quot;RETURN&quot;;
    &quot;RESTART&quot;;
    &quot;GRAB&quot;;
    &quot;GRABREC&quot;;
    &quot;CLOSURE&quot;;
    &quot;CLOSUREREC&quot;;
    &quot;CLOSURECOFIX&quot;;
    &quot;OFFSETCLOSUREM2&quot;;
    &quot;OFFSETCLOSURE0&quot;;
    &quot;OFFSETCLOSURE2&quot;;
    &quot;OFFSETCLOSURE&quot;;
    &quot;PUSHOFFSETCLOSUREM2&quot;;
    &quot;PUSHOFFSETCLOSURE0&quot;;
    &quot;PUSHOFFSETCLOSURE2&quot;;
    &quot;PUSHOFFSETCLOSURE&quot;;
    &quot;GETGLOBAL&quot;;
    &quot;PUSHGETGLOBAL&quot;;
    &quot;MAKEBLOCK&quot;;
    &quot;MAKEBLOCK1&quot;;
    &quot;MAKEBLOCK2&quot;;
    &quot;MAKEBLOCK3&quot;;
    &quot;MAKEBLOCK4&quot;;
    &quot;SWITCH&quot;;
    &quot;PUSHFIELDS&quot;;
    &quot;GETFIELD0&quot;;
    &quot;GETFIELD1&quot;;
    &quot;GETFIELD&quot;;
    &quot;SETFIELD0&quot;;
    &quot;SETFIELD1&quot;;
    &quot;SETFIELD&quot;;
    &quot;PROJ&quot;;
    &quot;ENSURESTACKCAPACITY&quot;;
    &quot;CONST0&quot;;
    &quot;CONST1&quot;;
    &quot;CONST2&quot;;
    &quot;CONST3&quot;;
    &quot;CONSTINT&quot;;
    &quot;PUSHCONST0&quot;;
    &quot;PUSHCONST1&quot;;
    &quot;PUSHCONST2&quot;;
    &quot;PUSHCONST3&quot;;
    &quot;PUSHCONSTINT&quot;;
    &quot;ACCUMULATE&quot;;
    &quot;MAKESWITCHBLOCK&quot;;
    &quot;MAKEACCU&quot;;
    &quot;MAKEPROD&quot;;
    &quot;BRANCH&quot;;
    &quot;CHECKADDINT63&quot;;
    &quot;ADDINT63&quot;;
    &quot;CHECKADDCINT63&quot;;
    &quot;CHECKADDCARRYCINT63&quot;;
    &quot;CHECKSUBINT63&quot;;
    &quot;SUBINT63&quot;;
    &quot;CHECKSUBCINT63&quot;;
    &quot;CHECKSUBCARRYCINT63&quot;;
    &quot;CHECKMULINT63&quot;;
    &quot;CHECKMULCINT63&quot;;
    &quot;CHECKDIVINT63&quot;;
    &quot;CHECKMODINT63&quot;;
    &quot;CHECKDIVEUCLINT63&quot;;
    &quot;CHECKDIV21INT63&quot;;
    &quot;CHECKLXORINT63&quot;;
    &quot;CHECKLORINT63&quot;;
    &quot;CHECKLANDINT63&quot;;
    &quot;CHECKLSLINT63&quot;;
    &quot;CHECKLSRINT63&quot;;
    &quot;CHECKADDMULDIVINT63&quot;;
    &quot;CHECKLSLINT63CONST1&quot;;
    &quot;CHECKLSRINT63CONST1&quot;;
    &quot;CHECKEQINT63&quot;;
    &quot;CHECKLTINT63&quot;;
    &quot;LTINT63&quot;;
    &quot;CHECKLEINT63&quot;;
    &quot;LEINT63&quot;;
    &quot;CHECKCOMPAREINT63&quot;;
    &quot;CHECKHEAD0INT63&quot;;
    &quot;CHECKTAIL0INT63&quot;;
    &quot;ISINT&quot;;
    &quot;AREINT2&quot;;
    &quot;STOP&quot;
  |]

let pp_c_comment fmt =
  Format.fprintf fmt &quot;/* %a */&quot;

let pp_ocaml_comment fmt =
  Format.fprintf fmt &quot;(* %a *)&quot;

let pp_header isOcaml fmt =
  Format.fprintf fmt &quot;%a&quot;
    (fun fmt -&gt;
       (if isOcaml then pp_ocaml_comment else pp_c_comment) fmt
         Format.pp_print_string)
    &quot;DO NOT EDIT: automatically generated by kernel/genOpcodeFiles.ml&quot;

let pp_with_commas fmt k =
  Array.iteri (fun n s -&gt;
      Format.fprintf fmt &quot;  %a%s@.&quot;
        k s
        (if n + 1 &lt; Array.length opcodes
         then &quot;,&quot; else &quot;&quot;)
    ) opcodes

let pp_coq_instruct_h fmt =
  let line = Format.fprintf fmt &quot;%s@.&quot; in
  pp_header false fmt;
  line &quot;#pragma once&quot;;
  line &quot;enum instructions {&quot;;
  pp_with_commas fmt Format.pp_print_string;
  line &quot;};&quot;

let pp_coq_jumptbl_h fmt =
  pp_with_commas fmt (fun fmt -&gt; Format.fprintf fmt &quot;&amp;&amp;coq_lbl_%s&quot;)

let pp_copcodes_ml fmt =
  pp_header true fmt;
  Array.iteri (fun n s -&gt;
      Format.fprintf fmt &quot;let op%s = %d@.@.&quot; s n
    ) opcodes

let usage () =
  Format.eprintf &quot;usage: %s [enum|jump|copml]@.&quot; Sys.argv.(0);
  exit 1

let main () =
  match Sys.argv.(1) with
  | &quot;enum&quot; -&gt; pp_coq_instruct_h Format.std_formatter
  | &quot;jump&quot; -&gt; pp_coq_jumptbl_h Format.std_formatter
  | &quot;copml&quot; -&gt; pp_copcodes_ml Format.std_formatter
  | _ -&gt; usage ()
  | exception Invalid_argument _ -&gt; usage ()

let () = main ()
</pre>
          </div>
          <div class="col-md-6">
            <code>genOpcodeFiles.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Definition opcodes : array string :=
  (&quot;ACC0&quot; % string, &quot;ACC1&quot; % string, &quot;ACC2&quot; % string, &quot;ACC3&quot; % string,
    &quot;ACC4&quot; % string, &quot;ACC5&quot; % string, &quot;ACC6&quot; % string, &quot;ACC7&quot; % string,
    &quot;ACC&quot; % string, &quot;PUSH&quot; % string, &quot;PUSHACC0&quot; % string, &quot;PUSHACC1&quot; % string,
    &quot;PUSHACC2&quot; % string, &quot;PUSHACC3&quot; % string, &quot;PUSHACC4&quot; % string,
    &quot;PUSHACC5&quot; % string, &quot;PUSHACC6&quot; % string, &quot;PUSHACC7&quot; % string,
    &quot;PUSHACC&quot; % string, &quot;POP&quot; % string, &quot;ENVACC1&quot; % string, &quot;ENVACC2&quot; % string,
    &quot;ENVACC3&quot; % string, &quot;ENVACC4&quot; % string, &quot;ENVACC&quot; % string,
    &quot;PUSHENVACC1&quot; % string, &quot;PUSHENVACC2&quot; % string, &quot;PUSHENVACC3&quot; % string,
    &quot;PUSHENVACC4&quot; % string, &quot;PUSHENVACC&quot; % string, &quot;PUSH_RETADDR&quot; % string,
    &quot;APPLY&quot; % string, &quot;APPLY1&quot; % string, &quot;APPLY2&quot; % string, &quot;APPLY3&quot; % string,
    &quot;APPLY4&quot; % string, &quot;APPTERM&quot; % string, &quot;APPTERM1&quot; % string,
    &quot;APPTERM2&quot; % string, &quot;APPTERM3&quot; % string, &quot;RETURN&quot; % string,
    &quot;RESTART&quot; % string, &quot;GRAB&quot; % string, &quot;GRABREC&quot; % string, &quot;CLOSURE&quot; % string,
    &quot;CLOSUREREC&quot; % string, &quot;CLOSURECOFIX&quot; % string, &quot;OFFSETCLOSUREM2&quot; % string,
    &quot;OFFSETCLOSURE0&quot; % string, &quot;OFFSETCLOSURE2&quot; % string,
    &quot;OFFSETCLOSURE&quot; % string, &quot;PUSHOFFSETCLOSUREM2&quot; % string,
    &quot;PUSHOFFSETCLOSURE0&quot; % string, &quot;PUSHOFFSETCLOSURE2&quot; % string,
    &quot;PUSHOFFSETCLOSURE&quot; % string, &quot;GETGLOBAL&quot; % string,
    &quot;PUSHGETGLOBAL&quot; % string, &quot;MAKEBLOCK&quot; % string, &quot;MAKEBLOCK1&quot; % string,
    &quot;MAKEBLOCK2&quot; % string, &quot;MAKEBLOCK3&quot; % string, &quot;MAKEBLOCK4&quot; % string,
    &quot;SWITCH&quot; % string, &quot;PUSHFIELDS&quot; % string, &quot;GETFIELD0&quot; % string,
    &quot;GETFIELD1&quot; % string, &quot;GETFIELD&quot; % string, &quot;SETFIELD0&quot; % string,
    &quot;SETFIELD1&quot; % string, &quot;SETFIELD&quot; % string, &quot;PROJ&quot; % string,
    &quot;ENSURESTACKCAPACITY&quot; % string, &quot;CONST0&quot; % string, &quot;CONST1&quot; % string,
    &quot;CONST2&quot; % string, &quot;CONST3&quot; % string, &quot;CONSTINT&quot; % string,
    &quot;PUSHCONST0&quot; % string, &quot;PUSHCONST1&quot; % string, &quot;PUSHCONST2&quot; % string,
    &quot;PUSHCONST3&quot; % string, &quot;PUSHCONSTINT&quot; % string, &quot;ACCUMULATE&quot; % string,
    &quot;MAKESWITCHBLOCK&quot; % string, &quot;MAKEACCU&quot; % string, &quot;MAKEPROD&quot; % string,
    &quot;BRANCH&quot; % string, &quot;CHECKADDINT63&quot; % string, &quot;ADDINT63&quot; % string,
    &quot;CHECKADDCINT63&quot; % string, &quot;CHECKADDCARRYCINT63&quot; % string,
    &quot;CHECKSUBINT63&quot; % string, &quot;SUBINT63&quot; % string, &quot;CHECKSUBCINT63&quot; % string,
    &quot;CHECKSUBCARRYCINT63&quot; % string, &quot;CHECKMULINT63&quot; % string,
    &quot;CHECKMULCINT63&quot; % string, &quot;CHECKDIVINT63&quot; % string,
    &quot;CHECKMODINT63&quot; % string, &quot;CHECKDIVEUCLINT63&quot; % string,
    &quot;CHECKDIV21INT63&quot; % string, &quot;CHECKLXORINT63&quot; % string,
    &quot;CHECKLORINT63&quot; % string, &quot;CHECKLANDINT63&quot; % string,
    &quot;CHECKLSLINT63&quot; % string, &quot;CHECKLSRINT63&quot; % string,
    &quot;CHECKADDMULDIVINT63&quot; % string, &quot;CHECKLSLINT63CONST1&quot; % string,
    &quot;CHECKLSRINT63CONST1&quot; % string, &quot;CHECKEQINT63&quot; % string,
    &quot;CHECKLTINT63&quot; % string, &quot;LTINT63&quot; % string, &quot;CHECKLEINT63&quot; % string,
    &quot;LEINT63&quot; % string, &quot;CHECKCOMPAREINT63&quot; % string,
    &quot;CHECKHEAD0INT63&quot; % string, &quot;CHECKTAIL0INT63&quot; % string, &quot;ISINT&quot; % string,
    &quot;AREINT2&quot; % string, &quot;STOP&quot; % string).

Definition pp_c_comment {A : Type} (fmt : Stdlib.Format.formatter)
  : (Stdlib.Format.formatter -&gt; A -&gt; unit) -&gt; A -&gt; unit :=
  Stdlib.Format.fprintf fmt
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.String_literal &quot;/* &quot; % string
        (CamlinternalFormatBasics.Alpha
          (CamlinternalFormatBasics.String_literal &quot; */&quot; % string
            CamlinternalFormatBasics.End_of_format))) &quot;/* %a */&quot; % string).

Definition pp_ocaml_comment {A : Type} (fmt : Stdlib.Format.formatter)
  : (Stdlib.Format.formatter -&gt; A -&gt; unit) -&gt; A -&gt; unit :=
  Stdlib.Format.fprintf fmt
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.String_literal &quot;(* &quot; % string
        (CamlinternalFormatBasics.Alpha
          (CamlinternalFormatBasics.String_literal &quot; *)&quot; % string
            CamlinternalFormatBasics.End_of_format))) &quot;(* %a *)&quot; % string).

Definition pp_header (isOcaml : bool) (fmt : Stdlib.Format.formatter) : unit :=
  Stdlib.Format.fprintf fmt
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.Alpha CamlinternalFormatBasics.End_of_format)
      &quot;%a&quot; % string)
    (fun fmt =&gt;
      (if isOcaml then
        pp_ocaml_comment
      else
        pp_c_comment) fmt Stdlib.Format.pp_print_string)
    &quot;DO NOT EDIT: automatically generated by kernel/genOpcodeFiles.ml&quot; % string.

Definition pp_with_commas
  (fmt : Stdlib.Format.formatter)
  (k : Stdlib.Format.formatter -&gt; string -&gt; unit) : unit :=
  Stdlib.Array.iteri
    (fun n =&gt;
      fun s =&gt;
        Stdlib.Format.fprintf fmt
          (CamlinternalFormatBasics.Format
            (CamlinternalFormatBasics.String_literal &quot;  &quot; % string
              (CamlinternalFormatBasics.Alpha
                (CamlinternalFormatBasics.String
                  CamlinternalFormatBasics.No_padding
                  (CamlinternalFormatBasics.Formatting_lit
                    CamlinternalFormatBasics.Flush_newline
                    CamlinternalFormatBasics.End_of_format))))
            &quot;  %a%s@.&quot; % string) k s
          (if OCaml.Stdlib.lt (Z.add n 1) (Stdlib.Array.length opcodes) then
            &quot;,&quot; % string
          else
            &quot;&quot; % string)) opcodes.

Definition pp_coq_instruct_h (fmt : Stdlib.Format.formatter) : unit :=
  let line :=
    Stdlib.Format.fprintf fmt
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
          (CamlinternalFormatBasics.Formatting_lit
            CamlinternalFormatBasics.Flush_newline
            CamlinternalFormatBasics.End_of_format)) &quot;%s@.&quot; % string) in
  pp_header false fmt;
  line &quot;#pragma once&quot; % string;
  line &quot;enum instructions {&quot; % string;
  pp_with_commas fmt Stdlib.Format.pp_print_string;
  line &quot;};&quot; % string.

Definition pp_coq_jumptbl_h (fmt : Stdlib.Format.formatter) : unit :=
  pp_with_commas fmt
    (fun fmt =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;&amp;&amp;coq_lbl_&quot; % string
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              CamlinternalFormatBasics.End_of_format)) &quot;&amp;&amp;coq_lbl_%s&quot; % string)).

Definition pp_copcodes_ml (fmt : Stdlib.Format.formatter) : unit :=
  pp_header true fmt;
  Stdlib.Array.iteri
    (fun n =&gt;
      fun s =&gt;
        Stdlib.Format.fprintf fmt
          (CamlinternalFormatBasics.Format
            (CamlinternalFormatBasics.String_literal &quot;let op&quot; % string
              (CamlinternalFormatBasics.String
                CamlinternalFormatBasics.No_padding
                (CamlinternalFormatBasics.String_literal &quot; = &quot; % string
                  (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_d
                    CamlinternalFormatBasics.No_padding
                    CamlinternalFormatBasics.No_precision
                    (CamlinternalFormatBasics.Formatting_lit
                      CamlinternalFormatBasics.Flush_newline
                      (CamlinternalFormatBasics.Formatting_lit
                        CamlinternalFormatBasics.Flush_newline
                        CamlinternalFormatBasics.End_of_format))))))
            &quot;let op%s = %d@.@.&quot; % string) s n) opcodes.

Definition usage {A : Type} (function_parameter : unit) : A :=
  match function_parameter with
  | tt =&gt;
    Stdlib.Format.eprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;usage: &quot; % string
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal
              &quot; [enum|jump|copml]&quot; % string
              (CamlinternalFormatBasics.Formatting_lit
                CamlinternalFormatBasics.Flush_newline
                CamlinternalFormatBasics.End_of_format))))
        &quot;usage: %s [enum|jump|copml]@.&quot; % string)
      (Stdlib.Array.get Stdlib.Sys.argv 0);
    Stdlib.exit 1
  end.

Definition main (function_parameter : unit) : unit :=
  match function_parameter with
  | tt =&gt;
    match Stdlib.Array.get Stdlib.Sys.argv 1 with
    | &quot;enum&quot; % string =&gt; pp_coq_instruct_h Stdlib.Format.std_formatter
    | &quot;jump&quot; % string =&gt; pp_coq_jumptbl_h Stdlib.Format.std_formatter
    | &quot;copml&quot; % string =&gt; pp_copcodes_ml Stdlib.Format.std_formatter
    | _ =&gt; usage tt
    end
  end.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="indTyping" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>indTyping.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Util
open Names
open Univ
open Term
open Constr
open Declarations
open Environ
open Entries
open Type_errors
open Context.Rel.Declaration

(** Check name unicity.
    Redundant with safe_typing's add_field checks -&gt; to remove?. *)

(* [check_constructors_names id s cl] checks that all the constructors names
   appearing in [l] are not present in the set [s], and returns the new set
   of names. The name [id] is the name of the current inductive type, used
   when reporting the error. *)

let check_constructors_names =
  let rec check idset = function
    | [] -&gt; idset
    | c::cl -&gt;
        if Id.Set.mem c idset then
          raise (InductiveError (SameNamesConstructors c))
        else
          check (Id.Set.add c idset) cl
  in
  check

(* [mind_check_names mie] checks the names of an inductive types declaration,
   and raises the corresponding exceptions when two types or two constructors
   have the same name. *)

let mind_check_names mie =
  let rec check indset cstset = function
    | [] -&gt; ()
    | ind::inds -&gt;
        let id = ind.mind_entry_typename in
        let cl = ind.mind_entry_consnames in
        if Id.Set.mem id indset then
          raise (InductiveError (SameNamesTypes id))
        else
          let cstset' = check_constructors_names cstset cl in
          check (Id.Set.add id indset) cstset' inds
  in
  check Id.Set.empty Id.Set.empty mie.mind_entry_inds
(* The above verification is not necessary from the kernel point of
  vue since inductive and constructors are not referred to by their
  name, but only by the name of the inductive packet and an index. *)


(************************************************************************)
(************************** Cumulativity checking************************)
(************************************************************************)

(* Check arities and constructors *)
let check_subtyping_arity_constructor env subst arcn numparams is_arity =
  let numchecked = ref 0 in
  let basic_check ev tp =
    if !numchecked &lt; numparams then () else Reduction.conv_leq ev tp (subst tp);
    numchecked := !numchecked + 1
  in
  let check_typ typ typ_env =
    match typ with
    | LocalAssum (_, typ') -&gt;
      begin
       try
          basic_check typ_env typ'; Environ.push_rel typ typ_env
        with Reduction.NotConvertible -&gt;
          CErrors.anomaly ~label:&quot;bad inductive subtyping relation&quot;
            Pp.(str &quot;Invalid subtyping relation&quot;)
      end
    | _ -&gt; CErrors.anomaly Pp.(str &quot;&quot;)
  in
  let typs, codom = Reduction.dest_prod env arcn in
  let last_env = Context.Rel.fold_outside check_typ typs ~init:env in
  if not is_arity then basic_check last_env codom else ()

let check_cumulativity univs variances env_ar params data =
  let uctx = match univs with
    | Monomorphic_entry _ -&gt; raise (InductiveError BadUnivs)
    | Polymorphic_entry (_,uctx) -&gt; uctx
  in
  let instance = UContext.instance uctx in
  if Instance.length instance != Array.length variances then raise (InductiveError BadUnivs);
  let numparams = Context.Rel.nhyps params in
  let new_levels = Array.init (Instance.length instance)
      (fun i -&gt; Level.(make (UGlobal.make DirPath.empty i)))
  in
  let lmap = Array.fold_left2 (fun lmap u u' -&gt; LMap.add u u' lmap)
      LMap.empty (Instance.to_array instance) new_levels
  in
  let dosubst = Vars.subst_univs_level_constr lmap in
  let instance_other = Instance.of_array new_levels in
  let constraints_other = Univ.subst_univs_level_constraints lmap (UContext.constraints uctx) in
  let uctx_other = Univ.UContext.make (instance_other, constraints_other) in
  let env = Environ.push_context uctx_other env_ar in
  let subtyp_constraints =
    Univ.enforce_leq_variance_instances variances
      instance instance_other
      Constraint.empty
  in
  let env = Environ.add_constraints subtyp_constraints env in
  (* process individual inductive types: *)
  List.iter (fun (arity,lc) -&gt;
        check_subtyping_arity_constructor env dosubst arity numparams true;
        Array.iter (fun cnt -&gt; check_subtyping_arity_constructor env dosubst cnt numparams false) lc)
    data

(************************************************************************)
(************************** Type checking *******************************)
(************************************************************************)

type univ_info = { ind_squashed : bool; ind_has_relevant_arg : bool;
                   ind_min_univ : Universe.t option; (* Some for template *)
                   ind_univ : Universe.t }

let check_univ_leq ?(is_real_arg=false) env u info =
  let ind_univ = info.ind_univ in
  let info = if not info.ind_has_relevant_arg &amp;&amp; is_real_arg &amp;&amp; not (Univ.Universe.is_sprop u)
    then {info with ind_has_relevant_arg=true}
    else info
  in
  (* Inductive types provide explicit lifting from SProp to other universes, so allow SProp &lt;= any. *)
  if type_in_type env || Univ.Universe.is_sprop u || UGraph.check_leq (universes env) u ind_univ
  then { info with ind_min_univ = Option.map (Universe.sup u) info.ind_min_univ }
  else if is_impredicative_univ env ind_univ
  then if Option.is_empty info.ind_min_univ then { info with ind_squashed = true }
    else raise (InductiveError BadUnivs)
  else raise (InductiveError BadUnivs)

let check_context_univs ~ctor env info ctx =
  let check_one d (info,env) =
    let info = match d with
      | LocalAssum (_,t) -&gt;
        (* could be retyping if it becomes available in the kernel *)
        let tj = Typeops.infer_type env t in
        check_univ_leq ~is_real_arg:ctor env (Sorts.univ_of_sort tj.utj_type) info
      | LocalDef _ -&gt; info
    in
    info, push_rel d env
  in
  fst (Context.Rel.fold_outside ~init:(info,env) check_one ctx)

let check_indices_matter env_params info indices =
  if not (indices_matter env_params) then info
  else check_context_univs ~ctor:false env_params info indices

(* env_ar contains the inductives before the current ones in the block, and no parameters *)
let check_arity env_params env_ar ind =
  let {utj_val=arity;utj_type=_} = Typeops.infer_type env_params ind.mind_entry_arity in
  let indices, ind_sort = Reduction.dest_arity env_params arity in
  let ind_min_univ = if ind.mind_entry_template then Some Universe.type0m else None in
  let univ_info = {
    ind_squashed=false;
    ind_has_relevant_arg=false;
    ind_min_univ;
    ind_univ=Sorts.univ_of_sort ind_sort;
  }
  in
  let univ_info = check_indices_matter env_params univ_info indices in
  (* We do not need to generate the universe of the arity with params;
     if later, after the validation of the inductive definition,
     full_arity is used as argument or subject to cast, an upper
     universe will be generated *)
  let arity = it_mkProd_or_LetIn arity (Environ.rel_context env_params) in
  let x = Context.make_annot (Name ind.mind_entry_typename) (Sorts.relevance_of_sort ind_sort) in
  push_rel (LocalAssum (x, arity)) env_ar,
  (arity, indices, univ_info)

let check_constructor_univs env_ar_par info (args,_) =
  (* We ignore the output, positivity will check that it's the expected inductive type *)
  check_context_univs ~ctor:true env_ar_par info args

let check_constructors env_ar_par isrecord params lc (arity,indices,univ_info) =
  let lc = Array.map_of_list (fun c -&gt; (Typeops.infer_type env_ar_par c).utj_val) lc in
  let splayed_lc = Array.map (Reduction.dest_prod_assum env_ar_par) lc in
  let univ_info = match Array.length lc with
    (* Empty type: all OK *)
    | 0 -&gt; univ_info

    (* SProp primitive records are OK, if we squash and become fakerecord also OK *)
    | 1 when isrecord -&gt; univ_info

    (* Unit and identity types must squash if SProp *)
    | 1 -&gt; check_univ_leq env_ar_par Univ.Universe.type0m univ_info

    (* More than 1 constructor: must squash if Prop/SProp *)
    | _ -&gt; check_univ_leq env_ar_par Univ.Universe.type0 univ_info
  in
  let univ_info = Array.fold_left (check_constructor_univs env_ar_par) univ_info splayed_lc in
  (* generalize the constructors over the parameters *)
  let lc = Array.map (fun c -&gt; Term.it_mkProd_or_LetIn c params) lc in
  (arity, lc), (indices, splayed_lc), univ_info

let check_record data =
  List.for_all (fun (_,(_,splayed_lc),info) -&gt;
      (* records must have all projections definable -&gt; equivalent to not being squashed *)
      not info.ind_squashed
      (* relevant records must have at least 1 relevant argument *)
      &amp;&amp; (Univ.Universe.is_sprop info.ind_univ
          || info.ind_has_relevant_arg)
      &amp;&amp; (match splayed_lc with
          (* records must have 1 constructor with at least 1 argument, and no anonymous fields *)
          | [|ctx,_|] -&gt;
            let module D = Context.Rel.Declaration in
            List.exists D.is_local_assum ctx &amp;&amp;
            List.for_all (fun d -&gt; not (D.is_local_assum d)
                                   || not (Name.is_anonymous (D.get_name d)))
              ctx
          | _ -&gt; false))
    data

(* Allowed eliminations *)

(* Previous comment: *)
(* Unitary/empty Prop: elimination to all sorts are realizable *)
(* unless the type is large. If it is large, forbids large elimination *)
(* which otherwise allows simulating the inconsistent system Type:Type. *)
(* -&gt; this is now handled by is_smashed: *)
(* - all_sorts in case of small, unitary Prop (not smashed) *)
(* - logical_sorts in case of large, unitary Prop (smashed) *)

let allowed_sorts {ind_squashed;ind_univ;ind_min_univ=_;ind_has_relevant_arg=_} =
  if not ind_squashed then InType
  else Sorts.family (Sorts.sort_of_univ ind_univ)

(* For a level to be template polymorphic, it must be introduced
   by the definition (so have no constraint except lbound &lt;= l)
   and not to be constrained from below, so any universe l' &lt;= l
   can be used as an instance of l. All bounds from above, i.e.
   l &lt;=/&lt; r will be valid for any l' &lt;= l. *)
let unbounded_from_below u cstrs =
  Univ.Constraint.for_all (fun (l, d, r) -&gt;
      match d with
      | Eq -&gt; not (Univ.Level.equal l u) &amp;&amp; not (Univ.Level.equal r u)
      | Lt | Le -&gt; not (Univ.Level.equal r u))
    cstrs

(* Returns the list [x_1, ..., x_n] of levels contributing to template
   polymorphism. The elements x_k is None if the k-th parameter
   (starting from the most recent and ignoring let-definitions) is not
   contributing to the inductive type's sort or is Some u_k if its level
   is u_k and is contributing. *)
let template_polymorphic_univs ~template_check uctx paramsctxt concl =
  let check_level l =
    if Univ.LSet.mem l (Univ.ContextSet.levels uctx) &amp;&amp;
       unbounded_from_below l (Univ.ContextSet.constraints uctx) then
      Some l
    else None
  in
  let univs = Univ.Universe.levels concl in
  let univs =
    if template_check then
      Univ.LSet.filter (fun l -&gt; Option.has_some (check_level l) || Univ.Level.is_prop l) univs
    else univs (* Doesn't check the universes can be generalized *)
  in
  let fold acc = function
    | (LocalAssum (_, p)) -&gt;
      (let c = Term.strip_prod_assum p in
      match kind c with
        | Sort (Type u) -&gt;
          if template_check then
            (match Univ.Universe.level u with
             | Some l -&gt; if Univ.LSet.mem l univs &amp;&amp; not (Univ.Level.is_prop l) then Some l else None
             | None -&gt; None)
          else Univ.Universe.level u
        | _ -&gt; None) :: acc
    | LocalDef _ -&gt; acc
  in
  let params = List.fold_left fold [] paramsctxt in
  params, univs

let abstract_packets ~template_check univs usubst params ((arity,lc),(indices,splayed_lc),univ_info) =
  let arity = Vars.subst_univs_level_constr usubst arity in
  let lc = Array.map (Vars.subst_univs_level_constr usubst) lc in
  let indices = Vars.subst_univs_level_context usubst indices in
  let splayed_lc = Array.map (fun (args,out) -&gt;
      let args = Vars.subst_univs_level_context usubst args in
      let out = Vars.subst_univs_level_constr usubst out in
      args,out)
      splayed_lc
  in
  let ind_univ = Univ.subst_univs_level_universe usubst univ_info.ind_univ in

  let arity = match univ_info.ind_min_univ with
    | None -&gt; RegularArity {mind_user_arity = arity; mind_sort = Sorts.sort_of_univ ind_univ}
    | Some min_univ -&gt;
      let ctx = match univs with
          | Monomorphic ctx -&gt; ctx
          | Polymorphic _ -&gt;
            CErrors.anomaly ~label:&quot;polymorphic_template_ind&quot;
              Pp.(strbrk &quot;Template polymorphism and full polymorphism are incompatible.&quot;) in
      let param_levels, concl_levels = template_polymorphic_univs ~template_check ctx params min_univ in
      if template_check &amp;&amp; List.for_all (fun x -&gt; Option.is_empty x) param_levels
         &amp;&amp; Univ.LSet.is_empty concl_levels then
        CErrors.anomaly ~label:&quot;polymorphic_template_ind&quot;
          Pp.(strbrk &quot;Ill-formed template inductive declaration: not polymorphic on any universe.&quot;)
      else
        TemplateArity {template_param_levels = param_levels; template_level = min_univ}
  in

  let kelim = allowed_sorts univ_info in
  (arity,lc), (indices,splayed_lc), kelim

let typecheck_inductive env (mie:mutual_inductive_entry) =
  let () = match mie.mind_entry_inds with
  | [] -&gt; CErrors.anomaly Pp.(str &quot;empty inductive types declaration.&quot;)
  | _ -&gt; ()
  in
  (* Check unicity of names (redundant with safe_typing's add_field checks) *)
  mind_check_names mie;
  assert (List.is_empty (Environ.rel_context env));

  let has_template_poly = List.exists (fun oie -&gt; oie.mind_entry_template) mie.mind_entry_inds in

  (* universes *)
  let env_univs =
    match mie.mind_entry_universes with
    | Monomorphic_entry ctx -&gt;
      let env = if has_template_poly then set_universes_lbound env Univ.Level.prop else env in
      push_context_set ctx env
    | Polymorphic_entry (_, ctx) -&gt; push_context ctx env
  in

  (* Params *)
  let env_params, params = Typeops.check_context env_univs mie.mind_entry_params in

  (* Arities *)
  let env_ar, data = List.fold_left_map (check_arity env_params) env_univs mie.mind_entry_inds in
  let env_ar_par = push_rel_context params env_ar in

  (* Constructors *)
  let isrecord = match mie.mind_entry_record with
    | Some (Some _) -&gt; true
    | Some None | None -&gt; false
  in
  let data = List.map2 (fun ind data -&gt;
      check_constructors env_ar_par isrecord params ind.mind_entry_lc data)
      mie.mind_entry_inds data
  in

  let record = mie.mind_entry_record in
  let data, record = match record with
    | None | Some None -&gt; data, record
    | Some (Some _) -&gt;
      if check_record data then
        data, record
      else
        (* if someone tried to declare a record as SProp but it can't
           be primitive we must squash. *)
        let data = List.map (fun (a,b,univs) -&gt;
            a,b,check_univ_leq env_ar_par Univ.Universe.type0m univs)
            data
        in
        data, Some None
  in

  let () = match mie.mind_entry_variance with
    | None -&gt; ()
    | Some variances -&gt;
      check_cumulativity mie.mind_entry_universes variances env_ar params (List.map pi1 data)
  in

  (* Abstract universes *)
  let usubst, univs = Declareops.abstract_universes mie.mind_entry_universes in
  let params = Vars.subst_univs_level_context usubst params in
  let template_check = Environ.check_template env in
  let data = List.map (abstract_packets ~template_check univs usubst params) data in

  let env_ar_par =
    let ctx = Environ.rel_context env_ar_par in
    let ctx = Vars.subst_univs_level_context usubst ctx in
    let env = Environ.pop_rel_context (Environ.nb_rel env_ar_par) env_ar_par in
    Environ.push_rel_context ctx env
  in

  env_ar_par, univs, mie.mind_entry_variance, record, params, Array.of_list data
</pre>
          </div>
          <div class="col-md-6">
            <code>indTyping.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Util.

Import Names.

Import Univ.

Import Term.

Import Constr.

Import Declarations.

Import Environ.

Import Entries.

Import Type_errors.

Import Context.Rel.Declaration.

Definition check_constructors_names
  : Names.Id.Set.t -&gt; (list Names.Id.Set.elt) -&gt; Names.Id.Set.t :=
  let fix check
    (idset : Names.Id.Set.t) (function_parameter : list Names.Id.Set.elt)
    : Names.Id.Set.t :=
    match function_parameter with
    | [] =&gt; idset
    | cons c cl =&gt;
      if Names.Id.Set.mem c idset then
        Stdlib.raise (InductiveError (SameNamesConstructors c))
      else
        check (Names.Id.Set.add c idset) cl
    end in
  check.

Definition mind_check_names (mie : Entries.mutual_inductive_entry) : unit :=
  let fix check
    (indset : Names.Id.Set.t) (cstset : Names.Id.Set.t) (function_parameter :
    list Entries.one_inductive_entry) : unit :=
    match function_parameter with
    | [] =&gt; tt
    | cons ind inds =&gt;
      let id := mind_entry_typename ind in
      let cl := mind_entry_consnames ind in
      if Names.Id.Set.mem id indset then
        Stdlib.raise (InductiveError (SameNamesTypes id))
      else
        let cstset' := check_constructors_names cstset cl in
        check (Names.Id.Set.add id indset) cstset' inds
    end in
  check Names.Id.Set.empty Names.Id.Set.empty (mind_entry_inds mie).

Definition check_subtyping_arity_constructor
  (env : Environ.env) (subst : Constr.types -&gt; Constr.types)
  (arcn : Constr.types) (numparams : Z) (is_arity : bool) : unit :=
  let numchecked := Stdlib.ref 0 in
  let basic_check (ev : Environ.env) (tp : Constr.types) : unit :=
    if OCaml.Stdlib.lt (Util.op_exclamation numchecked) numparams then
      tt
    else
      Reduction.conv_leq None None ev None tp (subst tp);
    Stdlib.op_colon_eq numchecked
      (Util.op_plus (Util.op_exclamation numchecked) 1) in
  let check_typ (typ : Constr.rel_declaration) (typ_env : Environ.env)
    : Environ.env :=
    match typ with
    | LocalAssum _ typ' =&gt; try
    | _ =&gt; CErrors.anomaly None None (Pp.str &quot;&quot; % string)
    end in
  match Reduction.dest_prod env arcn with
  | (typs, codom) =&gt;
    let last_env := Context.Rel.fold_outside check_typ typs env in
    if negb is_arity then
      basic_check last_env codom
    else
      tt
  end.

Definition check_cumulativity {A B : Type}
  (univs : Entries.universes_entry) (variances : array Univ.Variance.t)
  (env_ar : Environ.env) (params : Context.Rel.pt A B)
  (data : list (Constr.types * (array Constr.types))) : unit :=
  let uctx :=
    match univs with
    | Monomorphic_entry _ =&gt; Stdlib.raise (InductiveError BadUnivs)
    | Polymorphic_entry _ uctx =&gt; uctx
    end in
  let instance := Univ.UContext.instance uctx in
  if
    Stdlib.op_exclamation_eq (Univ.Instance.length instance)
      (Util.Array.(CArray.ExtS.length) variances) then
    Stdlib.raise (InductiveError BadUnivs)
  else
    tt;
  let numparams := Context.Rel.nhyps params in
  let new_levels :=
    Util.Array.(CArray.ExtS.init) (Univ.Instance.length instance)
      (fun i =&gt; Univ.Level.make (Univ.Level.UGlobal.make Names.DirPath.empty i))
    in
  let lmap :=
    Util.Array.(CArray.ExtS.fold_left2)
      (fun lmap =&gt; fun u =&gt; fun u' =&gt; Univ.LMap.add u u' lmap) Univ.LMap.empty
      (Univ.Instance.to_array instance) new_levels in
  let dosubst := Vars.subst_univs_level_constr lmap in
  let instance_other := Univ.Instance.of_array new_levels in
  let constraints_other :=
    Univ.subst_univs_level_constraints lmap (Univ.UContext.constraints uctx) in
  let uctx_other := Univ.UContext.make (instance_other, constraints_other) in
  let env := Environ.push_context None uctx_other env_ar in
  let subtyp_constraints :=
    Univ.enforce_leq_variance_instances variances instance instance_other
      Univ.Constraint.empty in
  let env := Environ.add_constraints subtyp_constraints env in
  Util.List.(CList.ExtS.iter)
    (fun function_parameter =&gt;
      match function_parameter with
      | (arity, lc) =&gt;
        check_subtyping_arity_constructor env dosubst arity numparams true;
        Util.Array.(CArray.ExtS.iter)
          (fun cnt =&gt;
            check_subtyping_arity_constructor env dosubst cnt numparams false)
          lc
      end) data.

Record univ_info := {
  ind_squashed : bool;
  ind_has_relevant_arg : bool;
  ind_min_univ : option Univ.Universe.t;
  ind_univ : Univ.Universe.t }.

Definition check_univ_leq (op_star_o_p_t_star : option bool)
  : Environ.env -&gt; Univ.Universe.t -&gt; univ_info -&gt; univ_info :=
  let is_real_arg :=
    match op_star_o_p_t_star with
    | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
    | None =&gt; false
    end in
  fun env =&gt;
    fun u =&gt;
      fun info =&gt;
        let ind_univ := ind_univ info in
        let info :=
          if
            andb (negb (ind_has_relevant_arg info))
              (andb is_real_arg (negb (Univ.Universe.is_sprop u))) then
            record
          else
            info in
        if
          orb (Environ.type_in_type env)
            (orb (Univ.Universe.is_sprop u)
              (UGraph.check_leq (Environ.universes env) u ind_univ)) then
          record
        else
          if Environ.is_impredicative_univ env ind_univ then
            if Option.is_empty (ind_min_univ info) then
              record
            else
              Stdlib.raise (InductiveError BadUnivs)
          else
            Stdlib.raise (InductiveError BadUnivs).

Definition check_context_univs
  (ctor : bool) (env : Environ.env) (info : univ_info)
  (ctx : Context.Rel.pt Constr.constr Constr.types) : univ_info :=
  let check_one
    (d : Constr.rel_declaration) (function_parameter : univ_info * Environ.env)
    : univ_info * Environ.env :=
    match function_parameter with
    | (info, env) =&gt;
      let info :=
        match d with
        | LocalAssum _ t =&gt;
          let tj := Typeops.infer_type env t in
          check_univ_leq (Some ctor) env (Sorts.univ_of_sort (utj_type tj)) info
        | LocalDef _ _ _ =&gt; info
        end in
      (info, (Environ.push_rel d env))
    end in
  fst (Context.Rel.fold_outside check_one ctx (info, env)).

Definition check_indices_matter
  (env_params : Environ.env) (info : univ_info)
  (indices : Context.Rel.pt Constr.constr Constr.types) : univ_info :=
  if negb (Environ.indices_matter env_params) then
    info
  else
    check_context_univs false env_params info indices.

Definition check_arity
  (env_params : Environ.env) (env_ar : Environ.env)
  (ind : Entries.one_inductive_entry)
  : Environ.env * (Constr.types * Constr.rel_context * univ_info) :=
  match Typeops.infer_type env_params (mind_entry_arity ind) with
  | {| utj_val := arity; utj_type := _ |} =&gt;
    match Reduction.dest_arity env_params arity with
    | (indices, ind_sort) =&gt;
      let ind_min_univ :=
        if mind_entry_template ind then
          Some Univ.Universe.type0m
        else
          None in
      let univ_info :=
        {| ind_squashed := false; ind_has_relevant_arg := false;
          ind_min_univ := ind_min_univ; ind_univ := Sorts.univ_of_sort ind_sort
          |} in
      let univ_info := check_indices_matter env_params univ_info indices in
      let arity :=
        Term.it_mkProd_or_LetIn arity (Environ.rel_context env_params) in
      let x :=
        Context.make_annot (Name (mind_entry_typename ind))
          (Sorts.relevance_of_sort ind_sort) in
      ((Environ.push_rel (LocalAssum x arity) env_ar),
        (arity, indices, univ_info))
    end
  end.

Definition check_constructor_univs {A : Type}
  (env_ar_par : Environ.env) (info : univ_info)
  (function_parameter : (Context.Rel.pt Constr.constr Constr.types) * A)
  : univ_info :=
  match function_parameter with
  | (args, _) =&gt; check_context_univs true env_ar_par info args
  end.

Definition check_constructors {A B : Type}
  (env_ar_par : Environ.env) (isrecord : bool) (params : Constr.rel_context)
  (lc : list Constr.types) (function_parameter : A * B * univ_info)
  : (A * (array Constr.types)) *
    (B * (array (Constr.rel_context * Constr.types))) * univ_info :=
  match function_parameter with
  | (arity, indices, univ_info) =&gt;
    let lc :=
      Util.Array.(CArray.ExtS.map_of_list)
        (fun c =&gt; utj_val (Typeops.infer_type env_ar_par c)) lc in
    let splayed_lc :=
      Util.Array.(CArray.ExtS.map) (Reduction.dest_prod_assum env_ar_par) lc in
    let univ_info :=
      match Util.Array.(CArray.ExtS.length) lc with
      | 0 =&gt; univ_info
      | 1 =&gt; check_univ_leq None env_ar_par Univ.Universe.type0m univ_info
      | _ =&gt; check_univ_leq None env_ar_par Univ.Universe.type0 univ_info
      end in
    let univ_info :=
      Util.Array.(CArray.ExtS.fold_left) (check_constructor_univs env_ar_par)
        univ_info splayed_lc in
    let lc :=
      Util.Array.(CArray.ExtS.map) (fun c =&gt; Term.it_mkProd_or_LetIn c params)
        lc in
    ((arity, lc), (indices, splayed_lc), univ_info)
  end.

Definition check_record {A B C D E : Type}
  (data :
    list
      (A * (B * (array ((list (Context.Rel.Declaration.pt C D)) * E))) *
        univ_info)) : bool :=
  Util.List.(CList.ExtS.for_all)
    (fun function_parameter =&gt;
      match function_parameter with
      | (_, (_, splayed_lc), info) =&gt;
        andb (negb (ind_squashed info))
          (andb
            (orb (Univ.Universe.is_sprop (ind_univ info))
              (ind_has_relevant_arg info))
            match splayed_lc with
            | ((ctx, _)) =&gt;
              let D := Context.Rel.Declaration in
              andb (Util.List.(CList.ExtS._exists) D.is_local_assum ctx)
                (Util.List.(CList.ExtS.for_all)
                  (fun d =&gt;
                    orb (negb (D.is_local_assum d))
                      (negb (Names.Name.is_anonymous (D.get_name d)))) ctx)
            | _ =&gt; false
            end)
      end) data.

Definition allowed_sorts (function_parameter : univ_info) : Term.sorts_family :=
  match function_parameter with
  | {|
    ind_squashed := ind_squashed;
      ind_has_relevant_arg := _;
      ind_min_univ := _;
      ind_univ := ind_univ
      |} =&gt;
    if negb ind_squashed then
      InType
    else
      Sorts.family (Sorts.sort_of_univ ind_univ)
  end.

Definition unbounded_from_below (u : Univ.Level.t) (cstrs : Univ.Constraint.t)
  : bool :=
  Univ.Constraint.for_all
    (fun function_parameter =&gt;
      match function_parameter with
      | (l, d, r) =&gt;
        match d with
        | Eq =&gt; andb (negb (Univ.Level.equal l u)) (negb (Univ.Level.equal r u))
        | Lt | Le =&gt; negb (Univ.Level.equal r u)
        end
      end) cstrs.

Definition template_polymorphic_univs {A : Type}
  (template_check : bool) (uctx : Univ.ContextSet.t)
  (paramsctxt : list (Context.Rel.Declaration.pt A Constr.types))
  (concl : Univ.Universe.t) : (list (option Univ.Level.t)) * Univ.LSet.t :=
  let check_level (l : Univ.LSet.elt) : option Univ.LSet.elt :=
    if
      andb (Univ.LSet.mem l (Univ.ContextSet.levels uctx))
        (unbounded_from_below l (Univ.ContextSet.constraints uctx)) then
      Some l
    else
      None in
  let univs := Univ.Universe.levels concl in
  let univs :=
    if template_check then
      Univ.LSet.filter
        (fun l =&gt; orb (Option.has_some (check_level l)) (Univ.Level.is_prop l))
        univs
    else
      univs in
  let fold {B : Type}
    (acc : list (option Univ.Level.t)) (function_parameter :
    Context.Rel.Declaration.pt B Constr.types) : list (option Univ.Level.t) :=
    match function_parameter with
    | LocalAssum _ p =&gt;
      cons
        (let c := Term.strip_prod_assum p in
        match Constr.kind c with
        | Sort (Type u) =&gt;
          if template_check then
            match Univ.Universe.level u with
            | Some l =&gt;
              if andb (Univ.LSet.mem l univs) (negb (Univ.Level.is_prop l)) then
                Some l
              else
                None
            | None =&gt; None
            end
          else
            Univ.Universe.level u
        | _ =&gt; None
        end) acc
    | LocalDef _ _ _ =&gt; acc
    end in
  let params := Util.List.(CList.ExtS.fold_left) fold [] paramsctxt in
  (params, univs).

Definition abstract_packets {A : Type}
  (template_check : bool) (univs : Declarations.universes)
  (usubst : Univ.universe_level_subst)
  (params : list (Context.Rel.Declaration.pt A Constr.types))
  (function_parameter :
    (Constr.constr * (array Constr.constr)) *
      (Constr.rel_context * (array (Constr.rel_context * Constr.constr))) *
      univ_info)
  : ((Declarations.declaration_arity Declarations.regular_inductive_arity
    Declarations.template_arity) * (array Constr.constr)) *
    (Constr.rel_context * (array (Constr.rel_context * Constr.constr))) *
    Term.sorts_family :=
  match function_parameter with
  | ((arity, lc), (indices, splayed_lc), univ_info) =&gt;
    let arity := Vars.subst_univs_level_constr usubst arity in
    let lc :=
      Util.Array.(CArray.ExtS.map) (Vars.subst_univs_level_constr usubst) lc in
    let indices := Vars.subst_univs_level_context usubst indices in
    let splayed_lc :=
      Util.Array.(CArray.ExtS.map)
        (fun function_parameter =&gt;
          match function_parameter with
          | (args, out) =&gt;
            let args := Vars.subst_univs_level_context usubst args in
            let out := Vars.subst_univs_level_constr usubst out in
            (args, out)
          end) splayed_lc in
    let ind_univ := Univ.subst_univs_level_universe usubst (ind_univ univ_info)
      in
    let arity :=
      match ind_min_univ univ_info with
      | None =&gt;
        RegularArity
          {| mind_user_arity := arity; mind_sort := Sorts.sort_of_univ ind_univ
            |}
      | Some min_univ =&gt;
        let ctx :=
          match univs with
          | Monomorphic ctx =&gt; ctx
          | Polymorphic _ =&gt;
            CErrors.anomaly None (Some &quot;polymorphic_template_ind&quot; % string)
              (Pp.strbrk
                &quot;Template polymorphism and full polymorphism are incompatible.&quot;
                  % string)
          end in
        match template_polymorphic_univs template_check ctx params min_univ with
        | (param_levels, concl_levels) =&gt;
          if
            andb template_check
              (andb
                (Util.List.(CList.ExtS.for_all) (fun x =&gt; Option.is_empty x)
                  param_levels) (Univ.LSet.is_empty concl_levels)) then
            CErrors.anomaly None (Some &quot;polymorphic_template_ind&quot; % string)
              (Pp.strbrk
                &quot;Ill-formed template inductive declaration: not polymorphic on any universe.&quot;
                  % string)
          else
            TemplateArity
              {| template_param_levels := param_levels;
                template_level := min_univ |}
        end
      end in
    let kelim := allowed_sorts univ_info in
    ((arity, lc), (indices, splayed_lc), kelim)
  end.

Definition typecheck_inductive
  (env : Environ.env) (mie : Entries.mutual_inductive_entry)
  : Environ.env * Declarations.universes * (option (array Univ.Variance.t)) *
    (option (option (array Names.Id.t))) * Constr.rel_context *
    (array
      (((Declarations.declaration_arity Declarations.regular_inductive_arity
        Declarations.template_arity) * (array Constr.constr)) *
        (Constr.rel_context * (array (Constr.rel_context * Constr.constr))) *
        Term.sorts_family)) :=
  match
    match mind_entry_inds mie with
    | [] =&gt;
      CErrors.anomaly None None
        (Pp.str &quot;empty inductive types declaration.&quot; % string)
    | _ =&gt; tt
    end with
  | tt =&gt;
    mind_check_names mie;
    Util.List.(CList.ExtS.is_empty) (Environ.rel_context env);
    let has_template_poly :=
      Util.List.(CList.ExtS._exists) (fun oie =&gt; mind_entry_template oie)
        (mind_entry_inds mie) in
    let env_univs :=
      match mind_entry_universes mie with
      | Monomorphic_entry ctx =&gt;
        let env :=
          if has_template_poly then
            Environ.set_universes_lbound env Univ.Level.prop
          else
            env in
        Environ.push_context_set None ctx env
      | Polymorphic_entry _ ctx =&gt; Environ.push_context None ctx env
      end in
    match Typeops.check_context env_univs (mind_entry_params mie) with
    | (env_params, params) =&gt;
      match
        Util.List.(CList.ExtS.fold_left_map) (check_arity env_params) env_univs
          (mind_entry_inds mie) with
      | (env_ar, data) =&gt;
        let env_ar_par := Environ.push_rel_context params env_ar in
        let isrecord :=
          match mind_entry_record mie with
          | Some (Some _) =&gt; true
          | Some None | None =&gt; false
          end in
        let data :=
          Util.List.(CList.ExtS.map2)
            (fun ind =&gt;
              fun data =&gt;
                check_constructors env_ar_par isrecord params
                  (mind_entry_lc ind) data) (mind_entry_inds mie) data in
        let record := mind_entry_record mie in
        match
          match record with
          | None | Some None =&gt; (data, record)
          | Some (Some _) =&gt;
            if check_record data then
              (data, record)
            else
              let data :=
                Util.List.(CList.ExtS.map)
                  (fun function_parameter =&gt;
                    match function_parameter with
                    | (a, b, univs) =&gt;
                      (a, b,
                        (check_univ_leq None env_ar_par Univ.Universe.type0m
                          univs))
                    end) data in
              (data, (Some None))
          end with
        | (data, record) =&gt;
          match
            match mind_entry_variance mie with
            | None =&gt; tt
            | Some variances =&gt;
              check_cumulativity (mind_entry_universes mie) variances env_ar
                params (Util.List.(CList.ExtS.map) Util.pi1 data)
            end with
          | tt =&gt;
            match Declareops.abstract_universes (mind_entry_universes mie) with
            | (usubst, univs) =&gt;
              let params := Vars.subst_univs_level_context usubst params in
              let template_check := Environ.check_template env in
              let data :=
                Util.List.(CList.ExtS.map)
                  (abstract_packets template_check univs usubst params) data in
              let env_ar_par :=
                let ctx := Environ.rel_context env_ar_par in
                let ctx := Vars.subst_univs_level_context usubst ctx in
                let env :=
                  Environ.pop_rel_context (Environ.nb_rel env_ar_par) env_ar_par
                  in
                Environ.push_rel_context ctx env in
              (env_ar_par, univs, (mind_entry_variance mie), record, params,
                (Util.Array.(CArray.ExtS.of_list) data))
            end
          end
        end
      end
    end
  end.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="indtypes" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>indtypes.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open CErrors
open Util
open Names
open Term
open Constr
open Vars
open Declarations
open Declareops
open Inductive
open Environ
open Reduction
open Entries
open Context.Rel.Declaration

(* Terminology:
paramdecls (ou paramsctxt?)
args = params + realargs (called vargs when an array, largs when a list)
params = recparams + nonrecparams
nonrecargs = nonrecparams + realargs
env_ar = initial env + declaration of inductive types
env_ar_par = env_ar + declaration of parameters
nmr = ongoing computation of recursive parameters
*)

(* [weaker_noccur_between env n nvars t] (defined above), checks that
   no de Bruijn indices between [n] and [n+nvars] occur in [t]. If
   some such occurrences are found, then reduction is performed
   (lazily for efficiency purposes) in order to determine whether
   these occurrences are occurrences in the normal form. If the
   occurrences are eliminated a witness reduct [Some t'] of [t] is
   returned otherwise [None] is returned. *)
let weaker_noccur_between env x nvars t =
  if noccur_between x nvars t then Some t
  else
   let t' = whd_all env t in
   if noccur_between x nvars t' then Some t'
   else None

(************************************************************************)
(* Various well-formedness check for inductive declarations            *)

exception InductiveError = Type_errors.InductiveError

(************************************************************************)
(************************************************************************)
(* Positivity *)

type ill_formed_ind =
  | LocalNonPos of int
  | LocalNotEnoughArgs of int
  | LocalNotConstructor of Constr.rel_context * int
  | LocalNonPar of int * int * int

exception IllFormedInd of ill_formed_ind

(* [mind_extract_params mie] extracts the params from an inductive types
   declaration, and checks that they are all present (and all the same)
   for all the given types. *)

let mind_extract_params = decompose_prod_n_assum

let explain_ind_err id ntyp env nparamsctxt c err =
  let open Type_errors in
  let (_lparams,c') = mind_extract_params nparamsctxt c in
  match err with
    | LocalNonPos kt -&gt;
	raise (InductiveError (NonPos (env,c',mkRel (kt+nparamsctxt))))
    | LocalNotEnoughArgs kt -&gt;
	raise (InductiveError
		 (NotEnoughArgs (env,c',mkRel (kt+nparamsctxt))))
    | LocalNotConstructor (paramsctxt,nargs)-&gt;
        let nparams = Context.Rel.nhyps paramsctxt in
	raise (InductiveError
		 (NotConstructor (env,id,c',mkRel (ntyp+nparamsctxt),
                                  nparams,nargs)))
    | LocalNonPar (n,i,l) -&gt;
	raise (InductiveError
		 (NonPar (env,c',n,mkRel i,mkRel (l+nparamsctxt))))

let failwith_non_pos n ntypes c =
  for k = n to n + ntypes - 1 do
    if not (noccurn k c) then raise (IllFormedInd (LocalNonPos (k-n+1)))
  done

let failwith_non_pos_vect n ntypes v =
  Array.iter (failwith_non_pos n ntypes) v;
  anomaly ~label:&quot;failwith_non_pos_vect&quot; (Pp.str &quot;some k in [n;n+ntypes-1] should occur.&quot;)

let failwith_non_pos_list n ntypes l =
  List.iter (failwith_non_pos n ntypes) l;
  anomaly ~label:&quot;failwith_non_pos_list&quot; (Pp.str &quot;some k in [n;n+ntypes-1] should occur.&quot;)

(* Check the inductive type is called with the expected parameters *)
(* [n] is the index of the last inductive type in [env] *)
let check_correct_par (env,n,ntypes,_) paramdecls ind_index args =
  let nparams = Context.Rel.nhyps paramdecls in
  let args = Array.of_list args in
  if Array.length args &lt; nparams then
    raise (IllFormedInd (LocalNotEnoughArgs ind_index));
  let (params,realargs) = Array.chop nparams args in
  let nparamdecls = List.length paramdecls in
  let rec check param_index paramdecl_index = function
    | [] -&gt; ()
    | LocalDef _ :: paramdecls -&gt;
      check param_index (paramdecl_index+1) paramdecls
    | _::paramdecls -&gt;
        match kind (whd_all env params.(param_index)) with
	  | Rel w when Int.equal w paramdecl_index -&gt;
            check (param_index-1) (paramdecl_index+1) paramdecls
	  | _ -&gt;
            let paramdecl_index_in_env = paramdecl_index-n+nparamdecls+1 in
            let err =
              LocalNonPar (param_index+1, paramdecl_index_in_env, ind_index) in
            raise (IllFormedInd err)
  in check (nparams-1) (n-nparamdecls) paramdecls;
  if not (Array.for_all (noccur_between n ntypes) realargs) then
    failwith_non_pos_vect n ntypes realargs

(* Computes the maximum number of recursive parameters:
   the first parameters which are constant in recursive arguments
   [n] is the current depth, [nmr] is the maximum number of possible
   recursive parameters *)

let compute_rec_par (env,n,_,_) paramsctxt nmr largs =
if Int.equal nmr 0 then 0 else
(* start from 0, params will be in reverse order *)
  let (lpar,_) = List.chop nmr largs in
  let rec find k index =
      function
	  ([],_) -&gt; nmr
	| (_,[]) -&gt; assert false (* |paramsctxt|&gt;=nmr *)
	| (lp, LocalDef _ :: paramsctxt) -&gt; find k (index-1) (lp,paramsctxt)
	| (p::lp,_::paramsctxt) -&gt;
       ( match kind (whd_all env p) with
	  | Rel w when Int.equal w index -&gt; find (k+1) (index-1) (lp,paramsctxt)
          | _ -&gt; k)
  in find 0 (n-1) (lpar,List.rev paramsctxt)

(* [env] is the typing environment
   [n] is the dB of the last inductive type
   [ntypes] is the number of inductive types in the definition
     (i.e. range of inductives is [n; n+ntypes-1])
   [lra] is the list of recursive tree of each variable
 *)
let ienv_push_var (env, n, ntypes, lra) (x,a,ra) =
  (push_rel (LocalAssum (x,a)) env, n+1, ntypes, (Norec,ra)::lra)

let ienv_push_inductive (env, n, ntypes, ra_env) ((mi,u),lrecparams) =
  let auxntyp = 1 in
  let specif = (lookup_mind_specif env mi, u) in
  let ty = type_of_inductive env specif in
  let env' =
    let r = (snd (fst specif)).mind_relevance in
    let anon = Context.make_annot Anonymous r in
    let decl = LocalAssum (anon, hnf_prod_applist env ty lrecparams) in
    push_rel decl env in
  let ra_env' =
    (Imbr mi,(Rtree.mk_rec_calls 1).(0)) ::
    List.map (fun (r,t) -&gt; (r,Rtree.lift 1 t)) ra_env in
  (* New index of the inductive types *)
  let newidx = n + auxntyp in
  (env', newidx, ntypes, ra_env')

let rec ienv_decompose_prod (env,_,_,_ as ienv) n c =
  if Int.equal n 0 then (ienv,c) else
    let c' = whd_all env c in
    match kind c' with
        Prod(na,a,b) -&gt;
          let ienv' = ienv_push_var ienv (na,a,mk_norec) in
	  ienv_decompose_prod ienv' (n-1) b
      | _ -&gt; assert false

let array_min nmr a = if Int.equal nmr 0 then 0 else
  Array.fold_left (fun k (nmri,_) -&gt; min k nmri) nmr a

(** [check_positivity_one ienv paramsctxt (mind,i) nnonrecargs lcnames indlc]
    checks the positivity of the [i]-th member of the mutually
    inductive definition [mind]. It returns an [Rtree.t] which
    represents the position of the recursive calls of inductive in [i]
    for use by the guard condition (terms at these positions are
    considered sub-terms) as well as the number of of non-uniform
    arguments (used to generate induction schemes, so a priori less
    relevant to the kernel).

    If [chkpos] is [false] then positivity is assumed, and
    [check_positivity_one] computes the subterms occurrences in a
    best-effort fashion. *)
let check_positivity_one ~chkpos recursive (env,_,ntypes,_ as ienv) paramsctxt (_,i as ind) nnonrecargs lcnames indlc =
  let nparamsctxt = Context.Rel.length paramsctxt in
  let nmr = Context.Rel.nhyps paramsctxt in
  (** Positivity of one argument [c] of a constructor (i.e. the
      constructor [cn] has a type of the shape [‚Ä¶ -&gt; c ‚Ä¶ -&gt; P], where,
      more generally, the arrows may be dependent). *)
  let rec check_pos (env, n, ntypes, ra_env as ienv) nmr c =
    let x,largs = decompose_app (whd_all env c) in
      match kind x with
        | Prod (na,b,d) -&gt;
	    let () = assert (List.is_empty largs) in
            (** If one of the inductives of the mutually inductive
                block occurs in the left-hand side of a product, then
                such an occurrence is a non-strictly-positive
                recursive call. Occurrences in the right-hand side of
                the product must be strictly positive.*)
            (match weaker_noccur_between env n ntypes b with
	      | None when chkpos -&gt;
                  failwith_non_pos_list n ntypes [b]
              | None -&gt;
                  check_pos (ienv_push_var ienv (na, b, mk_norec)) nmr d
              | Some b -&gt;
                  check_pos (ienv_push_var ienv (na, b, mk_norec)) nmr d)
	| Rel k -&gt;
            (try let (ra,rarg) = List.nth ra_env (k-1) in
            let largs = List.map (whd_all env) largs in
	    let nmr1 =
	      (match ra with
                  Mrec _ -&gt; compute_rec_par ienv paramsctxt nmr largs
		|  _ -&gt; nmr)
	    in
              (** The case where one of the inductives of the mutually
                  inductive block occurs as an argument of another is not
                  known to be safe. So Coq rejects it. *)
	      if chkpos &amp;&amp;
                 not (List.for_all (noccur_between n ntypes) largs)
	      then failwith_non_pos_list n ntypes largs
	      else (nmr1,rarg)
              with Failure _ | Invalid_argument _ -&gt; (nmr,mk_norec))
	| Ind ind_kn -&gt;
            (** If one of the inductives of the mutually inductive
                block being defined appears in a parameter, then we
                have a nested inductive type. The positivity is then
                discharged to the [check_positive_nested] function. *)
            if List.for_all (noccur_between n ntypes) largs then (nmr,mk_norec)
            else check_positive_nested ienv nmr (ind_kn, largs)
        | _err -&gt;
            (** If an inductive of the mutually inductive block
                appears in any other way, then the positivy check gives
                up. *)
	    if not chkpos ||
              (noccur_between n ntypes x &amp;&amp;
               List.for_all (noccur_between n ntypes) largs)
	    then (nmr,mk_norec)
	    else failwith_non_pos_list n ntypes (x::largs)

  (** [check_positive_nested] handles the case of nested inductive
      calls, that is, when an inductive types from the mutually
      inductive block is called as an argument of an inductive types
      (for the moment, this inductive type must be a previously
      defined types, not one of the types of the mutually inductive
      block being defined). *)
  (* accesses to the environment are not factorised, but is it worth? *)
  and check_positive_nested (env,n,ntypes,_ra_env as ienv) nmr ((mi,u), largs) =
    let (mib,mip) = lookup_mind_specif env mi in
    let auxnrecpar = mib.mind_nparams_rec in
    let auxnnonrecpar = mib.mind_nparams - auxnrecpar in
    let (auxrecparams,auxnonrecargs) =
      try List.chop auxnrecpar largs
      with Failure _ -&gt; raise (IllFormedInd (LocalNonPos n)) in

      (** Inductives of the inductive block being defined are only
          allowed to appear nested in the parameters of another inductive
          type. Not in the proper indices. *)
      if chkpos &amp;&amp; not (List.for_all (noccur_between n ntypes) auxnonrecargs) then
	failwith_non_pos_list n ntypes auxnonrecargs;
      (* Nested mutual inductive types are not supported *)
      let auxntyp = mib.mind_ntypes in
	if not (Int.equal auxntyp 1) then raise (IllFormedInd (LocalNonPos n));
	(* The nested inductive type with parameters removed *)
	let auxlcvect = abstract_mind_lc auxntyp auxnrecpar mip.mind_nf_lc in
	  (* Extends the environment with a variable corresponding to
	     the inductive def *)
	let (env',_,_,_ as ienv') = ienv_push_inductive ienv ((mi,u),auxrecparams) in
	  (* Parameters expressed in env' *)
	let auxrecparams' = List.map (lift auxntyp) auxrecparams in
	let irecargs_nmr =
	  (** Checks that the &quot;nesting&quot; inductive type is covariant in
	      the relevant parameters. In other words, that the
	      (nested) parameters which are instantiated with
	      inductives of the mutually inductive block occur
	      positively in the types of the nested constructors. *)
	  Array.map
	    (function c -&gt;
	      let c' = hnf_prod_applist env' c auxrecparams' in
	      (* skip non-recursive parameters *)
	      let (ienv',c') = ienv_decompose_prod ienv' auxnnonrecpar c' in
		check_constructors ienv' false nmr c')
	    auxlcvect
	in
	let irecargs = Array.map snd irecargs_nmr
	and nmr' = array_min nmr irecargs_nmr
	in
	  (nmr',(Rtree.mk_rec [|mk_paths (Imbr mi) irecargs|]).(0))

  (** [check_constructors ienv check_head nmr c] checks the positivity
      condition in the type [c] of a constructor (i.e. that recursive
      calls to the inductives of the mutually inductive definition
      appear strictly positively in each of the arguments of the
      constructor, see also [check_pos]). If [check_head] is [true],
      then the type of the fully applied constructor (the &quot;head&quot; of
      the type [c]) is checked to be the right (properly applied)
      inductive type. *)
  and check_constructors ienv check_head nmr c =
    let rec check_constr_rec (env,n,ntypes,_ra_env as ienv) nmr lrec c =
      let x,largs = decompose_app (whd_all env c) in
	match kind x with

          | Prod (na,b,d) -&gt;
	      let () = assert (List.is_empty largs) in
	      if not recursive &amp;&amp; not (noccur_between n ntypes b) then
                raise (InductiveError Type_errors.BadEntry);
              let nmr',recarg = check_pos ienv nmr b in
              let ienv' = ienv_push_var ienv (na,b,mk_norec) in
                check_constr_rec ienv' nmr' (recarg::lrec) d
          | hd -&gt;
            let () =
              if check_head then
                begin match hd with
                | Rel j when Int.equal j (n + ntypes - i - 1) -&gt;
                  check_correct_par ienv paramsctxt (ntypes - i) largs
                | _ -&gt; raise (IllFormedInd (LocalNotConstructor(paramsctxt,nnonrecargs)))
                end
              else
                if chkpos &amp;&amp;
                   not (List.for_all (noccur_between n ntypes) largs)
                then failwith_non_pos_list n ntypes largs
            in
            (nmr, List.rev lrec)
    in check_constr_rec ienv nmr [] c
  in
  let irecargs_nmr =
    Array.map2
      (fun id c -&gt;
        let _,rawc = mind_extract_params nparamsctxt c in
          try
	    check_constructors ienv true nmr rawc
          with IllFormedInd err -&gt;
	    explain_ind_err id (ntypes-i) env nparamsctxt c err)
      (Array.of_list lcnames) indlc
  in
  let irecargs = Array.map snd irecargs_nmr
  and nmr' = array_min nmr irecargs_nmr
  in (nmr', mk_paths (Mrec ind) irecargs)

(** [check_positivity ~chkpos kn env_ar paramsctxt inds] checks that the mutually
    inductive block [inds] is strictly positive.

    If [chkpos] is [false] then positivity is assumed, and
    [check_positivity_one] computes the subterms occurrences in a
    best-effort fashion. *)
let check_positivity ~chkpos kn names env_ar_par paramsctxt finite inds =
  let ntypes = Array.length inds in
  let recursive = finite != BiFinite in
  let rc = Array.mapi (fun j t -&gt; (Mrec (kn,j),t)) (Rtree.mk_rec_calls ntypes) in
  let ra_env_ar = Array.rev_to_list rc in
  let nparamsctxt = Context.Rel.length paramsctxt in
  let nmr = Context.Rel.nhyps paramsctxt in
  let check_one i (_,lcnames) (nindices,lc) =
    let ra_env_ar_par =
      List.init nparamsctxt (fun _ -&gt; (Norec,mk_norec)) @ ra_env_ar in
    let ienv = (env_ar_par, 1+nparamsctxt, ntypes, ra_env_ar_par) in
    check_positivity_one ~chkpos recursive ienv paramsctxt (kn,i) nindices lcnames lc
  in
  let irecargs_nmr = Array.map2_i check_one names inds in
  let irecargs = Array.map snd irecargs_nmr
  and nmr' = array_min nmr irecargs_nmr
  in (nmr',Rtree.mk_rec irecargs)


(************************************************************************)
(************************************************************************)
(* Build the inductive packet *)

let repair_arity indices = function
  | RegularArity ar -&gt; ar.mind_user_arity
  | TemplateArity ar -&gt; mkArity (indices,Sorts.sort_of_univ ar.template_level)

let fold_inductive_blocks f =
  Array.fold_left (fun acc ((arity,lc),(indices,_),_) -&gt;
    f (Array.fold_left f acc lc) (repair_arity indices arity))

let used_section_variables env inds =
  let fold l c = Id.Set.union (Environ.global_vars_set env c) l in
  let ids = fold_inductive_blocks fold Id.Set.empty inds in
  keep_hyps env ids

let rel_vect n m = Array.init m (fun i -&gt; mkRel(n+m-i))
let rel_list n m = Array.to_list (rel_vect n m)

(** From a rel context describing the constructor arguments,
    build an expansion function.
    The term built is expecting to be substituted first by 
    a substitution of the form [params, x : ind params] *)
let compute_projections (kn, i as ind) mib =
  let pkt = mib.mind_packets.(i) in
  let u = Univ.make_abstract_instance (Declareops.inductive_polymorphic_context mib) in
  let subst = List.init mib.mind_ntypes (fun i -&gt; mkIndU ((kn, mib.mind_ntypes - i - 1), u)) in
  let (ctx, cty) = pkt.mind_nf_lc.(0) in
  let cty = it_mkProd_or_LetIn cty ctx in
  let rctx, _ = decompose_prod_assum (substl subst cty) in
  let ctx, paramslet = List.chop pkt.mind_consnrealdecls.(0) rctx in
  (** We build a substitution smashing the lets in the record parameters so
      that typechecking projections requires just a substitution and not
      matching with a parameter context. *)
  let paramsletsubst =
    (* [Ind inst] is typed in context [params-wo-let] *)
    let inst' = rel_list 0 mib.mind_nparams in
    (* {params-wo-let |- subst:params] *)
    let subst = subst_of_rel_context_instance paramslet inst' in
    (* {params-wo-let, x:Ind inst' |- subst':(params,x:Ind inst)] *)
    let subst = (* For the record parameter: *)
      mkRel 1 :: List.map (lift 1) subst in
    subst
  in
  let projections decl (i, j, labs, rs, pbs, letsubst) =
    match decl with
    | LocalDef (_na,c,_t) -&gt;
        (* From [params, field1,..,fieldj |- c(params,field1,..,fieldj)]
           to [params, x:I, field1,..,fieldj |- c(params,field1,..,fieldj)] *)
        let c = liftn 1 j c in
        (* From [params, x:I, field1,..,fieldj |- c(params,field1,..,fieldj)]
           to [params-wo-let, x:I |- c(params,proj1 x,..,projj x)] *)
        let c2 = substl letsubst c in
        (* From [params-wo-let, x:I |- subst:(params, x:I, field1,..,fieldj)]
           to [params-wo-let, x:I |- subst:(params, x:I, field1,..,fieldj+1)] *)
        let letsubst = c2 :: letsubst in
        (i, j+1, labs, rs, pbs, letsubst)
    | LocalAssum (na,t) -&gt;
      match na.Context.binder_name with
      | Name id -&gt;
        let r = na.Context.binder_relevance in
        let lab = Label.of_id id in
        let kn = Projection.Repr.make ind ~proj_npars:mib.mind_nparams ~proj_arg:i lab in
        (* from [params, field1,..,fieldj |- t(params,field1,..,fieldj)]
           to [params, x:I, field1,..,fieldj |- t(params,field1,..,fieldj] *)
        let t = liftn 1 j t in
        (* from [params, x:I, field1,..,fieldj |- t(params,field1,..,fieldj)]
           to [params-wo-let, x:I |- t(params,proj1 x,..,projj x)] *)
	let projty = substl letsubst t in
        (* from [params, x:I, field1,..,fieldj |- t(field1,..,fieldj)]
           to [params, x:I |- t(proj1 x,..,projj x)] *)
	let fterm = mkProj (Projection.make kn false, mkRel 1) in
        (i + 1, j + 1, lab :: labs, r :: rs, projty :: pbs, fterm :: letsubst)
      | Anonymous -&gt; assert false (* checked by indTyping *)
  in
  let (_, _, labs, rs, pbs, _letsubst) =
    List.fold_right projections ctx (0, 1, [], [], [], paramsletsubst)
  in
  Array.of_list (List.rev labs),
  Array.of_list (List.rev rs),
  Array.of_list (List.rev pbs)

let build_inductive env names prv univs variance paramsctxt kn isrecord isfinite inds nmr recargs =
  let ntypes = Array.length inds in
  (* Compute the set of used section variables *)
  let hyps = used_section_variables env inds in
  let nparamargs = Context.Rel.nhyps paramsctxt in
  (* Check one inductive *)
  let build_one_packet (id,cnames) ((arity,lc),(indices,splayed_lc),kelim) recarg =
    (* Type of constructors in normal form *)
    let nf_lc = Array.map (fun (d, b) -&gt; (d@paramsctxt, b)) splayed_lc in
    let consnrealdecls =
      Array.map (fun (d,_) -&gt; Context.Rel.length d)
	splayed_lc in
    let consnrealargs =
      Array.map (fun (d,_) -&gt; Context.Rel.nhyps d)
        splayed_lc in
    let mind_relevance = match arity with
      | RegularArity { mind_sort;_ } -&gt; Sorts.relevance_of_sort mind_sort
      | TemplateArity _ -&gt; Sorts.Relevant
    in
    (* Assigning VM tags to constructors *)
    let nconst, nblock = ref 0, ref 0 in
    let transf num =
      let arity = List.length (dest_subterms recarg).(num) in
	if Int.equal arity 0 then
	  let p  = (!nconst, 0) in
	    incr nconst; p
	else
	  let p = (!nblock + 1, arity) in
	    incr nblock; p
	      (* les tag des constructeur constant commence a 0,
		 les tag des constructeur non constant a 1 (0 =&gt; accumulator) *)
    in
    let rtbl = Array.init (List.length cnames) transf in
      (* Build the inductive packet *)
      { mind_typename = id;
        mind_arity = arity;
        mind_arity_ctxt = indices @ paramsctxt;
        mind_nrealargs = Context.Rel.nhyps indices;
        mind_nrealdecls = Context.Rel.length indices;
	mind_kelim = kelim;
	mind_consnames = Array.of_list cnames;
	mind_consnrealdecls = consnrealdecls;
	mind_consnrealargs = consnrealargs;
	mind_user_lc = lc;
	mind_nf_lc = nf_lc;
        mind_recargs = recarg;
        mind_relevance;
        mind_nb_constant = !nconst;
	mind_nb_args = !nblock;
	mind_reloc_tbl = rtbl;
      } in
  let packets = Array.map3 build_one_packet names inds recargs in
  let mib =
      (* Build the mutual inductive *)
    { mind_record = NotRecord;
      mind_ntypes = ntypes;
      mind_finite = isfinite;
      mind_hyps = hyps;
      mind_nparams = nparamargs;
      mind_nparams_rec = nmr;
      mind_params_ctxt = paramsctxt;
      mind_packets = packets;
      mind_universes = univs;
      mind_variance = variance;
      mind_private = prv;
      mind_typing_flags = Environ.typing_flags env;
    }
  in
  let record_info = match isrecord with
  | Some (Some rid) -&gt;
    (** The elimination criterion ensures that all projections can be defined. *)
    let map i id =
      let labs, rs, projs = compute_projections (kn, i) mib in
      (id, labs, rs, projs)
    in
    PrimRecord (Array.mapi map rid)
  | Some None -&gt; FakeRecord
  | None -&gt; NotRecord
  in
  { mib with mind_record = record_info }

(************************************************************************)
(************************************************************************)

let check_inductive env kn mie =
  (* First type-check the inductive definition *)
  let (env_ar_par, univs, variance, record, paramsctxt, inds) = IndTyping.typecheck_inductive env mie in
  (* Then check positivity conditions *)
  let chkpos = (Environ.typing_flags env).check_positive in
  let names = Array.map_of_list (fun entry -&gt; entry.mind_entry_typename, entry.mind_entry_consnames)
      mie.mind_entry_inds
  in
  let (nmr,recargs) = check_positivity ~chkpos kn names
      env_ar_par paramsctxt mie.mind_entry_finite
      (Array.map (fun ((_,lc),(indices,_),_) -&gt; Context.Rel.nhyps indices,lc) inds)
  in
  (* Build the inductive packets *)
    build_inductive env names mie.mind_entry_private univs variance
      paramsctxt kn record mie.mind_entry_finite
      inds nmr recargs
</pre>
          </div>
          <div class="col-md-6">
            <code>indtypes.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import CErrors.

Import Util.

Import Names.

Import Term.

Import Constr.

Import Vars.

Import Declarations.

Import Declareops.

Import Inductive.

Import Environ.

Import Reduction.

Import Entries.

Import Context.Rel.Declaration.

Definition weaker_noccur_between
  (env : Environ.env) (x : Z) (nvars : Z) (t : Constr.constr)
  : option Constr.constr :=
  if Vars.noccur_between x nvars t then
    Some t
  else
    let t' := Reduction.whd_all env t in
    if Vars.noccur_between x nvars t' then
      Some t'
    else
      None.

Inductive ill_formed_ind : Type :=
| LocalNonPos : Z -&gt; ill_formed_ind
| LocalNotEnoughArgs : Z -&gt; ill_formed_ind
| LocalNotConstructor : Constr.rel_context -&gt; Z -&gt; ill_formed_ind
| LocalNonPar : Z -&gt; Z -&gt; Z -&gt; ill_formed_ind.

Definition mind_extract_params
  : Z -&gt; Constr.types -&gt; Constr.rel_context * Constr.types :=
  Term.decompose_prod_n_assum.

Definition explain_ind_err {A : Type}
  (id : Names.Id.t) (ntyp : Z) (env : Environ.env) (nparamsctxt : Z)
  (c : Constr.types) (err : ill_formed_ind) : A :=
  match mind_extract_params nparamsctxt c with
  | (_lparams, c') =&gt;
    match err with
    | LocalNonPos kt =&gt;
      Stdlib.raise
        (InductiveError
          (NonPos env c' (Constr.mkRel (Util.op_plus kt nparamsctxt))))
    | LocalNotEnoughArgs kt =&gt;
      Stdlib.raise
        (InductiveError
          (NotEnoughArgs env c' (Constr.mkRel (Util.op_plus kt nparamsctxt))))
    | LocalNotConstructor paramsctxt nargs =&gt;
      let nparams := Context.Rel.nhyps paramsctxt in
      Stdlib.raise
        (InductiveError
          (NotConstructor env id c'
            (Constr.mkRel (Util.op_plus ntyp nparamsctxt)) nparams nargs))
    | LocalNonPar n i l =&gt;
      Stdlib.raise
        (InductiveError
          (NonPar env c' n (Constr.mkRel i)
            (Constr.mkRel (Util.op_plus l nparamsctxt))))
    end
  end.

Definition failwith_non_pos (n : Z) (ntypes : Z) (c : Constr.constr) : unit :=
  for.

Definition failwith_non_pos_vect {A : Type}
  (n : Z) (ntypes : Z) (v : array Constr.constr) : A :=
  Util.Array.(CArray.ExtS.iter) (failwith_non_pos n ntypes) v;
  CErrors.anomaly None (Some &quot;failwith_non_pos_vect&quot; % string)
    (Pp.str &quot;some k in [n;n+ntypes-1] should occur.&quot; % string).

Definition failwith_non_pos_list {A : Type}
  (n : Z) (ntypes : Z) (l : list Constr.constr) : A :=
  Util.List.(CList.ExtS.iter) (failwith_non_pos n ntypes) l;
  CErrors.anomaly None (Some &quot;failwith_non_pos_list&quot; % string)
    (Pp.str &quot;some k in [n;n+ntypes-1] should occur.&quot; % string).

Definition check_correct_par {A B C : Type}
  (function_parameter : Environ.env * Z * Z * A)
  : (Context.Rel.pt B C) -&gt; Z -&gt; (list Constr.constr) -&gt; unit :=
  match function_parameter with
  | (env, n, ntypes, _) =&gt;
    fun paramdecls =&gt;
      fun ind_index =&gt;
        fun args =&gt;
          let nparams := Context.Rel.nhyps paramdecls in
          let args := Util.Array.(CArray.ExtS.of_list) args in
          if OCaml.Stdlib.lt (Util.Array.(CArray.ExtS.length) args) nparams then
            Stdlib.raise (IllFormedInd (LocalNotEnoughArgs ind_index))
          else
            tt;
          match Util.Array.(CArray.ExtS.chop) nparams args with
          | (params, realargs) =&gt;
            let nparamdecls := Util.List.(CList.ExtS.length) paramdecls in
            let fix check {D E : Type}
              (param_index : Z) (paramdecl_index : Z) (function_parameter :
              list (Context.Rel.Declaration.pt D E)) : unit :=
              match function_parameter with
              | [] =&gt; tt
              | cons (LocalDef _ _ _) paramdecls =&gt;
                check param_index (Util.op_plus paramdecl_index 1) paramdecls
              | cons _ paramdecls =&gt;
                match
                  Constr.kind
                    (Reduction.whd_all env
                      (Util.Array.(CArray.ExtS.get) params param_index)) with
                | _ =&gt;
                  let paramdecl_index_in_env :=
                    Util.op_plus
                      (Util.op_plus (Util.op_minus paramdecl_index n)
                        nparamdecls) 1 in
                  let err :=
                    LocalNonPar (Util.op_plus param_index 1)
                      paramdecl_index_in_env ind_index in
                  Stdlib.raise (IllFormedInd err)
                end
              end in
            check (Util.op_minus nparams 1) (Util.op_minus n nparamdecls)
              paramdecls;
            if
              negb
                (Util.Array.(CArray.ExtS.for_all) (Vars.noccur_between n ntypes)
                  realargs) then
              failwith_non_pos_vect n ntypes realargs
            else
              tt
          end
  end.

Definition compute_rec_par {A B C D : Type}
  (function_parameter : Environ.env * Z * A * B)
  : (list (Context.Rel.Declaration.pt C D)) -&gt;
    Int.t -&gt; (list Constr.constr) -&gt; Int.t :=
  match function_parameter with
  | (env, n, _, _) =&gt;
    fun paramsctxt =&gt;
      fun nmr =&gt;
        fun largs =&gt;
          if Int.equal nmr 0 then
            0
          else
            match Util.List.(CList.ExtS.chop) nmr largs with
            | (lpar, _) =&gt;
              let fix find {E F : Type}
                (k : Int.t) (index : Z) (function_parameter :
                (list Constr.constr) * (list (Context.Rel.Declaration.pt E F)))
                : Int.t :=
                match function_parameter with
                | ([], _) =&gt; nmr
                | (_, []) =&gt; false
                | (lp, cons (LocalDef _ _ _) paramsctxt) =&gt;
                  find k (Util.op_minus index 1) (lp, paramsctxt)
                | (cons p lp, cons _ paramsctxt) =&gt;
                  match Constr.kind (Reduction.whd_all env p) with
                  | _ =&gt; k
                  end
                end in
              find 0 (Util.op_minus n 1)
                (lpar, (Util.List.(CList.ExtS.rev) paramsctxt))
            end
  end.

Definition ienv_push_var {A B : Type}
  (function_parameter : Environ.env * Z * A * (list (Declarations.recarg * B)))
  : ((Context.binder_annot Names.Name.t) * Constr.types * B) -&gt;
    Environ.env * Z * A * (list (Declarations.recarg * B)) :=
  match function_parameter with
  | (env, n, ntypes, lra) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (x, a, ra) =&gt;
        ((Environ.push_rel (LocalAssum x a) env), (Util.op_plus n 1), ntypes,
          (cons (Norec, ra) lra))
      end
  end.

Definition ienv_push_inductive {A B : Type}
  (function_parameter :
    Environ.env * Z * A * (list (Declarations.recarg * (Rtree.t B))))
  : ((Names.inductive * Univ.Instance.t) * (list Constr.constr)) -&gt;
    Environ.env * Z * A * (list (Declarations.recarg * (Rtree.t B))) :=
  match function_parameter with
  | (env, n, ntypes, ra_env) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | ((mi, u), lrecparams) =&gt;
        let auxntyp := 1 in
        let specif := ((Inductive.lookup_mind_specif env mi), u) in
        let ty := Inductive.type_of_inductive env specif in
        let env' :=
          let r := mind_relevance (snd (fst specif)) in
          let anon := Context.make_annot Anonymous r in
          let decl :=
            LocalAssum anon (Reduction.hnf_prod_applist env ty lrecparams) in
          Environ.push_rel decl env in
        let ra_env' :=
          cons
            ((Imbr mi), (Util.Array.(CArray.ExtS.get) (Rtree.mk_rec_calls 1) 0))
            (Util.List.(CList.ExtS.map)
              (fun function_parameter =&gt;
                match function_parameter with
                | (r, t) =&gt; (r, (Rtree.lift 1 t))
                end) ra_env) in
        let newidx := Util.op_plus n auxntyp in
        (env', newidx, ntypes, ra_env')
      end
  end.

Fixpoint ienv_decompose_prod {A : Type}
  (function_parameter :
    Environ.env * Z * A * (list (Declarations.recarg * Declarations.wf_paths)))
  : Int.t -&gt;
    Constr.constr -&gt;
      (Environ.env * Z * A *
        (list (Declarations.recarg * Declarations.wf_paths))) * Constr.constr :=
  match function_parameter with
  | (env, _, _, _) as ienv =&gt;
    fun n =&gt;
      fun c =&gt;
        if Int.equal n 0 then
          (ienv, c)
        else
          let c' := Reduction.whd_all env c in
          match Constr.kind c' with
          | Prod na a b =&gt;
            let ienv' := ienv_push_var ienv (na, a, Declareops.mk_norec) in
            ienv_decompose_prod ienv' (Util.op_minus n 1) b
          | _ =&gt; false
          end
  end.

Definition array_min {A : Type} (nmr : Int.t) (a : array (Int.t * A)) : Int.t :=
  if Int.equal nmr 0 then
    0
  else
    Util.Array.(CArray.ExtS.fold_left)
      (fun k =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | (nmri, _) =&gt; OCaml.Stdlib.min k nmri
          end) nmr a.

Definition check_positivity_one
  (chkpos : bool) (recursive : bool)
  (function_parameter :
    Environ.env * Z * Z * (list (Declarations.recarg * Declarations.wf_paths)))
  : (Context.Rel.pt Constr.constr Constr.types) -&gt;
    (Names.MutInd.t * Z) -&gt;
      Z -&gt;
        (list Names.Id.t) -&gt;
          (array Constr.types) -&gt; Int.t * Declarations.wf_paths :=
  match function_parameter with
  | (env, _, ntypes, _) as ienv =&gt;
    fun paramsctxt =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | (_, i) as ind =&gt;
          fun nnonrecargs =&gt;
            fun lcnames =&gt;
              fun indlc =&gt;
                let nparamsctxt := Context.Rel.length paramsctxt in
                let nmr := Context.Rel.nhyps paramsctxt in
                let fix check_pos
                  (function_parameter :
                  Environ.env * Z * Z *
                    (list (Declarations.recarg * Declarations.wf_paths)))
                  : Int.t -&gt; Constr.constr -&gt; Int.t * Declarations.wf_paths :=
                  match function_parameter with
                  | (env, n, ntypes, ra_env) as ienv =&gt;
                    fun nmr =&gt;
                      fun c =&gt;
                        match Constr.decompose_app (Reduction.whd_all env c)
                          with
                        | (x, largs) =&gt;
                          match Constr.kind x with
                          | Prod na b d =&gt;
                            match Util.List.(CList.ExtS.is_empty) largs with
                            | tt =&gt;
                              match weaker_noccur_between env n ntypes b with
                              | None =&gt;
                                check_pos
                                  (ienv_push_var ienv
                                    (na, b, Declareops.mk_norec)) nmr d
                              | Some b =&gt;
                                check_pos
                                  (ienv_push_var ienv
                                    (na, b, Declareops.mk_norec)) nmr d
                              end
                            end
                          | Rel k =&gt; try
                          | Ind ind_kn =&gt;
                            if
                              Util.List.(CList.ExtS.for_all)
                                (Vars.noccur_between n ntypes) largs then
                              (nmr, Declareops.mk_norec)
                            else
                              check_positive_nested ienv nmr (ind_kn, largs)
                          | _err =&gt;
                            if
                              orb (negb chkpos)
                                (andb (Vars.noccur_between n ntypes x)
                                  (Util.List.(CList.ExtS.for_all)
                                    (Vars.noccur_between n ntypes) largs)) then
                              (nmr, Declareops.mk_norec)
                            else
                              failwith_non_pos_list n ntypes (cons x largs)
                          end
                        end
                  end
                with check_positive_nested
                  (function_parameter :
                  Environ.env * Z * Z *
                    (list (Declarations.recarg * Declarations.wf_paths)))
                  : Int.t -&gt;
                    ((Names.inductive * Univ.Instance.t) * (list Constr.constr))
                      -&gt; Int.t * Declarations.wf_paths :=
                  match function_parameter with
                  | (env, n, ntypes, _ra_env) as ienv =&gt;
                    fun nmr =&gt;
                      fun function_parameter =&gt;
                        match function_parameter with
                        | ((mi, u), largs) =&gt;
                          match Inductive.lookup_mind_specif env mi with
                          | (mib, mip) =&gt;
                            let auxnrecpar := mind_nparams_rec mib in
                            let auxnnonrecpar :=
                              Util.op_minus (mind_nparams mib) auxnrecpar in
                            match try with
                            | (auxrecparams, auxnonrecargs) =&gt;
                              if
                                andb chkpos
                                  (negb
                                    (Util.List.(CList.ExtS.for_all)
                                      (Vars.noccur_between n ntypes)
                                      auxnonrecargs)) then
                                failwith_non_pos_list n ntypes auxnonrecargs
                              else
                                tt;
                              let auxntyp := mind_ntypes mib in
                              if negb (Int.equal auxntyp 1) then
                                Stdlib.raise (IllFormedInd (LocalNonPos n))
                              else
                                tt;
                              let auxlcvect :=
                                Inductive.abstract_mind_lc auxntyp auxnrecpar
                                  (mind_nf_lc mip) in
                              match
                                ienv_push_inductive ienv ((mi, u), auxrecparams)
                                with
                              | (env', _, _, _) as ienv' =&gt;
                                let auxrecparams' :=
                                  Util.List.(CList.ExtS.map) (Vars.lift auxntyp)
                                    auxrecparams in
                                let irecargs_nmr :=
                                  Util.Array.(CArray.ExtS.map)
                                    (fun c =&gt;
                                      let c' :=
                                        Reduction.hnf_prod_applist env' c
                                          auxrecparams' in
                                      match
                                        ienv_decompose_prod ienv' auxnnonrecpar
                                          c' with
                                      | (ienv', c') =&gt;
                                        check_constructors ienv' false nmr c'
                                      end) auxlcvect in
                                let irecargs
                                  : array (list Declarations.wf_paths) :=
                                  Util.Array.(CArray.ExtS.map) snd irecargs_nmr
                                with nmr' : Int.t :=
                                  array_min nmr irecargs_nmr in
                                (nmr',
                                  (Util.Array.(CArray.ExtS.get)
                                    (Rtree.mk_rec
                                      ((Declareops.mk_paths (Imbr mi) irecargs)))
                                    0))
                              end
                            end
                          end
                        end
                  end
                with check_constructors
                  (ienv :
                  Environ.env * Z * Z *
                    (list (Declarations.recarg * Declarations.wf_paths)))
                  (check_head : bool) (nmr : Int.t) (c : Constr.constr)
                  : Int.t * (list Declarations.wf_paths) :=
                  let fix check_constr_rec
                    (function_parameter :
                    Environ.env * Z * Z *
                      (list (Declarations.recarg * Declarations.wf_paths)))
                    : Int.t -&gt;
                      (list Declarations.wf_paths) -&gt;
                        Constr.constr -&gt; Int.t * (list Declarations.wf_paths) :=
                    match function_parameter with
                    | (env, n, ntypes, _ra_env) as ienv =&gt;
                      fun nmr =&gt;
                        fun lrec =&gt;
                          fun c =&gt;
                            match Constr.decompose_app (Reduction.whd_all env c)
                              with
                            | (x, largs) =&gt;
                              match Constr.kind x with
                              | Prod na b d =&gt;
                                match Util.List.(CList.ExtS.is_empty) largs with
                                | tt =&gt;
                                  if
                                    andb (negb recursive)
                                      (negb (Vars.noccur_between n ntypes b))
                                    then
                                    Stdlib.raise
                                      (InductiveError Type_errors.BadEntry)
                                  else
                                    tt;
                                  match check_pos ienv nmr b with
                                  | (nmr', recarg) =&gt;
                                    let ienv' :=
                                      ienv_push_var ienv
                                        (na, b, Declareops.mk_norec) in
                                    check_constr_rec ienv' nmr'
                                      (cons recarg lrec) d
                                  end
                                end
                              | hd =&gt;
                                match
                                  if check_head then
                                    match hd with
                                    | _ =&gt;
                                      Stdlib.raise
                                        (IllFormedInd
                                          (LocalNotConstructor paramsctxt
                                            nnonrecargs))
                                    end
                                  else
                                    if
                                      andb chkpos
                                        (negb
                                          (Util.List.(CList.ExtS.for_all)
                                            (Vars.noccur_between n ntypes) largs))
                                      then
                                      failwith_non_pos_list n ntypes largs
                                    else
                                      tt with
                                | tt =&gt; (nmr, (Util.List.(CList.ExtS.rev) lrec))
                                end
                              end
                            end
                    end in
                  check_constr_rec ienv nmr [] c in
                let irecargs_nmr :=
                  Util.Array.(CArray.ExtS.map2)
                    (fun id =&gt;
                      fun c =&gt;
                        match mind_extract_params nparamsctxt c with
                        | (_, rawc) =&gt; try
                        end) (Util.Array.(CArray.ExtS.of_list) lcnames) indlc in
                let irecargs : array (list Declarations.wf_paths) :=
                  Util.Array.(CArray.ExtS.map) snd irecargs_nmr
                with nmr' : Int.t :=
                  array_min nmr irecargs_nmr in
                (nmr', (Declareops.mk_paths (Mrec ind) irecargs))
        end
  end.

Definition check_positivity {A : Type}
  (chkpos : bool) (kn : Names.MutInd.t) (names : array (A * (list Names.Id.t)))
  (env_ar_par : Environ.env)
  (paramsctxt : Context.Rel.pt Constr.constr Constr.types)
  (finite : Declarations.recursivity_kind)
  (inds : array (Z * (array Constr.types)))
  : Int.t * (array (Rtree.t Declarations.recarg)) :=
  let ntypes := Util.Array.(CArray.ExtS.length) inds in
  let recursive := Stdlib.op_exclamation_eq finite BiFinite in
  let rc :=
    Util.Array.(CArray.ExtS.mapi) (fun j =&gt; fun t =&gt; ((Mrec (kn, j)), t))
      (Rtree.mk_rec_calls ntypes) in
  let ra_env_ar := Util.Array.(CArray.ExtS.rev_to_list) rc in
  let nparamsctxt := Context.Rel.length paramsctxt in
  let nmr := Context.Rel.nhyps paramsctxt in
  let check_one {B : Type} (i : Z) (function_parameter : B * (list Names.Id.t))
    : (Z * (array Constr.types)) -&gt; Int.t * Declarations.wf_paths :=
    match function_parameter with
    | (_, lcnames) =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | (nindices, lc) =&gt;
          let ra_env_ar_par :=
            Util.op_at
              (Util.List.(CList.ExtS.init) nparamsctxt
                (fun function_parameter =&gt;
                  match function_parameter with
                  | _ =&gt; (Norec, Declareops.mk_norec)
                  end)) ra_env_ar in
          let ienv :=
            (env_ar_par, (Util.op_plus 1 nparamsctxt), ntypes, ra_env_ar_par) in
          check_positivity_one chkpos recursive ienv paramsctxt (kn, i) nindices
            lcnames lc
        end
    end in
  let irecargs_nmr := Util.Array.(CArray.ExtS.map2_i) check_one names inds in
  let irecargs : array Declarations.wf_paths :=
    Util.Array.(CArray.ExtS.map) snd irecargs_nmr
  with nmr' : Int.t :=
    array_min nmr irecargs_nmr in
  (nmr', (Rtree.mk_rec irecargs)).

Definition repair_arity
  (indices : Constr.rel_context)
  (function_parameter :
    Declarations.declaration_arity Declarations.regular_inductive_arity
      Declarations.template_arity) : Constr.types :=
  match function_parameter with
  | RegularArity ar =&gt; mind_user_arity ar
  | TemplateArity ar =&gt;
    Term.mkArity (indices, (Sorts.sort_of_univ (template_level ar)))
  end.

Definition fold_inductive_blocks {A B C : Type} (f : A -&gt; Constr.types -&gt; A)
  : A -&gt;
    (array
      (((Declarations.declaration_arity Declarations.regular_inductive_arity
        Declarations.template_arity) * (array Constr.types)) *
        (Constr.rel_context * B) * C)) -&gt; A :=
  Util.Array.(CArray.ExtS.fold_left)
    (fun acc =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | ((arity, lc), (indices, _), _) =&gt;
          f (Util.Array.(CArray.ExtS.fold_left) f acc lc)
            (repair_arity indices arity)
        end).

Definition used_section_variables {A B : Type}
  (env : Environ.env)
  (inds :
    array
      (((Declarations.declaration_arity Declarations.regular_inductive_arity
        Declarations.template_arity) * (array Constr.types)) *
        (Constr.rel_context * A) * B)) : Constr.named_context :=
  let fold (l : Names.Id.Set.t) (c : Constr.constr) : Names.Id.Set.t :=
    Names.Id.Set.union (Environ.global_vars_set env c) l in
  let ids := fold_inductive_blocks fold Names.Id.Set.empty inds in
  Environ.keep_hyps env ids.

Definition rel_vect (n : Z) (m : Z) : array Constr.constr :=
  Util.Array.(CArray.ExtS.init) m
    (fun i =&gt; Constr.mkRel (Util.op_minus (Util.op_plus n m) i)).

Definition rel_list (n : Z) (m : Z) : list Constr.constr :=
  Util.Array.(CArray.ExtS.to_list) (rel_vect n m).

Definition compute_projections (function_parameter : Names.MutInd.t * Z)
  : Declarations.mutual_inductive_body -&gt;
    (array Names.Label.t) * (array Sorts.relevance) * (array Constr.constr) :=
  match function_parameter with
  | (kn, i) as ind =&gt;
    fun mib =&gt;
      let pkt := Util.Array.(CArray.ExtS.get) (mind_packets mib) i in
      let u :=
        Univ.make_abstract_instance
          (Declareops.inductive_polymorphic_context mib) in
      let subst :=
        Util.List.(CList.ExtS.init) (mind_ntypes mib)
          (fun i =&gt;
            Constr.mkIndU
              ((kn, (Util.op_minus (Util.op_minus (mind_ntypes mib) i) 1)), u))
        in
      match Util.Array.(CArray.ExtS.get) (mind_nf_lc pkt) 0 with
      | (ctx, cty) =&gt;
        let cty := Term.it_mkProd_or_LetIn cty ctx in
        match Term.decompose_prod_assum (Vars.substl subst cty) with
        | (rctx, _) =&gt;
          match
            Util.List.(CList.ExtS.chop)
              (Util.Array.(CArray.ExtS.get) (mind_consnrealdecls pkt) 0) rctx
            with
          | (ctx, paramslet) =&gt;
            let paramsletsubst :=
              let inst' := rel_list 0 (mind_nparams mib) in
              let subst := Vars.subst_of_rel_context_instance paramslet inst' in
              let subst :=
                cons (Constr.mkRel 1)
                  (Util.List.(CList.ExtS.map) (Vars.lift 1) subst) in
              subst in
            let projections
              (decl : Context.Rel.Declaration.pt Constr.constr Constr.constr)
              (function_parameter :
              Z * Z * (list Names.Label.t) * (list Sorts.relevance) *
                (list Constr.constr) * Vars.substl)
              : Z * Z * (list Names.Label.t) * (list Sorts.relevance) *
                (list Constr.constr) * (list Constr.constr) :=
              match function_parameter with
              | (i, j, labs, rs, pbs, letsubst) =&gt;
                match decl with
                | LocalDef _na c _t =&gt;
                  let c := Vars.liftn 1 j c in
                  let c2 := Vars.substl letsubst c in
                  let letsubst := cons c2 letsubst in
                  (i, (Util.op_plus j 1), labs, rs, pbs, letsubst)
                | LocalAssum na t =&gt;
                  match Context.binder_name na with
                  | Name id =&gt;
                    let r := Context.binder_relevance na in
                    let lab := Names.Label.of_id id in
                    let kn :=
                      Names.Projection.Repr.make ind (mind_nparams mib) i lab in
                    let t := Vars.liftn 1 j t in
                    let projty := Vars.substl letsubst t in
                    let fterm :=
                      Constr.mkProj
                        ((Names.Projection.make kn false), (Constr.mkRel 1)) in
                    ((Util.op_plus i 1), (Util.op_plus j 1), (cons lab labs),
                      (cons r rs), (cons projty pbs), (cons fterm letsubst))
                  | Anonymous =&gt; false
                  end
                end
              end in
            match
              Util.List.(CList.ExtS.fold_right) projections ctx
                (0, 1, [], [], [], paramsletsubst) with
            | (_, _, labs, rs, pbs, _letsubst) =&gt;
              ((Util.Array.(CArray.ExtS.of_list)
                (Util.List.(CList.ExtS.rev) labs)),
                (Util.Array.(CArray.ExtS.of_list)
                  (Util.List.(CList.ExtS.rev) rs)),
                (Util.Array.(CArray.ExtS.of_list)
                  (Util.List.(CList.ExtS.rev) pbs)))
            end
          end
        end
      end
  end.

Definition build_inductive
  (env : Environ.env) (names : array (Names.Id.t * (list Names.Id.t)))
  (prv : option bool) (univs : Declarations.universes)
  (variance : option (array Univ.Variance.t))
  (paramsctxt : Context.Rel.pt Constr.constr Constr.types) (kn : Names.MutInd.t)
  (isrecord : option (option (array Names.Id.t)))
  (isfinite : Declarations.recursivity_kind)
  (inds :
    array
      ((Declarations.inductive_arity * (array Constr.types)) *
        ((Context.Rel.pt Constr.constr Constr.types) *
          (array ((Context.Rel.pt Constr.constr Constr.types) * Constr.types)))
        * Sorts.family)) (nmr : Z) (recargs : array Declarations.wf_paths)
  : Declarations.mutual_inductive_body :=
  let ntypes := Util.Array.(CArray.ExtS.length) inds in
  let hyps := used_section_variables env inds in
  let nparamargs := Context.Rel.nhyps paramsctxt in
  let build_one_packet (function_parameter : Names.Id.t * (list Names.Id.t))
    : ((Declarations.inductive_arity * (array Constr.types)) *
      ((Context.Rel.pt Constr.constr Constr.types) *
        (array ((Context.Rel.pt Constr.constr Constr.types) * Constr.types))) *
      Sorts.family) -&gt; Declarations.wf_paths -&gt; Declarations.one_inductive_body :=
    match function_parameter with
    | (id, cnames) =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | ((arity, lc), (indices, splayed_lc), kelim) =&gt;
          fun recarg =&gt;
            let nf_lc :=
              Util.Array.(CArray.ExtS.map)
                (fun function_parameter =&gt;
                  match function_parameter with
                  | (d, b) =&gt; ((Util.op_at d paramsctxt), b)
                  end) splayed_lc in
            let consnrealdecls :=
              Util.Array.(CArray.ExtS.map)
                (fun function_parameter =&gt;
                  match function_parameter with
                  | (d, _) =&gt; Context.Rel.length d
                  end) splayed_lc in
            let consnrealargs :=
              Util.Array.(CArray.ExtS.map)
                (fun function_parameter =&gt;
                  match function_parameter with
                  | (d, _) =&gt; Context.Rel.nhyps d
                  end) splayed_lc in
            let mind_relevance :=
              match arity with
              | RegularArity {| mind_sort := mind_sort |} =&gt;
                Sorts.relevance_of_sort mind_sort
              | TemplateArity _ =&gt; Sorts.Relevant
              end in
            match ((Stdlib.ref 0), (Stdlib.ref 0)) with
            | (nconst, nblock) =&gt;
              let transf (num : Z) : Z * Z :=
                let arity :=
                  Util.List.(CList.ExtS.length)
                    (Util.Array.(CArray.ExtS.get)
                      (Declareops.dest_subterms recarg) num) in
                if Int.equal arity 0 then
                  let p := ((Util.op_exclamation nconst), 0) in
                  Stdlib.incr nconst;
                  p
                else
                  let p :=
                    ((Util.op_plus (Util.op_exclamation nblock) 1), arity) in
                  Stdlib.incr nblock;
                  p in
              let rtbl :=
                Util.Array.(CArray.ExtS.init)
                  (Util.List.(CList.ExtS.length) cnames) transf in
              {| mind_typename := id;
                mind_arity_ctxt := Util.op_at indices paramsctxt;
                mind_arity := arity;
                mind_consnames := Util.Array.(CArray.ExtS.of_list) cnames;
                mind_user_lc := lc; mind_nrealargs := Context.Rel.nhyps indices;
                mind_nrealdecls := Context.Rel.length indices;
                mind_kelim := kelim; mind_nf_lc := nf_lc;
                mind_consnrealargs := consnrealargs;
                mind_consnrealdecls := consnrealdecls; mind_recargs := recarg;
                mind_relevance := mind_relevance;
                mind_nb_constant := Util.op_exclamation nconst;
                mind_nb_args := Util.op_exclamation nblock;
                mind_reloc_tbl := rtbl |}
            end
        end
    end in
  let packets :=
    Util.Array.(CArray.ExtS.map3) build_one_packet names inds recargs in
  let mib :=
    {| mind_packets := packets; mind_record := NotRecord;
      mind_finite := isfinite; mind_ntypes := ntypes; mind_hyps := hyps;
      mind_nparams := nparamargs; mind_nparams_rec := nmr;
      mind_params_ctxt := paramsctxt; mind_universes := univs;
      mind_variance := variance; mind_private := prv;
      mind_typing_flags := Environ.typing_flags env |} in
  let record_info :=
    match isrecord with
    | Some (Some rid) =&gt;
      let map {A : Type} (i : Z) (id : A)
        : A * (array Names.Label.t) * (array Sorts.relevance) *
          (array Constr.constr) :=
        match compute_projections (kn, i) mib with
        | (labs, rs, projs) =&gt; (id, labs, rs, projs)
        end in
      PrimRecord (Util.Array.(CArray.ExtS.mapi) map rid)
    | Some None =&gt; FakeRecord
    | None =&gt; NotRecord
    end in
  record.

Definition check_inductive
  (env : Environ.env) (kn : Names.MutInd.t)
  (mie : Entries.mutual_inductive_entry) : Declarations.mutual_inductive_body :=
  match IndTyping.typecheck_inductive env mie with
  | (env_ar_par, univs, variance, record, paramsctxt, inds) =&gt;
    let chkpos := check_positive (Environ.typing_flags env) in
    let names :=
      Util.Array.(CArray.ExtS.map_of_list)
        (fun entry =&gt;
          ((mind_entry_typename entry), (mind_entry_consnames entry)))
        (mind_entry_inds mie) in
    match
      check_positivity chkpos kn names env_ar_par paramsctxt
        (mind_entry_finite mie)
        (Util.Array.(CArray.ExtS.map)
          (fun function_parameter =&gt;
            match function_parameter with
            | ((_, lc), (indices, _), _) =&gt; ((Context.Rel.nhyps indices), lc)
            end) inds) with
    | (nmr, recargs) =&gt;
      build_inductive env names (mind_entry_private mie) univs variance
        paramsctxt kn record (mind_entry_finite mie) inds nmr recargs
    end
  end.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="inductive" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>inductive.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open CErrors
open Util
open Names
open Univ
open Constr
open Vars
open Declarations
open Declareops
open Environ
open Reduction
open Type_errors
open Context.Rel.Declaration

type mind_specif = mutual_inductive_body * one_inductive_body

(* raise Not_found if not an inductive type *)
let lookup_mind_specif env (kn,tyi) =
  let mib = Environ.lookup_mind kn env in
  if tyi &gt;= Array.length mib.mind_packets then
    user_err Pp.(str &quot;Inductive.lookup_mind_specif: invalid inductive index&quot;);
  (mib, mib.mind_packets.(tyi))

let find_rectype env c =
  let (t, l) = decompose_app (whd_all env c) in
  match kind t with
  | Ind ind -&gt; (ind, l)
  | _ -&gt; raise Not_found

let find_inductive env c =
  let (t, l) = decompose_app (whd_all env c) in
  match kind t with
    | Ind ind
        when (fst (lookup_mind_specif env (out_punivs ind))).mind_finite &lt;&gt; CoFinite -&gt; (ind, l)
    | _ -&gt; raise Not_found

let find_coinductive env c =
  let (t, l) = decompose_app (whd_all env c) in
  match kind t with
    | Ind ind
        when (fst (lookup_mind_specif env (out_punivs ind))).mind_finite == CoFinite -&gt; (ind, l)
    | _ -&gt; raise Not_found

let inductive_params (mib,_) = mib.mind_nparams

let inductive_paramdecls (mib,u) = 
  Vars.subst_instance_context u mib.mind_params_ctxt

let instantiate_inductive_constraints mib u =
  Univ.AUContext.instantiate u (Declareops.inductive_polymorphic_context mib)

(************************************************************************)

(* Build the substitution that replaces Rels by the appropriate *)
(* inductives *)
let ind_subst mind mib u =
  let ntypes = mib.mind_ntypes in
  let make_Ik k = mkIndU ((mind,ntypes-k-1),u) in
  List.init ntypes make_Ik

(* Instantiate inductives in constructor type *)
let constructor_instantiate mind u mib c =
  let s = ind_subst mind mib u in
    substl s (subst_instance_constr u c)

let instantiate_params full t u args sign =
  let fail () =
    anomaly ~label:&quot;instantiate_params&quot; (Pp.str &quot;type, ctxt and args mismatch.&quot;) in
  let (rem_args, subs, ty) =
    Context.Rel.fold_outside
      (fun decl (largs,subs,ty) -&gt;
        match (decl, largs, kind ty) with
          | (LocalAssum _, a::args, Prod(_,_,t)) -&gt; (args, a::subs, t)
          | (LocalDef (_,b,_), _, LetIn(_,_,_,t))    -&gt;
	     (largs, (substl subs (subst_instance_constr u b))::subs, t)
	  | (_,[],_)                -&gt; if full then fail() else ([], subs, ty)
	  | _                       -&gt; fail ())
      sign
      ~init:(args,[],t)
  in
  let () = if not (List.is_empty rem_args) then fail () in
  substl subs ty

let full_inductive_instantiate mib u params sign =
  let dummy = Sorts.prop in
  let t = Term.mkArity (Vars.subst_instance_context u sign,dummy) in
    fst (Term.destArity (instantiate_params true t u params mib.mind_params_ctxt))

let full_constructor_instantiate ((mind,_),u,(mib,_),params) t =
  let inst_ind = constructor_instantiate mind u mib t in
   instantiate_params true inst_ind u params mib.mind_params_ctxt
		      
(************************************************************************)
(************************************************************************)

(* Functions to build standard types related to inductive *)

(*
Computing the actual sort of an applied or partially applied inductive type:

I_i: forall uniformparams:utyps, forall otherparams:otyps, Type(a)
uniformargs : utyps
otherargs : otyps
I_1:forall ...,s_1;...I_n:forall ...,s_n |- sort(C_kj(uniformargs)) = s_kj
s'_k = max(..s_kj..)
merge(..s'_k..) = ..s''_k..
--------------------------------------------------------------------
Gamma |- I_i uniformargs otherargs : phi(s''_i)

where

- if p=0, phi() = Prop
- if p=1, phi(s) = s
- if p&lt;&gt;1, phi(s) = sup(Set,s)

Remark: Set (predicative) is encoded as Type(0)
*)

(* Template polymorphism *)

(* cons_subst add the mapping [u |-&gt; su] in subst if [u] is not *)
(* in the domain or add [u |-&gt; sup x su] if [u] is already mapped *)
(* to [x]. *)
let cons_subst u su subst =
  try
    Univ.LMap.add u (Univ.sup (Univ.LMap.find u subst) su) subst
  with Not_found -&gt; Univ.LMap.add u su subst

(* remember_subst updates the mapping [u |-&gt; x] by [u |-&gt; sup x u] *)
(* if it is presents and returns the substitution unchanged if not.*)
let remember_subst u subst =
  try
    let su = Universe.make u in
    Univ.LMap.add u (Univ.sup (Univ.LMap.find u subst) su) subst
  with Not_found -&gt; subst

(* Bind expected levels of parameters to actual levels *)
(* Propagate the new levels in the signature *)
let make_subst env =
  let rec make subst = function
    | LocalDef _ :: sign, exp, args -&gt;
        make subst (sign, exp, args)
    | _d::sign, None::exp, args -&gt;
        let args = match args with _::args -&gt; args | [] -&gt; [] in
        make subst (sign, exp, args)
    | _d::sign, Some u::exp, a::args -&gt;
        (* We recover the level of the argument, but we don't change the *)
        (* level in the corresponding type in the arity; this level in the *)
        (* arity is a global level which, at typing time, will be enforce *)
        (* to be greater than the level of the argument; this is probably *)
        (* a useless extra constraint *)
        let s = Sorts.univ_of_sort (snd (dest_arity env (Lazy.force a))) in
          make (cons_subst u s subst) (sign, exp, args)
    | LocalAssum (_na,_t) :: sign, Some u::exp, [] -&gt;
        (* No more argument here: we add the remaining universes to the *)
        (* substitution (when [u] is distinct from all other universes in the *)
        (* template, it is identity substitution  otherwise (ie. when u is *)
        (* already in the domain of the substitution) [remember_subst] will *)
        (* update its image [x] by [sup x u] in order not to forget the *)
        (* dependency in [u] that remains to be fulfilled. *)
        make (remember_subst u subst) (sign, exp, [])
    | _sign, [], _ -&gt;
        (* Uniform parameters are exhausted *)
        subst
    | [], _, _ -&gt;
        assert false
  in
  make Univ.LMap.empty

exception SingletonInductiveBecomesProp of Id.t

let instantiate_universes env ctx ar argsorts =
  let args = Array.to_list argsorts in
  let subst = make_subst env (ctx,ar.template_param_levels,args) in
  let level = Univ.subst_univs_universe (Univ.make_subst subst) ar.template_level in
  let ty =
    (* Singleton type not containing types are interpretable in Prop *)
    if is_type0m_univ level then Sorts.prop
    (* Non singleton type not containing types are interpretable in Set *)
    else if is_type0_univ level then Sorts.set
    (* This is a Type with constraints *)
    else Sorts.sort_of_univ level
  in
    (ctx, ty)

(* Type of an inductive type *)

let relevance_of_inductive env ind =
  let _, mip = lookup_mind_specif env ind in
  mip.mind_relevance

let type_of_inductive_gen ?(polyprop=true) env ((_,mip),u) paramtyps =
  match mip.mind_arity with
  | RegularArity a -&gt; subst_instance_constr u a.mind_user_arity
  | TemplateArity ar -&gt;
    let ctx = List.rev mip.mind_arity_ctxt in
    let ctx,s = instantiate_universes env ctx ar paramtyps in
      (* The Ocaml extraction cannot handle (yet?) &quot;Prop-polymorphism&quot;, i.e.
         the situation where a non-Prop singleton inductive becomes Prop
         when applied to Prop params *)
      if not polyprop &amp;&amp; not (is_type0m_univ ar.template_level) &amp;&amp; Sorts.is_prop s
      then raise (SingletonInductiveBecomesProp mip.mind_typename);
      Term.mkArity (List.rev ctx,s)

let type_of_inductive env pind = 
  type_of_inductive_gen env pind [||]

let constrained_type_of_inductive env ((mib,_mip),u as pind) =
  let ty = type_of_inductive env pind in
  let cst = instantiate_inductive_constraints mib u in
    (ty, cst)

let constrained_type_of_inductive_knowing_parameters env ((mib,_mip),u as pind) args =
  let ty = type_of_inductive_gen env pind args in
  let cst = instantiate_inductive_constraints mib u in
    (ty, cst)

let type_of_inductive_knowing_parameters env ?(polyprop=true) mip args =
  type_of_inductive_gen ~polyprop env mip args

(* The max of an array of universes *)

let cumulate_constructor_univ u = let open Sorts in function
  | SProp | Prop -&gt;
    (* SProp is non cumulative but allowed in constructors of any
       inductive (except non-sprop primitive records) *)
    u
  | Set -&gt; Universe.sup Universe.type0 u
  | Type u' -&gt; Universe.sup u u'

let max_inductive_sort =
  Array.fold_left cumulate_constructor_univ Universe.type0m

(************************************************************************)
(* Type of a constructor *)

let type_of_constructor (cstr, u) (mib,mip) =
  let ind = inductive_of_constructor cstr in
  let specif = mip.mind_user_lc in
  let i = index_of_constructor cstr in
  let nconstr = Array.length mip.mind_consnames in
  if i &gt; nconstr then user_err Pp.(str &quot;Not enough constructors in the type.&quot;);
  constructor_instantiate (fst ind) u mib specif.(i-1)

let constrained_type_of_constructor (_cstr,u as cstru) (mib,_mip as ind) =
  let ty = type_of_constructor cstru ind in
  let cst = instantiate_inductive_constraints mib u in
    (ty, cst)

let arities_of_specif (kn,u) (mib,mip) =
  let specif = mip.mind_nf_lc in
  let map (ctx, c) =
    let cty = Term.it_mkProd_or_LetIn c ctx in
    constructor_instantiate kn u mib cty
  in
  Array.map map specif

let arities_of_constructors ind specif =
  arities_of_specif (fst (fst ind), snd ind) specif

let type_of_constructors (ind,u) (mib,mip) =
  let specif = mip.mind_user_lc in
    Array.map (constructor_instantiate (fst ind) u mib) specif

(************************************************************************)

(* Type of case predicates *)

(* Get type of inductive, with parameters instantiated *)

let inductive_sort_family mip =
  match mip.mind_arity with
  | RegularArity s -&gt; Sorts.family s.mind_sort
  | TemplateArity _ -&gt; Sorts.InType

let mind_arity mip =
  mip.mind_arity_ctxt, inductive_sort_family mip

let get_instantiated_arity (_ind,u) (mib,mip) params =
  let sign, s = mind_arity mip in
  full_inductive_instantiate mib u params sign, s

let elim_sort (_,mip) = mip.mind_kelim

let is_private (mib,_) = mib.mind_private = Some true
let is_primitive_record (mib,_) = 
  match mib.mind_record with
  | PrimRecord _ -&gt; true
  | NotRecord | FakeRecord -&gt; false

let build_dependent_inductive ind (_,mip) params =
  let realargs,_ = List.chop mip.mind_nrealdecls mip.mind_arity_ctxt in
  Term.applist
    (mkIndU ind,
       List.map (lift mip.mind_nrealdecls) params
       @ Context.Rel.to_extended_list mkRel 0 realargs)

(* This exception is local *)
exception LocalArity of (Sorts.family * Sorts.family * Sorts.family * arity_error) option

let check_allowed_sort ksort specif =
  if not (Sorts.family_leq ksort (elim_sort specif)) then
    let s = inductive_sort_family (snd specif) in
    raise (LocalArity (Some(elim_sort specif, ksort,s,error_elim_explain ksort s)))

let is_correct_arity env c pj ind specif params =
  let arsign,_ = get_instantiated_arity ind specif params in
  let rec srec env pt ar =
    let pt' = whd_all env pt in
    match kind pt', ar with
      | Prod (na1,a1,t), (LocalAssum (_,a1'))::ar' -&gt;
          let () =
            try conv env a1 a1'
            with NotConvertible -&gt; raise (LocalArity None) in
          srec (push_rel (LocalAssum (na1,a1)) env) t ar'
      (* The last Prod domain is the type of the scrutinee *)
      | Prod (na1,a1,a2), [] -&gt; (* whnf of t was not needed here! *)
         let env' = push_rel (LocalAssum (na1,a1)) env in
	 let ksort = match kind (whd_all env' a2) with
	 | Sort s -&gt; Sorts.family s
	 | _ -&gt; raise (LocalArity None) in
	 let dep_ind = build_dependent_inductive ind specif params in
	 let _ =
           try conv env a1 dep_ind
           with NotConvertible -&gt; raise (LocalArity None) in
	   check_allowed_sort ksort specif
      | _, (LocalDef _ as d)::ar' -&gt;
	  srec (push_rel d env) (lift 1 pt') ar'
      | _ -&gt;
	  raise (LocalArity None)
  in
  try srec env pj.uj_type (List.rev arsign) 
  with LocalArity kinds -&gt;
    error_elim_arity env ind c pj kinds


(************************************************************************)
(* Type of case branches *)

(* [p] is the predicate, [i] is the constructor number (starting from 0),
   and [cty] is the type of the constructor (params not instantiated) *)
let build_branches_type (ind,u) (_,mip as specif) params p =
  let build_one_branch i (ctx, c) =
    let cty = Term.it_mkProd_or_LetIn c ctx in
    let typi = full_constructor_instantiate (ind,u,specif,params) cty in
    let (cstrsign,ccl) = Term.decompose_prod_assum typi in
    let nargs = Context.Rel.length cstrsign in
    let (_,allargs) = decompose_app ccl in
    let (lparams,vargs) = List.chop (inductive_params specif) allargs in
    let cargs =
      let cstr = ith_constructor_of_inductive ind (i+1) in
      let dep_cstr = Term.applist (mkConstructU (cstr,u),lparams@(Context.Rel.to_extended_list mkRel 0 cstrsign)) in
      vargs @ [dep_cstr] in
    let base = Term.lambda_appvect_assum (mip.mind_nrealdecls+1) (lift nargs p) (Array.of_list cargs) in
    Term.it_mkProd_or_LetIn base cstrsign in
  Array.mapi build_one_branch mip.mind_nf_lc

(* [p] is the predicate, [c] is the match object, [realargs] is the
   list of real args of the inductive type *)
let build_case_type env n p c realargs =
  whd_betaiota env (Term.lambda_appvect_assum (n+1) p (Array.of_list (realargs@[c])))

let type_case_branches env (pind,largs) pj c =
  let specif = lookup_mind_specif env (fst pind) in
  let nparams = inductive_params specif in
  let (params,realargs) = List.chop nparams largs in
  let p = pj.uj_val in
  let () = is_correct_arity env c pj pind specif params in
  let lc = build_branches_type pind specif params p in
  let ty = build_case_type env (snd specif).mind_nrealdecls p c realargs in
  (lc, ty)


(************************************************************************)
(* Checking the case annotation is relevant *)

let check_case_info env (indsp,u) r ci =
  let (mib,mip as spec) = lookup_mind_specif env indsp in
  if
    not (eq_ind indsp ci.ci_ind) ||
    not (Int.equal mib.mind_nparams ci.ci_npar) ||
    not (Array.equal Int.equal mip.mind_consnrealdecls ci.ci_cstr_ndecls) ||
    not (Array.equal Int.equal mip.mind_consnrealargs ci.ci_cstr_nargs) ||
    not (ci.ci_relevance == r) ||
    is_primitive_record spec
  then raise (TypeError(env,WrongCaseInfo((indsp,u),ci)))

(************************************************************************)
(************************************************************************)

(* Guard conditions for fix and cofix-points *)

(* Check if t is a subterm of Rel n, and gives its specification,
   assuming lst already gives index of
   subterms with corresponding specifications of recursive arguments *)

(* A powerful notion of subterm *)

(* To each inductive definition corresponds an array describing the
   structure of recursive arguments for each constructor, we call it
   the recursive spec of the type (it has type recargs vect).  For
   checking the guard, we start from the decreasing argument (Rel n)
   with its recursive spec.  During checking the guardness condition,
   we collect patterns variables corresponding to subterms of n, each
   of them with its recursive spec.  They are organised in a list lst
   of type (int * recargs) list which is sorted with respect to the
   first argument.
*)

(*************************************************************)
(* Environment annotated with marks on recursive arguments *)

(* tells whether it is a strict or loose subterm *)
type size = Large | Strict

(* merging information *)
let size_glb s1 s2 =
  match s1,s2 with
      Strict, Strict -&gt; Strict
    | _ -&gt; Large

(* possible specifications for a term:
   - Not_subterm: when the size of a term is not related to the
     recursive argument of the fixpoint
   - Subterm: when the term is a subterm of the recursive argument
       the wf_paths argument specifies which subterms are recursive
   - Dead_code: when the term has been built by elimination over an
       empty type
 *)

type subterm_spec =
    Subterm of (size * wf_paths)
  | Dead_code
  | Not_subterm

let eq_wf_paths = Rtree.equal Declareops.eq_recarg

let inter_recarg r1 r2 = match r1, r2 with
| Norec, Norec -&gt; Some r1
| Mrec i1, Mrec i2
| Imbr i1, Imbr i2
| Mrec i1, Imbr i2 -&gt; if Names.eq_ind i1 i2 then Some r1 else None
| Imbr i1, Mrec i2 -&gt; if Names.eq_ind i1 i2 then Some r2 else None
| _ -&gt; None

let inter_wf_paths = Rtree.inter Declareops.eq_recarg inter_recarg Norec

let incl_wf_paths = Rtree.incl Declareops.eq_recarg inter_recarg Norec

let spec_of_tree t =
  if eq_wf_paths t mk_norec
  then Not_subterm
  else Subterm (Strict, t)

let inter_spec s1 s2 =
  match s1, s2 with
  | _, Dead_code -&gt; s1
  | Dead_code, _ -&gt; s2
  | Not_subterm, _ -&gt; s1
  | _, Not_subterm -&gt; s2
  | Subterm (a1,t1), Subterm (a2,t2) -&gt;
     Subterm (size_glb a1 a2, inter_wf_paths t1 t2)

let subterm_spec_glb =
  Array.fold_left inter_spec Dead_code

type guard_env =
  { env     : env;
    (* dB of last fixpoint *)
    rel_min : int;
    (* dB of variables denoting subterms *)
    genv    : subterm_spec Lazy.t list;
  }

let make_renv env recarg tree =
  { env = env;
    rel_min = recarg+2; (* recarg = 0 ==&gt; Rel 1 -&gt; recarg; Rel 2 -&gt; fix *)
    genv = [Lazy.from_val(Subterm(Large,tree))] }

let push_var renv (x,ty,spec) =
  { env = push_rel (LocalAssum (x,ty)) renv.env;
    rel_min = renv.rel_min+1;
    genv = spec:: renv.genv }

let assign_var_spec renv (i,spec) =
  { renv with genv = List.assign renv.genv (i-1) spec }

let push_var_renv renv (x,ty) =
  push_var renv (x,ty,lazy Not_subterm)

(* Fetch recursive information about a variable p *)
let subterm_var p renv =
  try Lazy.force (List.nth renv.genv (p-1))
  with Failure _ | Invalid_argument _ -&gt; Not_subterm

let push_ctxt_renv renv ctxt =
  let n = Context.Rel.length ctxt in
  { env = push_rel_context ctxt renv.env;
    rel_min = renv.rel_min+n;
    genv = iterate (fun ge -&gt; lazy Not_subterm::ge) n renv.genv }

let push_fix_renv renv (_,v,_ as recdef) =
  let n = Array.length v in
  { env = push_rec_types recdef renv.env;
    rel_min = renv.rel_min+n;
    genv = iterate (fun ge -&gt; lazy Not_subterm::ge) n renv.genv }

(* Definition and manipulation of the stack *)
type stack_element = |SClosure of guard_env*constr |SArg of subterm_spec Lazy.t

let push_stack_closures renv l stack = 
  List.fold_right (fun h b -&gt; (SClosure (renv,h))::b) l stack

let push_stack_args l stack = 
  List.fold_right (fun h b -&gt; (SArg h)::b) l stack

(******************************)
(* {6 Computing the recursive subterms of a term (propagation of size
   information through Cases).} *)

let lookup_subterms env ind =
  let (_,mip) = lookup_mind_specif env ind in
  mip.mind_recargs

let match_inductive ind ra =
  match ra with
    | (Mrec i | Imbr i) -&gt; eq_ind ind i
    | Norec -&gt; false

(* In {match c as z in ci y_s return P with |C_i x_s =&gt; t end}
   [branches_specif renv c_spec ci] returns an array of x_s specs knowing
   c_spec. *)
let branches_specif renv c_spec ci =
  let car = 
    (* We fetch the regular tree associated to the inductive of the match.
       This is just to get the number of constructors (and constructor
       arities) that fit the match branches without forcing c_spec.
       Note that c_spec might be more precise than [v] below, because of
       nested inductive types. *)
    let (_,mip) = lookup_mind_specif renv.env ci.ci_ind in
    let v = dest_subterms mip.mind_recargs in
      Array.map List.length v in
    Array.mapi
      (fun i nca -&gt; (* i+1-th cstructor has arity nca *)
	 let lvra = lazy 
	   (match Lazy.force c_spec with
		Subterm (_,t) when match_inductive ci.ci_ind (dest_recarg t) -&gt;
		  let vra = Array.of_list (dest_subterms t).(i) in
		  assert (Int.equal nca (Array.length vra));
		  Array.map spec_of_tree vra
	      | Dead_code -&gt; Array.make nca Dead_code
	      | _ -&gt; Array.make nca Not_subterm) in
	 List.init nca (fun j -&gt; lazy (Lazy.force lvra).(j)))
      car 

let check_inductive_codomain env p =
  let absctx, ar = dest_lam_assum env p in
  let env = push_rel_context absctx env in
  let arctx, s = dest_prod_assum env ar in
  let env = push_rel_context arctx env in
  let i,_l' = decompose_app (whd_all env s) in
  isInd i

(* The following functions are almost duplicated from indtypes.ml, except
that they carry here a poorer environment (containing less information). *)
let ienv_push_var (env, lra) (x,a,ra) =
  (push_rel (LocalAssum (x,a)) env, (Norec,ra)::lra)

let ienv_push_inductive (env, ra_env) ((mind,u),lpar) =
  let mib = Environ.lookup_mind mind env in
  let ntypes = mib.mind_ntypes in
  let push_ind specif env =
    let r = specif.mind_relevance in
    let anon = Context.make_annot Anonymous r in
    let decl = LocalAssum (anon, hnf_prod_applist env (type_of_inductive env ((mib,specif),u)) lpar) in
    push_rel decl env
  in
  let env = Array.fold_right push_ind mib.mind_packets env in
  let rc = Array.mapi (fun j t -&gt; (Imbr (mind,j),t)) (Rtree.mk_rec_calls ntypes) in
  let lra_ind = Array.rev_to_list rc in
  let ra_env = List.map (fun (r,t) -&gt; (r,Rtree.lift ntypes t)) ra_env in
  (env, lra_ind @ ra_env)

let rec ienv_decompose_prod (env,_ as ienv) n c =
 if Int.equal n 0 then (ienv,c) else
   let c' = whd_all env c in
   match kind c' with
   Prod(na,a,b) -&gt;
     let ienv' = ienv_push_var ienv (na,a,mk_norec) in
     ienv_decompose_prod ienv' (n-1) b
     | _ -&gt; assert false

let dummy_univ = Level.(make (UGlobal.make (DirPath.make [Id.of_string &quot;implicit&quot;]) 0))
let dummy_implicit_sort = mkType (Universe.make dummy_univ)
let lambda_implicit_lift n a =
  let anon = Context.make_annot Anonymous Sorts.Relevant in
  let lambda_implicit a = mkLambda (anon, dummy_implicit_sort, a) in
  iterate lambda_implicit n (lift n a)

(* This removes global parameters of the inductive types in lc (for
   nested inductive types only ) *)
let abstract_mind_lc ntyps npars lc =
  let lc = Array.map (fun (ctx, c) -&gt; Term.it_mkProd_or_LetIn c ctx) lc in
  if Int.equal npars 0 then
    lc
  else
    let make_abs =
      List.init ntyps
	(function i -&gt; lambda_implicit_lift npars (mkRel (i+1)))
    in
    Array.map (substl make_abs) lc

(* [get_recargs_approx env tree ind args] builds an approximation of the recargs
tree for ind, knowing args. The argument tree is used to know when candidate
nested types should be traversed, pruning the tree otherwise. This code is very
close to check_positive in indtypes.ml, but does no positivity check and does not
compute the number of recursive arguments. *)
let get_recargs_approx env tree ind args =
  let rec build_recargs (env, ra_env as ienv) tree c =
    let x,largs = decompose_app (whd_all env c) in
    match kind x with
    | Prod (na,b,d) -&gt;
       assert (List.is_empty largs);
       build_recargs (ienv_push_var ienv (na, b, mk_norec)) tree d
    | Rel k -&gt;
       (* Free variables are allowed and assigned Norec *)
       (try snd (List.nth ra_env (k-1))
        with Failure _ | Invalid_argument _ -&gt; mk_norec)
    | Ind ind_kn -&gt;
       (* When the inferred tree allows it, we consider that we have a potential
       nested inductive type *)
       begin match dest_recarg tree with
	     | Imbr kn' | Mrec kn' when eq_ind (fst ind_kn) kn' -&gt;
			   build_recargs_nested ienv tree (ind_kn, largs)
	     | _ -&gt; mk_norec
       end
    | _err -&gt;
       mk_norec

  and build_recargs_nested (env,_ra_env as ienv) tree (((mind,i),u), largs) =
    (* If the inferred tree already disallows recursion, no need to go further *)
    if eq_wf_paths tree mk_norec then tree
    else
    let mib = Environ.lookup_mind mind env in
    let auxnpar = mib.mind_nparams_rec in
    let nonrecpar = mib.mind_nparams - auxnpar in
    let (lpar,_) = List.chop auxnpar largs in
    let auxntyp = mib.mind_ntypes in
    (* Extends the environment with a variable corresponding to
	     the inductive def *)
    let (env',_ as ienv') = ienv_push_inductive ienv ((mind,u),lpar) in
    (* Parameters expressed in env' *)
    let lpar' = List.map (lift auxntyp) lpar in
    (* In case of mutual inductive types, we use the recargs tree which was
    computed statically. This is fine because nested inductive types with
    mutually recursive containers are not supported. *)
    let trees =
      if Int.equal auxntyp 1 then [|dest_subterms tree|]
      else Array.map (fun mip -&gt; dest_subterms mip.mind_recargs) mib.mind_packets
    in
    let mk_irecargs j specif =
      (* The nested inductive type with parameters removed *)
      let auxlcvect = abstract_mind_lc auxntyp auxnpar specif.mind_nf_lc in
      let paths = Array.mapi
        (fun k c -&gt;
	 let c' = hnf_prod_applist env' c lpar' in
	 (* skip non-recursive parameters *)
	 let (ienv',c') = ienv_decompose_prod ienv' nonrecpar c' in
	 build_recargs_constructors ienv' trees.(j).(k) c')
	auxlcvect
      in
      mk_paths (Imbr (mind,j)) paths
    in
    let irecargs = Array.mapi mk_irecargs mib.mind_packets in
    (Rtree.mk_rec irecargs).(i)

  and build_recargs_constructors ienv trees c =
    let rec recargs_constr_rec (env,_ra_env as ienv) trees lrec c =
      let x,largs = decompose_app (whd_all env c) in
	match kind x with

          | Prod (na,b,d) -&gt;
	     let () = assert (List.is_empty largs) in
             let recarg = build_recargs ienv (List.hd trees) b in
             let ienv' = ienv_push_var ienv (na,b,mk_norec) in
             recargs_constr_rec ienv' (List.tl trees) (recarg::lrec) d
          | _hd -&gt;
             List.rev lrec
    in
    recargs_constr_rec ienv trees [] c
  in
  (* starting with ra_env = [] seems safe because any unbounded Rel will be
  assigned Norec *)
  build_recargs_nested (env,[]) tree (ind, args)

(* [restrict_spec env spec p] restricts the size information in spec to what is
   allowed to flow through a match with predicate p in environment env. *)
let restrict_spec env spec p =
  if spec = Not_subterm then spec
  else let absctx, ar = dest_lam_assum env p in
  (* Optimization: if the predicate is not dependent, no restriction is needed
     and we avoid building the recargs tree. *)
  if noccur_with_meta 1 (Context.Rel.length absctx) ar then spec
  else
  let env = push_rel_context absctx env in
  let arctx, s = dest_prod_assum env ar in
  let env = push_rel_context arctx env in
  let i,args = decompose_app (whd_all env s) in
  match kind i with
  | Ind i -&gt;
     begin match spec with
	   | Dead_code -&gt; spec
	   | Subterm(st,tree) -&gt;
	      let recargs = get_recargs_approx env tree i args in
	      let recargs = inter_wf_paths tree recargs in
	      Subterm(st,recargs)
	   | _ -&gt; assert false
     end
  | _ -&gt; Not_subterm

(* [subterm_specif renv t] computes the recursive structure of [t] and
   compare its size with the size of the initial recursive argument of
   the fixpoint we are checking. [renv] collects such information
   about variables.
*)

let rec subterm_specif renv stack t =
  (* maybe reduction is not always necessary! *)
  let f,l = decompose_app (whd_all renv.env t) in
    match kind f with
    | Rel k -&gt; subterm_var k renv
    | Case (ci,p,c,lbr) -&gt;
       let stack' = push_stack_closures renv l stack in
       let cases_spec =
	 branches_specif renv (lazy_subterm_specif renv [] c) ci
       in
       let stl =
	 Array.mapi (fun i br' -&gt;
		     let stack_br = push_stack_args (cases_spec.(i)) stack' in
		     subterm_specif renv stack_br br')
		    lbr in
       let spec = subterm_spec_glb stl in
       restrict_spec renv.env spec p

    | Fix ((recindxs,i),(_,typarray,bodies as recdef)) -&gt;
      (* when proving that the fixpoint f(x)=e is less than n, it is enough
	 to prove that e is less than n assuming f is less than n
	 furthermore when f is applied to a term which is strictly less than
	 n, one may assume that x itself is strictly less than n
      *)
    if not (check_inductive_codomain renv.env typarray.(i)) then Not_subterm
    else 
      let (ctxt,clfix) = dest_prod renv.env typarray.(i) in	    
      let oind =
        let env' = push_rel_context ctxt renv.env in
          try Some(fst(find_inductive env' clfix))
          with Not_found -&gt; None in
        (match oind with
      None -&gt; Not_subterm (* happens if fix is polymorphic *)
        | Some (ind, _) -&gt;
	let nbfix = Array.length typarray in
	let recargs = lookup_subterms renv.env ind in
		   (* pushing the fixpoints *)
	let renv' = push_fix_renv renv recdef in
	let renv' =
                     (* Why Strict here ? To be general, it could also be
			Large... *)
          assign_var_spec renv'
	  (nbfix-i, lazy (Subterm(Strict,recargs))) in
	let decrArg = recindxs.(i) in
	let theBody = bodies.(i)   in
	let nbOfAbst = decrArg+1 in
	let sign,strippedBody = Term.decompose_lam_n_assum nbOfAbst theBody in
		   (* pushing the fix parameters *)
	let stack' = push_stack_closures renv l stack in
	let renv'' = push_ctxt_renv renv' sign in
	let renv'' =
          if List.length stack' &lt; nbOfAbst then renv''
          else
	    let decrArg = List.nth stack' decrArg in
            let arg_spec = stack_element_specif decrArg in
	      assign_var_spec renv'' (1, arg_spec) in
	  subterm_specif renv'' [] strippedBody)

    | Lambda (x,a,b) -&gt;
      let () = assert (List.is_empty l) in
      let spec,stack' = extract_stack stack in
	subterm_specif (push_var renv (x,a,spec)) stack' b

      (* Metas and evars are considered OK *)
    | (Meta _|Evar _) -&gt; Dead_code

    | Proj (p, c) -&gt; 
      let subt = subterm_specif renv stack c in
      (match subt with
       | Subterm (_s, wf) -&gt;
         (* We take the subterm specs of the constructor of the record *)
         let wf_args = (dest_subterms wf).(0) in
         (* We extract the tree of the projected argument *)
         let n = Projection.arg p in
         spec_of_tree (List.nth wf_args n)
       | Dead_code -&gt; Dead_code
       | Not_subterm -&gt; Not_subterm)

    | Var _ | Sort _ | Cast _ | Prod _ | LetIn _ | App _ | Const _ | Ind _
      | Construct _ | CoFix _ | Int _ -&gt; Not_subterm


      (* Other terms are not subterms *)

and lazy_subterm_specif renv stack t =
  lazy (subterm_specif renv stack t)

and stack_element_specif = function
  |SClosure (h_renv,h) -&gt; lazy_subterm_specif h_renv [] h
  |SArg x -&gt; x

and extract_stack = function
   | [] -&gt; Lazy.from_val Not_subterm , []
   | h::t -&gt; stack_element_specif h, t

(* Check term c can be applied to one of the mutual fixpoints. *)
let check_is_subterm x tree =
  match Lazy.force x with
  | Subterm (Strict,tree') -&gt; incl_wf_paths tree tree'
  | Dead_code -&gt; true
  |  _ -&gt; false

(************************************************************************)

exception FixGuardError of env * guard_error

let error_illegal_rec_call renv fx (arg_renv,arg) =
  let (_,le_vars,lt_vars) =
    List.fold_left
      (fun (i,le,lt) sbt -&gt;
        match Lazy.force sbt with
            (Subterm(Strict,_) | Dead_code) -&gt; (i+1, le, i::lt)
          | (Subterm(Large,_)) -&gt; (i+1, i::le, lt)
          | _ -&gt; (i+1, le ,lt))
      (1,[],[]) renv.genv in
  raise (FixGuardError (renv.env,
                        RecursionOnIllegalTerm(fx,(arg_renv.env, arg),
					       le_vars,lt_vars)))

let error_partial_apply renv fx =
  raise (FixGuardError (renv.env,NotEnoughArgumentsForFixCall fx))

let filter_stack_domain env p stack =
  let absctx, ar = dest_lam_assum env p in
  (* Optimization: if the predicate is not dependent, no restriction is needed
     and we avoid building the recargs tree. *)
  if noccur_with_meta 1 (Context.Rel.length absctx) ar then stack
  else let env = push_rel_context absctx env in
  let rec filter_stack env ar stack =
    let t = whd_all env ar in
    match stack, kind t with
    | elt :: stack', Prod (n,a,c0) -&gt;
      let d = LocalAssum (n,a) in
      let ctx, a = dest_prod_assum env a in
      let env = push_rel_context ctx env in
      let ty, args = decompose_app (whd_all env a) in
      let elt = match kind ty with
      | Ind ind -&gt; 
        let spec' = stack_element_specif elt in
        (match (Lazy.force spec') with
        | Not_subterm | Dead_code -&gt; elt
        | Subterm(s,path) -&gt;
            let recargs = get_recargs_approx env path ind args in
            let path = inter_wf_paths path recargs in
            SArg (lazy (Subterm(s,path))))
      | _ -&gt; (SArg (lazy Not_subterm))
      in
      elt :: filter_stack (push_rel d env) c0 stack'
    | _,_ -&gt; List.fold_right (fun _ l -&gt; SArg (lazy Not_subterm) :: l) stack []
  in
  filter_stack env ar stack

(* Check if [def] is a guarded fixpoint body with decreasing arg.
   given [recpos], the decreasing arguments of each mutually defined
   fixpoint. *)
let check_one_fix renv recpos trees def =
  let nfi = Array.length recpos in

  (* Checks if [t] only make valid recursive calls 
     [stack] is the list of constructor's argument specification and 
     arguments that will be applied after reduction.
     example u in t where we have (match .. with |.. =&gt; t end) u *)
  let rec check_rec_call renv stack t =
    (* if [t] does not make recursive calls, it is guarded: *)
    if noccur_with_meta renv.rel_min nfi t then ()
    else
      let (f,l) = decompose_app (whd_betaiotazeta renv.env t) in
      match kind f with
        | Rel p -&gt;
            (* Test if [p] is a fixpoint (recursive call) *)
	    if renv.rel_min &lt;= p &amp;&amp; p &lt; renv.rel_min+nfi then
              begin
                List.iter (check_rec_call renv []) l;
                (* the position of the invoked fixpoint: *)
	        let glob = renv.rel_min+nfi-1-p in
                (* the decreasing arg of the rec call: *)
	        let np = recpos.(glob) in
		let stack' = push_stack_closures renv l stack in
                if List.length stack' &lt;= np then error_partial_apply renv glob
                else
		  (* Retrieve the expected tree for the argument *)
                  (* Check the decreasing arg is smaller *)
                  let z = List.nth stack' np in
	          if not (check_is_subterm (stack_element_specif z) trees.(glob)) then
                    begin match z with
		      |SClosure (z,z') -&gt; error_illegal_rec_call renv glob (z,z') 
		      |SArg _ -&gt; error_partial_apply renv glob
		    end
              end
            else
              begin
                match lookup_rel p renv.env with
                | LocalAssum _ -&gt;
                    List.iter (check_rec_call renv []) l
                | LocalDef (_,c,_) -&gt;
                    try List.iter (check_rec_call renv []) l
                    with FixGuardError _ -&gt;
                      check_rec_call renv stack (Term.applist(lift p c,l))
              end
		
        | Case (ci,p,c_0,lrest) -&gt;
            begin try
              List.iter (check_rec_call renv []) (c_0::p::l);
              (* compute the recarg info for the arguments of each branch *)
              let case_spec =
                branches_specif renv (lazy_subterm_specif renv [] c_0) ci in
              let stack' = push_stack_closures renv l stack in
              let stack' = filter_stack_domain renv.env p stack' in
              lrest |&gt; Array.iteri (fun k br' -&gt;
                let stack_br = push_stack_args case_spec.(k) stack' in
                check_rec_call renv stack_br br')
            with (FixGuardError _ as exn) -&gt;
              let exn = CErrors.push exn in
              (* we try hard to reduce the match away by looking for a
                 constructor in c_0 (we unfold definitions too) *)
              let c_0 = whd_all renv.env c_0 in
              let hd, _ = decompose_app c_0 in
              match kind hd with
              | Construct _ -&gt;
                  (* the call to whd_betaiotazeta will reduce the
                     apparent iota redex away *)
                  check_rec_call renv []
                    (Term.applist (mkCase (ci,p,c_0,lrest), l))
              | _ -&gt; Exninfo.iraise exn
            end

        (* Enables to traverse Fixpoint definitions in a more intelligent
           way, ie, the rule :
           if - g = fix g (y1:T1)...(yp:Tp) {struct yp} := e &amp;
              - f is guarded with respect to the set of pattern variables S
                in a1 ... am        &amp;
              - f is guarded with respect to the set of pattern variables S
                in T1 ... Tp        &amp;
              - ap is a sub-term of the formal argument of f &amp;
              - f is guarded with respect to the set of pattern variables
                S+{yp} in e
           then f is guarded with respect to S in (g a1 ... am).
           Eduardo 7/9/98 *)
        | Fix ((recindxs,i),(_,typarray,bodies as recdef)) -&gt;
            let decrArg = recindxs.(i) in
            begin try
              List.iter (check_rec_call renv []) l;
              Array.iter (check_rec_call renv []) typarray;
              let renv' = push_fix_renv renv recdef in
              let stack' = push_stack_closures renv l stack in
              bodies |&gt; Array.iteri (fun j body -&gt;
                if Int.equal i j &amp;&amp; (List.length stack' &gt; decrArg) then
                  let recArg = List.nth stack' decrArg in
                  let arg_sp = stack_element_specif recArg in
                  check_nested_fix_body renv' (decrArg+1) arg_sp body
                else check_rec_call renv' [] body)
            with (FixGuardError _ as exn) -&gt;
              let exn = CErrors.push exn in
              (* we try hard to reduce the fix away by looking for a
                 constructor in l[decrArg] (we unfold definitions too) *)
              if List.length l &lt;= decrArg then Exninfo.iraise exn;
              let recArg = List.nth l decrArg in
              let recArg = whd_all renv.env recArg in
              let hd, _ = decompose_app recArg in
              match kind hd with
              | Construct _ -&gt;
                  let before, after = CList.(firstn decrArg l, skipn (decrArg+1) l) in
                  check_rec_call renv []
                    (Term.applist (mkFix ((recindxs,i),recdef), (before @ recArg :: after)))
              | _ -&gt; Exninfo.iraise exn
            end

        | Const (kn,_u as cu) -&gt;
            if evaluable_constant kn renv.env then
              try List.iter (check_rec_call renv []) l
              with (FixGuardError _ ) -&gt;
		let value = (Term.applist(constant_value_in renv.env cu, l)) in
	        check_rec_call renv stack value
	    else List.iter (check_rec_call renv []) l

        | Lambda (x,a,b) -&gt;
            let () = assert (List.is_empty l) in
	    check_rec_call renv [] a ;
            let spec, stack' = extract_stack stack in
	    check_rec_call (push_var renv (x,a,spec)) stack' b

        | Prod (x,a,b) -&gt;
            let () = assert (List.is_empty l &amp;&amp; List.is_empty stack) in
            check_rec_call renv [] a;
            check_rec_call (push_var_renv renv (x,a)) [] b

        | CoFix (_i,(_,typarray,bodies as recdef)) -&gt;
            List.iter (check_rec_call renv []) l;
	    Array.iter (check_rec_call renv []) typarray;
	    let renv' = push_fix_renv renv recdef in
	    Array.iter (check_rec_call renv' []) bodies

        | (Ind _ | Construct _) -&gt;
            List.iter (check_rec_call renv []) l

        | Proj (p, c) -&gt;
            begin try
              List.iter (check_rec_call renv []) l;
              check_rec_call renv [] c
            with (FixGuardError _ as exn) -&gt;
              let exn = CErrors.push exn in
              (* we try hard to reduce the proj away by looking for a
                 constructor in c (we unfold definitions too) *)
              let c = whd_all renv.env c in
              let hd, _ = decompose_app c in
              match kind hd with
              | Construct _ -&gt;
                  check_rec_call renv []
                    (Term.applist (mkProj(Projection.unfold p,c), l))
              | _ -&gt; Exninfo.iraise exn
            end

        | Var id -&gt;
            begin
              let open! Context.Named.Declaration in
              match lookup_named id renv.env with
              | LocalAssum _ -&gt;
                  List.iter (check_rec_call renv []) l
              | LocalDef (_,c,_) -&gt;
                  try List.iter (check_rec_call renv []) l
                  with (FixGuardError _) -&gt; 
		    check_rec_call renv stack (Term.applist(c,l))
            end

        | Sort _ | Int _ -&gt;
          assert (List.is_empty l)

        (* l is not checked because it is considered as the meta's context *)
        | (Evar _ | Meta _) -&gt; ()

        | (App _ | LetIn _ | Cast _) -&gt; assert false (* beta zeta reduction *)

  and check_nested_fix_body renv decr recArgsDecrArg body =
    if Int.equal decr 0 then
      check_rec_call (assign_var_spec renv (1,recArgsDecrArg)) [] body
    else
      match kind body with
        | Lambda (x,a,b) -&gt;
	    check_rec_call renv [] a;
            let renv' = push_var_renv renv (x,a) in
	      check_nested_fix_body renv' (decr-1) recArgsDecrArg b
	| _ -&gt; anomaly (Pp.str &quot;Not enough abstractions in fix body.&quot;)
	    
  in
  check_rec_call renv [] def

let judgment_of_fixpoint (_, types, bodies) =
  Array.map2 (fun typ body -&gt; { uj_val = body ; uj_type = typ }) types bodies

let inductive_of_mutfix env ((nvect,bodynum),(names,types,bodies as recdef)) =
  let nbfix = Array.length bodies in
  if Int.equal nbfix 0
    || not (Int.equal (Array.length nvect) nbfix)
    || not (Int.equal (Array.length types) nbfix)
    || not (Int.equal (Array.length names) nbfix)
    || bodynum &lt; 0
    || bodynum &gt;= nbfix
  then anomaly (Pp.str &quot;Ill-formed fix term.&quot;);
  let fixenv = push_rec_types recdef env in
  let vdefj = judgment_of_fixpoint recdef in
  let raise_err env i err =
    error_ill_formed_rec_body env err names i fixenv vdefj in
  (* Check the i-th definition with recarg k *)
  let find_ind i k def =
    (* check fi does not appear in the k+1 first abstractions,
       gives the type of the k+1-eme abstraction (must be an inductive)  *)
    let rec check_occur env n def =
      match kind (whd_all env def) with
        | Lambda (x,a,b) -&gt;
	    if noccur_with_meta n nbfix a then
              let env' = push_rel (LocalAssum (x,a)) env in
              if Int.equal n (k + 1) then
                (* get the inductive type of the fixpoint *)
                let (mind, _) =
                  try find_inductive env a
                  with Not_found -&gt;
		    raise_err env i (RecursionNotOnInductiveType a) in
                let mib,_ = lookup_mind_specif env (out_punivs mind) in
                if mib.mind_finite != Finite then
                  raise_err env i (RecursionNotOnInductiveType a);
                (mind, (env', b))
	      else check_occur env' (n+1) b
            else anomaly ~label:&quot;check_one_fix&quot; (Pp.str &quot;Bad occurrence of recursive call.&quot;)
        | _ -&gt; raise_err env i NotEnoughAbstractionInFixBody
    in
    let ((ind, _), _) as res = check_occur fixenv 1 def in
    let _, ind = lookup_mind_specif env ind in
    (* recursive sprop means non record with projections -&gt; squashed *)
    if Sorts.Irrelevant == ind.mind_relevance
    then
      begin
        if names.(i).Context.binder_relevance == Sorts.Relevant
        then raise_err env i FixpointOnIrrelevantInductive
      end;
    res
  in
  (* Do it on every fixpoint *)
  let rv = Array.map2_i find_ind nvect bodies in
  (Array.map fst rv, Array.map snd rv)


let check_fix env ((nvect,_),(names,_,bodies as recdef) as fix) =
  let flags = Environ.typing_flags env in
  if flags.check_guarded then
    let (minds, rdef) = inductive_of_mutfix env fix in
    let get_tree (kn,i) =
      let mib = Environ.lookup_mind kn env in
      mib.mind_packets.(i).mind_recargs
    in
    let trees = Array.map (fun (mind,_) -&gt; get_tree mind) minds in
    for i = 0 to Array.length bodies - 1 do
      let (fenv,body) = rdef.(i) in
      let renv = make_renv fenv nvect.(i) trees.(i) in
      try check_one_fix renv nvect trees body
      with FixGuardError (fixenv,err) -&gt;
        error_ill_formed_rec_body fixenv err names i
	  (push_rec_types recdef env) (judgment_of_fixpoint recdef)
    done
  else
    ()

(*
let cfkey = CProfile.declare_profile &quot;check_fix&quot;;;
let check_fix env fix = CProfile.profile3 cfkey check_fix env fix;;
*)

(************************************************************************)
(* Co-fixpoints. *)

exception CoFixGuardError of env * guard_error

let anomaly_ill_typed () =
  anomaly ~label:&quot;check_one_cofix&quot; (Pp.str &quot;too many arguments applied to constructor.&quot;)

let rec codomain_is_coind env c =
  let b = whd_all env c in
  match kind b with
    | Prod (x,a,b) -&gt;
        codomain_is_coind (push_rel (LocalAssum (x,a)) env) b
    | _ -&gt;
	(try find_coinductive env b
        with Not_found -&gt;
	  raise (CoFixGuardError (env, CodomainNotInductiveType b)))

let check_one_cofix env nbfix def deftype =
  let rec check_rec_call env alreadygrd n tree vlra  t =
    if not (noccur_with_meta n nbfix t) then
      let c,args = decompose_app (whd_all env t) in
      match kind c with
	| Rel p when  n &lt;= p &amp;&amp; p &lt; n+nbfix -&gt;
	    (* recursive call: must be guarded and no nested recursive
               call allowed *)
            if not alreadygrd then
	      raise (CoFixGuardError (env,UnguardedRecursiveCall t))
            else if not(List.for_all (noccur_with_meta n nbfix) args) then
	      raise (CoFixGuardError (env,NestedRecursiveOccurrences))
        | Construct ((_,i as cstr_kn),_u)  -&gt;
            let lra = vlra.(i-1) in
            let mI = inductive_of_constructor cstr_kn in
            let (mib,_mip) = lookup_mind_specif env mI in
            let realargs = List.skipn mib.mind_nparams args in
            let rec process_args_of_constr = function
              | (t::lr), (rar::lrar) -&gt;
                  if eq_wf_paths rar mk_norec then
                    if noccur_with_meta n nbfix t
                    then process_args_of_constr (lr, lrar)
                    else raise (CoFixGuardError
		                 (env,RecCallInNonRecArgOfConstructor t))
                  else begin
                      check_rec_call env true n rar (dest_subterms rar) t;
                      process_args_of_constr (lr, lrar)
		    end
              | [],_ -&gt; ()
              | _ -&gt; anomaly_ill_typed ()
            in process_args_of_constr (realargs, lra)

        | Lambda (x,a,b) -&gt;
	    let () = assert (List.is_empty args) in
            if noccur_with_meta n nbfix a then
              let env' = push_rel (LocalAssum (x,a)) env in
              check_rec_call env' alreadygrd (n+1) tree vlra b
            else
	      raise (CoFixGuardError (env,RecCallInTypeOfAbstraction a))

        | CoFix (_j,(_,varit,vdefs as recdef)) -&gt;
            if List.for_all (noccur_with_meta n nbfix) args
            then
	      if Array.for_all (noccur_with_meta n nbfix) varit then
		let nbfix = Array.length vdefs in
		let env' = push_rec_types recdef env in
		(Array.iter (check_rec_call env' alreadygrd (n+nbfix) tree vlra) vdefs;
		 List.iter (check_rec_call env alreadygrd n tree vlra) args)
              else
		raise (CoFixGuardError (env,RecCallInTypeOfDef c))
	    else
	      raise (CoFixGuardError (env,UnguardedRecursiveCall c))

	| Case (_,p,tm,vrest) -&gt;
	   begin
	     let tree = match restrict_spec env (Subterm (Strict, tree)) p with
	     | Dead_code -&gt; assert false
	     | Subterm (_, tree') -&gt; tree'
	     | _ -&gt; raise (CoFixGuardError (env, ReturnPredicateNotCoInductive c))
	     in
               if (noccur_with_meta n nbfix p) then
		 if (noccur_with_meta n nbfix tm) then
		   if (List.for_all (noccur_with_meta n nbfix) args) then
		     let vlra = dest_subterms tree in
		     Array.iter (check_rec_call env alreadygrd n tree vlra) vrest
		   else
		     raise (CoFixGuardError (env,RecCallInCaseFun c))
		 else
		   raise (CoFixGuardError (env,RecCallInCaseArg c))
               else
		 raise (CoFixGuardError (env,RecCallInCasePred c))
	   end

	| Meta _ -&gt; ()
        | Evar _ -&gt;
	    List.iter (check_rec_call env alreadygrd n tree vlra) args
        | Rel _ | Var _ | Sort _ | Cast _ | Prod _ | LetIn _ | App _ | Const _
          | Ind _ | Fix _ | Proj _ | Int _ -&gt;
           raise (CoFixGuardError (env,NotGuardedForm t)) in

  let ((mind, _),_) = codomain_is_coind env deftype in
  let vlra = lookup_subterms env mind in
  check_rec_call env false 1 vlra (dest_subterms vlra) def

(* The  function which checks that the whole block of definitions
   satisfies the guarded condition *)

let check_cofix env (_bodynum,(names,types,bodies as recdef)) =
  let flags = Environ.typing_flags env in
  if flags.check_guarded then
    let nbfix = Array.length bodies in
    for i = 0 to nbfix-1 do
      let fixenv = push_rec_types recdef env in
      try check_one_cofix fixenv nbfix bodies.(i) types.(i)
      with CoFixGuardError (errenv,err) -&gt;
        error_ill_formed_rec_body errenv err names i
	  fixenv (judgment_of_fixpoint recdef)
    done
  else
    ()
</pre>
          </div>
          <div class="col-md-6">
            <code>inductive.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import CErrors.

Import Util.

Import Names.

Import Univ.

Import Constr.

Import Vars.

Import Declarations.

Import Declareops.

Import Environ.

Import Reduction.

Import Type_errors.

Import Context.Rel.Declaration.

Definition mind_specif :=
  Declarations.mutual_inductive_body * Declarations.one_inductive_body.

Definition lookup_mind_specif
  (env : Environ.env) (function_parameter : Names.MutInd.t * Z)
  : Declarations.mutual_inductive_body * Declarations.one_inductive_body :=
  match function_parameter with
  | (kn, tyi) =&gt;
    let mib := Environ.lookup_mind kn env in
    if OCaml.Stdlib.ge tyi (Util.Array.(CArray.ExtS.length) (mind_packets mib))
      then
      CErrors.user_err None None
        (Pp.str &quot;Inductive.lookup_mind_specif: invalid inductive index&quot; % string)
    else
      tt;
    (mib, (Util.Array.(CArray.ExtS.get) (mind_packets mib) tyi))
  end.

Definition find_rectype (env : Environ.env) (c : Constr.constr)
  : (Names.inductive * Univ.Instance.t) * (list Constr.constr) :=
  match Constr.decompose_app (Reduction.whd_all env c) with
  | (t, l) =&gt;
    match Constr.kind t with
    | Ind ind =&gt; (ind, l)
    | _ =&gt; Stdlib.raise OCaml.Not_found
    end
  end.

Definition find_inductive (env : Environ.env) (c : Constr.constr)
  : (Names.inductive * Univ.Instance.t) * (list Constr.constr) :=
  match Constr.decompose_app (Reduction.whd_all env c) with
  | (t, l) =&gt;
    match Constr.kind t with
    | _ =&gt; Stdlib.raise OCaml.Not_found
    end
  end.

Definition find_coinductive (env : Environ.env) (c : Constr.constr)
  : (Names.inductive * Univ.Instance.t) * (list Constr.constr) :=
  match Constr.decompose_app (Reduction.whd_all env c) with
  | (t, l) =&gt;
    match Constr.kind t with
    | _ =&gt; Stdlib.raise OCaml.Not_found
    end
  end.

Definition inductive_params {A : Type}
  (function_parameter : Declarations.mutual_inductive_body * A) : Z :=
  match function_parameter with
  | (mib, _) =&gt; mind_nparams mib
  end.

Definition inductive_paramdecls
  (function_parameter : Declarations.mutual_inductive_body * Univ.Instance.t)
  : Constr.rel_context :=
  match function_parameter with
  | (mib, u) =&gt; Vars.subst_instance_context u (mind_params_ctxt mib)
  end.

Definition instantiate_inductive_constraints
  (mib : Declarations.mutual_inductive_body) (u : Univ.Instance.t)
  : Univ.Constraint.t :=
  Univ.AUContext.instantiate u (Declareops.inductive_polymorphic_context mib).

Definition ind_subst
  (mind : Names.MutInd.t) (mib : Declarations.mutual_inductive_body)
  (u : Univ.Instance.t) : list Constr.constr :=
  let ntypes := mind_ntypes mib in
  let make_Ik (k : Z) : Constr.constr :=
    Constr.mkIndU ((mind, (Util.op_minus (Util.op_minus ntypes k) 1)), u) in
  Util.List.(CList.ExtS.init) ntypes make_Ik.

Definition constructor_instantiate
  (mind : Names.MutInd.t) (u : Univ.Instance.t)
  (mib : Declarations.mutual_inductive_body) (c : Constr.constr)
  : Constr.constr :=
  let s := ind_subst mind mib u in
  Vars.substl s (Vars.subst_instance_constr u c).

Definition instantiate_params {A : Type}
  (full : bool) (t : Constr.constr) (u : Univ.Instance.t)
  (args : list Constr.constr) (sign : Context.Rel.pt Constr.constr A)
  : Constr.constr :=
  let fail {B : Type} (function_parameter : unit) : B :=
    match function_parameter with
    | tt =&gt;
      CErrors.anomaly None (Some &quot;instantiate_params&quot; % string)
        (Pp.str &quot;type, ctxt and args mismatch.&quot; % string)
    end in
  match
    Context.Rel.fold_outside
      (fun decl =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | (largs, subs, ty) =&gt;
            match (decl, largs, (Constr.kind ty)) with
            | (LocalAssum _ _, cons a args, Prod _ _ t) =&gt;
              (args, (cons a subs), t)
            | (LocalDef _ b _, _, LetIn _ _ _ t) =&gt;
              (largs,
                (cons (Vars.substl subs (Vars.subst_instance_constr u b)) subs),
                t)
            | (_, [], _) =&gt;
              if full then
                fail tt
              else
                ([], subs, ty)
            | _ =&gt; fail tt
            end
          end) sign (args, [], t) with
  | (rem_args, subs, ty) =&gt;
    match
      if negb (Util.List.(CList.ExtS.is_empty) rem_args) then
        fail tt
      else
        tt with
    | tt =&gt; Vars.substl subs ty
    end
  end.

Definition full_inductive_instantiate
  (mib : Declarations.mutual_inductive_body) (u : Univ.Instance.t)
  (params : list Constr.constr) (sign : Constr.rel_context)
  : Constr.rel_context :=
  let dummy := Sorts.prop in
  let t := Term.mkArity ((Vars.subst_instance_context u sign), dummy) in
  fst
    (Term.destArity (instantiate_params true t u params (mind_params_ctxt mib))).

Definition full_constructor_instantiate {A B : Type}
  (function_parameter :
    (Names.MutInd.t * A) * Univ.Instance.t *
      (Declarations.mutual_inductive_body * B) * (list Constr.constr))
  : Constr.constr -&gt; Constr.constr :=
  match function_parameter with
  | ((mind, _), u, (mib, _), params) =&gt;
    fun t =&gt;
      let inst_ind := constructor_instantiate mind u mib t in
      instantiate_params true inst_ind u params (mind_params_ctxt mib)
  end.

Definition cons_subst
  (u : Univ.LMap.key) (su : Univ.Universe.t)
  (subst : Univ.LMap.t Univ.Universe.t) : Univ.LMap.t Univ.Universe.t := try.

Definition remember_subst
  (u : Univ.LMap.key) (subst : Univ.LMap.t Univ.Universe.t)
  : Univ.LMap.t Univ.Universe.t := try.

Definition make_subst {A B : Type} (env : Environ.env)
  : ((list (Context.Rel.Declaration.pt A B)) * (list (option Univ.LMap.key)) *
    (list (Stdlib.Lazy.t Constr.types))) -&gt; Univ.LMap.t Univ.Universe.t :=
  let fix make {C D : Type}
    (subst : Univ.LMap.t Univ.Universe.t) (function_parameter :
    (list (Context.Rel.Declaration.pt C D)) * (list (option Univ.LMap.key)) *
      (list (Stdlib.Lazy.t Constr.types))) : Univ.LMap.t Univ.Universe.t :=
    match function_parameter with
    | (cons (LocalDef _ _ _) sign, exp, args) =&gt; make subst (sign, exp, args)
    | (cons _d sign, cons None exp, args) =&gt;
      let args :=
        match args with
        | cons _ args =&gt; args
        | [] =&gt; []
        end in
      make subst (sign, exp, args)
    | (cons _d sign, cons (Some u) exp, cons a args) =&gt;
      let s :=
        Sorts.univ_of_sort
          (snd (Reduction.dest_arity env (Stdlib.Lazy.force a))) in
      make (cons_subst u s subst) (sign, exp, args)
    | (cons (LocalAssum _na _t) sign, cons (Some u) exp, []) =&gt;
      make (remember_subst u subst) (sign, exp, [])
    | (_sign, [], _) =&gt; subst
    | ([], _, _) =&gt; false
    end in
  make Univ.LMap.empty.

Definition instantiate_universes {A B : Type}
  (env : Environ.env) (ctx : list (Context.Rel.Declaration.pt A B))
  (ar : Declarations.template_arity)
  (argsorts : array (Stdlib.Lazy.t Constr.types))
  : (list (Context.Rel.Declaration.pt A B)) * Sorts.t :=
  let args := Util.Array.(CArray.ExtS.to_list) argsorts in
  let subst := make_subst env (ctx, (template_param_levels ar), args) in
  let level :=
    Univ.subst_univs_universe (Univ.make_subst subst) (template_level ar) in
  let ty :=
    if Univ.is_type0m_univ level then
      Sorts.prop
    else
      if Univ.is_type0_univ level then
        Sorts.set
      else
        Sorts.sort_of_univ level in
  (ctx, ty).

Definition relevance_of_inductive (env : Environ.env) (ind : Names.MutInd.t * Z)
  : Sorts.relevance :=
  match lookup_mind_specif env ind with
  | (_, mip) =&gt; mind_relevance mip
  end.

Definition type_of_inductive_gen {A : Type} (op_star_o_p_t_star : option bool)
  : Environ.env -&gt;
    ((A * Declarations.one_inductive_body) * Univ.Instance.t) -&gt;
      (array (Stdlib.Lazy.t Constr.types)) -&gt; Constr.constr :=
  let polyprop :=
    match op_star_o_p_t_star with
    | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
    | None =&gt; true
    end in
  fun env =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | ((_, mip), u) =&gt;
        fun paramtyps =&gt;
          match mind_arity mip with
          | RegularArity a =&gt; Vars.subst_instance_constr u (mind_user_arity a)
          | TemplateArity ar =&gt;
            let ctx := Util.List.(CList.ExtS.rev) (mind_arity_ctxt mip) in
            match instantiate_universes env ctx ar paramtyps with
            | (ctx, s) =&gt;
              if
                andb (negb polyprop)
                  (andb (negb (Univ.is_type0m_univ (template_level ar)))
                    (Sorts.is_prop s)) then
                Stdlib.raise (SingletonInductiveBecomesProp (mind_typename mip))
              else
                tt;
              Term.mkArity ((Util.List.(CList.ExtS.rev) ctx), s)
            end
          end
      end.

Definition type_of_inductive {A : Type}
  (env : Environ.env)
  (pind : (A * Declarations.one_inductive_body) * Univ.Instance.t)
  : Constr.constr := type_of_inductive_gen None env pind tt.

Definition constrained_type_of_inductive
  (env : Environ.env)
  (function_parameter :
    (Declarations.mutual_inductive_body * Declarations.one_inductive_body) *
      Univ.Instance.t) : Constr.constr * Univ.Constraint.t :=
  match function_parameter with
  | ((mib, _mip), u) as pind =&gt;
    let ty := type_of_inductive env pind in
    let cst := instantiate_inductive_constraints mib u in
    (ty, cst)
  end.

Definition constrained_type_of_inductive_knowing_parameters
  (env : Environ.env)
  (function_parameter :
    (Declarations.mutual_inductive_body * Declarations.one_inductive_body) *
      Univ.Instance.t)
  : (array (Stdlib.Lazy.t Constr.types)) -&gt; Constr.constr * Univ.Constraint.t :=
  match function_parameter with
  | ((mib, _mip), u) as pind =&gt;
    fun args =&gt;
      let ty := type_of_inductive_gen None env pind args in
      let cst := instantiate_inductive_constraints mib u in
      (ty, cst)
  end.

Definition type_of_inductive_knowing_parameters {A : Type}
  (env : Environ.env) (op_star_o_p_t_star : option bool)
  : ((A * Declarations.one_inductive_body) * Univ.Instance.t) -&gt;
    (array (Stdlib.Lazy.t Constr.types)) -&gt; Constr.constr :=
  let polyprop :=
    match op_star_o_p_t_star with
    | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
    | None =&gt; true
    end in
  fun mip =&gt; fun args =&gt; type_of_inductive_gen (Some polyprop) env mip args.

Definition cumulate_constructor_univ
  (u : Univ.Universe.t) (function_parameter : Sorts.t) : Univ.Universe.t :=
  match function_parameter with
  | SProp | Prop =&gt; u
  | Set =&gt; Univ.Universe.sup Univ.Universe.type0 u
  | Type u' =&gt; Univ.Universe.sup u u'
  end.

Definition max_inductive_sort : (array Sorts.t) -&gt; Univ.Universe.t :=
  Util.Array.(CArray.ExtS.fold_left) cumulate_constructor_univ
    Univ.Universe.type0m.

Definition type_of_constructor
  (function_parameter : Names.constructor * Univ.Instance.t)
  : (Declarations.mutual_inductive_body * Declarations.one_inductive_body) -&gt;
    Constr.constr :=
  match function_parameter with
  | (cstr, u) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (mib, mip) =&gt;
        let ind := Names.inductive_of_constructor cstr in
        let specif := mind_user_lc mip in
        let i := Names.index_of_constructor cstr in
        let nconstr := Util.Array.(CArray.ExtS.length) (mind_consnames mip) in
        if OCaml.Stdlib.gt i nconstr then
          CErrors.user_err None None
            (Pp.str &quot;Not enough constructors in the type.&quot; % string)
        else
          tt;
        constructor_instantiate (fst ind) u mib
          (Util.Array.(CArray.ExtS.get) specif (Util.op_minus i 1))
      end
  end.

Definition constrained_type_of_constructor
  (function_parameter : Names.constructor * Univ.Instance.t)
  : (Declarations.mutual_inductive_body * Declarations.one_inductive_body) -&gt;
    Constr.constr * Univ.Constraint.t :=
  match function_parameter with
  | (_cstr, u) as cstru =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (mib, _mip) as ind =&gt;
        let ty := type_of_constructor cstru ind in
        let cst := instantiate_inductive_constraints mib u in
        (ty, cst)
      end
  end.

Definition arities_of_specif
  (function_parameter : Names.MutInd.t * Univ.Instance.t)
  : (Declarations.mutual_inductive_body * Declarations.one_inductive_body) -&gt;
    array Constr.constr :=
  match function_parameter with
  | (kn, u) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (mib, mip) =&gt;
        let specif := mind_nf_lc mip in
        let map (function_parameter : Constr.rel_context * Constr.types)
          : Constr.constr :=
          match function_parameter with
          | (ctx, c) =&gt;
            let cty := Term.it_mkProd_or_LetIn c ctx in
            constructor_instantiate kn u mib cty
          end in
        Util.Array.(CArray.ExtS.map) map specif
      end
  end.

Definition arities_of_constructors {A : Type}
  (ind : (Names.MutInd.t * A) * Univ.Instance.t)
  (specif : Declarations.mutual_inductive_body * Declarations.one_inductive_body)
  : array Constr.constr := arities_of_specif ((fst (fst ind)), (snd ind)) specif.

Definition type_of_constructors {A : Type}
  (function_parameter : (Names.MutInd.t * A) * Univ.Instance.t)
  : (Declarations.mutual_inductive_body * Declarations.one_inductive_body) -&gt;
    array Constr.constr :=
  match function_parameter with
  | (ind, u) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (mib, mip) =&gt;
        let specif := mind_user_lc mip in
        Util.Array.(CArray.ExtS.map) (constructor_instantiate (fst ind) u mib)
          specif
      end
  end.

Definition inductive_sort_family (mip : Declarations.one_inductive_body)
  : Sorts.family :=
  match mind_arity mip with
  | RegularArity s =&gt; Sorts.family (mind_sort s)
  | TemplateArity _ =&gt; Sorts.InType
  end.

Definition mind_arity (mip : Declarations.one_inductive_body)
  : Constr.rel_context * Sorts.family :=
  ((mind_arity_ctxt mip), (inductive_sort_family mip)).

Definition get_instantiated_arity {A : Type}
  (function_parameter : A * Univ.Instance.t)
  : (Declarations.mutual_inductive_body * Declarations.one_inductive_body) -&gt;
    (list Constr.constr) -&gt; Constr.rel_context * Sorts.family :=
  match function_parameter with
  | (_ind, u) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (mib, mip) =&gt;
        fun params =&gt;
          match mind_arity mip with
          | (sign, s) =&gt; ((full_inductive_instantiate mib u params sign), s)
          end
      end
  end.

Definition elim_sort {A : Type}
  (function_parameter : A * Declarations.one_inductive_body) : Sorts.family :=
  match function_parameter with
  | (_, mip) =&gt; mind_kelim mip
  end.

Definition is_private {A : Type}
  (function_parameter : Declarations.mutual_inductive_body * A) : bool :=
  match function_parameter with
  | (mib, _) =&gt; equiv_decb (mind_private mib) (Some true)
  end.

Definition is_primitive_record {A : Type}
  (function_parameter : Declarations.mutual_inductive_body * A) : bool :=
  match function_parameter with
  | (mib, _) =&gt;
    match mind_record mib with
    | PrimRecord _ =&gt; true
    | NotRecord | FakeRecord =&gt; false
    end
  end.

Definition build_dependent_inductive {A : Type}
  (ind : Constr.pinductive)
  (function_parameter : A * Declarations.one_inductive_body)
  : (list Constr.constr) -&gt; Constr.constr :=
  match function_parameter with
  | (_, mip) =&gt;
    fun params =&gt;
      match
        Util.List.(CList.ExtS.chop) (mind_nrealdecls mip) (mind_arity_ctxt mip)
        with
      | (realargs, _) =&gt;
        Term.applist
          ((Constr.mkIndU ind),
            (Util.op_at
              (Util.List.(CList.ExtS.map) (Vars.lift (mind_nrealdecls mip))
                params) (Context.Rel.to_extended_list Constr.mkRel 0 realargs)))
      end
  end.

Definition check_allowed_sort {A : Type}
  (ksort : Sorts.family) (specif : A * Declarations.one_inductive_body)
  : unit :=
  if negb (Sorts.family_leq ksort (elim_sort specif)) then
    let s := inductive_sort_family (snd specif) in
    Stdlib.raise
      (LocalArity
        (Some
          ((elim_sort specif), ksort, s,
            (Type_errors.error_elim_explain ksort s))))
  else
    tt.

Definition is_correct_arity
  (env : Environ.env) (c : Constr.constr)
  (pj : Environ.punsafe_judgment Constr.constr Constr.constr)
  (ind : Names.inductive * Univ.Instance.t)
  (specif : Declarations.mutual_inductive_body * Declarations.one_inductive_body)
  (params : list Constr.constr) : unit :=
  match get_instantiated_arity ind specif params with
  | (arsign, _) =&gt;
    let fix srec
      (env : Environ.env) (pt : Constr.constr) (ar :
      list (Context.Rel.Declaration.pt Constr.constr Constr.constr)) : unit :=
      let pt' := Reduction.whd_all env pt in
      match ((Constr.kind pt'), ar) with
      | (Prod na1 a1 t, cons (LocalAssum _ a1') ar') =&gt;
        match try with
        | tt =&gt; srec (Environ.push_rel (LocalAssum na1 a1) env) t ar'
        end
      | (Prod na1 a1 a2, []) =&gt;
        let env' := Environ.push_rel (LocalAssum na1 a1) env in
        let ksort :=
          match Constr.kind (Reduction.whd_all env' a2) with
          | Sort s =&gt; Sorts.family s
          | _ =&gt; Stdlib.raise (LocalArity None)
          end in
        let dep_ind := build_dependent_inductive ind specif params in
        match try with
        | _ =&gt; check_allowed_sort ksort specif
        end
      | (_, cons ((LocalDef _ _ _) as d) ar') =&gt;
        srec (Environ.push_rel d env) (Vars.lift 1 pt') ar'
      | _ =&gt; Stdlib.raise (LocalArity None)
      end in
    try
  end.

Definition build_branches_type
  (function_parameter : Names.inductive * Univ.Instance.t)
  : (Declarations.mutual_inductive_body * Declarations.one_inductive_body) -&gt;
    (list Constr.constr) -&gt; Constr.constr -&gt; array Constr.types :=
  match function_parameter with
  | (ind, u) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (_, mip) as specif =&gt;
        fun params =&gt;
          fun p =&gt;
            let build_one_branch
              (i : Z) (function_parameter : Constr.rel_context * Constr.types)
              : Constr.types :=
              match function_parameter with
              | (ctx, c) =&gt;
                let cty := Term.it_mkProd_or_LetIn c ctx in
                let typi :=
                  full_constructor_instantiate (ind, u, specif, params) cty in
                match Term.decompose_prod_assum typi with
                | (cstrsign, ccl) =&gt;
                  let nargs := Context.Rel.length cstrsign in
                  match Constr.decompose_app ccl with
                  | (_, allargs) =&gt;
                    match
                      Util.List.(CList.ExtS.chop) (inductive_params specif)
                        allargs with
                    | (lparams, vargs) =&gt;
                      let cargs :=
                        let cstr :=
                          Names.ith_constructor_of_inductive ind
                            (Util.op_plus i 1) in
                        let dep_cstr :=
                          Term.applist
                            ((Constr.mkConstructU (cstr, u)),
                              (Util.op_at lparams
                                (Context.Rel.to_extended_list Constr.mkRel 0
                                  cstrsign))) in
                        Util.op_at vargs (cons dep_cstr []) in
                      let base :=
                        Term.lambda_appvect_assum
                          (Util.op_plus (mind_nrealdecls mip) 1)
                          (Vars.lift nargs p)
                          (Util.Array.(CArray.ExtS.of_list) cargs) in
                      Term.it_mkProd_or_LetIn base cstrsign
                    end
                  end
                end
              end in
            Util.Array.(CArray.ExtS.mapi) build_one_branch (mind_nf_lc mip)
      end
  end.

Definition build_case_type
  (env : Environ.env) (n : Z) (p : Constr.constr) (c : Constr.constr)
  (realargs : list Constr.constr) : Constr.constr :=
  Reduction.whd_betaiota env
    (Term.lambda_appvect_assum (Util.op_plus n 1) p
      (Util.Array.(CArray.ExtS.of_list) (Util.op_at realargs (cons c [])))).

Definition type_case_branches
  (env : Environ.env)
  (function_parameter :
    (Names.inductive * Univ.Instance.t) * (list Constr.constr))
  : (Environ.punsafe_judgment Constr.constr Constr.constr) -&gt;
    Constr.constr -&gt; (array Constr.types) * Constr.constr :=
  match function_parameter with
  | (pind, largs) =&gt;
    fun pj =&gt;
      fun c =&gt;
        let specif := lookup_mind_specif env (fst pind) in
        let nparams := inductive_params specif in
        match Util.List.(CList.ExtS.chop) nparams largs with
        | (params, realargs) =&gt;
          let p := uj_val pj in
          match is_correct_arity env c pj pind specif params with
          | tt =&gt;
            let lc := build_branches_type pind specif params p in
            let ty :=
              build_case_type env (mind_nrealdecls (snd specif)) p c realargs in
            (lc, ty)
          end
        end
  end.

Definition check_case_info
  (env : Environ.env) (function_parameter : Names.inductive * Univ.Instance.t)
  : Sorts.relevance -&gt; Constr.case_info -&gt; unit :=
  match function_parameter with
  | (indsp, u) =&gt;
    fun r =&gt;
      fun ci =&gt;
        match lookup_mind_specif env indsp with
        | (mib, mip) as spec =&gt;
          if
            orb (negb (Names.eq_ind indsp (ci_ind ci)))
              (orb (negb (Int.equal (mind_nparams mib) (ci_npar ci)))
                (orb
                  (negb
                    (Util.Array.(CArray.ExtS.equal) Int.equal
                      (mind_consnrealdecls mip) (ci_cstr_ndecls ci)))
                  (orb
                    (negb
                      (Util.Array.(CArray.ExtS.equal) Int.equal
                        (mind_consnrealargs mip) (ci_cstr_nargs ci)))
                    (orb (negb (Stdlib.op_eq_eq (ci_relevance ci) r))
                      (is_primitive_record spec))))) then
            Stdlib.raise (TypeError env (WrongCaseInfo (indsp, u) ci))
          else
            tt
        end
  end.

Inductive size : Type :=
| Large : size
| Strict : size.

Definition size_glb (s1 : size) (s2 : size) : size :=
  match (s1, s2) with
  | (Strict, Strict) =&gt; Strict
  | _ =&gt; Large
  end.

Inductive subterm_spec : Type :=
| Subterm : (size * Declarations.wf_paths) -&gt; subterm_spec
| Dead_code : subterm_spec
| Not_subterm : subterm_spec.

Definition eq_wf_paths
  : (Rtree.t Declarations.recarg) -&gt; (Rtree.t Declarations.recarg) -&gt; bool :=
  Rtree.equal Declareops.eq_recarg.

Definition inter_recarg (r1 : Declarations.recarg) (r2 : Declarations.recarg)
  : option Declarations.recarg :=
  match (r1, r2) with
  | (Norec, Norec) =&gt; Some r1
  | (Mrec i1, Mrec i2) | (Imbr i1, Imbr i2) | (Mrec i1, Imbr i2) =&gt;
    if Names.eq_ind i1 i2 then
      Some r1
    else
      None
  | (Imbr i1, Mrec i2) =&gt;
    if Names.eq_ind i1 i2 then
      Some r2
    else
      None
  | _ =&gt; None
  end.

Definition inter_wf_paths
  : (Rtree.t Declarations.recarg) -&gt;
    (Rtree.t Declarations.recarg) -&gt; Rtree.t Declarations.recarg :=
  Rtree.inter Declareops.eq_recarg inter_recarg Norec.

Definition incl_wf_paths
  : (Rtree.t Declarations.recarg) -&gt; (Rtree.t Declarations.recarg) -&gt; bool :=
  Rtree.incl Declareops.eq_recarg inter_recarg Norec.

Definition spec_of_tree (t : Declarations.wf_paths) : subterm_spec :=
  if eq_wf_paths t Declareops.mk_norec then
    Not_subterm
  else
    Subterm (Strict, t).

Definition inter_spec (s1 : subterm_spec) (s2 : subterm_spec) : subterm_spec :=
  match (s1, s2) with
  | (_, Dead_code) =&gt; s1
  | (Dead_code, _) =&gt; s2
  | (Not_subterm, _) =&gt; s1
  | (_, Not_subterm) =&gt; s2
  | (Subterm (a1, t1), Subterm (a2, t2)) =&gt;
    Subterm ((size_glb a1 a2), (inter_wf_paths t1 t2))
  end.

Definition subterm_spec_glb : (array subterm_spec) -&gt; subterm_spec :=
  Util.Array.(CArray.ExtS.fold_left) inter_spec Dead_code.

Record guard_env := {
  env : Environ.env;
  rel_min : Z;
  genv : list (Stdlib.Lazy.t subterm_spec) }.

Definition make_renv
  (env : Environ.env) (recarg : Z) (tree : Declarations.wf_paths) : guard_env :=
  {| env := env; rel_min := Util.op_plus recarg 2;
    genv := cons (Stdlib.Lazy.from_val (Subterm (Large, tree))) [] |}.

Definition push_var
  (renv : guard_env)
  (function_parameter :
    (Context.binder_annot Names.Name.t) * Constr.types *
      (Stdlib.Lazy.t subterm_spec)) : guard_env :=
  match function_parameter with
  | (x, ty, spec) =&gt;
    {| env := Environ.push_rel (LocalAssum x ty) (env renv);
      rel_min := Util.op_plus (rel_min renv) 1; genv := cons spec (genv renv) |}
  end.

Definition assign_var_spec
  (renv : guard_env) (function_parameter : Z * (Stdlib.Lazy.t subterm_spec))
  : guard_env :=
  match function_parameter with
  | (i, spec) =&gt; record
  end.

Definition push_var_renv
  (renv : guard_env)
  (function_parameter : (Context.binder_annot Names.Name.t) * Constr.types)
  : guard_env :=
  match function_parameter with
  | (x, ty) =&gt; push_var renv (x, ty, Not_subterm)
  end.

Definition subterm_var (p : Z) (renv : guard_env) : subterm_spec := try.

Definition push_ctxt_renv
  (renv : guard_env) (ctxt : Context.Rel.pt Constr.constr Constr.types)
  : guard_env :=
  let n := Context.Rel.length ctxt in
  {| env := Environ.push_rel_context ctxt (env renv);
    rel_min := Util.op_plus (rel_min renv) n;
    genv := Util.iterate (fun ge =&gt; cons Not_subterm ge) n (genv renv) |}.

Definition push_fix_renv
  (renv : guard_env)
  (function_parameter :
    (array (Context.binder_annot Names.Name.t)) * (array Constr.types) *
      (array Constr.constr)) : guard_env :=
  match function_parameter with
  | (_, v, _) as recdef =&gt;
    let n := Util.Array.(CArray.ExtS.length) v in
    {| env := Environ.push_rec_types recdef (env renv);
      rel_min := Util.op_plus (rel_min renv) n;
      genv := Util.iterate (fun ge =&gt; cons Not_subterm ge) n (genv renv) |}
  end.

Inductive stack_element : Type :=
| SClosure : guard_env -&gt; Constr.constr -&gt; stack_element
| SArg : (Stdlib.Lazy.t subterm_spec) -&gt; stack_element.

Definition push_stack_closures
  (renv : guard_env) (l : list Constr.constr) (stack : list stack_element)
  : list stack_element :=
  Util.List.(CList.ExtS.fold_right) (fun h =&gt; fun b =&gt; cons (SClosure renv h) b)
    l stack.

Definition push_stack_args
  (l : list (Stdlib.Lazy.t subterm_spec)) (stack : list stack_element)
  : list stack_element :=
  Util.List.(CList.ExtS.fold_right) (fun h =&gt; fun b =&gt; cons (SArg h) b) l stack.

Definition lookup_subterms (env : Environ.env) (ind : Names.MutInd.t * Z)
  : Declarations.wf_paths :=
  match lookup_mind_specif env ind with
  | (_, mip) =&gt; mind_recargs mip
  end.

Definition match_inductive (ind : Names.inductive) (ra : Declarations.recarg)
  : bool :=
  match ra with
  | Mrec i | Imbr i =&gt; Names.eq_ind ind i
  | Norec =&gt; false
  end.

Definition branches_specif
  (renv : guard_env) (c_spec : Stdlib.Lazy.t subterm_spec)
  (ci : Constr.case_info) : array (list (lazy_t subterm_spec)) :=
  let car :=
    match lookup_mind_specif (env renv) (ci_ind ci) with
    | (_, mip) =&gt;
      let v := Declareops.dest_subterms (mind_recargs mip) in
      Util.Array.(CArray.ExtS.map) Util.List.(CList.ExtS.length) v
    end in
  Util.Array.(CArray.ExtS.mapi)
    (fun i =&gt;
      fun nca =&gt;
        let lvra :=
          match Stdlib.Lazy.force c_spec with
          | Dead_code =&gt; Util.Array.(CArray.ExtS.make) nca Dead_code
          | _ =&gt; Util.Array.(CArray.ExtS.make) nca Not_subterm
          end in
        Util.List.(CList.ExtS.init) nca
          (fun j =&gt; Util.Array.(CArray.ExtS.get) (Stdlib.Lazy.force lvra) j))
    car.

Definition check_inductive_codomain (env : Environ.env) (p : Constr.constr)
  : bool :=
  match Reduction.dest_lam_assum env p with
  | (absctx, ar) =&gt;
    let env := Environ.push_rel_context absctx env in
    match Reduction.dest_prod_assum env ar with
    | (arctx, s) =&gt;
      let env := Environ.push_rel_context arctx env in
      match Constr.decompose_app (Reduction.whd_all env s) with
      | (i, _l') =&gt; Constr.isInd i
      end
    end
  end.

Definition ienv_push_var {A : Type}
  (function_parameter : Environ.env * (list (Declarations.recarg * A)))
  : ((Context.binder_annot Names.Name.t) * Constr.types * A) -&gt;
    Environ.env * (list (Declarations.recarg * A)) :=
  match function_parameter with
  | (env, lra) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (x, a, ra) =&gt;
        ((Environ.push_rel (LocalAssum x a) env), (cons (Norec, ra) lra))
      end
  end.

Definition ienv_push_inductive {A : Type}
  (function_parameter : Environ.env * (list (Declarations.recarg * (Rtree.t A))))
  : ((Names.MutInd.t * Univ.Instance.t) * (list Constr.constr)) -&gt;
    Environ.env * (list (Declarations.recarg * (Rtree.t A))) :=
  match function_parameter with
  | (env, ra_env) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | ((mind, u), lpar) =&gt;
        let mib := Environ.lookup_mind mind env in
        let ntypes := mind_ntypes mib in
        let push_ind
          (specif : Declarations.one_inductive_body) (env : Environ.env)
          : Environ.env :=
          let r := mind_relevance specif in
          let anon := Context.make_annot Anonymous r in
          let decl :=
            LocalAssum anon
              (Reduction.hnf_prod_applist env
                (type_of_inductive env ((mib, specif), u)) lpar) in
          Environ.push_rel decl env in
        let env :=
          Util.Array.(CArray.ExtS.fold_right) push_ind (mind_packets mib) env in
        let rc :=
          Util.Array.(CArray.ExtS.mapi)
            (fun j =&gt; fun t =&gt; ((Imbr (mind, j)), t))
            (Rtree.mk_rec_calls ntypes) in
        let lra_ind := Util.Array.(CArray.ExtS.rev_to_list) rc in
        let ra_env :=
          Util.List.(CList.ExtS.map)
            (fun function_parameter =&gt;
              match function_parameter with
              | (r, t) =&gt; (r, (Rtree.lift ntypes t))
              end) ra_env in
        (env, (Util.op_at lra_ind ra_env))
      end
  end.

Fixpoint ienv_decompose_prod
  (function_parameter :
    Environ.env * (list (Declarations.recarg * Declarations.wf_paths)))
  : Int.t -&gt;
    Constr.constr -&gt;
      (Environ.env * (list (Declarations.recarg * Declarations.wf_paths))) *
        Constr.constr :=
  match function_parameter with
  | (env, _) as ienv =&gt;
    fun n =&gt;
      fun c =&gt;
        if Int.equal n 0 then
          (ienv, c)
        else
          let c' := Reduction.whd_all env c in
          match Constr.kind c' with
          | Prod na a b =&gt;
            let ienv' := ienv_push_var ienv (na, a, Declareops.mk_norec) in
            ienv_decompose_prod ienv' (Util.op_minus n 1) b
          | _ =&gt; false
          end
  end.

Definition dummy_univ : Univ.Level.t :=
  Univ.Level.make
    (Univ.Level.UGlobal.make
      (Names.DirPath.make (cons (Names.Id.of_string &quot;implicit&quot; % string) [])) 0).

Definition dummy_implicit_sort : Constr.types :=
  Constr.mkType (Univ.Universe.make dummy_univ).

Definition lambda_implicit_lift (n : Z) (a : Constr.constr) : Constr.constr :=
  let anon := Context.make_annot Anonymous Sorts.Relevant in
  let lambda_implicit (a : Constr.constr) : Constr.constr :=
    Constr.mkLambda (anon, dummy_implicit_sort, a) in
  Util.iterate lambda_implicit n (Vars.lift n a).

Definition abstract_mind_lc
  (ntyps : Z) (npars : Int.t) (lc : array (Constr.rel_context * Constr.types))
  : array Constr.types :=
  let lc :=
    Util.Array.(CArray.ExtS.map)
      (fun function_parameter =&gt;
        match function_parameter with
        | (ctx, c) =&gt; Term.it_mkProd_or_LetIn c ctx
        end) lc in
  if Int.equal npars 0 then
    lc
  else
    let make_abs :=
      Util.List.(CList.ExtS.init) ntyps
        (fun i =&gt; lambda_implicit_lift npars (Constr.mkRel (Util.op_plus i 1)))
      in
    Util.Array.(CArray.ExtS.map) (Vars.substl make_abs) lc.

Definition get_recargs_approx
  (env : Environ.env) (tree : Declarations.wf_paths)
  (ind : Names.inductive * Univ.Instance.t) (args : list Constr.constr)
  : Declarations.wf_paths :=
  let fix build_recargs
    (function_parameter :
    Environ.env * (list (Declarations.recarg * Declarations.wf_paths)))
    : Declarations.wf_paths -&gt; Constr.constr -&gt; Declarations.wf_paths :=
    match function_parameter with
    | (env, ra_env) as ienv =&gt;
      fun tree =&gt;
        fun c =&gt;
          match Constr.decompose_app (Reduction.whd_all env c) with
          | (x, largs) =&gt;
            match Constr.kind x with
            | Prod na b d =&gt;
              Util.List.(CList.ExtS.is_empty) largs;
              build_recargs (ienv_push_var ienv (na, b, Declareops.mk_norec))
                tree d
            | Rel k =&gt; try
            | Ind ind_kn =&gt;
              match Declareops.dest_recarg tree with
              | _ =&gt; Declareops.mk_norec
              end
            | _err =&gt; Declareops.mk_norec
            end
          end
    end
  with build_recargs_nested
    (function_parameter :
    Environ.env * (list (Declarations.recarg * Declarations.wf_paths)))
    : Declarations.wf_paths -&gt;
      ((Names.inductive * Univ.Instance.t) * (list Constr.constr)) -&gt;
        Declarations.wf_paths :=
    match function_parameter with
    | (env, _ra_env) as ienv =&gt;
      fun tree =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | (((mind, i), u), largs) =&gt;
            if eq_wf_paths tree Declareops.mk_norec then
              tree
            else
              let mib := Environ.lookup_mind mind env in
              let auxnpar := mind_nparams_rec mib in
              let nonrecpar := Util.op_minus (mind_nparams mib) auxnpar in
              match Util.List.(CList.ExtS.chop) auxnpar largs with
              | (lpar, _) =&gt;
                let auxntyp := mind_ntypes mib in
                match ienv_push_inductive ienv ((mind, u), lpar) with
                | (env', _) as ienv' =&gt;
                  let lpar' :=
                    Util.List.(CList.ExtS.map) (Vars.lift auxntyp) lpar in
                  let trees :=
                    if Int.equal auxntyp 1 then
                      ((Declareops.dest_subterms tree))
                    else
                      Util.Array.(CArray.ExtS.map)
                        (fun mip =&gt; Declareops.dest_subterms (mind_recargs mip))
                        (mind_packets mib) in
                  let mk_irecargs
                    (j : Z) (specif : Declarations.one_inductive_body)
                    : Declarations.wf_paths :=
                    let auxlcvect :=
                      abstract_mind_lc auxntyp auxnpar (mind_nf_lc specif) in
                    let paths :=
                      Util.Array.(CArray.ExtS.mapi)
                        (fun k =&gt;
                          fun c =&gt;
                            let c' := Reduction.hnf_prod_applist env' c lpar' in
                            match ienv_decompose_prod ienv' nonrecpar c' with
                            | (ienv', c') =&gt;
                              build_recargs_constructors ienv'
                                (Util.Array.(CArray.ExtS.get)
                                  (Util.Array.(CArray.ExtS.get) trees j) k) c'
                            end) auxlcvect in
                    Declareops.mk_paths (Imbr (mind, j)) paths in
                  let irecargs :=
                    Util.Array.(CArray.ExtS.mapi) mk_irecargs (mind_packets mib)
                    in
                  Util.Array.(CArray.ExtS.get) (Rtree.mk_rec irecargs) i
                end
              end
          end
    end
  with build_recargs_constructors
    (ienv : Environ.env * (list (Declarations.recarg * Declarations.wf_paths)))
    (trees : list Declarations.wf_paths) (c : Constr.constr)
    : list Declarations.wf_paths :=
    let fix recargs_constr_rec
      (function_parameter :
      Environ.env * (list (Declarations.recarg * Declarations.wf_paths)))
      : (list Declarations.wf_paths) -&gt;
        (list Declarations.wf_paths) -&gt;
          Constr.constr -&gt; list Declarations.wf_paths :=
      match function_parameter with
      | (env, _ra_env) as ienv =&gt;
        fun trees =&gt;
          fun lrec =&gt;
            fun c =&gt;
              match Constr.decompose_app (Reduction.whd_all env c) with
              | (x, largs) =&gt;
                match Constr.kind x with
                | Prod na b d =&gt;
                  match Util.List.(CList.ExtS.is_empty) largs with
                  | tt =&gt;
                    let recarg :=
                      build_recargs ienv (Util.List.(CList.ExtS.hd) trees) b in
                    let ienv' := ienv_push_var ienv (na, b, Declareops.mk_norec)
                      in
                    recargs_constr_rec ienv' (Util.List.(CList.ExtS.tl) trees)
                      (cons recarg lrec) d
                  end
                | _hd =&gt; Util.List.(CList.ExtS.rev) lrec
                end
              end
      end in
    recargs_constr_rec ienv trees [] c in
  build_recargs_nested (env, []) tree (ind, args).

Definition restrict_spec
  (env : Environ.env) (spec : subterm_spec) (p : Constr.constr)
  : subterm_spec :=
  if equiv_decb spec Not_subterm then
    spec
  else
    match Reduction.dest_lam_assum env p with
    | (absctx, ar) =&gt;
      if Vars.noccur_with_meta 1 (Context.Rel.length absctx) ar then
        spec
      else
        let env := Environ.push_rel_context absctx env in
        match Reduction.dest_prod_assum env ar with
        | (arctx, s) =&gt;
          let env := Environ.push_rel_context arctx env in
          match Constr.decompose_app (Reduction.whd_all env s) with
          | (i, args) =&gt;
            match Constr.kind i with
            | Ind i =&gt;
              match spec with
              | Dead_code =&gt; spec
              | Subterm (st, tree) =&gt;
                let recargs := get_recargs_approx env tree i args in
                let recargs := inter_wf_paths tree recargs in
                Subterm (st, recargs)
              | _ =&gt; false
              end
            | _ =&gt; Not_subterm
            end
          end
        end
    end.

Fixpoint subterm_specif
  (renv : guard_env) (stack : list stack_element) (t : Constr.constr)
  : subterm_spec :=
  match Constr.decompose_app (Reduction.whd_all (env renv) t) with
  | (f, l) =&gt;
    match Constr.kind f with
    | Rel k =&gt; subterm_var k renv
    | Case ci p c lbr =&gt;
      let stack' := push_stack_closures renv l stack in
      let cases_spec := branches_specif renv (lazy_subterm_specif renv [] c) ci
        in
      let stl :=
        Util.Array.(CArray.ExtS.mapi)
          (fun i =&gt;
            fun br' =&gt;
              let stack_br :=
                push_stack_args (Util.Array.(CArray.ExtS.get) cases_spec i)
                  stack' in
              subterm_specif renv stack_br br') lbr in
      let spec := subterm_spec_glb stl in
      restrict_spec (env renv) spec p
    | Fix ((recindxs, i), (_, typarray, bodies) as recdef) =&gt;
      if
        negb
          (check_inductive_codomain (env renv)
            (Util.Array.(CArray.ExtS.get) typarray i)) then
        Not_subterm
      else
        match
          Reduction.dest_prod (env renv)
            (Util.Array.(CArray.ExtS.get) typarray i) with
        | (ctxt, clfix) =&gt;
          let oind :=
            let env' := Environ.push_rel_context ctxt (env renv) in
            try in
          match oind with
          | None =&gt; Not_subterm
          | Some (ind, _) =&gt;
            let nbfix := Util.Array.(CArray.ExtS.length) typarray in
            let recargs := lookup_subterms (env renv) ind in
            let renv' := push_fix_renv renv recdef in
            let renv' :=
              assign_var_spec renv'
                ((Util.op_minus nbfix i), (Subterm (Strict, recargs))) in
            let decrArg := Util.Array.(CArray.ExtS.get) recindxs i in
            let theBody := Util.Array.(CArray.ExtS.get) bodies i in
            let nbOfAbst := Util.op_plus decrArg 1 in
            match Term.decompose_lam_n_assum nbOfAbst theBody with
            | (sign, strippedBody) =&gt;
              let stack' := push_stack_closures renv l stack in
              let renv'' := push_ctxt_renv renv' sign in
              let renv'' :=
                if
                  OCaml.Stdlib.lt (Util.List.(CList.ExtS.length) stack')
                    nbOfAbst then
                  renv''
                else
                  let decrArg := Util.List.(CList.ExtS.nth) stack' decrArg in
                  let arg_spec := stack_element_specif decrArg in
                  assign_var_spec renv'' (1, arg_spec) in
              subterm_specif renv'' [] strippedBody
            end
          end
        end
    | Lambda x a b =&gt;
      match Util.List.(CList.ExtS.is_empty) l with
      | tt =&gt;
        match extract_stack stack with
        | (spec, stack') =&gt; subterm_specif (push_var renv (x, a, spec)) stack' b
        end
      end
    | Meta _ | Evar _ =&gt; Dead_code
    | Proj p c =&gt;
      let subt := subterm_specif renv stack c in
      match subt with
      | Subterm (_s, wf) =&gt;
        let wf_args :=
          Util.Array.(CArray.ExtS.get) (Declareops.dest_subterms wf) 0 in
        let n := Names.Projection.arg p in
        spec_of_tree (Util.List.(CList.ExtS.nth) wf_args n)
      | Dead_code =&gt; Dead_code
      | Not_subterm =&gt; Not_subterm
      end
    |
      Var _ | Sort _ | Cast _ _ _ | Prod _ _ _ | LetIn _ _ _ _ | App _ _ |
        Const _ | Ind _ | Construct _ | CoFix _ | Int _ =&gt; Not_subterm
    end
  end

with lazy_subterm_specif
  (renv : guard_env) (stack : list stack_element) (t : Constr.constr)
  : Stdlib.Lazy.t subterm_spec := subterm_specif renv stack t

with stack_element_specif (function_parameter : stack_element)
  : Stdlib.Lazy.t subterm_spec :=
  match function_parameter with
  | SClosure h_renv h =&gt; lazy_subterm_specif h_renv [] h
  | SArg x =&gt; x
  end

with extract_stack (function_parameter : list stack_element)
  : (Stdlib.Lazy.t subterm_spec) * (list stack_element) :=
  match function_parameter with
  | [] =&gt; ((Stdlib.Lazy.from_val Not_subterm), [])
  | cons h t =&gt; ((stack_element_specif h), t)
  end.

Definition check_is_subterm
  (x : Stdlib.Lazy.t subterm_spec) (tree : Rtree.t Declarations.recarg)
  : bool :=
  match Stdlib.Lazy.force x with
  | Subterm (Strict, tree') =&gt; incl_wf_paths tree tree'
  | Dead_code =&gt; true
  | _ =&gt; false
  end.

Definition error_illegal_rec_call {A : Type}
  (renv : guard_env) (fx : Z) (function_parameter : guard_env * Constr.constr)
  : A :=
  match function_parameter with
  | (arg_renv, arg) =&gt;
    match
      Util.List.(CList.ExtS.fold_left)
        (fun function_parameter =&gt;
          match function_parameter with
          | (i, le, lt) =&gt;
            fun sbt =&gt;
              match Stdlib.Lazy.force sbt with
              | Subterm (Strict, _) | Dead_code =&gt;
                ((Util.op_plus i 1), le, (cons i lt))
              | Subterm (Large, _) =&gt; ((Util.op_plus i 1), (cons i le), lt)
              | _ =&gt; ((Util.op_plus i 1), le, lt)
              end
          end) (1, [], []) (genv renv) with
    | (_, le_vars, lt_vars) =&gt;
      Stdlib.raise
        (FixGuardError (env renv)
          (RecursionOnIllegalTerm fx ((env arg_renv), arg) le_vars lt_vars))
    end
  end.

Definition error_partial_apply {A : Type} (renv : guard_env) (fx : Z) : A :=
  Stdlib.raise (FixGuardError (env renv) (NotEnoughArgumentsForFixCall fx)).

Definition filter_stack_domain
  (env : Environ.env) (p : Constr.constr) (stack : list stack_element)
  : list stack_element :=
  match Reduction.dest_lam_assum env p with
  | (absctx, ar) =&gt;
    if Vars.noccur_with_meta 1 (Context.Rel.length absctx) ar then
      stack
    else
      let env := Environ.push_rel_context absctx env in
      let fix filter_stack
        (env : Environ.env) (ar : Constr.constr) (stack : list stack_element)
        : list stack_element :=
        let t := Reduction.whd_all env ar in
        match (stack, (Constr.kind t)) with
        | (cons elt stack', Prod n a c0) =&gt;
          let d := LocalAssum n a in
          match Reduction.dest_prod_assum env a with
          | (ctx, a) =&gt;
            let env := Environ.push_rel_context ctx env in
            match Constr.decompose_app (Reduction.whd_all env a) with
            | (ty, args) =&gt;
              let elt :=
                match Constr.kind ty with
                | Ind ind =&gt;
                  let spec' := stack_element_specif elt in
                  match Stdlib.Lazy.force spec' with
                  | Not_subterm | Dead_code =&gt; elt
                  | Subterm (s, path) =&gt;
                    let recargs := get_recargs_approx env path ind args in
                    let path := inter_wf_paths path recargs in
                    SArg (Subterm (s, path))
                  end
                | _ =&gt; SArg Not_subterm
                end in
              cons elt (filter_stack (Environ.push_rel d env) c0 stack')
            end
          end
        | (_, _) =&gt;
          Util.List.(CList.ExtS.fold_right)
            (fun function_parameter =&gt;
              match function_parameter with
              | _ =&gt; fun l =&gt; cons (SArg Not_subterm) l
              end) stack []
        end in
      filter_stack env ar stack
  end.

Definition check_one_fix
  (renv : guard_env) (recpos : array Z)
  (trees : array (Rtree.t Declarations.recarg)) (def : Constr.constr) : unit :=
  let nfi := Util.Array.(CArray.ExtS.length) recpos in
  let fix check_rec_call
    (renv : guard_env) (stack : list stack_element) (t : Constr.constr)
    : unit :=
    if Vars.noccur_with_meta (rel_min renv) nfi t then
      tt
    else
      match Constr.decompose_app (Reduction.whd_betaiotazeta (env renv) t) with
      | (f, l) =&gt;
        match Constr.kind f with
        | Rel p =&gt;
          if
            andb (OCaml.Stdlib.le (rel_min renv) p)
              (OCaml.Stdlib.lt p (Util.op_plus (rel_min renv) nfi)) then
            Util.List.(CList.ExtS.iter) (check_rec_call renv []) l;
            let glob :=
              Util.op_minus (Util.op_minus (Util.op_plus (rel_min renv) nfi) 1)
                p in
            let np := Util.Array.(CArray.ExtS.get) recpos glob in
            let stack' := push_stack_closures renv l stack in
            if OCaml.Stdlib.le (Util.List.(CList.ExtS.length) stack') np then
              error_partial_apply renv glob
            else
              let z := Util.List.(CList.ExtS.nth) stack' np in
              if
                negb
                  (check_is_subterm (stack_element_specif z)
                    (Util.Array.(CArray.ExtS.get) trees glob)) then
                match z with
                | SClosure z z' =&gt; error_illegal_rec_call renv glob (z, z')
                | SArg _ =&gt; error_partial_apply renv glob
                end
              else
                tt
          else
            match Environ.lookup_rel p (env renv) with
            | LocalAssum _ _ =&gt;
              Util.List.(CList.ExtS.iter) (check_rec_call renv []) l
            | LocalDef _ c _ =&gt; try
            end
        | Case ci p c_0 lrest =&gt; try
        | Fix ((recindxs, i), (_, typarray, bodies) as recdef) =&gt;
          let decrArg := Util.Array.(CArray.ExtS.get) recindxs i in
          try
        | Const ((kn, _u) as cu) =&gt;
          if Environ.evaluable_constant kn (env renv) then
            try
          else
            Util.List.(CList.ExtS.iter) (check_rec_call renv []) l
        | Lambda x a b =&gt;
          match Util.List.(CList.ExtS.is_empty) l with
          | tt =&gt;
            check_rec_call renv [] a;
            match extract_stack stack with
            | (spec, stack') =&gt;
              check_rec_call (push_var renv (x, a, spec)) stack' b
            end
          end
        | Prod x a b =&gt;
          match
            andb (Util.List.(CList.ExtS.is_empty) l)
              (Util.List.(CList.ExtS.is_empty) stack) with
          | tt =&gt;
            check_rec_call renv [] a;
            check_rec_call (push_var_renv renv (x, a)) [] b
          end
        | CoFix (_i, (_, typarray, bodies) as recdef) =&gt;
          Util.List.(CList.ExtS.iter) (check_rec_call renv []) l;
          Util.Array.(CArray.ExtS.iter) (check_rec_call renv []) typarray;
          let renv' := push_fix_renv renv recdef in
          Util.Array.(CArray.ExtS.iter) (check_rec_call renv' []) bodies
        | Ind _ | Construct _ =&gt;
          Util.List.(CList.ExtS.iter) (check_rec_call renv []) l
        | Proj p c =&gt; try
        | Var id =&gt;
          match Environ.lookup_named id (env renv) with
          | LocalAssum _ _ =&gt;
            Util.List.(CList.ExtS.iter) (check_rec_call renv []) l
          | LocalDef _ c _ =&gt; try
          end
        | Sort _ | Int _ =&gt; Util.List.(CList.ExtS.is_empty) l
        | Evar _ | Meta _ =&gt; tt
        | App _ _ | LetIn _ _ _ _ | Cast _ _ _ =&gt; false
        end
      end
  with check_nested_fix_body
    (renv : guard_env) (decr : Int.t) (recArgsDecrArg :
    Stdlib.Lazy.t subterm_spec) (body : Constr.constr) : unit :=
    if Int.equal decr 0 then
      check_rec_call (assign_var_spec renv (1, recArgsDecrArg)) [] body
    else
      match Constr.kind body with
      | Lambda x a b =&gt;
        check_rec_call renv [] a;
        let renv' := push_var_renv renv (x, a) in
        check_nested_fix_body renv' (Util.op_minus decr 1) recArgsDecrArg b
      | _ =&gt;
        CErrors.anomaly None None
          (Pp.str &quot;Not enough abstractions in fix body.&quot; % string)
      end in
  check_rec_call renv [] def.

Definition judgment_of_fixpoint {A B C : Type}
  (function_parameter : A * (array B) * (array C))
  : array (Environ.punsafe_judgment C B) :=
  match function_parameter with
  | (_, types, bodies) =&gt;
    Util.Array.(CArray.ExtS.map2)
      (fun typ =&gt; fun body =&gt; {| uj_val := body; uj_type := typ |}) types bodies
  end.

Definition inductive_of_mutfix
  (env : Environ.env)
  (function_parameter :
    ((array Z) * Z) *
      ((array (Context.binder_annot Names.Name.t)) * (array Constr.types) *
        (array Constr.constr)))
  : (array (Names.inductive * Univ.Instance.t)) *
    (array (Environ.env * Constr.constr)) :=
  match function_parameter with
  | ((nvect, bodynum), (names, types, bodies) as recdef) =&gt;
    let nbfix := Util.Array.(CArray.ExtS.length) bodies in
    if
      orb (Int.equal nbfix 0)
        (orb (negb (Int.equal (Util.Array.(CArray.ExtS.length) nvect) nbfix))
          (orb (negb (Int.equal (Util.Array.(CArray.ExtS.length) types) nbfix))
            (orb
              (negb (Int.equal (Util.Array.(CArray.ExtS.length) names) nbfix))
              (orb (OCaml.Stdlib.lt bodynum 0) (OCaml.Stdlib.ge bodynum nbfix)))))
      then
      CErrors.anomaly None None (Pp.str &quot;Ill-formed fix term.&quot; % string)
    else
      tt;
    let fixenv := Environ.push_rec_types recdef env in
    let vdefj := judgment_of_fixpoint recdef in
    let raise_err {A : Type}
      (env : Environ.env) (i : Z) (err : Type_errors.guard_error) : A :=
      Type_errors.error_ill_formed_rec_body env err names i fixenv vdefj in
    let find_ind (i : Z) (k : Z) (def : Constr.constr)
      : (Names.inductive * Univ.Instance.t) * (Environ.env * Constr.constr) :=
      let fix check_occur (env : Environ.env) (n : Int.t) (def : Constr.constr)
        : (Names.inductive * Univ.Instance.t) * (Environ.env * Constr.constr) :=
        match Constr.kind (Reduction.whd_all env def) with
        | Lambda x a b =&gt;
          if Vars.noccur_with_meta n nbfix a then
            let env' := Environ.push_rel (LocalAssum x a) env in
            if Int.equal n (Util.op_plus k 1) then
              match try with
              | (mind, _) =&gt;
                match lookup_mind_specif env (Univ.out_punivs mind) with
                | (mib, _) =&gt;
                  if Stdlib.op_exclamation_eq (mind_finite mib) Finite then
                    raise_err env i (RecursionNotOnInductiveType a)
                  else
                    tt;
                  (mind, (env', b))
                end
              end
            else
              check_occur env' (Util.op_plus n 1) b
          else
            CErrors.anomaly None (Some &quot;check_one_fix&quot; % string)
              (Pp.str &quot;Bad occurrence of recursive call.&quot; % string)
        | _ =&gt; raise_err env i NotEnoughAbstractionInFixBody
        end in
      match check_occur fixenv 1 def with
      | ((ind, _), _) as res =&gt;
        match lookup_mind_specif env ind with
        | (_, ind) =&gt;
          if Stdlib.op_eq_eq Sorts.Irrelevant (mind_relevance ind) then
            if
              Stdlib.op_eq_eq
                (Context.binder_relevance (Util.Array.(CArray.ExtS.get) names i))
                Sorts.Relevant then
              raise_err env i FixpointOnIrrelevantInductive
            else
              tt
          else
            tt;
          res
        end
      end in
    let rv := Util.Array.(CArray.ExtS.map2_i) find_ind nvect bodies in
    ((Util.Array.(CArray.ExtS.map) fst rv),
      (Util.Array.(CArray.ExtS.map) snd rv))
  end.

Definition check_fix
  (env : Environ.env)
  (function_parameter :
    ((array Z) * Z) *
      ((array (Context.binder_annot Names.Name.t)) * (array Constr.types) *
        (array Constr.constr))) : unit :=
  match function_parameter with
  | ((nvect, _), (names, _, bodies) as recdef) as fix =&gt;
    let flags := Environ.typing_flags env in
    if check_guarded flags then
      match inductive_of_mutfix env fix with
      | (minds, rdef) =&gt;
        let get_tree (function_parameter : Names.MutInd.t * Z)
          : Declarations.wf_paths :=
          match function_parameter with
          | (kn, i) =&gt;
            let mib := Environ.lookup_mind kn env in
            mind_recargs (Util.Array.(CArray.ExtS.get) (mind_packets mib) i)
          end in
        let trees :=
          Util.Array.(CArray.ExtS.map)
            (fun function_parameter =&gt;
              match function_parameter with
              | (mind, _) =&gt; get_tree mind
              end) minds in
        for
      end
    else
      tt
  end.

Definition anomaly_ill_typed {A : Type} (function_parameter : unit) : A :=
  match function_parameter with
  | tt =&gt;
    CErrors.anomaly None (Some &quot;check_one_cofix&quot; % string)
      (Pp.str &quot;too many arguments applied to constructor.&quot; % string)
  end.

Fixpoint codomain_is_coind (env : Environ.env) (c : Constr.constr)
  : (Names.inductive * Univ.Instance.t) * (list Constr.constr) :=
  let b := Reduction.whd_all env c in
  match Constr.kind b with
  | Prod x a b =&gt; codomain_is_coind (Environ.push_rel (LocalAssum x a) env) b
  | _ =&gt; try
  end.

Definition check_one_cofix
  (env : Environ.env) (nbfix : Z) (def : Constr.constr)
  (deftype : Constr.constr) : unit :=
  let fix check_rec_call
    (env : Environ.env) (alreadygrd : bool) (n : Z) (tree :
    Declarations.wf_paths) (vlra : array (list Declarations.wf_paths)) (t :
    Constr.constr) : unit :=
    if negb (Vars.noccur_with_meta n nbfix t) then
      match Constr.decompose_app (Reduction.whd_all env t) with
      | (c, args) =&gt;
        match Constr.kind c with
        | Construct ((_, i) as cstr_kn, _u) =&gt;
          let lra := Util.Array.(CArray.ExtS.get) vlra (Util.op_minus i 1) in
          let mI := Names.inductive_of_constructor cstr_kn in
          match lookup_mind_specif env mI with
          | (mib, _mip) =&gt;
            let realargs := Util.List.(CList.ExtS.skipn) (mind_nparams mib) args
              in
            let fix process_args_of_constr
              (function_parameter :
              (list Constr.constr) * (list Declarations.wf_paths)) : unit :=
              match function_parameter with
              | (cons t lr, cons rar lrar) =&gt;
                if eq_wf_paths rar Declareops.mk_norec then
                  if Vars.noccur_with_meta n nbfix t then
                    process_args_of_constr (lr, lrar)
                  else
                    Stdlib.raise
                      (CoFixGuardError env (RecCallInNonRecArgOfConstructor t))
                else
                  check_rec_call env true n rar (Declareops.dest_subterms rar) t;
                  process_args_of_constr (lr, lrar)
              | ([], _) =&gt; tt
              | _ =&gt; anomaly_ill_typed tt
              end in
            process_args_of_constr (realargs, lra)
          end
        | Lambda x a b =&gt;
          match Util.List.(CList.ExtS.is_empty) args with
          | tt =&gt;
            if Vars.noccur_with_meta n nbfix a then
              let env' := Environ.push_rel (LocalAssum x a) env in
              check_rec_call env' alreadygrd (Util.op_plus n 1) tree vlra b
            else
              Stdlib.raise (CoFixGuardError env (RecCallInTypeOfAbstraction a))
          end
        | CoFix (_j, (_, varit, vdefs) as recdef) =&gt;
          if Util.List.(CList.ExtS.for_all) (Vars.noccur_with_meta n nbfix) args
            then
            if
              Util.Array.(CArray.ExtS.for_all) (Vars.noccur_with_meta n nbfix)
                varit then
              let nbfix := Util.Array.(CArray.ExtS.length) vdefs in
              let env' := Environ.push_rec_types recdef env in
              Util.Array.(CArray.ExtS.iter)
                (check_rec_call env' alreadygrd (Util.op_plus n nbfix) tree vlra)
                vdefs;
              Util.List.(CList.ExtS.iter)
                (check_rec_call env alreadygrd n tree vlra) args
            else
              Stdlib.raise (CoFixGuardError env (RecCallInTypeOfDef c))
          else
            Stdlib.raise (CoFixGuardError env (UnguardedRecursiveCall c))
        | Case _ p tm vrest =&gt;
          let tree :=
            match restrict_spec env (Subterm (Strict, tree)) p with
            | Dead_code =&gt; false
            | Subterm (_, tree') =&gt; tree'
            | _ =&gt;
              Stdlib.raise
                (CoFixGuardError env (ReturnPredicateNotCoInductive c))
            end in
          if Vars.noccur_with_meta n nbfix p then
            if Vars.noccur_with_meta n nbfix tm then
              if
                Util.List.(CList.ExtS.for_all) (Vars.noccur_with_meta n nbfix)
                  args then
                let vlra := Declareops.dest_subterms tree in
                Util.Array.(CArray.ExtS.iter)
                  (check_rec_call env alreadygrd n tree vlra) vrest
              else
                Stdlib.raise (CoFixGuardError env (RecCallInCaseFun c))
            else
              Stdlib.raise (CoFixGuardError env (RecCallInCaseArg c))
          else
            Stdlib.raise (CoFixGuardError env (RecCallInCasePred c))
        | Meta _ =&gt; tt
        | Evar _ =&gt;
          Util.List.(CList.ExtS.iter)
            (check_rec_call env alreadygrd n tree vlra) args
        |
          Rel _ | Var _ | Sort _ | Cast _ _ _ | Prod _ _ _ | LetIn _ _ _ _ |
            App _ _ | Const _ | Ind _ | Fix _ | Proj _ _ | Int _ =&gt;
          Stdlib.raise (CoFixGuardError env (NotGuardedForm t))
        end
      end
    else
      tt in
  match codomain_is_coind env deftype with
  | ((mind, _), _) =&gt;
    let vlra := lookup_subterms env mind in
    check_rec_call env false 1 vlra (Declareops.dest_subterms vlra) def
  end.

Definition check_cofix {A : Type}
  (env : Environ.env)
  (function_parameter :
    A *
      ((array (Context.binder_annot Names.Name.t)) * (array Constr.types) *
        (array Constr.constr))) : unit :=
  match function_parameter with
  | (_bodynum, (names, types, bodies) as recdef) =&gt;
    let flags := Environ.typing_flags env in
    if check_guarded flags then
      let nbfix := Util.Array.(CArray.ExtS.length) bodies in
      for
    else
      tt
  end.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="inferCumulativity" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>inferCumulativity.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Reduction
open Declarations
open Constr
open Univ
open Variance
open Util

type inferred = IrrelevantI | CovariantI

(** Throughout this module we modify a map [variances] from local
    universes to [inferred]. It starts as a trivial mapping to
    [Irrelevant] and every time we encounter a local universe we
    restrict it accordingly.
    [Invariant] universes are removed from the map.
*)
exception TrivialVariance

let maybe_trivial variances =
  if LMap.is_empty variances then raise TrivialVariance
  else variances

let infer_level_eq u variances =
  maybe_trivial (LMap.remove u variances)

let infer_level_leq u variances =
  (* can only set Irrelevant -&gt; Covariant so nontrivial *)
  LMap.update u (function
      | None -&gt; None
      | Some CovariantI as x -&gt; x
      | Some IrrelevantI -&gt; Some CovariantI)
    variances

let infer_generic_instance_eq variances u =
  Array.fold_left (fun variances u -&gt; infer_level_eq u variances)
    variances (Instance.to_array u)

let infer_cumulative_ind_instance cv_pb mind_variance variances u =
  Array.fold_left2 (fun variances varu u -&gt;
      match cv_pb, varu with
      | _, Irrelevant -&gt; variances
      | _, Invariant | CONV, Covariant -&gt; infer_level_eq u variances
      | CUMUL, Covariant -&gt; infer_level_leq u variances)
    variances mind_variance (Instance.to_array u)

let infer_inductive_instance cv_pb env variances ind nargs u =
  let mind = Environ.lookup_mind (fst ind) env in
  match mind.mind_variance with
  | None -&gt; infer_generic_instance_eq variances u
  | Some mind_variance -&gt;
    if not (Int.equal (inductive_cumulativity_arguments (mind,snd ind)) nargs)
    then infer_generic_instance_eq variances u
    else infer_cumulative_ind_instance cv_pb mind_variance variances u

let infer_constructor_instance_eq env variances ((mi,ind),ctor) nargs u =
  let mind = Environ.lookup_mind mi env in
  match mind.mind_variance with
  | None -&gt; infer_generic_instance_eq variances u
  | Some _ -&gt;
    if not (Int.equal (constructor_cumulativity_arguments (mind,ind,ctor)) nargs)
    then infer_generic_instance_eq variances u
    else variances (* constructors are convertible at common supertype *)

let infer_sort cv_pb variances s =
  match cv_pb with
  | CONV -&gt;
    LSet.fold infer_level_eq (Universe.levels (Sorts.univ_of_sort s)) variances
  | CUMUL -&gt;
    LSet.fold infer_level_leq (Universe.levels (Sorts.univ_of_sort s)) variances

let infer_table_key variances c =
  let open Names in
  match c with
  | ConstKey (_, u) -&gt;
    infer_generic_instance_eq variances u
  | VarKey _ | RelKey _ -&gt; variances

let whd_stack (infos, tab) hd stk = CClosure.whd_stack infos tab hd stk

let rec infer_fterm cv_pb infos variances hd stk =
  Control.check_for_interrupt ();
  let hd,stk = whd_stack infos hd stk in
  let open CClosure in
  match fterm_of hd with
  | FAtom a -&gt;
    begin match kind a with
      | Sort s -&gt; infer_sort cv_pb variances s
      | Meta _ -&gt; infer_stack infos variances stk
      | _ -&gt; assert false
    end
  | FEvar ((_,args),e) -&gt;
    let variances = infer_stack infos variances stk in
    infer_vect infos variances (Array.map (mk_clos e) args)
  | FRel _ -&gt; infer_stack infos variances stk
  | FInt _ -&gt; infer_stack infos variances stk
  | FFlex fl -&gt;
    let variances = infer_table_key variances fl in
    infer_stack infos variances stk
  | FProj (_,c) -&gt;
    let variances = infer_fterm CONV infos variances c [] in
    infer_stack infos variances stk
  | FLambda _ -&gt;
    let (_,ty,bd) = destFLambda mk_clos hd in
    let variances = infer_fterm CONV infos variances ty [] in
    infer_fterm CONV infos variances bd []
  | FProd (_,dom,codom,e) -&gt;
    let variances = infer_fterm CONV infos variances dom [] in
    infer_fterm cv_pb infos variances (mk_clos (Esubst.subs_lift e) codom) []
  | FInd (ind, u) -&gt;
    let variances =
      if Instance.is_empty u then variances
      else
        let nargs = stack_args_size stk in
        infer_inductive_instance cv_pb (info_env (fst infos)) variances ind nargs u
    in
    infer_stack infos variances stk
  | FConstruct (ctor,u) -&gt;
    let variances =
      if Instance.is_empty u then variances
      else
        let nargs = stack_args_size stk in
        infer_constructor_instance_eq (info_env (fst infos)) variances ctor nargs u
    in
    infer_stack infos variances stk
  | FFix ((_,(_,tys,cl)),e) | FCoFix ((_,(_,tys,cl)),e) -&gt;
    let n = Array.length cl in
    let variances = infer_vect infos variances (Array.map (mk_clos e) tys) in
    let le = Esubst.subs_liftn n e in
    let variances = infer_vect infos variances (Array.map (mk_clos le) cl) in
    infer_stack infos variances stk

  (* Removed by whnf *)
  | FLOCKED | FCaseT _ | FLetIn _ | FApp _ | FLIFT _ | FCLOS _ -&gt; assert false

and infer_stack infos variances (stk:CClosure.stack) =
  match stk with
  | [] -&gt; variances
  | z :: stk -&gt;
    let open CClosure in
    let variances = match z with
      | Zapp v -&gt; infer_vect infos variances v
      | Zproj _ -&gt; variances
      | Zfix (fx,a) -&gt;
        let variances = infer_fterm CONV infos variances fx [] in
        infer_stack infos variances a
      | ZcaseT (_, p, br, e) -&gt;
        let variances = infer_fterm CONV infos variances (mk_clos e p) [] in
        infer_vect infos variances (Array.map (mk_clos e) br)
      | Zshift _ -&gt; variances
      | Zupdate _ -&gt; variances
      | Zprimitive (_,_,rargs,kargs) -&gt;
        let variances = List.fold_left (fun variances c -&gt; infer_fterm CONV infos variances c []) variances rargs in
        let variances = List.fold_left (fun variances (_,c) -&gt; infer_fterm CONV infos variances c []) variances kargs in
        variances
    in
    infer_stack infos variances stk

and infer_vect infos variances v =
  Array.fold_left (fun variances c -&gt; infer_fterm CONV infos variances c []) variances v

let infer_term cv_pb env variances c =
  let open CClosure in
  let infos = (create_clos_infos all env, create_tab ()) in
  infer_fterm cv_pb infos variances (CClosure.inject c) []

let infer_arity_constructor is_arity env variances arcn =
  let infer_typ typ (env,variances) =
    match typ with
    | Context.Rel.Declaration.LocalAssum (_, typ') -&gt;
      (Environ.push_rel typ env, infer_term CUMUL env variances typ')
    | Context.Rel.Declaration.LocalDef _ -&gt; assert false
  in
  let typs, codom = Reduction.dest_prod env arcn in
  let env, variances = Context.Rel.fold_outside infer_typ typs ~init:(env, variances) in
  (* If we have Inductive foo@{i j} : ... -&gt; Type@{i} := C : ... -&gt; foo Type@{j}
     i is irrelevant, j is invariant. *)
  if not is_arity then infer_term CUMUL env variances codom else variances

open Entries

let infer_inductive_core env params entries uctx =
  let uarray = Instance.to_array @@ UContext.instance uctx in
  if Array.is_empty uarray then raise TrivialVariance;
  let env = Environ.push_context uctx env in
  let variances =
    Array.fold_left (fun variances u -&gt; LMap.add u IrrelevantI variances)
      LMap.empty uarray
  in
  let env, _ = Typeops.check_context env params in
  let variances = List.fold_left (fun variances entry -&gt;
      let variances = infer_arity_constructor true
          env variances entry.mind_entry_arity
      in
      List.fold_left (infer_arity_constructor false env)
        variances entry.mind_entry_lc)
      variances
      entries
  in
  Array.map (fun u -&gt; match LMap.find u variances with
      | exception Not_found -&gt; Invariant
      | IrrelevantI -&gt; Irrelevant
      | CovariantI -&gt; Covariant)
    uarray

let infer_inductive env mie =
  let open Entries in
  let params = mie.mind_entry_params in
  let entries = mie.mind_entry_inds in
  let variances =
    match mie.mind_entry_variance with
    | None -&gt; None
    | Some _ -&gt;
      let uctx = match mie.mind_entry_universes with
        | Monomorphic_entry _ -&gt; assert false
        | Polymorphic_entry (_,uctx) -&gt; uctx
      in
      try Some (infer_inductive_core env params entries uctx)
      with TrivialVariance -&gt; Some (Array.make (UContext.size uctx) Invariant)
  in
  { mie with mind_entry_variance = variances }

let dummy_variance = let open Entries in function
  | Monomorphic_entry _ -&gt; assert false
  | Polymorphic_entry (_,uctx) -&gt; Array.make (UContext.size uctx) Irrelevant
</pre>
          </div>
          <div class="col-md-6">
            <code>inferCumulativity.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Reduction.

Import Declarations.

Import Constr.

Import Univ.

Import Univ.Variance.

Import Util.

Inductive inferred : Type :=
| IrrelevantI : inferred
| CovariantI : inferred.

Definition maybe_trivial {A : Type} (variances : Univ.LMap.t A)
  : Univ.LMap.t A :=
  if Univ.LMap.is_empty variances then
    Stdlib.raise TrivialVariance
  else
    variances.

Definition infer_level_eq {A : Type}
  (u : Univ.LMap.key) (variances : Univ.LMap.t A) : Univ.LMap.t A :=
  maybe_trivial (Univ.LMap.remove u variances).

Definition infer_level_leq
  (u : Univ.LMap.key) (variances : Univ.LMap.t inferred)
  : Univ.LMap.t inferred :=
  Univ.LMap.update u
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt; None
      | (Some CovariantI) as x =&gt; x
      | Some IrrelevantI =&gt; Some CovariantI
      end) variances.

Definition infer_generic_instance_eq {A : Type}
  (variances : Univ.LMap.t A) (u : Univ.Instance.t) : Univ.LMap.t A :=
  Util.Array.(CArray.ExtS.fold_left)
    (fun variances =&gt; fun u =&gt; infer_level_eq u variances) variances
    (Univ.Instance.to_array u).

Definition infer_cumulative_ind_instance
  (cv_pb : Reduction.conv_pb) (mind_variance : array Univ.Variance.t)
  (variances : Univ.LMap.t inferred) (u : Univ.Instance.t)
  : Univ.LMap.t inferred :=
  Util.Array.(CArray.ExtS.fold_left2)
    (fun variances =&gt;
      fun varu =&gt;
        fun u =&gt;
          match (cv_pb, varu) with
          | (_, Irrelevant) =&gt; variances
          | (_, Invariant) | (CONV, Covariant) =&gt; infer_level_eq u variances
          | (CUMUL, Covariant) =&gt; infer_level_leq u variances
          end) variances mind_variance (Univ.Instance.to_array u).

Definition infer_inductive_instance
  (cv_pb : Reduction.conv_pb) (env : Environ.env)
  (variances : Univ.LMap.t inferred) (ind : Names.MutInd.t * Z) (nargs : Int.t)
  (u : Univ.Instance.t) : Univ.LMap.t inferred :=
  let mind := Environ.lookup_mind (fst ind) env in
  match mind_variance mind with
  | None =&gt; infer_generic_instance_eq variances u
  | Some mind_variance =&gt;
    if
      negb
        (Int.equal
          (Reduction.inductive_cumulativity_arguments (mind, (snd ind))) nargs)
      then
      infer_generic_instance_eq variances u
    else
      infer_cumulative_ind_instance cv_pb mind_variance variances u
  end.

Definition infer_constructor_instance_eq {A : Type}
  (env : Environ.env) (variances : Univ.LMap.t A)
  (function_parameter : (Names.MutInd.t * Z) * Z)
  : Int.t -&gt; Univ.Instance.t -&gt; Univ.LMap.t A :=
  match function_parameter with
  | ((mi, ind), ctor) =&gt;
    fun nargs =&gt;
      fun u =&gt;
        let mind := Environ.lookup_mind mi env in
        match mind_variance mind with
        | None =&gt; infer_generic_instance_eq variances u
        | Some _ =&gt;
          if
            negb
              (Int.equal
                (Reduction.constructor_cumulativity_arguments (mind, ind, ctor))
                nargs) then
            infer_generic_instance_eq variances u
          else
            variances
        end
  end.

Definition infer_sort
  (cv_pb : Reduction.conv_pb) (variances : Univ.LMap.t inferred) (s : Sorts.t)
  : Univ.LMap.t inferred :=
  match cv_pb with
  | CONV =&gt;
    Univ.LSet.fold infer_level_eq (Univ.Universe.levels (Sorts.univ_of_sort s))
      variances
  | CUMUL =&gt;
    Univ.LSet.fold infer_level_leq (Univ.Universe.levels (Sorts.univ_of_sort s))
      variances
  end.

Definition infer_table_key {A B : Type}
  (variances : Univ.LMap.t A) (c : Names.tableKey (B * Univ.Instance.t))
  : Univ.LMap.t A :=
  match c with
  | ConstKey (_, u) =&gt; infer_generic_instance_eq variances u
  | VarKey _ | RelKey _ =&gt; variances
  end.

Definition whd_stack
  (function_parameter : CClosure.clos_infos * CClosure.clos_tab)
  : CClosure.fconstr -&gt; CClosure.stack -&gt; CClosure.fconstr * CClosure.stack :=
  match function_parameter with
  | (infos, tab) =&gt; fun hd =&gt; fun stk =&gt; CClosure.whd_stack infos tab hd stk
  end.

Fixpoint infer_fterm
  (cv_pb : Reduction.conv_pb) (infos : CClosure.clos_infos * CClosure.clos_tab)
  (variances : Univ.LMap.t inferred) (hd : CClosure.fconstr)
  (stk : CClosure.stack) : Univ.LMap.t inferred :=
  Control.check_for_interrupt tt;
  match whd_stack infos hd stk with
  | (hd, stk) =&gt;
    match CClosure.fterm_of hd with
    | FAtom a =&gt;
      match Constr.kind a with
      | Sort s =&gt; infer_sort cv_pb variances s
      | Meta _ =&gt; infer_stack infos variances stk
      | _ =&gt; false
      end
    | FEvar (_, args) e =&gt;
      let variances := infer_stack infos variances stk in
      infer_vect infos variances
        (Util.Array.(CArray.ExtS.map) (CClosure.mk_clos e) args)
    | FRel _ =&gt; infer_stack infos variances stk
    | FInt _ =&gt; infer_stack infos variances stk
    | FFlex fl =&gt;
      let variances := infer_table_key variances fl in
      infer_stack infos variances stk
    | FProj _ c =&gt;
      let variances := infer_fterm CONV infos variances c [] in
      infer_stack infos variances stk
    | FLambda _ _ _ _ =&gt;
      match CClosure.destFLambda CClosure.mk_clos hd with
      | (_, ty, bd) =&gt;
        let variances := infer_fterm CONV infos variances ty [] in
        infer_fterm CONV infos variances bd []
      end
    | FProd _ dom codom e =&gt;
      let variances := infer_fterm CONV infos variances dom [] in
      infer_fterm cv_pb infos variances
        (CClosure.mk_clos (Esubst.subs_lift e) codom) []
    | FInd (ind, u) =&gt;
      let variances :=
        if Univ.Instance.is_empty u then
          variances
        else
          let nargs := CClosure.stack_args_size stk in
          infer_inductive_instance cv_pb (CClosure.info_env (fst infos))
            variances ind nargs u in
      infer_stack infos variances stk
    | FConstruct (ctor, u) =&gt;
      let variances :=
        if Univ.Instance.is_empty u then
          variances
        else
          let nargs := CClosure.stack_args_size stk in
          infer_constructor_instance_eq (CClosure.info_env (fst infos))
            variances ctor nargs u in
      infer_stack infos variances stk
    | FFix (_, (_, tys, cl)) e | FCoFix (_, (_, tys, cl)) e =&gt;
      let n := Util.Array.(CArray.ExtS.length) cl in
      let variances :=
        infer_vect infos variances
          (Util.Array.(CArray.ExtS.map) (CClosure.mk_clos e) tys) in
      let le := Esubst.subs_liftn n e in
      let variances :=
        infer_vect infos variances
          (Util.Array.(CArray.ExtS.map) (CClosure.mk_clos le) cl) in
      infer_stack infos variances stk
    |
      FLOCKED | FCaseT _ _ _ _ _ | FLetIn _ _ _ _ _ | FApp _ _ | FLIFT _ _ |
        FCLOS _ _ =&gt; false
    end
  end

with infer_stack
  (infos : CClosure.clos_infos * CClosure.clos_tab)
  (variances : Univ.LMap.t inferred) (stk : CClosure.stack)
  : Univ.LMap.t inferred :=
  match stk with
  | [] =&gt; variances
  | cons z stk =&gt;
    let variances :=
      match z with
      | Zapp v =&gt; infer_vect infos variances v
      | Zproj _ =&gt; variances
      | Zfix fx a =&gt;
        let variances := infer_fterm CONV infos variances fx [] in
        infer_stack infos variances a
      | ZcaseT _ p br e =&gt;
        let variances :=
          infer_fterm CONV infos variances (CClosure.mk_clos e p) [] in
        infer_vect infos variances
          (Util.Array.(CArray.ExtS.map) (CClosure.mk_clos e) br)
      | Zshift _ =&gt; variances
      | Zupdate _ =&gt; variances
      | Zprimitive _ _ rargs kargs =&gt;
        let variances :=
          Util.List.(CList.ExtS.fold_left)
            (fun variances =&gt; fun c =&gt; infer_fterm CONV infos variances c [])
            variances rargs in
        let variances :=
          Util.List.(CList.ExtS.fold_left)
            (fun variances =&gt;
              fun function_parameter =&gt;
                match function_parameter with
                | (_, c) =&gt; infer_fterm CONV infos variances c []
                end) variances kargs in
        variances
      end in
    infer_stack infos variances stk
  end

with infer_vect
  (infos : CClosure.clos_infos * CClosure.clos_tab)
  (variances : Univ.LMap.t inferred) (v : array CClosure.fconstr)
  : Univ.LMap.t inferred :=
  Util.Array.(CArray.ExtS.fold_left)
    (fun variances =&gt; fun c =&gt; infer_fterm CONV infos variances c []) variances
    v.

Definition infer_term
  (cv_pb : Reduction.conv_pb) (env : Environ.env)
  (variances : Univ.LMap.t inferred) (c : Constr.constr)
  : Univ.LMap.t inferred :=
  let infos :=
    ((CClosure.create_clos_infos None CClosure.all env),
      (CClosure.create_tab tt)) in
  infer_fterm cv_pb infos variances (CClosure.inject c) [].

Definition infer_arity_constructor
  (is_arity : bool) (env : Environ.env) (variances : Univ.LMap.t inferred)
  (arcn : Constr.types) : Univ.LMap.t inferred :=
  let infer_typ
    (typ : Constr.rel_declaration) (function_parameter :
    Environ.env * (Univ.LMap.t inferred))
    : Environ.env * (Univ.LMap.t inferred) :=
    match function_parameter with
    | (env, variances) =&gt;
      match typ with
      | Context.Rel.Declaration.LocalAssum _ typ' =&gt;
        ((Environ.push_rel typ env), (infer_term CUMUL env variances typ'))
      | Context.Rel.Declaration.LocalDef _ _ _ =&gt; false
      end
    end in
  match Reduction.dest_prod env arcn with
  | (typs, codom) =&gt;
    match Context.Rel.fold_outside infer_typ typs (env, variances) with
    | (env, variances) =&gt;
      if negb is_arity then
        infer_term CUMUL env variances codom
      else
        variances
    end
  end.

Import Entries.

Definition infer_inductive_core
  (env : Environ.env) (params : Constr.rel_context)
  (entries : list Entries.one_inductive_entry) (uctx : Univ.UContext.t)
  : array Univ.Variance.t :=
  let uarray := apply Univ.Instance.to_array (Univ.UContext.instance uctx) in
  if Util.Array.(CArray.ExtS.is_empty) uarray then
    Stdlib.raise TrivialVariance
  else
    tt;
  let env := Environ.push_context None uctx env in
  let variances :=
    Util.Array.(CArray.ExtS.fold_left)
      (fun variances =&gt; fun u =&gt; Univ.LMap.add u IrrelevantI variances)
      Univ.LMap.empty uarray in
  match Typeops.check_context env params with
  | (env, _) =&gt;
    let variances :=
      Util.List.(CList.ExtS.fold_left)
        (fun variances =&gt;
          fun entry =&gt;
            let variances :=
              infer_arity_constructor true env variances
                (mind_entry_arity entry) in
            Util.List.(CList.ExtS.fold_left) (infer_arity_constructor false env)
              variances (mind_entry_lc entry)) variances entries in
    Util.Array.(CArray.ExtS.map)
      (fun u =&gt;
        match Univ.LMap.find u variances with
        | IrrelevantI =&gt; Irrelevant
        | CovariantI =&gt; Covariant
        end) uarray
  end.

Definition infer_inductive
  (env : Environ.env) (mie : Entries.mutual_inductive_entry)
  : Entries.mutual_inductive_entry :=
  let params := mind_entry_params mie in
  let entries := mind_entry_inds mie in
  let variances :=
    match mind_entry_variance mie with
    | None =&gt; None
    | Some _ =&gt;
      let uctx :=
        match mind_entry_universes mie with
        | Monomorphic_entry _ =&gt; false
        | Polymorphic_entry _ uctx =&gt; uctx
        end in
      try
    end in
  record.

Definition dummy_variance (function_parameter : Entries.universes_entry)
  : array Univ.Variance.t :=
  match function_parameter with
  | Monomorphic_entry _ =&gt; false
  | Polymorphic_entry _ uctx =&gt;
    Util.Array.(CArray.ExtS.make) (Univ.UContext.size uctx) Irrelevant
  end.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="mod_subst" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>mod_subst.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Claudio Sacerdoti from contents of term.ml, names.ml and
   new support for constant inlining in functor application, Nov 2004 *)
(* Optimizations and bug fixes by √âlie Soubiran, from Feb 2008 *)

(* This file provides types and functions for managing name
   substitution in module constructions *)

open Pp
open Util
open Names
open Constr

(* For Inline, the int is an inlining level, and the constr (if present)
   is the term into which we should inline. *)

type delta_hint =
  | Inline of int * constr Univ.univ_abstracted option
  | Equiv of KerName.t

(* NB: earlier constructor Prefix_equiv of ModPath.t
   is now stored in a separate table, see Deltamap.t below *)

module Deltamap = struct
  type t = ModPath.t MPmap.t * delta_hint KNmap.t
  let empty = MPmap.empty, KNmap.empty
  let is_empty (mm, km) =
    MPmap.is_empty mm &amp;&amp; KNmap.is_empty km
  let add_kn kn hint (mm,km) = (mm,KNmap.add kn hint km)
  let add_mp mp mp' (mm,km) = (MPmap.add mp mp' mm, km)
  let find_mp mp map = MPmap.find mp (fst map)
  let find_kn kn map = KNmap.find kn (snd map)
  let mem_mp mp map = MPmap.mem mp (fst map)
  let fold_kn f map i = KNmap.fold f (snd map) i
  let fold fmp fkn (mm,km) i =
    MPmap.fold fmp mm (KNmap.fold fkn km i)
  let join map1 map2 = fold add_mp add_kn map1 map2
end

(* Invariant: in the [delta_hint] map, an [Equiv] should only
   relate [KerName.t] with the same label (and section dirpath). *)

type delta_resolver = Deltamap.t

let empty_delta_resolver = Deltamap.empty

module Umap :
  sig
    type 'a t
    val empty : 'a t
    val is_empty : 'a t -&gt; bool
    val add_mbi : MBId.t -&gt; 'a -&gt; 'a t -&gt; 'a t
    val add_mp : ModPath.t -&gt; 'a -&gt; 'a t -&gt; 'a t
    val find : ModPath.t -&gt; 'a t -&gt; 'a
    val join : 'a t -&gt; 'a t -&gt; 'a t
    val fold : (ModPath.t -&gt; 'a -&gt; 'b -&gt; 'b) -&gt; 'a t -&gt; 'b -&gt; 'b
  end = struct
  type 'a t = 'a MPmap.t
  let empty = MPmap.empty
  let is_empty m = MPmap.is_empty m
  let add_mbi mbi x m = MPmap.add (MPbound mbi) x m
  let add_mp mp x m = MPmap.add mp x m
  let find = MPmap.find
  let fold = MPmap.fold
  let join map1 map2 = fold add_mp map1 map2
end

type substitution = (ModPath.t * delta_resolver) Umap.t

let empty_subst = Umap.empty

let is_empty_subst = Umap.is_empty

(* &lt;debug&gt; *)

let string_of_hint = function
  | Inline (_,Some _) -&gt; &quot;inline(Some _)&quot;
  | Inline _ -&gt; &quot;inline()&quot;
  | Equiv kn -&gt; KerName.to_string kn

let debug_string_of_delta resolve =
  let kn_to_string kn hint l =
    (KerName.to_string kn ^ &quot;=&gt;&quot; ^ string_of_hint hint) :: l
  in
  let mp_to_string mp mp' l =
    (ModPath.to_string mp ^ &quot;=&gt;&quot; ^ ModPath.to_string mp') :: l
  in
  let l = Deltamap.fold mp_to_string kn_to_string resolve [] in
  String.concat &quot;, &quot; (List.rev l)

let list_contents sub =
  let one_pair (mp,reso) = (ModPath.to_string mp,debug_string_of_delta reso) in
  let mp_one_pair mp0 p l = (ModPath.to_string mp0, one_pair p)::l in
  Umap.fold mp_one_pair sub []

let debug_string_of_subst sub =
  let l = List.map (fun (s1,(s2,s3)) -&gt; s1^&quot;|-&gt;&quot;^s2^&quot;[&quot;^s3^&quot;]&quot;)
    (list_contents sub)
  in
  &quot;{&quot; ^ String.concat &quot;; &quot; l ^ &quot;}&quot;

let debug_pr_delta resolve =
  str (debug_string_of_delta resolve)

let debug_pr_subst sub =
  let l = list_contents sub in
  let f (s1,(s2,s3)) = hov 2 (str s1 ++ spc () ++ str &quot;|-&gt; &quot; ++ str s2 ++
			      spc () ++ str &quot;[&quot; ++ str s3 ++ str &quot;]&quot;)
  in
  str &quot;{&quot; ++ hov 2 (prlist_with_sep pr_comma f l) ++ str &quot;}&quot;

(* &lt;/debug&gt; *)

(** Extending a [delta_resolver] *)

let add_inline_delta_resolver kn (lev,oc) = Deltamap.add_kn kn (Inline (lev,oc))

let add_kn_delta_resolver kn kn' =
  assert (Label.equal (KerName.label kn) (KerName.label kn'));
  Deltamap.add_kn kn (Equiv kn')

let add_mp_delta_resolver mp1 mp2 = Deltamap.add_mp mp1 mp2

(** Extending a [substitution] without sequential composition *)

let add_mbid mbid mp resolve s = Umap.add_mbi mbid (mp,resolve) s
let add_mp mp1 mp2 resolve s = Umap.add_mp mp1 (mp2,resolve) s

let map_mbid mbid mp resolve = add_mbid mbid mp resolve empty_subst
let map_mp mp1 mp2 resolve = add_mp mp1 mp2 resolve empty_subst

let mp_in_delta mp = Deltamap.mem_mp mp

let kn_in_delta kn resolver =
  try
    match Deltamap.find_kn kn resolver with
      | Equiv _ -&gt; true
      | Inline _ -&gt; false
  with Not_found -&gt; false

let con_in_delta con resolver = kn_in_delta (Constant.user con) resolver
let mind_in_delta mind resolver = kn_in_delta (MutInd.user mind) resolver

let mp_of_delta resolve mp =
 try Deltamap.find_mp mp resolve with Not_found -&gt; mp

let find_prefix resolve mp =
  let rec sub_mp = function
    | MPdot(mp,l) as mp_sup -&gt;
	(try Deltamap.find_mp mp_sup resolve
	 with Not_found -&gt; MPdot(sub_mp mp,l))
    | p -&gt; Deltamap.find_mp p resolve
  in
  try sub_mp mp with Not_found -&gt; mp

(** Applying a resolver to a kernel name *)

exception Change_equiv_to_inline of (int * constr Univ.univ_abstracted)

let solve_delta_kn resolve kn =
  try
    match Deltamap.find_kn kn resolve with
      | Equiv kn1 -&gt; kn1
      | Inline (lev, Some c) -&gt;	raise (Change_equiv_to_inline (lev,c))
      | Inline (_, None) -&gt; raise Not_found
  with Not_found -&gt;
    let mp,l = KerName.repr kn in
    let new_mp = find_prefix resolve mp in
    if mp == new_mp then
      kn
    else
      KerName.make new_mp l

let kn_of_delta resolve kn =
  try solve_delta_kn resolve kn
  with Change_equiv_to_inline _ -&gt; kn

(** Try a 1st resolver, and then a 2nd in case it had no effect *)

let kn_of_deltas resolve1 resolve2 kn =
  let kn' = kn_of_delta resolve1 kn in
  if kn' == kn then kn_of_delta resolve2 kn else kn'

let constant_of_delta_kn resolve kn =
  Constant.make kn (kn_of_delta resolve kn)

let constant_of_deltas_kn resolve1 resolve2 kn =
  Constant.make kn (kn_of_deltas resolve1 resolve2 kn)

let mind_of_delta_kn resolve kn =
  MutInd.make kn (kn_of_delta resolve kn)

let mind_of_deltas_kn resolve1 resolve2 kn =
  MutInd.make kn (kn_of_deltas resolve1 resolve2 kn)

let inline_of_delta inline resolver =
  match inline with
    | None -&gt; []
    | Some inl_lev -&gt;
      let extract kn hint l =
	match hint with
	  | Inline (lev,_) -&gt; if lev &lt;= inl_lev then (lev,kn)::l else l
	  | _ -&gt; l
      in
      Deltamap.fold_kn extract resolver []

let search_delta_inline resolve kn1 kn2 =
  let find kn = match Deltamap.find_kn kn resolve with
    | Inline (_,o) -&gt; o
    | Equiv _ -&gt; raise Not_found
  in
  try find kn1
  with Not_found -&gt;
    if kn1 == kn2 then None
    else
      try find kn2
      with Not_found -&gt; None

let subst_mp0 sub mp = (* 's like subst *)
 let rec aux mp =
  match mp with
    | MPfile _ | MPbound _ -&gt; Umap.find mp sub
    | MPdot (mp1,l) as mp2 -&gt;
	begin
          try Umap.find mp2 sub
	  with Not_found -&gt;
	    let mp1',resolve = aux mp1 in
	    MPdot (mp1',l),resolve
	end
 in
 try Some (aux mp) with Not_found -&gt; None

let subst_mp sub mp =
 match subst_mp0 sub mp with
    None -&gt; mp
  | Some (mp',_) -&gt; mp'

let subst_kn_delta sub kn =
 let mp,l = KerName.repr kn in
  match subst_mp0 sub mp with
     Some (mp',resolve) -&gt;
      solve_delta_kn resolve (KerName.make mp' l)
   | None -&gt; kn


let subst_kn sub kn =
 let mp,l = KerName.repr kn in
  match subst_mp0 sub mp with
     Some (mp',_) -&gt;
      (KerName.make mp' l)
   | None -&gt; kn

exception No_subst

let subst_dual_mp sub mp1 mp2 =
  let o1 = subst_mp0 sub mp1 in
  let o2 = if mp1 == mp2 then o1 else subst_mp0 sub mp2 in
  match o1, o2 with
    | None, None -&gt; raise No_subst
    | Some (mp1',resolve), None -&gt; mp1', mp2, resolve, true
    | None, Some (mp2',resolve) -&gt; mp1, mp2', resolve, false
    | Some (mp1',_), Some (mp2',resolve) -&gt; mp1', mp2', resolve, false

let progress f x ~orelse =
  let y = f x in
  if y != x then y else orelse

let subst_mind sub mind =
  let mpu,l = MutInd.repr2 mind in
  let mpc = KerName.modpath (MutInd.canonical mind) in
  try
    let mpu,mpc,resolve,user = subst_dual_mp sub mpu mpc in
    let knu = KerName.make mpu l in
    let knc = if mpu == mpc then knu else KerName.make mpc l in
    let knc' =
      progress (kn_of_delta resolve) (if user then knu else knc) ~orelse:knc
    in
    MutInd.make knu knc'
  with No_subst -&gt; mind

let subst_ind sub (ind,i as indi) =
  let ind' = subst_mind sub ind in
    if ind' == ind then indi else ind',i

let subst_pind sub (ind,u) =
  (subst_ind sub ind, u)

let subst_con0 sub cst =
  let mpu,l = Constant.repr2 cst in
  let mpc = KerName.modpath (Constant.canonical cst) in
  let mpu,mpc,resolve,user = subst_dual_mp sub mpu mpc in
  let knu = KerName.make mpu l in
  let knc = if mpu == mpc then knu else KerName.make mpc l in
  match search_delta_inline resolve knu knc with
    | Some t -&gt;
      (* In case of inlining, discard the canonical part (cf #2608) *)
      Constant.make1 knu, Some t
    | None -&gt;
      let knc' =
        progress (kn_of_delta resolve) (if user then knu else knc) ~orelse:knc
      in
      let cst' = Constant.make knu knc' in
      cst', None

let subst_con sub cst =
  try subst_con0 sub cst
  with No_subst -&gt; cst, None

let subst_pcon sub (con,u as pcon) =
  try let con', _can = subst_con0 sub con in
	con',u
  with No_subst -&gt; pcon

let subst_constant sub con =
  try fst (subst_con0 sub con)
  with No_subst -&gt; con

let subst_proj_repr sub p =
  Projection.Repr.map (subst_mind sub) p

let subst_proj sub p =
  Projection.map (subst_mind sub) p

let subst_retro_action subst action =
  let open Retroknowledge in
  match action with
  | Register_ind(prim,ind) -&gt;
    let ind' = subst_ind subst ind in
    if ind == ind' then action else Register_ind(prim, ind')
  | Register_type(prim,c) -&gt;
    let c' = subst_constant subst c in
    if c == c' then action else Register_type(prim, c')

(* Here the semantics is completely unclear.
   What does &quot;Hint Unfold t&quot; means when &quot;t&quot; is a parameter?
   Does the user mean &quot;Unfold X.t&quot; or does she mean &quot;Unfold y&quot;
   where X.t is later on instantiated with y? I choose the first
   interpretation (i.e. an evaluable reference is never expanded). *)
let subst_evaluable_reference subst = function
  | EvalVarRef id -&gt; EvalVarRef id
  | EvalConstRef kn -&gt; EvalConstRef (subst_constant subst kn)

let rec map_kn f f' c =
  let func = map_kn f f' in
    match kind c with
      | Const kn -&gt; (try f' kn with No_subst -&gt; c)
      | Proj (p,t) -&gt; 
          let p' = Projection.map f p in
	  let t' = func t in
	    if p' == p &amp;&amp; t' == t then c
	    else mkProj (p', t')
      | Ind ((kn,i),u) -&gt;
	  let kn' = f kn in
	  if kn'==kn then c else mkIndU ((kn',i),u)
      | Construct (((kn,i),j),u) -&gt;
	  let kn' = f kn in
	  if kn'==kn then c else mkConstructU (((kn',i),j),u)
      | Case (ci,p,ct,l) -&gt;
	  let ci_ind =
            let (kn,i) = ci.ci_ind in
	    let kn' = f kn in
	    if kn'==kn then ci.ci_ind else kn',i
	  in
	  let p' = func p in
	  let ct' = func ct in
          let l' = Array.Smart.map func l in
	    if (ci.ci_ind==ci_ind &amp;&amp; p'==p
		&amp;&amp; l'==l &amp;&amp; ct'==ct)then c
	    else
	      mkCase ({ci with ci_ind = ci_ind},
		      p',ct', l')
      | Cast (ct,k,t) -&gt;
	  let ct' = func ct in
	  let t'= func t in
	    if (t'==t &amp;&amp; ct'==ct) then c
	    else mkCast (ct', k, t')
      | Prod (na,t,ct) -&gt;
	  let ct' = func ct in
	  let t'= func t in
	    if (t'==t &amp;&amp; ct'==ct) then c
	    else mkProd (na, t', ct')
      | Lambda (na,t,ct) -&gt;
	  let ct' = func ct in
	  let t'= func t in
	    if (t'==t &amp;&amp; ct'==ct) then c
	    else mkLambda (na, t', ct')
      | LetIn (na,b,t,ct) -&gt;
	  let ct' = func ct in
	  let t'= func t in
	  let b'= func b in
	    if (t'==t &amp;&amp; ct'==ct &amp;&amp; b==b') then c
	    else mkLetIn (na, b', t', ct')
      | App (ct,l) -&gt;
	  let ct' = func ct in
          let l' = Array.Smart.map func l in
	    if (ct'== ct &amp;&amp; l'==l) then c
	    else mkApp (ct',l')
      | Evar (e,l) -&gt;
          let l' = Array.Smart.map func l in
	    if (l'==l) then c
	    else mkEvar (e,l')
      | Fix (ln,(lna,tl,bl)) -&gt;
          let tl' = Array.Smart.map func tl in
          let bl' = Array.Smart.map func bl in
	    if (bl == bl'&amp;&amp; tl == tl') then c
	    else mkFix (ln,(lna,tl',bl'))
      | CoFix(ln,(lna,tl,bl)) -&gt;
          let tl' = Array.Smart.map func tl in
          let bl' = Array.Smart.map func bl in
	    if (bl == bl'&amp;&amp; tl == tl') then c
	    else mkCoFix (ln,(lna,tl',bl'))
      | _ -&gt; c

let subst_mps sub c =
  let subst_pcon_term sub (con,u) =
    let con', can = subst_con0 sub con in
    match can with
    | None -&gt; mkConstU (con',u)
    | Some t -&gt; Vars.univ_instantiate_constr u t
  in
  if is_empty_subst sub then c
  else map_kn (subst_mind sub) (subst_pcon_term sub) c

let rec replace_mp_in_mp mpfrom mpto mp =
  match mp with
    | _ when ModPath.equal mp mpfrom -&gt; mpto
    | MPdot (mp1,l) -&gt;
	let mp1' = replace_mp_in_mp mpfrom mpto mp1 in
	  if mp1 == mp1' then mp
	  else MPdot (mp1',l)
    | _ -&gt; mp

let replace_mp_in_kn mpfrom mpto kn =
 let mp,l = KerName.repr kn in
  let mp'' = replace_mp_in_mp mpfrom mpto mp in
    if mp==mp'' then kn
    else KerName.make mp'' l

let rec mp_in_mp mp mp1 =
  match mp1 with
    | _ when ModPath.equal mp1 mp -&gt; true
    | MPdot (mp2,_l) -&gt; mp_in_mp mp mp2
    | _ -&gt; false

let subset_prefixed_by mp resolver =
  let mp_prefix mkey mequ rslv =
    if mp_in_mp mp mkey then Deltamap.add_mp mkey mequ rslv else rslv
  in
  let kn_prefix kn hint rslv =
    match hint with
      | Inline _ -&gt; rslv
      | Equiv _ -&gt;
	if mp_in_mp mp (KerName.modpath kn) then Deltamap.add_kn kn hint rslv else rslv
  in
  Deltamap.fold mp_prefix kn_prefix resolver empty_delta_resolver

let subst_dom_delta_resolver subst resolver =
  let mp_apply_subst mkey mequ rslv =
    Deltamap.add_mp (subst_mp subst mkey) mequ rslv
  in
  let kn_apply_subst kkey hint rslv =
    Deltamap.add_kn (subst_kn subst kkey) hint rslv
  in
  Deltamap.fold mp_apply_subst kn_apply_subst resolver empty_delta_resolver

let subst_mp_delta sub mp mkey =
 match subst_mp0 sub mp with
    None -&gt; empty_delta_resolver,mp
  | Some (mp',resolve) -&gt;
      let mp1 = find_prefix resolve mp' in
      let resolve1 = subset_prefixed_by mp1 resolve in
      (subst_dom_delta_resolver
	 (map_mp mp1 mkey empty_delta_resolver) resolve1),mp1

let gen_subst_delta_resolver dom subst resolver =
  let mp_apply_subst mkey mequ rslv =
    let mkey' = if dom then subst_mp subst mkey else mkey in
    let rslv',mequ' = subst_mp_delta subst mequ mkey in
    Deltamap.join rslv' (Deltamap.add_mp mkey' mequ' rslv)
  in
  let kn_apply_subst kkey hint rslv =
    let kkey' = if dom then subst_kn subst kkey else kkey in
    let hint' = match hint with
      | Equiv kequ -&gt;
	  (try Equiv (subst_kn_delta subst kequ)
	   with Change_equiv_to_inline (lev,c) -&gt; Inline (lev,Some c))
      | Inline (lev,Some t) -&gt; Inline (lev,Some (Univ.map_univ_abstracted (subst_mps subst) t))
      | Inline (_,None) -&gt; hint
    in
    Deltamap.add_kn kkey' hint' rslv
  in
  Deltamap.fold mp_apply_subst kn_apply_subst resolver empty_delta_resolver

let subst_codom_delta_resolver = gen_subst_delta_resolver false
let subst_dom_codom_delta_resolver = gen_subst_delta_resolver true

let update_delta_resolver resolver1 resolver2 =
  let mp_apply_rslv mkey mequ rslv =
    Deltamap.add_mp mkey (find_prefix resolver2 mequ) rslv
  in
  let kn_apply_rslv kkey hint1 rslv =
    let hint = match hint1 with
      | Equiv kequ -&gt;
	(try Equiv (solve_delta_kn resolver2 kequ)
	 with Change_equiv_to_inline (lev,c) -&gt; Inline (lev, Some c))
      | Inline (_,Some _) -&gt; hint1
      | Inline (_,None) -&gt;
        (try Deltamap.find_kn kkey resolver2 with Not_found -&gt; hint1)
    in
    Deltamap.add_kn kkey hint rslv
  in
  Deltamap.fold mp_apply_rslv kn_apply_rslv resolver1 resolver2

let add_delta_resolver resolver1 resolver2 =
  if Deltamap.is_empty resolver2 then
    resolver1
  else
    update_delta_resolver resolver1 resolver2

let substition_prefixed_by k mp subst =
  let mp_prefixmp kmp (mp_to,reso) sub =
    if mp_in_mp mp kmp &amp;&amp; not (ModPath.equal mp kmp) then
      let new_key = replace_mp_in_mp mp k kmp in
      Umap.add_mp new_key (mp_to,reso) sub
    else sub
  in
  Umap.fold mp_prefixmp subst empty_subst

let join subst1 subst2 =
  let apply_subst mpk add (mp,resolve) res =
    let mp',resolve' =
      match subst_mp0 subst2 mp with
	| None -&gt; mp, None
	| Some (mp',resolve') -&gt;  mp', Some resolve' in
    let resolve'' =
      match resolve' with
        | Some res -&gt;
	    add_delta_resolver
	      (subst_dom_codom_delta_resolver subst2 resolve) res
	| None -&gt;
	    subst_codom_delta_resolver subst2 resolve
    in
    let prefixed_subst = substition_prefixed_by mpk mp' subst2 in
    Umap.join prefixed_subst (add (mp',resolve'') res)
  in
  let mp_apply_subst mp = apply_subst mp (Umap.add_mp mp) in
  let subst = Umap.fold mp_apply_subst subst1 empty_subst in
  Umap.join subst2 subst

type 'a substituted = {
  mutable subst_value : 'a;
  mutable subst_subst : substitution list;
}

let from_val x = { subst_value = x; subst_subst = []; }

let force fsubst r = match r.subst_subst with
| [] -&gt; r.subst_value
| s -&gt;
  let subst = List.fold_left join empty_subst (List.rev s) in
  let x = fsubst subst r.subst_value in
  let () = r.subst_subst &lt;- [] in
  let () = r.subst_value &lt;- x in
  x

let subst_substituted s r = { r with subst_subst = s :: r.subst_subst; }

let force_constr = force subst_mps
let subst_constr = subst_substituted

(* debug *)
let repr_substituted r = match r.subst_subst with
| [] -&gt; None, r.subst_value
| s -&gt; Some s, r.subst_value
</pre>
          </div>
          <div class="col-md-6">
            <code>mod_subst.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Pp.

Import Util.

Import Names.

Import Constr.

Inductive delta_hint : Type :=
| Inline : Z -&gt; (option (Univ.univ_abstracted Constr.constr)) -&gt; delta_hint
| Equiv : Names.KerName.t -&gt; delta_hint.

Module Deltamap.
  Definition t := (Names.MPmap.t Names.ModPath.t) * (Names.KNmap.t delta_hint).
  
  Definition empty {A B : Type} : (Names.MPmap.t A) * (Names.KNmap.t B) :=
    (Names.MPmap.empty, Names.KNmap.empty).
  
  Definition is_empty {A B : Type}
    (function_parameter : (Names.MPmap.t A) * (Names.KNmap.t B)) : bool :=
    match function_parameter with
    | (mm, km) =&gt; andb (Names.MPmap.is_empty mm) (Names.KNmap.is_empty km)
    end.
  
  Definition add_kn {A B : Type}
    (kn : Names.KNmap.key) (hint : A)
    (function_parameter : B * (Names.KNmap.t A)) : B * (Names.KNmap.t A) :=
    match function_parameter with
    | (mm, km) =&gt; (mm, (Names.KNmap.add kn hint km))
    end.
  
  Definition add_mp {A B : Type}
    (mp : Names.MPmap.key) (mp' : A)
    (function_parameter : (Names.MPmap.t A) * B) : (Names.MPmap.t A) * B :=
    match function_parameter with
    | (mm, km) =&gt; ((Names.MPmap.add mp mp' mm), km)
    end.
  
  Definition find_mp {A B : Type}
    (mp : Names.MPmap.key) (map : (Names.MPmap.t A) * B) : A :=
    Names.MPmap.find mp (fst map).
  
  Definition find_kn {A B : Type}
    (kn : Names.KNmap.key) (map : A * (Names.KNmap.t B)) : B :=
    Names.KNmap.find kn (snd map).
  
  Definition mem_mp {A B : Type}
    (mp : Names.MPmap.key) (map : (Names.MPmap.t A) * B) : bool :=
    Names.MPmap.mem mp (fst map).
  
  Definition fold_kn {A B C : Type}
    (f : Names.KNmap.key -&gt; A -&gt; B -&gt; B) (map : C * (Names.KNmap.t A)) (i : B)
    : B := Names.KNmap.fold f (snd map) i.
  
  Definition fold {A B C : Type}
    (fmp : Names.MPmap.key -&gt; A -&gt; B -&gt; B)
    (fkn : Names.KNmap.key -&gt; C -&gt; B -&gt; B)
    (function_parameter : (Names.MPmap.t A) * (Names.KNmap.t C)) : B -&gt; B :=
    match function_parameter with
    | (mm, km) =&gt; fun i =&gt; Names.MPmap.fold fmp mm (Names.KNmap.fold fkn km i)
    end.
  
  Definition join {A B : Type}
    (map1 : (Names.MPmap.t A) * (Names.KNmap.t B))
    (map2 : (Names.MPmap.t A) * (Names.KNmap.t B))
    : (Names.MPmap.t A) * (Names.KNmap.t B) := fold add_mp add_kn map1 map2.
End Deltamap.

Definition delta_resolver := Deltamap.t.

Definition empty_delta_resolver {A B : Type}
  : (Names.MPmap.t A) * (Names.KNmap.t B) := Deltamap.empty.

Module Umap.
  Definition t (a : Type) := Names.MPmap.t a.
  
  Definition empty {A : Type} : Names.MPmap.t A := Names.MPmap.empty.
  
  Definition is_empty {A : Type} (m : Names.MPmap.t A) : bool :=
    Names.MPmap.is_empty m.
  
  Definition add_mbi {A : Type}
    (mbi : Names.MBId.t) (x : A) (m : Names.MPmap.t A) : Names.MPmap.t A :=
    Names.MPmap.add (MPbound mbi) x m.
  
  Definition add_mp {A : Type}
    (mp : Names.MPmap.key) (x : A) (m : Names.MPmap.t A) : Names.MPmap.t A :=
    Names.MPmap.add mp x m.
  
  Definition find {A : Type} : Names.MPmap.key -&gt; (Names.MPmap.t A) -&gt; A :=
    Names.MPmap.find.
  
  Definition fold {A B : Type}
    : (Names.MPmap.key -&gt; A -&gt; B -&gt; B) -&gt; (Names.MPmap.t A) -&gt; B -&gt; B :=
    Names.MPmap.fold.
  
  Definition join {A : Type} (map1 : Names.MPmap.t A) (map2 : Names.MPmap.t A)
    : Names.MPmap.t A := fold add_mp map1 map2.
End Umap.

Definition substitution := Umap.t (Names.ModPath.t * delta_resolver).

Definition empty_subst {A : Type} : Umap.t A := Umap.empty.

Definition is_empty_subst {A : Type} : (Umap.t A) -&gt; bool := Umap.is_empty.

Definition string_of_hint (function_parameter : delta_hint) : string :=
  match function_parameter with
  | Inline _ (Some _) =&gt; &quot;inline(Some _)&quot; % string
  | Inline _ _ =&gt; &quot;inline()&quot; % string
  | Equiv kn =&gt; Names.KerName.to_string kn
  end.

Definition debug_string_of_delta
  (resolve : (Names.MPmap.t Names.ModPath.t) * (Names.KNmap.t delta_hint))
  : string :=
  let kn_to_string (kn : Names.KerName.t) (hint : delta_hint) (l : list string)
    : list string :=
    cons
      (String.append (Names.KerName.to_string kn)
        (String.append &quot;=&gt;&quot; % string (string_of_hint hint))) l in
  let mp_to_string
    (mp : Names.ModPath.t) (mp' : Names.ModPath.t) (l : list string)
    : list string :=
    cons
      (String.append (Names.ModPath.to_string mp)
        (String.append &quot;=&gt;&quot; % string (Names.ModPath.to_string mp'))) l in
  let l := Deltamap.fold mp_to_string kn_to_string resolve [] in
  Util.String.(CString.ExtS.concat) &quot;, &quot; % string (Util.List.(CList.ExtS.rev) l).

Definition list_contents
  (sub :
    Umap.t
      (Names.ModPath.t *
        ((Names.MPmap.t Names.ModPath.t) * (Names.KNmap.t delta_hint))))
  : list (string * (string * string)) :=
  let one_pair
    (function_parameter :
    Names.ModPath.t *
      ((Names.MPmap.t Names.ModPath.t) * (Names.KNmap.t delta_hint)))
    : string * string :=
    match function_parameter with
    | (mp, reso) =&gt; ((Names.ModPath.to_string mp), (debug_string_of_delta reso))
    end in
  let mp_one_pair
    (mp0 : Names.ModPath.t) (p :
    Names.ModPath.t *
      ((Names.MPmap.t Names.ModPath.t) * (Names.KNmap.t delta_hint))) (l :
    list (string * (string * string))) : list (string * (string * string)) :=
    cons ((Names.ModPath.to_string mp0), (one_pair p)) l in
  Umap.fold mp_one_pair sub [].

Definition debug_string_of_subst
  (sub :
    Umap.t
      (Names.ModPath.t *
        ((Names.MPmap.t Names.ModPath.t) * (Names.KNmap.t delta_hint))))
  : string :=
  let l :=
    Util.List.(CList.ExtS.map)
      (fun function_parameter =&gt;
        match function_parameter with
        | (s1, (s2, s3)) =&gt;
          String.append s1
            (String.append &quot;|-&gt;&quot; % string
              (String.append s2
                (String.append &quot;[&quot; % string (String.append s3 &quot;]&quot; % string))))
        end) (list_contents sub) in
  String.append &quot;{&quot; % string
    (String.append (Util.String.(CString.ExtS.concat) &quot;; &quot; % string l)
      &quot;}&quot; % string).

Definition debug_pr_delta
  (resolve : (Names.MPmap.t Names.ModPath.t) * (Names.KNmap.t delta_hint))
  : Pp.t := Pp.str (debug_string_of_delta resolve).

Definition debug_pr_subst
  (sub :
    Umap.t
      (Names.ModPath.t *
        ((Names.MPmap.t Names.ModPath.t) * (Names.KNmap.t delta_hint))))
  : Pp.t :=
  let l := list_contents sub in
  let f (function_parameter : string * (string * string)) : Pp.t :=
    match function_parameter with
    | (s1, (s2, s3)) =&gt;
      Pp.hov 2
        (Pp.op_plus_plus
          (Pp.op_plus_plus
            (Pp.op_plus_plus
              (Pp.op_plus_plus
                (Pp.op_plus_plus
                  (Pp.op_plus_plus (Pp.op_plus_plus (Pp.str s1) (Pp.spc tt))
                    (Pp.str &quot;|-&gt; &quot; % string)) (Pp.str s2)) (Pp.spc tt))
              (Pp.str &quot;[&quot; % string)) (Pp.str s3)) (Pp.str &quot;]&quot; % string))
    end in
  Pp.op_plus_plus
    (Pp.op_plus_plus (Pp.str &quot;{&quot; % string)
      (Pp.hov 2 (Pp.prlist_with_sep Pp.pr_comma f l))) (Pp.str &quot;}&quot; % string).

Definition add_inline_delta_resolver {A : Type}
  (kn : Names.KNmap.key)
  (function_parameter : Z * (option (Univ.univ_abstracted Constr.constr)))
  : (A * (Names.KNmap.t delta_hint)) -&gt; A * (Names.KNmap.t delta_hint) :=
  match function_parameter with
  | (lev, oc) =&gt; Deltamap.add_kn kn (Inline lev oc)
  end.

Definition add_kn_delta_resolver {A : Type}
  (kn : Names.KNmap.key) (kn' : Names.KerName.t)
  : (A * (Names.KNmap.t delta_hint)) -&gt; A * (Names.KNmap.t delta_hint) :=
  Names.Label.equal (Names.KerName.label kn) (Names.KerName.label kn');
  Deltamap.add_kn kn (Equiv kn').

Definition add_mp_delta_resolver {A B : Type} (mp1 : Names.MPmap.key) (mp2 : A)
  : ((Names.MPmap.t A) * B) -&gt; (Names.MPmap.t A) * B := Deltamap.add_mp mp1 mp2.

Definition add_mbid {A B : Type}
  (mbid : Names.MBId.t) (mp : A) (resolve : B) (s : Umap.t (A * B))
  : Umap.t (A * B) := Umap.add_mbi mbid (mp, resolve) s.

Definition add_mp {A B : Type}
  (mp1 : Names.ModPath.t) (mp2 : A) (resolve : B) (s : Umap.t (A * B))
  : Umap.t (A * B) := Umap.add_mp mp1 (mp2, resolve) s.

Definition map_mbid {A B : Type} (mbid : Names.MBId.t) (mp : A) (resolve : B)
  : Umap.t (A * B) := add_mbid mbid mp resolve empty_subst.

Definition map_mp {A B : Type} (mp1 : Names.ModPath.t) (mp2 : A) (resolve : B)
  : Umap.t (A * B) := add_mp mp1 mp2 resolve empty_subst.

Definition mp_in_delta {A B : Type} (mp : Names.MPmap.key)
  : ((Names.MPmap.t A) * B) -&gt; bool := Deltamap.mem_mp mp.

Definition kn_in_delta {A : Type}
  (kn : Names.KNmap.key) (resolver : A * (Names.KNmap.t delta_hint)) : bool :=
  try.

Definition con_in_delta {A : Type}
  (con : Names.Constant.t) (resolver : A * (Names.KNmap.t delta_hint)) : bool :=
  kn_in_delta (Names.Constant.user con) resolver.

Definition mind_in_delta {A : Type}
  (mind : Names.MutInd.t) (resolver : A * (Names.KNmap.t delta_hint)) : bool :=
  kn_in_delta (Names.MutInd.user mind) resolver.

Definition mp_of_delta {A : Type}
  (resolve : (Names.MPmap.t Names.MPmap.key) * A) (mp : Names.MPmap.key)
  : Names.MPmap.key := try.

Definition find_prefix {A : Type}
  (resolve : (Names.MPmap.t Names.module_path) * A) (mp : Names.module_path)
  : Names.module_path :=
  let fix sub_mp (function_parameter : Names.module_path) : Names.module_path :=
    match function_parameter with
    | (MPdot mp l) as mp_sup =&gt; try
    | p =&gt; Deltamap.find_mp p resolve
    end in
  try.

Definition solve_delta_kn
  (resolve : (Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))
  (kn : Names.KNmap.key) : Names.KerName.t := try.

Definition kn_of_delta
  (resolve : (Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))
  (kn : Names.KNmap.key) : Names.KerName.t := try.

Definition kn_of_deltas
  (resolve1 : (Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))
  (resolve2 : (Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))
  (kn : Names.KNmap.key) : Names.KerName.t :=
  let kn' := kn_of_delta resolve1 kn in
  if Stdlib.op_eq_eq kn' kn then
    kn_of_delta resolve2 kn
  else
    kn'.

Definition constant_of_delta_kn
  (resolve : (Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))
  (kn : Names.KNmap.key) : Names.Constant.t :=
  Names.Constant.make kn (kn_of_delta resolve kn).

Definition constant_of_deltas_kn
  (resolve1 : (Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))
  (resolve2 : (Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))
  (kn : Names.KNmap.key) : Names.Constant.t :=
  Names.Constant.make kn (kn_of_deltas resolve1 resolve2 kn).

Definition mind_of_delta_kn
  (resolve : (Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))
  (kn : Names.KNmap.key) : Names.MutInd.t :=
  Names.MutInd.make kn (kn_of_delta resolve kn).

Definition mind_of_deltas_kn
  (resolve1 : (Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))
  (resolve2 : (Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))
  (kn : Names.KNmap.key) : Names.MutInd.t :=
  Names.MutInd.make kn (kn_of_deltas resolve1 resolve2 kn).

Definition inline_of_delta {A : Type}
  (inline : option Z) (resolver : A * (Names.KNmap.t delta_hint))
  : list (Z * Names.KNmap.key) :=
  match inline with
  | None =&gt; []
  | Some inl_lev =&gt;
    let extract {B : Type} (kn : B) (hint : delta_hint) (l : list (Z * B))
      : list (Z * B) :=
      match hint with
      | Inline lev _ =&gt;
        if OCaml.Stdlib.le lev inl_lev then
          cons (lev, kn) l
        else
          l
      | _ =&gt; l
      end in
    Deltamap.fold_kn extract resolver []
  end.

Definition search_delta_inline {A : Type}
  (resolve : A * (Names.KNmap.t delta_hint)) (kn1 : Names.KNmap.key)
  (kn2 : Names.KNmap.key) : option (Univ.univ_abstracted Constr.constr) :=
  let find (kn : Names.KNmap.key)
    : option (Univ.univ_abstracted Constr.constr) :=
    match Deltamap.find_kn kn resolve with
    | Inline _ o =&gt; o
    | Equiv _ =&gt; Stdlib.raise OCaml.Not_found
    end in
  try.

Definition subst_mp0 {A : Type}
  (sub : Umap.t (Names.module_path * A)) (mp : Names.module_path)
  : option (Names.module_path * A) :=
  let fix aux (mp : Names.module_path) : Names.module_path * A :=
    match mp with
    | MPfile _ | MPbound _ =&gt; Umap.find mp sub
    | (MPdot mp1 l) as mp2 =&gt; try
    end in
  try.

Definition subst_mp {A : Type}
  (sub : Umap.t (Names.module_path * A)) (mp : Names.module_path)
  : Names.module_path :=
  match subst_mp0 sub mp with
  | None =&gt; mp
  | Some (mp', _) =&gt; mp'
  end.

Definition subst_kn_delta
  (sub :
    Umap.t
      (Names.module_path *
        ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))))
  (kn : Names.KerName.t) : Names.KerName.t :=
  match Names.KerName.repr kn with
  | (mp, l) =&gt;
    match subst_mp0 sub mp with
    | Some (mp', resolve) =&gt; solve_delta_kn resolve (Names.KerName.make mp' l)
    | None =&gt; kn
    end
  end.

Definition subst_kn {A : Type}
  (sub : Umap.t (Names.module_path * A)) (kn : Names.KerName.t)
  : Names.KerName.t :=
  match Names.KerName.repr kn with
  | (mp, l) =&gt;
    match subst_mp0 sub mp with
    | Some (mp', _) =&gt; Names.KerName.make mp' l
    | None =&gt; kn
    end
  end.

Definition subst_dual_mp {A : Type}
  (sub : Umap.t (Names.module_path * A)) (mp1 : Names.module_path)
  (mp2 : Names.module_path)
  : Names.module_path * Names.module_path * A * bool :=
  let o1 := subst_mp0 sub mp1 in
  let o2 :=
    if Stdlib.op_eq_eq mp1 mp2 then
      o1
    else
      subst_mp0 sub mp2 in
  match (o1, o2) with
  | (None, None) =&gt; Stdlib.raise No_subst
  | (Some (mp1', resolve), None) =&gt; (mp1', mp2, resolve, true)
  | (None, Some (mp2', resolve)) =&gt; (mp1, mp2', resolve, false)
  | (Some (mp1', _), Some (mp2', resolve)) =&gt; (mp1', mp2', resolve, false)
  end.

Definition progress {A : Type} (f : A -&gt; A) (x : A) (orelse : A) : A :=
  let y := f x in
  if Stdlib.op_exclamation_eq y x then
    y
  else
    orelse.

Definition subst_mind
  (sub :
    Umap.t
      (Names.module_path *
        ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))))
  (mind : Names.MutInd.t) : Names.MutInd.t :=
  match Names.MutInd.repr2 mind with
  | (mpu, l) =&gt;
    let mpc := Names.KerName.modpath (Names.MutInd.canonical mind) in
    try
  end.

Definition subst_ind {A : Type}
  (sub :
    Umap.t
      (Names.module_path *
        ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))))
  (function_parameter : Names.MutInd.t * A) : Names.MutInd.t * A :=
  match function_parameter with
  | (ind, i) as indi =&gt;
    let ind' := subst_mind sub ind in
    if Stdlib.op_eq_eq ind' ind then
      indi
    else
      (ind', i)
  end.

Definition subst_pind {A B : Type}
  (sub :
    Umap.t
      (Names.module_path *
        ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))))
  (function_parameter : (Names.MutInd.t * A) * B) : (Names.MutInd.t * A) * B :=
  match function_parameter with
  | (ind, u) =&gt; ((subst_ind sub ind), u)
  end.

Definition subst_con0
  (sub :
    Umap.t
      (Names.module_path *
        ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))))
  (cst : Names.Constant.t)
  : Names.Constant.t * (option (Univ.univ_abstracted Constr.constr)) :=
  match Names.Constant.repr2 cst with
  | (mpu, l) =&gt;
    let mpc := Names.KerName.modpath (Names.Constant.canonical cst) in
    match subst_dual_mp sub mpu mpc with
    | (mpu, mpc, resolve, user) =&gt;
      let knu := Names.KerName.make mpu l in
      let knc :=
        if Stdlib.op_eq_eq mpu mpc then
          knu
        else
          Names.KerName.make mpc l in
      match search_delta_inline resolve knu knc with
      | Some t =&gt; ((Names.Constant.make1 knu), (Some t))
      | None =&gt;
        let knc' :=
          progress (kn_of_delta resolve)
            (if user then
              knu
            else
              knc) knc in
        let cst' := Names.Constant.make knu knc' in
        (cst', None)
      end
    end
  end.

Definition subst_con
  (sub :
    Umap.t
      (Names.module_path *
        ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))))
  (cst : Names.Constant.t)
  : Names.Constant.t * (option (Univ.univ_abstracted Constr.constr)) := try.

Definition subst_pcon {A : Type}
  (sub :
    Umap.t
      (Names.module_path *
        ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))))
  (function_parameter : Names.Constant.t * A) : Names.Constant.t * A :=
  match function_parameter with
  | (con, u) as pcon =&gt; try
  end.

Definition subst_constant
  (sub :
    Umap.t
      (Names.module_path *
        ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))))
  (con : Names.Constant.t) : Names.Constant.t := try.

Definition subst_proj_repr
  (sub :
    Umap.t
      (Names.module_path *
        ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))))
  (p : Names.Projection.Repr.t) : Names.Projection.Repr.t :=
  Names.Projection.Repr.map (subst_mind sub) p.

Definition subst_proj
  (sub :
    Umap.t
      (Names.module_path *
        ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))))
  (p : Names.Projection.t) : Names.Projection.t :=
  Names.Projection.map (subst_mind sub) p.

Definition subst_retro_action
  (subst :
    Umap.t
      (Names.module_path *
        ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))))
  (action : Retroknowledge.action) : Retroknowledge.action :=
  match action with
  | Register_ind prim ind =&gt;
    let ind' := subst_ind subst ind in
    if Stdlib.op_eq_eq ind ind' then
      action
    else
      Register_ind prim ind'
  | Register_type prim c =&gt;
    let c' := subst_constant subst c in
    if Stdlib.op_eq_eq c c' then
      action
    else
      Register_type prim c'
  end.

Definition subst_evaluable_reference
  (subst :
    Umap.t
      (Names.module_path *
        ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))))
  (function_parameter : Names.evaluable_global_reference)
  : Names.evaluable_global_reference :=
  match function_parameter with
  | EvalVarRef id =&gt; EvalVarRef id
  | EvalConstRef kn =&gt; EvalConstRef (subst_constant subst kn)
  end.

Fixpoint map_kn
  (f : Names.MutInd.t -&gt; Names.MutInd.t)
  (f' : (Names.Constant.t * Univ.Instance.t) -&gt; Constr.constr)
  (c : Constr.constr) : Constr.constr :=
  let func := map_kn f f' in
  match Constr.kind c with
  | Const kn =&gt; try
  | Proj p t =&gt;
    let p' := Names.Projection.map f p in
    let t' := func t in
    if andb (Stdlib.op_eq_eq p' p) (Stdlib.op_eq_eq t' t) then
      c
    else
      Constr.mkProj (p', t')
  | Ind ((kn, i), u) =&gt;
    let kn' := f kn in
    if Stdlib.op_eq_eq kn' kn then
      c
    else
      Constr.mkIndU ((kn', i), u)
  | Construct (((kn, i), j), u) =&gt;
    let kn' := f kn in
    if Stdlib.op_eq_eq kn' kn then
      c
    else
      Constr.mkConstructU (((kn', i), j), u)
  | Case ci p ct l =&gt;
    let ci_ind :=
      match ci_ind ci with
      | (kn, i) =&gt;
        let kn' := f kn in
        if Stdlib.op_eq_eq kn' kn then
          ci_ind ci
        else
          (kn', i)
      end in
    let p' := func p in
    let ct' := func ct in
    let l' := Util.Array.Smart.map func l in
    if
      andb (Stdlib.op_eq_eq (ci_ind ci) ci_ind)
        (andb (Stdlib.op_eq_eq p' p)
          (andb (Stdlib.op_eq_eq l' l) (Stdlib.op_eq_eq ct' ct))) then
      c
    else
      Constr.mkCase (record, p', ct', l')
  | Cast ct k t =&gt;
    let ct' := func ct in
    let t' := func t in
    if andb (Stdlib.op_eq_eq t' t) (Stdlib.op_eq_eq ct' ct) then
      c
    else
      Constr.mkCast (ct', k, t')
  | Prod na t ct =&gt;
    let ct' := func ct in
    let t' := func t in
    if andb (Stdlib.op_eq_eq t' t) (Stdlib.op_eq_eq ct' ct) then
      c
    else
      Constr.mkProd (na, t', ct')
  | Lambda na t ct =&gt;
    let ct' := func ct in
    let t' := func t in
    if andb (Stdlib.op_eq_eq t' t) (Stdlib.op_eq_eq ct' ct) then
      c
    else
      Constr.mkLambda (na, t', ct')
  | LetIn na b t ct =&gt;
    let ct' := func ct in
    let t' := func t in
    let b' := func b in
    if
      andb (Stdlib.op_eq_eq t' t)
        (andb (Stdlib.op_eq_eq ct' ct) (Stdlib.op_eq_eq b b')) then
      c
    else
      Constr.mkLetIn (na, b', t', ct')
  | App ct l =&gt;
    let ct' := func ct in
    let l' := Util.Array.Smart.map func l in
    if andb (Stdlib.op_eq_eq ct' ct) (Stdlib.op_eq_eq l' l) then
      c
    else
      Constr.mkApp (ct', l')
  | Evar (e, l) =&gt;
    let l' := Util.Array.Smart.map func l in
    if Stdlib.op_eq_eq l' l then
      c
    else
      Constr.mkEvar (e, l')
  | Fix (ln, (lna, tl, bl)) =&gt;
    let tl' := Util.Array.Smart.map func tl in
    let bl' := Util.Array.Smart.map func bl in
    if andb (Stdlib.op_eq_eq bl bl') (Stdlib.op_eq_eq tl tl') then
      c
    else
      Constr.mkFix (ln, (lna, tl', bl'))
  | CoFix (ln, (lna, tl, bl)) =&gt;
    let tl' := Util.Array.Smart.map func tl in
    let bl' := Util.Array.Smart.map func bl in
    if andb (Stdlib.op_eq_eq bl bl') (Stdlib.op_eq_eq tl tl') then
      c
    else
      Constr.mkCoFix (ln, (lna, tl', bl'))
  | _ =&gt; c
  end.

Definition subst_mps
  (sub :
    Umap.t
      (Names.module_path *
        ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))))
  (c : Constr.constr) : Constr.constr :=
  let subst_pcon_term
    (sub :
    Umap.t
      (Names.module_path *
        ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))))
    (function_parameter : Names.Constant.t * Univ.Instance.t) : Constr.constr :=
    match function_parameter with
    | (con, u) =&gt;
      match subst_con0 sub con with
      | (con', can) =&gt;
        match can with
        | None =&gt; Constr.mkConstU (con', u)
        | Some t =&gt; Vars.univ_instantiate_constr u t
        end
      end
    end in
  if is_empty_subst sub then
    c
  else
    map_kn (subst_mind sub) (subst_pcon_term sub) c.

Fixpoint replace_mp_in_mp
  (mpfrom : Names.ModPath.t) (mpto : Names.module_path) (mp : Names.module_path)
  : Names.module_path :=
  match mp with
  | MPdot mp1 l =&gt;
    let mp1' := replace_mp_in_mp mpfrom mpto mp1 in
    if Stdlib.op_eq_eq mp1 mp1' then
      mp
    else
      MPdot mp1' l
  | _ =&gt; mp
  end.

Definition replace_mp_in_kn
  (mpfrom : Names.ModPath.t) (mpto : Names.module_path) (kn : Names.KerName.t)
  : Names.KerName.t :=
  match Names.KerName.repr kn with
  | (mp, l) =&gt;
    let mp'' := replace_mp_in_mp mpfrom mpto mp in
    if Stdlib.op_eq_eq mp mp'' then
      kn
    else
      Names.KerName.make mp'' l
  end.

Fixpoint mp_in_mp (mp : Names.ModPath.t) (mp1 : Names.module_path) : bool :=
  match mp1 with
  | MPdot mp2 _l =&gt; mp_in_mp mp mp2
  | _ =&gt; false
  end.

Definition subset_prefixed_by {A : Type}
  (mp : Names.ModPath.t)
  (resolver : (Names.MPmap.t A) * (Names.KNmap.t delta_hint))
  : (Names.MPmap.t A) * (Names.KNmap.t delta_hint) :=
  let mp_prefix {B C : Type}
    (mkey : Names.module_path) (mequ : B) (rslv : (Names.MPmap.t B) * C)
    : (Names.MPmap.t B) * C :=
    if mp_in_mp mp mkey then
      Deltamap.add_mp mkey mequ rslv
    else
      rslv in
  let kn_prefix {B : Type}
    (kn : Names.KNmap.key) (hint : delta_hint) (rslv :
    B * (Names.KNmap.t delta_hint)) : B * (Names.KNmap.t delta_hint) :=
    match hint with
    | Inline _ _ =&gt; rslv
    | Equiv _ =&gt;
      if mp_in_mp mp (Names.KerName.modpath kn) then
        Deltamap.add_kn kn hint rslv
      else
        rslv
    end in
  Deltamap.fold mp_prefix kn_prefix resolver empty_delta_resolver.

Definition subst_dom_delta_resolver {A B C : Type}
  (subst : Umap.t (Names.module_path * A))
  (resolver : (Names.MPmap.t B) * (Names.KNmap.t C))
  : (Names.MPmap.t B) * (Names.KNmap.t C) :=
  let mp_apply_subst {D E : Type}
    (mkey : Names.module_path) (mequ : D) (rslv : (Names.MPmap.t D) * E)
    : (Names.MPmap.t D) * E :=
    Deltamap.add_mp (subst_mp subst mkey) mequ rslv in
  let kn_apply_subst {D E : Type}
    (kkey : Names.KerName.t) (hint : D) (rslv : E * (Names.KNmap.t D))
    : E * (Names.KNmap.t D) :=
    Deltamap.add_kn (subst_kn subst kkey) hint rslv in
  Deltamap.fold mp_apply_subst kn_apply_subst resolver empty_delta_resolver.

Definition subst_mp_delta
  (sub :
    Umap.t
      (Names.module_path *
        ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))))
  (mp : Names.module_path) (mkey : Names.module_path)
  : ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint)) *
    Names.module_path :=
  match subst_mp0 sub mp with
  | None =&gt; (empty_delta_resolver, mp)
  | Some (mp', resolve) =&gt;
    let mp1 := find_prefix resolve mp' in
    let resolve1 := subset_prefixed_by mp1 resolve in
    ((subst_dom_delta_resolver (map_mp mp1 mkey empty_delta_resolver) resolve1),
      mp1)
  end.

Definition gen_subst_delta_resolver
  (dom : bool)
  (subst :
    Umap.t
      (Names.module_path *
        ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))))
  (resolver : (Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))
  : (Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint) :=
  let mp_apply_subst
    (mkey : Names.module_path) (mequ : Names.module_path) (rslv :
    (Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))
    : (Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint) :=
    let mkey' :=
      if dom then
        subst_mp subst mkey
      else
        mkey in
    match subst_mp_delta subst mequ mkey with
    | (rslv', mequ') =&gt; Deltamap.join rslv' (Deltamap.add_mp mkey' mequ' rslv)
    end in
  let kn_apply_subst {A : Type}
    (kkey : Names.KNmap.key) (hint : delta_hint) (rslv :
    A * (Names.KNmap.t delta_hint)) : A * (Names.KNmap.t delta_hint) :=
    let kkey' :=
      if dom then
        subst_kn subst kkey
      else
        kkey in
    let hint' :=
      match hint with
      | Equiv kequ =&gt; try
      | Inline lev (Some t) =&gt;
        Inline lev (Some (Univ.map_univ_abstracted (subst_mps subst) t))
      | Inline _ None =&gt; hint
      end in
    Deltamap.add_kn kkey' hint' rslv in
  Deltamap.fold mp_apply_subst kn_apply_subst resolver empty_delta_resolver.

Definition subst_codom_delta_resolver
  : (Umap.t
    (Names.module_path *
      ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint)))) -&gt;
    ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint)) -&gt;
      (Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint) :=
  gen_subst_delta_resolver false.

Definition subst_dom_codom_delta_resolver
  : (Umap.t
    (Names.module_path *
      ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint)))) -&gt;
    ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint)) -&gt;
      (Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint) :=
  gen_subst_delta_resolver true.

Definition update_delta_resolver
  (resolver1 : (Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))
  (resolver2 : (Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))
  : (Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint) :=
  let mp_apply_rslv {A : Type}
    (mkey : Names.MPmap.key) (mequ : Names.module_path) (rslv :
    (Names.MPmap.t Names.module_path) * A)
    : (Names.MPmap.t Names.module_path) * A :=
    Deltamap.add_mp mkey (find_prefix resolver2 mequ) rslv in
  let kn_apply_rslv {A : Type}
    (kkey : Names.KNmap.key) (hint1 : delta_hint) (rslv :
    A * (Names.KNmap.t delta_hint)) : A * (Names.KNmap.t delta_hint) :=
    let hint :=
      match hint1 with
      | Equiv kequ =&gt; try
      | Inline _ (Some _) =&gt; hint1
      | Inline _ None =&gt; try
      end in
    Deltamap.add_kn kkey hint rslv in
  Deltamap.fold mp_apply_rslv kn_apply_rslv resolver1 resolver2.

Definition add_delta_resolver
  (resolver1 : (Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))
  (resolver2 : (Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))
  : (Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint) :=
  if Deltamap.is_empty resolver2 then
    resolver1
  else
    update_delta_resolver resolver1 resolver2.

Definition substition_prefixed_by {A B : Type}
  (k : Names.module_path) (mp : Names.ModPath.t) (subst : Umap.t (A * B))
  : Umap.t (A * B) :=
  let mp_prefixmp {C D : Type}
    (kmp : Names.module_path) (function_parameter : C * D)
    : (Umap.t (C * D)) -&gt; Umap.t (C * D) :=
    match function_parameter with
    | (mp_to, reso) =&gt;
      fun sub =&gt;
        if andb (mp_in_mp mp kmp) (negb (Names.ModPath.equal mp kmp)) then
          let new_key := replace_mp_in_mp mp k kmp in
          Umap.add_mp new_key (mp_to, reso) sub
        else
          sub
    end in
  Umap.fold mp_prefixmp subst empty_subst.

Definition join
  (subst1 :
    Umap.t
      (Names.module_path *
        ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))))
  (subst2 :
    Umap.t
      (Names.module_path *
        ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))))
  : Umap.t
    (Names.module_path *
      ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))) :=
  let apply_subst {A : Type}
    (mpk : Names.module_path) (add :
    (Names.module_path *
      ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))) -&gt;
      A -&gt;
        Umap.t
          (Names.module_path *
            ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))))
    (function_parameter :
    Names.module_path *
      ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint)))
    : A -&gt;
      Umap.t
        (Names.module_path *
          ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))) :=
    match function_parameter with
    | (mp, resolve) =&gt;
      fun res =&gt;
        match
          match subst_mp0 subst2 mp with
          | None =&gt; (mp, None)
          | Some (mp', resolve') =&gt; (mp', (Some resolve'))
          end with
        | (mp', resolve') =&gt;
          let resolve'' :=
            match resolve' with
            | Some res =&gt;
              add_delta_resolver (subst_dom_codom_delta_resolver subst2 resolve)
                res
            | None =&gt; subst_codom_delta_resolver subst2 resolve
            end in
          let prefixed_subst := substition_prefixed_by mpk mp' subst2 in
          Umap.join prefixed_subst (add (mp', resolve'') res)
        end
    end in
  let mp_apply_subst (mp : Names.module_path)
    : (Names.module_path *
      ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))) -&gt;
      (Umap.t
        (Names.module_path *
          ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint)))) -&gt;
        Umap.t
          (Names.module_path *
            ((Names.MPmap.t Names.module_path) * (Names.KNmap.t delta_hint))) :=
    apply_subst mp (Umap.add_mp mp) in
  let subst := Umap.fold mp_apply_subst subst1 empty_subst in
  Umap.join subst2 subst.

Record substituted {a : Type} := {
  subst_value : a;
  subst_subst : list substitution }.
Arguments substituted : clear implicits.

Definition from_val {A : Type} (x : A) : substituted A :=
  {| subst_value := x; subst_subst := [] |}.

Definition force {A : Type}
  (fsubst : (Umap.t (Names.module_path * delta_resolver)) -&gt; A -&gt; A)
  (r : substituted A) : A :=
  match subst_subst r with
  | [] =&gt; subst_value r
  | s =&gt;
    let subst :=
      Util.List.(CList.ExtS.fold_left) join empty_subst
        (Util.List.(CList.ExtS.rev) s) in
    let x := fsubst subst (subst_value r) in
    match set_field with
    | tt =&gt;
      match set_field with
      | tt =&gt; x
      end
    end
  end.

Definition subst_substituted {A : Type} (s : substitution) (r : substituted A)
  : substituted A := record.

Definition force_constr : (substituted Constr.constr) -&gt; Constr.constr :=
  force subst_mps.

Definition subst_constr {A : Type}
  : substitution -&gt; (substituted A) -&gt; substituted A := subst_substituted.

Definition repr_substituted {A : Type} (r : substituted A)
  : (option (list substitution)) * A :=
  match subst_subst r with
  | [] =&gt; (None, (subst_value r))
  | s =&gt; ((Some s), (subst_value r))
  end.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="mod_typing" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>mod_typing.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Jacek Chrzaszcz, Aug 2002 as part of the implementation of
   the Coq module system *)

(* This module provides the main functions for type-checking module
   declarations *)

open Util
open Names
open Declarations
open Entries
open Environ
open Modops
open Mod_subst

type 'alg translation =
  module_signature * 'alg * delta_resolver * Univ.ContextSet.t

let rec mp_from_mexpr = function
  | MEident mp -&gt; mp
  | MEapply (expr,_) -&gt; mp_from_mexpr expr
  | MEwith (expr,_) -&gt; mp_from_mexpr expr

let is_modular = function
  | SFBmodule _ | SFBmodtype _ -&gt; true
  | SFBconst _ | SFBmind _ -&gt; false

(** Split a [structure_body] at some label corresponding to
    a modular definition or not. *)

let split_struc k m struc =
  let rec split rev_before = function
    | [] -&gt; raise Not_found
    | (k',b)::after when Label.equal k k' &amp;&amp; (is_modular b) == (m : bool) -&gt;
      List.rev rev_before,b,after
    | h::tail -&gt; split (h::rev_before) tail
  in split [] struc

let discr_resolver mtb = match mtb.mod_type with
  | NoFunctor _ -&gt; mtb.mod_delta
  | MoreFunctor _ -&gt; empty_delta_resolver

let rec rebuild_mp mp l =
  match l with
  | []-&gt; mp
  | i::r -&gt; rebuild_mp (MPdot(mp,Label.of_id i)) r

let (+++) = Univ.ContextSet.union

let rec check_with_def env struc (idl,(c,ctx)) mp equiv =
  let lab,idl = match idl with
    | [] -&gt; assert false
    | id::idl -&gt; Label.of_id id, idl
  in
  try
    let modular = not (List.is_empty idl) in
    let before,spec,after = split_struc lab modular struc in
    let env' = Modops.add_structure mp before equiv env in
    if List.is_empty idl then
      (* Toplevel definition *)
      let cb = match spec with
        | SFBconst cb -&gt; cb
        | _ -&gt; error_not_a_constant lab
      in
      (* In the spirit of subtyping.check_constant, we accept
         any implementations of parameters and opaques terms,
         as long as they have the right type *)
      let c', univs, ctx' =
        match cb.const_universes, ctx with
        | Monomorphic _, None -&gt;
          let c',cst = match cb.const_body with
            | Undef _ | OpaqueDef _ -&gt;
              let j = Typeops.infer env' c in
              assert (j.uj_val == c); (* relevances should already be correct here *)
              let typ = cb.const_type in
              let cst' = Reduction.infer_conv_leq env' (Environ.universes env')
                  j.uj_type typ in
              j.uj_val, cst'
            | Def cs -&gt;
              let c' = Mod_subst.force_constr cs in
              c, Reduction.infer_conv env' (Environ.universes env') c c'
            | Primitive _ -&gt;
              error_incorrect_with_constraint lab
          in
          c', Monomorphic Univ.ContextSet.empty, cst
        | Polymorphic uctx, Some ctx -&gt;
          let () =
            if not (UGraph.check_subtype ~lbound:(Environ.universes_lbound env)
                      (Environ.universes env) uctx ctx) then
              error_incorrect_with_constraint lab
          in
          (** Terms are compared in a context with De Bruijn universe indices *)
          let env' = Environ.push_context ~strict:false (Univ.AUContext.repr uctx) env in
          let cst = match cb.const_body with
            | Undef _ | OpaqueDef _ -&gt;
              let j = Typeops.infer env' c in
              assert (j.uj_val == c); (* relevances should already be correct here *)
              let typ = cb.const_type in
              let cst' = Reduction.infer_conv_leq env' (Environ.universes env')
                  j.uj_type typ in
              cst'
            | Def cs -&gt;
              let c' = Mod_subst.force_constr cs in
              let cst' = Reduction.infer_conv env' (Environ.universes env') c c' in
              cst'
            | Primitive _ -&gt;
              error_incorrect_with_constraint lab
          in
          if not (Univ.Constraint.is_empty cst) then
            error_incorrect_with_constraint lab;
          c, Polymorphic ctx, Univ.Constraint.empty
        | _ -&gt; error_incorrect_with_constraint lab
      in
      let def = Def (Mod_subst.from_val c') in
      (*      let ctx' = Univ.UContext.make (newus, cst) in *)
      let cb' =
        { cb with
          const_body = def;
          const_universes = univs ;
          const_body_code = Option.map Cemitcodes.from_val
              (Cbytegen.compile_constant_body ~fail_on_error:false env' cb.const_universes def) }
      in
      before@(lab,SFBconst(cb'))::after, c', ctx'
    else
      (* Definition inside a sub-module *)
      let mb = match spec with
        | SFBmodule mb -&gt; mb
        | _ -&gt; error_not_a_module (Label.to_string lab)
      in
      begin match mb.mod_expr with
        | Abstract -&gt;
          let struc = Modops.destr_nofunctor mb.mod_type in
          let struc',c',cst =
            check_with_def env' struc (idl,(c,ctx)) (MPdot(mp,lab)) mb.mod_delta
          in
          let mb' = { mb with
                      mod_type = NoFunctor struc';
                      mod_type_alg = None }
          in
          before@(lab,SFBmodule mb')::after, c', cst
        | _ -&gt; error_generative_module_expected lab
      end
  with
  | Not_found -&gt; error_no_such_label lab
  | Reduction.NotConvertible -&gt; error_incorrect_with_constraint lab

let rec check_with_mod env struc (idl,mp1) mp equiv =
  let lab,idl = match idl with
    | [] -&gt; assert false
    | id::idl -&gt; Label.of_id id, idl
  in
  try
    let before,spec,after = split_struc lab true struc in
    let env' = Modops.add_structure mp before equiv env in
    let old = match spec with
      | SFBmodule mb -&gt; mb
      | _ -&gt; error_not_a_module (Label.to_string lab)
    in
    if List.is_empty idl then
      (* Toplevel module definition *)
      let mb_mp1 = lookup_module mp1 env in
      let mtb_mp1 = module_type_of_module mb_mp1 in
      let cst = match old.mod_expr with
        | Abstract -&gt;
          let mtb_old = module_type_of_module old in
          let chk_cst = Subtyping.check_subtypes env' mtb_mp1 mtb_old in
          Univ.ContextSet.add_constraints chk_cst old.mod_constraints
	| Algebraic (NoFunctor (MEident(mp'))) -&gt;
	  check_modpath_equiv env' mp1 mp';
	  old.mod_constraints
	| _ -&gt; error_generative_module_expected lab
      in
      let mp' = MPdot (mp,lab) in
      let new_mb = strengthen_and_subst_mb mb_mp1 mp' false in
      let new_mb' =
        { new_mb with
          mod_mp = mp';
          mod_expr = Algebraic (NoFunctor (MEident mp1));
          mod_constraints = cst }
      in
      let new_equiv = add_delta_resolver equiv new_mb.mod_delta in
      (* we propagate the new equality in the rest of the signature
         with the identity substitution accompanied by the new resolver*)
      let id_subst = map_mp mp' mp' new_mb.mod_delta in
      let new_after = subst_structure id_subst after in
      before@(lab,SFBmodule new_mb')::new_after, new_equiv, cst
    else
      (* Module definition of a sub-module *)
      let mp' = MPdot (mp,lab) in
      let old = match spec with
        | SFBmodule msb -&gt; msb
	| _ -&gt; error_not_a_module (Label.to_string lab)
      in
      begin match old.mod_expr with
      | Abstract -&gt;
        let struc = destr_nofunctor old.mod_type in
	let struc',equiv',cst =
          check_with_mod env' struc (idl,mp1) mp' old.mod_delta
        in
	let new_mb =
          { old with
            mod_type = NoFunctor struc';
            mod_type_alg = None;
            mod_delta = equiv' }
        in
	let new_equiv = add_delta_resolver equiv equiv' in
	let id_subst = map_mp mp' mp' equiv' in
        let new_after = subst_structure id_subst after in
	before@(lab,SFBmodule new_mb)::new_after, new_equiv, cst
      | Algebraic (NoFunctor (MEident mp0)) -&gt;
	let mpnew = rebuild_mp mp0 idl in
	check_modpath_equiv env' mpnew mp;
	before@(lab,spec)::after, equiv, Univ.ContextSet.empty
      | _ -&gt; error_generative_module_expected lab
      end
  with
  | Not_found -&gt; error_no_such_label lab
  | Reduction.NotConvertible -&gt; error_incorrect_with_constraint lab

let check_with env mp (sign,alg,reso,cst) = function
  |WithDef(idl, (c, ctx)) -&gt;
    let struc = destr_nofunctor sign in
    let struc', c', cst' = check_with_def env struc (idl, (c, ctx)) mp reso in
    let wd' = WithDef (idl, (c', ctx)) in
    NoFunctor struc', MEwith (alg,wd'), reso, Univ.ContextSet.add_constraints cst' cst
  |WithMod(idl,mp1) as wd -&gt;
    let struc = destr_nofunctor sign in
    let struc',reso',cst' = check_with_mod env struc (idl,mp1) mp reso in
    NoFunctor struc', MEwith (alg,wd), reso', cst+++cst'

let translate_apply env inl (sign,alg,reso,cst1) mp1 mkalg =
  let farg_id, farg_b, fbody_b = destr_functor sign in
  let mtb = module_type_of_module (lookup_module mp1 env) in
  let cst2 = Subtyping.check_subtypes env mtb farg_b in
  let mp_delta = discr_resolver mtb in
  let mp_delta = inline_delta_resolver env inl mp1 farg_id farg_b mp_delta in
  let subst = map_mbid farg_id mp1 mp_delta in
  let body = subst_signature subst fbody_b in
  let alg' = mkalg alg mp1 in
  let reso' = subst_codom_delta_resolver subst reso in
  body,alg',reso', Univ.ContextSet.add_constraints cst2 cst1

(** Translation of a module struct entry :
    - We translate to a module when a [module_path] is given,
      otherwise to a module type.
    - The first output is the expanded signature
    - The second output is the algebraic expression, kept for the extraction.
*)

let mk_alg_app alg arg = MEapply (alg,arg)

let rec translate_mse env mpo inl = function
  |MEident mp1 as me -&gt;
    let mb = match mpo with
      |Some mp -&gt; strengthen_and_subst_mb (lookup_module mp1 env) mp false
      |None -&gt;
        let mt = lookup_modtype mp1 env in
        module_body_of_type mt.mod_mp mt
    in
    mb.mod_type, me, mb.mod_delta, Univ.ContextSet.empty
  |MEapply (fe,mp1) -&gt;
    translate_apply env inl (translate_mse env mpo inl fe) mp1 mk_alg_app
  |MEwith(me, with_decl) -&gt;
    assert (mpo == None); (* No 'with' syntax for modules *)
    let mp = mp_from_mexpr me in
    check_with env mp (translate_mse env None inl me) with_decl

let mk_mod mp e ty cst reso =
  { mod_mp = mp;
    mod_expr = e;
    mod_type = ty;
    mod_type_alg = None;
    mod_constraints = cst;
    mod_delta = reso;
    mod_retroknowledge = ModBodyRK []; }

let mk_modtype mp ty cst reso =
  let mb = mk_mod mp Abstract ty cst reso in
  { mb with mod_expr = (); mod_retroknowledge = ModTypeRK }

let rec translate_mse_funct env mpo inl mse = function
  |[] -&gt;
    let sign,alg,reso,cst = translate_mse env mpo inl mse in
    sign, NoFunctor alg, reso, cst
  |(mbid, ty) :: params -&gt;
    let mp_id = MPbound mbid in
    let mtb = translate_modtype env mp_id inl ([],ty) in
    let env' = add_module_type mp_id mtb env in
    let sign,alg,reso,cst = translate_mse_funct env' mpo inl mse params in
    let alg' = MoreFunctor (mbid,mtb,alg) in
    MoreFunctor (mbid, mtb, sign), alg',reso, cst +++ mtb.mod_constraints

and translate_modtype env mp inl (params,mte) =
  let sign,alg,reso,cst = translate_mse_funct env None inl mte params in
  let mtb = mk_modtype (mp_from_mexpr mte) sign cst reso in
  let mtb' = subst_modtype_and_resolver mtb mp in
  { mtb' with mod_type_alg = Some alg }

(** [finalize_module] :
    from an already-translated (or interactive) implementation and
    an (optional) signature entry, produces a final [module_body] *)

let finalize_module env mp (sign,alg,reso,cst) restype = match restype with
  |None -&gt;
    let impl = match alg with Some e -&gt; Algebraic e | None -&gt; FullStruct in
    mk_mod mp impl sign cst reso
  |Some (params_mte,inl) -&gt;
    let res_mtb = translate_modtype env mp inl params_mte in
    let auto_mtb = mk_modtype mp sign Univ.ContextSet.empty reso in
    let cst' = Subtyping.check_subtypes env auto_mtb res_mtb in
    let impl = match alg with Some e -&gt; Algebraic e | None -&gt; Struct sign in
    { res_mtb with
      mod_mp = mp;
      mod_expr = impl;
      mod_retroknowledge = ModBodyRK [];
      (** cst from module body typing,
          cst' from subtyping,
          constraints from module type. *)
      mod_constraints =
        Univ.ContextSet.add_constraints cst' (cst +++ res_mtb.mod_constraints) }

let translate_module env mp inl = function
  |MType (params,ty) -&gt;
    let mtb = translate_modtype env mp inl (params,ty) in
    module_body_of_type mp mtb
  |MExpr (params,mse,oty) -&gt;
    let (sg,alg,reso,cst) = translate_mse_funct env (Some mp) inl mse params in
    let restype = Option.map (fun ty -&gt; ((params,ty),inl)) oty in
    finalize_module env mp (sg,Some alg,reso,cst) restype

(** We now forbid any Include of functors with restricted signatures.
    Otherwise, we could end with the creation of undesired axioms
    (see #3746). Note that restricted non-functorized modules are ok,
    thanks to strengthening. *)

let rec unfunct = function
  |NoFunctor me -&gt; me
  |MoreFunctor(_,_,me) -&gt; unfunct me

let rec forbid_incl_signed_functor env = function
  |MEapply(fe,_) -&gt; forbid_incl_signed_functor env fe
  |MEwith _ -&gt; assert false (* No 'with' syntax for modules *)
  |MEident mp1 -&gt;
    let mb = lookup_module mp1 env in
    match mb.mod_type, mb.mod_type_alg, mb.mod_expr with
    |MoreFunctor _, Some _, _ -&gt;
      (* functor + restricted signature = error *)
      error_include_restricted_functor mp1
    |MoreFunctor _, None, Algebraic me -&gt;
      (* functor, no signature yet, a definition which may be restricted *)
      forbid_incl_signed_functor env (unfunct me)
    |_ -&gt; ()

let rec translate_mse_inclmod env mp inl = function
  |MEident mp1 -&gt;
    let mb = strengthen_and_subst_mb (lookup_module mp1 env) mp true in
    let sign = clean_bounded_mod_expr mb.mod_type in
    sign,(),mb.mod_delta,Univ.ContextSet.empty
  |MEapply (fe,arg) -&gt;
    let ftrans = translate_mse_inclmod env mp inl fe in
    translate_apply env inl ftrans arg (fun _ _ -&gt; ())
  |MEwith _ -&gt; assert false (* No 'with' syntax for modules *)

let translate_mse_incl is_mod env mp inl me =
  if is_mod then
    let () = forbid_incl_signed_functor env me in
    translate_mse_inclmod env mp inl me
  else
    let mtb = translate_modtype env mp inl ([],me) in
    let sign = clean_bounded_mod_expr mtb.mod_type in
    sign,(),mtb.mod_delta,mtb.mod_constraints
</pre>
          </div>
          <div class="col-md-6">
            <code>mod_typing.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Util.

Import Names.

Import Declarations.

Import Entries.

Import Environ.

Import Modops.

Import Mod_subst.

Definition translation (alg : Type) :=
  Declarations.module_signature * alg * Mod_subst.delta_resolver *
    Univ.ContextSet.t.

Fixpoint mp_from_mexpr (function_parameter : Declarations.module_alg_expr)
  : Names.ModPath.t :=
  match function_parameter with
  | MEident mp =&gt; mp
  | MEapply expr _ =&gt; mp_from_mexpr expr
  | MEwith expr _ =&gt; mp_from_mexpr expr
  end.

Definition is_modular (function_parameter : Declarations.structure_field_body)
  : bool :=
  match function_parameter with
  | SFBmodule _ | SFBmodtype _ =&gt; true
  | SFBconst _ | SFBmind _ =&gt; false
  end.

Definition split_struc
  (k : Names.Label.t) (m : bool)
  (struc : list (Names.Label.t * Declarations.structure_field_body))
  : (list (Names.Label.t * Declarations.structure_field_body)) *
    Declarations.structure_field_body *
    (list (Names.Label.t * Declarations.structure_field_body)) :=
  let fix split
    (rev_before : list (Names.Label.t * Declarations.structure_field_body))
    (function_parameter :
    list (Names.Label.t * Declarations.structure_field_body))
    : (list (Names.Label.t * Declarations.structure_field_body)) *
      Declarations.structure_field_body *
      (list (Names.Label.t * Declarations.structure_field_body)) :=
    match function_parameter with
    | [] =&gt; Stdlib.raise OCaml.Not_found
    | cons (k', b) after =&gt; ((Util.List.(CList.ExtS.rev) rev_before), b, after)
    | cons h tail =&gt; split (cons h rev_before) tail
    end in
  split [] struc.

Definition discr_resolver {A : Type} (mtb : Declarations.generic_module_body A)
  : Mod_subst.delta_resolver :=
  match mod_type mtb with
  | NoFunctor _ =&gt; mod_delta mtb
  | MoreFunctor _ _ _ =&gt; Mod_subst.empty_delta_resolver
  end.

Fixpoint rebuild_mp (mp : Names.module_path) (l : list Names.Id.t)
  : Names.module_path :=
  match l with
  | [] =&gt; mp
  | cons i r =&gt; rebuild_mp (MPdot mp (Names.Label.of_id i)) r
  end.

Definition op_plus_plus_plus
  : Univ.ContextSet.t -&gt; Univ.ContextSet.t -&gt; Univ.ContextSet.t :=
  Univ.ContextSet.union.

Fixpoint check_with_def
  (env : Environ.env)
  (struc : list (Names.Label.t * Declarations.structure_field_body))
  (function_parameter :
    (list Names.Id.t) * (Constr.constr * (option Univ.AUContext.t)))
  : Names.ModPath.t -&gt;
    Mod_subst.delta_resolver -&gt;
      (list (Names.Label.t * Declarations.structure_field_body)) * Constr.constr
        * Univ.Constraint.t :=
  match function_parameter with
  | (idl, (c, ctx)) =&gt;
    fun mp =&gt;
      fun equiv =&gt;
        match
          match idl with
          | [] =&gt; false
          | cons id idl =&gt; ((Names.Label.of_id id), idl)
          end with
        | (lab, idl) =&gt; try
        end
  end.

Fixpoint check_with_mod
  (env : Environ.env)
  (struc : list (Names.Label.t * Declarations.structure_field_body))
  (function_parameter : (list Names.Id.t) * Names.ModPath.t)
  : Names.ModPath.t -&gt;
    Mod_subst.delta_resolver -&gt;
      (list (Names.Label.t * Declarations.structure_field_body)) *
        Mod_subst.delta_resolver * Univ.ContextSet.t :=
  match function_parameter with
  | (idl, mp1) =&gt;
    fun mp =&gt;
      fun equiv =&gt;
        match
          match idl with
          | [] =&gt; false
          | cons id idl =&gt; ((Names.Label.of_id id), idl)
          end with
        | (lab, idl) =&gt; try
        end
  end.

Definition check_with {A B : Type}
  (env : Environ.env) (mp : Names.ModPath.t)
  (function_parameter :
    (Declarations.functorize A
      (list (Names.Label.t * Declarations.structure_field_body))) *
      Declarations.module_alg_expr * Mod_subst.delta_resolver *
      Univ.ContextSet.t)
  : Declarations.with_declaration -&gt;
    (Declarations.functorize B
      (list (Names.Label.t * Declarations.structure_field_body))) *
      Declarations.module_alg_expr * Mod_subst.delta_resolver *
      Univ.ContextSet.t :=
  match function_parameter with
  | (sign, alg, reso, cst) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | WithDef idl (c, ctx) =&gt;
        let struc := Modops.destr_nofunctor sign in
        match check_with_def env struc (idl, (c, ctx)) mp reso with
        | (struc', c', cst') =&gt;
          let wd' := WithDef idl (c', ctx) in
          ((NoFunctor struc'), (MEwith alg wd'), reso,
            (Univ.ContextSet.add_constraints cst' cst))
        end
      | (WithMod idl mp1) as wd =&gt;
        let struc := Modops.destr_nofunctor sign in
        match check_with_mod env struc (idl, mp1) mp reso with
        | (struc', reso', cst') =&gt;
          ((NoFunctor struc'), (MEwith alg wd), reso',
            (op_plus_plus_plus cst cst'))
        end
      end
  end.

Definition translate_apply {A B : Type}
  (env : Environ.env) (inl : Entries.inline)
  (function_parameter :
    (Declarations.functorize Declarations.module_type_body
      Declarations.structure_body) * A * Mod_subst.delta_resolver *
      Univ.ContextSet.t)
  : Names.ModPath.t -&gt;
    (A -&gt; Names.ModPath.t -&gt; B) -&gt;
      Declarations.module_signature * B * Mod_subst.delta_resolver *
        Univ.ContextSet.t :=
  match function_parameter with
  | (sign, alg, reso, cst1) =&gt;
    fun mp1 =&gt;
      fun mkalg =&gt;
        match Modops.destr_functor sign with
        | (farg_id, farg_b, fbody_b) =&gt;
          let mtb :=
            Modops.module_type_of_module (Environ.lookup_module mp1 env) in
          let cst2 := Subtyping.check_subtypes env mtb farg_b in
          let mp_delta := discr_resolver mtb in
          let mp_delta :=
            Modops.inline_delta_resolver env inl mp1 farg_id farg_b mp_delta in
          let subst := Mod_subst.map_mbid farg_id mp1 mp_delta in
          let body := Modops.subst_signature subst fbody_b in
          let alg' := mkalg alg mp1 in
          let reso' := Mod_subst.subst_codom_delta_resolver subst reso in
          (body, alg', reso', (Univ.ContextSet.add_constraints cst2 cst1))
        end
  end.

Definition mk_alg_app
  (alg : Declarations.module_alg_expr) (arg : Names.ModPath.t)
  : Declarations.module_alg_expr := MEapply alg arg.

Fixpoint translate_mse
  (env : Environ.env) (mpo : option Names.ModPath.t) (inl : Entries.inline)
  (function_parameter : Declarations.module_alg_expr)
  : Declarations.module_signature * Declarations.module_alg_expr *
    Mod_subst.delta_resolver * Univ.ContextSet.t :=
  match function_parameter with
  | (MEident mp1) as me =&gt;
    let mb :=
      match mpo with
      | Some mp =&gt;
        Modops.strengthen_and_subst_mb (Environ.lookup_module mp1 env) mp false
      | None =&gt;
        let mt := Environ.lookup_modtype mp1 env in
        Modops.module_body_of_type (mod_mp mt) mt
      end in
    ((mod_type mb), me, (mod_delta mb), Univ.ContextSet.empty)
  | MEapply fe mp1 =&gt;
    translate_apply env inl (translate_mse env mpo inl fe) mp1 mk_alg_app
  | MEwith me with_decl =&gt;
    Stdlib.op_eq_eq mpo None;
    let mp := mp_from_mexpr me in
    check_with env mp (translate_mse env None inl me) with_decl
  end.

Definition mk_mod
  (mp : Names.ModPath.t) (e : Declarations.module_implementation)
  (ty : Declarations.module_signature) (cst : Univ.ContextSet.t)
  (reso : Mod_subst.delta_resolver)
  : Declarations.generic_module_body Declarations.module_implementation :=
  {| mod_mp := mp; mod_expr := e; mod_type := ty; mod_type_alg := None;
    mod_constraints := cst; mod_delta := reso;
    mod_retroknowledge := ModBodyRK [] |}.

Definition mk_modtype
  (mp : Names.ModPath.t) (ty : Declarations.module_signature)
  (cst : Univ.ContextSet.t) (reso : Mod_subst.delta_resolver)
  : Declarations.generic_module_body unit :=
  let mb := mk_mod mp Abstract ty cst reso in
  record.

Fixpoint translate_mse_funct
  (env : Environ.env) (mpo : option Names.ModPath.t) (inl : Entries.inline)
  (mse : Declarations.module_alg_expr)
  (function_parameter : list (Names.MBId.t * Declarations.module_alg_expr))
  : Declarations.module_signature * Declarations.module_expression *
    Mod_subst.delta_resolver * Univ.ContextSet.t :=
  match function_parameter with
  | [] =&gt;
    match translate_mse env mpo inl mse with
    | (sign, alg, reso, cst) =&gt; (sign, (NoFunctor alg), reso, cst)
    end
  | cons (mbid, ty) params =&gt;
    let mp_id := MPbound mbid in
    let mtb := translate_modtype env mp_id inl ([], ty) in
    let env' := Modops.add_module_type mp_id mtb env in
    match translate_mse_funct env' mpo inl mse params with
    | (sign, alg, reso, cst) =&gt;
      let alg' := MoreFunctor mbid mtb alg in
      ((MoreFunctor mbid mtb sign), alg', reso,
        (op_plus_plus_plus cst (mod_constraints mtb)))
    end
  end

with translate_modtype
  (env : Environ.env) (mp : Names.module_path) (inl : Entries.inline)
  (function_parameter :
    (list (Names.MBId.t * Declarations.module_alg_expr)) *
      Declarations.module_alg_expr) : Declarations.module_type_body :=
  match function_parameter with
  | (params, mte) =&gt;
    match translate_mse_funct env None inl mte params with
    | (sign, alg, reso, cst) =&gt;
      let mtb := mk_modtype (mp_from_mexpr mte) sign cst reso in
      let mtb' := Modops.subst_modtype_and_resolver mtb mp in
      record
    end
  end.

Definition finalize_module
  (env : Environ.env) (mp : Names.module_path)
  (function_parameter :
    Declarations.module_signature * (option Declarations.module_expression) *
      Mod_subst.delta_resolver * Univ.ContextSet.t)
  : (option
    (((list (Names.MBId.t * Declarations.module_alg_expr)) *
      Declarations.module_alg_expr) * Entries.inline)) -&gt;
    Declarations.generic_module_body Declarations.module_implementation :=
  match function_parameter with
  | (sign, alg, reso, cst) =&gt;
    fun restype =&gt;
      match restype with
      | None =&gt;
        let impl :=
          match alg with
          | Some e =&gt; Algebraic e
          | None =&gt; FullStruct
          end in
        mk_mod mp impl sign cst reso
      | Some (params_mte, inl) =&gt;
        let res_mtb := translate_modtype env mp inl params_mte in
        let auto_mtb := mk_modtype mp sign Univ.ContextSet.empty reso in
        let cst' := Subtyping.check_subtypes env auto_mtb res_mtb in
        let impl :=
          match alg with
          | Some e =&gt; Algebraic e
          | None =&gt; Struct sign
          end in
        record
      end
  end.

Definition translate_module
  (env : Environ.env) (mp : Names.module_path) (inl : Entries.inline)
  (function_parameter : Entries.module_entry) : Declarations.module_body :=
  match function_parameter with
  | MType params ty =&gt;
    let mtb := translate_modtype env mp inl (params, ty) in
    Modops.module_body_of_type mp mtb
  | MExpr params mse oty =&gt;
    match translate_mse_funct env (Some mp) inl mse params with
    | (sg, alg, reso, cst) =&gt;
      let restype := Option.map (fun ty =&gt; ((params, ty), inl)) oty in
      finalize_module env mp (sg, (Some alg), reso, cst) restype
    end
  end.

Fixpoint unfunct {A B : Type} (function_parameter : Declarations.functorize A B)
  : B :=
  match function_parameter with
  | NoFunctor me =&gt; me
  | MoreFunctor _ _ me =&gt; unfunct me
  end.

Fixpoint forbid_incl_signed_functor
  (env : Environ.env) (function_parameter : Declarations.module_alg_expr)
  : unit :=
  match function_parameter with
  | MEapply fe _ =&gt; forbid_incl_signed_functor env fe
  | MEwith _ _ =&gt; false
  | MEident mp1 =&gt;
    let mb := Environ.lookup_module mp1 env in
    match ((mod_type mb), (mod_type_alg mb), (mod_expr mb)) with
    | (MoreFunctor _ _ _, Some _, _) =&gt;
      Modops.error_include_restricted_functor mp1
    | (MoreFunctor _ _ _, None, Algebraic me) =&gt;
      forbid_incl_signed_functor env (unfunct me)
    | _ =&gt; tt
    end
  end.

Fixpoint translate_mse_inclmod
  (env : Environ.env) (mp : Names.ModPath.t) (inl : Entries.inline)
  (function_parameter : Declarations.module_alg_expr)
  : Declarations.module_signature * unit * Mod_subst.delta_resolver *
    Univ.ContextSet.t :=
  match function_parameter with
  | MEident mp1 =&gt;
    let mb :=
      Modops.strengthen_and_subst_mb (Environ.lookup_module mp1 env) mp true in
    let sign := Modops.clean_bounded_mod_expr (mod_type mb) in
    (sign, tt, (mod_delta mb), Univ.ContextSet.empty)
  | MEapply fe arg =&gt;
    let ftrans := translate_mse_inclmod env mp inl fe in
    translate_apply env inl ftrans arg
      (fun function_parameter =&gt;
        match function_parameter with
        | _ =&gt;
          fun function_parameter =&gt;
            match function_parameter with
            | _ =&gt; tt
            end
        end)
  | MEwith _ _ =&gt; false
  end.

Definition translate_mse_incl
  (is_mod : bool) (env : Environ.env) (mp : Names.module_path)
  (inl : Entries.inline) (me : Declarations.module_alg_expr)
  : Declarations.module_signature * unit * Mod_subst.delta_resolver *
    Univ.ContextSet.t :=
  if is_mod then
    match forbid_incl_signed_functor env me with
    | tt =&gt; translate_mse_inclmod env mp inl me
    end
  else
    let mtb := translate_modtype env mp inl ([], me) in
    let sign := Modops.clean_bounded_mod_expr (mod_type mtb) in
    (sign, tt, (mod_delta mtb), (mod_constraints mtb)).</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="modops" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>modops.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Jacek Chrzaszcz, Aug 2002 as part of the implementation of
   the Coq module system *)
(* Inlining and more liberal use of modules and module types by Claudio
   Sacerdoti, Nov 2004 *)
(* New structure-based model of modules and miscellaneous bug fixes by
   √âlie Soubiran, from Feb 2008 *)

(* This file provides with various operations on modules and module types *)

open Util
open Names
open Constr
open Declarations
open Declareops
open Environ
open Entries
open Mod_subst

(** {6 Errors } *)

type signature_mismatch_error =
  | InductiveFieldExpected of mutual_inductive_body
  | DefinitionFieldExpected
  | ModuleFieldExpected
  | ModuleTypeFieldExpected
  | NotConvertibleInductiveField of Id.t
  | NotConvertibleConstructorField of Id.t
  | NotConvertibleBodyField
  | NotConvertibleTypeField of env * types * types
  | CumulativeStatusExpected of bool
  | PolymorphicStatusExpected of bool
  | NotSameConstructorNamesField
  | NotSameInductiveNameInBlockField
  | FiniteInductiveFieldExpected of bool
  | InductiveNumbersFieldExpected of int
  | InductiveParamsNumberField of int
  | RecordFieldExpected of bool
  | RecordProjectionsExpected of Name.t list
  | NotEqualInductiveAliases
  | IncompatibleUniverses of Univ.univ_inconsistency
  | IncompatiblePolymorphism of env * types * types
  | IncompatibleConstraints of { got : Univ.AUContext.t; expect : Univ.AUContext.t }
  | IncompatibleVariance

type module_typing_error =
  | SignatureMismatch of
      Label.t * structure_field_body * signature_mismatch_error
  | LabelAlreadyDeclared of Label.t
  | ApplicationToNotPath of module_struct_entry
  | NotAFunctor
  | IsAFunctor
  | IncompatibleModuleTypes of module_type_body * module_type_body
  | NotEqualModulePaths of ModPath.t * ModPath.t
  | NoSuchLabel of Label.t
  | IncompatibleLabels of Label.t * Label.t
  | NotAModule of string
  | NotAModuleType of string
  | NotAConstant of Label.t
  | IncorrectWithConstraint of Label.t
  | GenerativeModuleExpected of Label.t
  | LabelMissing of Label.t * string
  | IncludeRestrictedFunctor of ModPath.t

exception ModuleTypingError of module_typing_error

let error_existing_label l =
  raise (ModuleTypingError (LabelAlreadyDeclared l))

let error_not_a_functor () =
  raise (ModuleTypingError NotAFunctor)

let error_is_a_functor () =
  raise (ModuleTypingError IsAFunctor)

let error_incompatible_modtypes mexpr1 mexpr2 =
  raise (ModuleTypingError (IncompatibleModuleTypes (mexpr1,mexpr2)))

let error_not_equal_modpaths mp1 mp2 =
  raise (ModuleTypingError (NotEqualModulePaths (mp1,mp2)))

let error_signature_mismatch l spec why =
  raise (ModuleTypingError (SignatureMismatch (l,spec,why)))

let error_no_such_label l =
  raise (ModuleTypingError (NoSuchLabel l))

let error_incompatible_labels l l' =
  raise (ModuleTypingError (IncompatibleLabels (l,l')))

let error_not_a_module s =
  raise (ModuleTypingError (NotAModule s))

let error_not_a_constant l =
  raise (ModuleTypingError (NotAConstant l))

let error_incorrect_with_constraint l =
  raise (ModuleTypingError (IncorrectWithConstraint l))

let error_generative_module_expected l =
  raise (ModuleTypingError (GenerativeModuleExpected l))

let error_no_such_label_sub l l1 =
  raise (ModuleTypingError (LabelMissing (l,l1)))

let error_include_restricted_functor mp =
  raise (ModuleTypingError (IncludeRestrictedFunctor mp))

(** {6 Operations on functors } *)

let is_functor = function
  |NoFunctor _ -&gt; false
  |MoreFunctor _ -&gt; true

let destr_functor = function
  |NoFunctor _ -&gt; error_not_a_functor ()
  |MoreFunctor (mbid,ty,x) -&gt; (mbid,ty,x)

let destr_nofunctor = function
  |NoFunctor a -&gt; a
  |MoreFunctor _ -&gt; error_is_a_functor ()

let rec functor_smart_map fty f0 funct = match funct with
  |MoreFunctor (mbid,ty,e) -&gt;
    let ty' = fty ty in
    let e' = functor_smart_map fty f0 e in
    if ty==ty' &amp;&amp; e==e' then funct else MoreFunctor (mbid,ty',e')
  |NoFunctor a -&gt;
    let a' = f0 a in if a==a' then funct else NoFunctor a'

let rec functor_iter fty f0 = function
  |MoreFunctor (_mbid,ty,e) -&gt; fty ty; functor_iter fty f0 e
  |NoFunctor a -&gt; f0 a

(** {6 Misc operations } *)

let module_type_of_module mb =
  { mb with mod_expr = (); mod_type_alg = None;
    mod_retroknowledge = ModTypeRK; }

let module_body_of_type mp mtb =
  { mtb with mod_expr = Abstract; mod_mp = mp;
      mod_retroknowledge = ModBodyRK []; }

let check_modpath_equiv env mp1 mp2 =
  if ModPath.equal mp1 mp2 then ()
  else
    let mp1' = mp_of_delta (lookup_module mp1 env).mod_delta mp1 in
    let mp2' = mp_of_delta (lookup_module mp2 env).mod_delta mp2 in
    if ModPath.equal mp1' mp2' then ()
    else error_not_equal_modpaths mp1 mp2

let implem_smartmap fs fa impl = match impl with
  |Struct e -&gt; let e' = fs e in if e==e' then impl else Struct e'
  |Algebraic a -&gt; let a' = fa a in if a==a' then impl else Algebraic a'
  |Abstract|FullStruct -&gt; impl

let implem_iter fs fa impl = match impl with
  |Struct e -&gt; fs e
  |Algebraic a -&gt; fa a
  |Abstract|FullStruct -&gt; ()

(** {6 Substitutions of modular structures } *)

let id_delta x _y = x

let subst_with_body sub = function
  |WithMod(id,mp) as orig -&gt;
    let mp' = subst_mp sub mp in
    if mp==mp' then orig else WithMod(id,mp')
  |WithDef(id,(c,ctx)) as orig -&gt;
    let c' = subst_mps sub c in
    if c==c' then orig else WithDef(id,(c',ctx))

let rec subst_structure sub do_delta sign =
  let subst_body ((l,body) as orig) = match body with
    |SFBconst cb -&gt;
      let cb' = subst_const_body sub cb in
      if cb==cb' then orig else (l,SFBconst cb')
    |SFBmind mib -&gt;
      let mib' = subst_mind_body sub mib in
      if mib==mib' then orig else (l,SFBmind mib')
    |SFBmodule mb -&gt;
      let mb' = subst_module sub do_delta mb in
      if mb==mb' then orig else (l,SFBmodule mb')
    |SFBmodtype mtb -&gt;
      let mtb' = subst_modtype sub do_delta mtb in
      if mtb==mtb' then orig else (l,SFBmodtype mtb')
  in
  List.Smart.map subst_body sign

and subst_retro : type a. Mod_subst.substitution -&gt; a module_retroknowledge -&gt; a module_retroknowledge =
  fun subst retro -&gt;
    match retro with
    | ModTypeRK as r -&gt; r
    | ModBodyRK l as r -&gt;
      let l' = List.Smart.map (subst_retro_action subst) l in
      if l == l' then r else ModBodyRK l

and subst_body : 'a. _ -&gt; _ -&gt; (_ -&gt; 'a -&gt; 'a) -&gt; _ -&gt; 'a generic_module_body -&gt; 'a generic_module_body =
  fun is_mod sub subst_impl do_delta mb -&gt;
    let { mod_mp=mp; mod_expr=me; mod_type=ty; mod_type_alg=aty;
          mod_retroknowledge=retro; _ } = mb in
  let mp' = subst_mp sub mp in
  let sub =
    if ModPath.equal mp mp' then sub
    else if is_mod &amp;&amp; not (is_functor ty) then sub
    else add_mp mp mp' empty_delta_resolver sub
  in
  let ty' = subst_signature sub do_delta ty in
  let me' = subst_impl sub me in
  let aty' = Option.Smart.map (subst_expression sub id_delta) aty in
  let retro' = subst_retro sub retro in
  let delta' = do_delta mb.mod_delta sub in
  if mp==mp' &amp;&amp; me==me' &amp;&amp; ty==ty' &amp;&amp; aty==aty'
     &amp;&amp; retro==retro' &amp;&amp; delta'==mb.mod_delta
  then mb
  else
    { mb with
      mod_mp = mp';
      mod_expr = me';
      mod_type = ty';
      mod_type_alg = aty';
      mod_retroknowledge = retro';
      mod_delta = delta';
    }

and subst_module sub do_delta mb =
  subst_body true sub subst_impl do_delta mb

and subst_impl sub me =
  implem_smartmap
    (subst_signature sub id_delta) (subst_expression sub id_delta) me

and subst_modtype sub do_delta mtb = subst_body false sub (fun _ () -&gt; ()) do_delta mtb

and subst_expr sub do_delta seb = match seb with
  |MEident mp -&gt;
    let mp' = subst_mp sub mp in
    if mp==mp' then seb else MEident mp'
  |MEapply (meb1,mp2) -&gt;
    let meb1' = subst_expr sub do_delta meb1 in
    let mp2' = subst_mp sub mp2 in
    if meb1==meb1' &amp;&amp; mp2==mp2' then seb else MEapply(meb1',mp2')
  |MEwith (meb,wdb) -&gt;
    let meb' = subst_expr sub do_delta meb in
    let wdb' = subst_with_body sub wdb in
    if meb==meb' &amp;&amp; wdb==wdb' then seb else MEwith(meb',wdb')

and subst_expression sub do_delta =
  functor_smart_map
    (subst_modtype sub do_delta)
    (subst_expr sub do_delta)

and subst_signature sub do_delta =
  functor_smart_map
    (subst_modtype sub do_delta)
    (subst_structure sub do_delta)

let do_delta_dom reso sub = subst_dom_delta_resolver sub reso
let do_delta_codom reso sub = subst_codom_delta_resolver sub reso
let do_delta_dom_codom reso sub = subst_dom_codom_delta_resolver sub reso

let subst_signature subst = subst_signature subst do_delta_codom
let subst_structure subst = subst_structure subst do_delta_codom

(** {6 Adding a module in the environment } *)

let add_retroknowledge r env =
  match r with
  | ModBodyRK l -&gt; List.fold_left Primred.add_retroknowledge env l

let rec add_structure mp sign resolver linkinfo env =
  let add_one env (l,elem) = match elem with
    |SFBconst cb -&gt;
      let c = constant_of_delta_kn resolver (KerName.make mp l) in
      Environ.add_constant_key c cb linkinfo env
    |SFBmind mib -&gt;
      let mind = mind_of_delta_kn resolver (KerName.make mp l) in
      let mib = 
	if mib.mind_private != None then 
	  { mib with mind_private = Some true }
	else mib
      in
      Environ.add_mind_key mind (mib,ref linkinfo) env
    |SFBmodule mb -&gt; add_module mb linkinfo env (* adds components as well *)
    |SFBmodtype mtb -&gt; Environ.add_modtype mtb env
  in
  List.fold_left add_one env sign

and add_module mb linkinfo env =
  let mp = mb.mod_mp in
  let env = Environ.shallow_add_module mb env in
  match mb.mod_type with
  |NoFunctor struc -&gt;
    add_retroknowledge mb.mod_retroknowledge
      (add_structure mp struc mb.mod_delta linkinfo env)
  |MoreFunctor _ -&gt; env

let add_linked_module mb linkinfo env =
  add_module mb linkinfo env

let add_structure mp sign resolver env =
  add_structure mp sign resolver no_link_info env

let add_module mb env =
  add_module mb no_link_info env

let add_module_type mp mtb env =
  add_module (module_body_of_type mp mtb) env

(** {6 Strengtening } *)

let strengthen_const mp_from l cb resolver =
  match cb.const_body with
  |Def _ -&gt; cb
  |_ -&gt;
    let kn = KerName.make mp_from l in
    let con = constant_of_delta_kn resolver kn in
    let u = Univ.make_abstract_instance (Declareops.constant_polymorphic_context cb) in
      { cb with
        const_body = Def (Mod_subst.from_val (mkConstU (con,u)));
	const_body_code = Some (Cemitcodes.from_val (Cbytegen.compile_alias con)) }

let rec strengthen_mod mp_from mp_to mb =
  if mp_in_delta mb.mod_mp mb.mod_delta then mb
  else match mb.mod_type with
  |NoFunctor struc -&gt;
    let reso,struc' = strengthen_sig mp_from struc mp_to mb.mod_delta in
    { mb with
      mod_expr = Algebraic (NoFunctor (MEident mp_to));
      mod_type = NoFunctor struc';
      mod_delta =
        add_mp_delta_resolver mp_from mp_to
	  (add_delta_resolver mb.mod_delta reso) }
  |MoreFunctor _ -&gt; mb

and strengthen_sig mp_from struc mp_to reso = match struc with
  |[] -&gt; empty_delta_resolver,[]
  |(l,SFBconst cb) :: rest -&gt;
    let item' = l,SFBconst (strengthen_const mp_from l cb reso) in
    let reso',rest' = strengthen_sig mp_from rest mp_to reso in
    reso',item'::rest'
  |(_,SFBmind _ as item):: rest -&gt;
    let reso',rest' = strengthen_sig mp_from rest mp_to reso in
    reso',item::rest'
  |(l,SFBmodule mb) :: rest -&gt;
    let mp_from' = MPdot (mp_from,l) in
    let mp_to' = MPdot(mp_to,l) in
    let mb' = strengthen_mod mp_from' mp_to' mb in
    let item' = l,SFBmodule mb' in
    let reso',rest' = strengthen_sig mp_from rest mp_to reso in
    add_delta_resolver reso' mb.mod_delta, item':: rest'
  |(_l,SFBmodtype _mty as item) :: rest -&gt;
    let reso',rest' = strengthen_sig mp_from rest mp_to reso in
    reso',item::rest'

let strengthen mtb mp =
  (* Has mtb already been strengthened ? *)
  if mp_in_delta mtb.mod_mp mtb.mod_delta then mtb
  else match mtb.mod_type with
  |NoFunctor struc -&gt;
    let reso',struc' = strengthen_sig mtb.mod_mp struc mp mtb.mod_delta in
    { mtb with
      mod_type = NoFunctor struc';
      mod_delta =
        add_delta_resolver mtb.mod_delta
	  (add_mp_delta_resolver mtb.mod_mp mp reso') }
  |MoreFunctor _ -&gt; mtb

let inline_delta_resolver env inl mp mbid mtb delta =
  let constants = inline_of_delta inl mtb.mod_delta in
  let rec make_inline delta = function
    | [] -&gt; delta
    | (lev,kn)::r -&gt;
	let kn = replace_mp_in_kn (MPbound mbid) mp kn in
	let con = constant_of_delta_kn delta kn in
	try
	  let constant = lookup_constant con env in
	  let l = make_inline delta r in
	  match constant.const_body with
            | Undef _ | OpaqueDef _ | Primitive _ -&gt; l
	    | Def body -&gt;
	      let constr = Mod_subst.force_constr body in
              let ctx = Declareops.constant_polymorphic_context constant in
              let constr = Univ.{univ_abstracted_value=constr; univ_abstracted_binder=ctx} in
              add_inline_delta_resolver kn (lev, Some constr) l
	with Not_found -&gt;
	  error_no_such_label_sub (Constant.label con)
	    (ModPath.to_string (Constant.modpath con))
  in
  make_inline delta constants

let rec strengthen_and_subst_mod mb subst mp_from mp_to =
  match mb.mod_type with
  |NoFunctor struc -&gt;
    let mb_is_an_alias = mp_in_delta mb.mod_mp mb.mod_delta in
    if mb_is_an_alias then subst_module subst do_delta_dom mb
    else
      let reso',struc' =
	strengthen_and_subst_struct struc subst
	  mp_from mp_to false false mb.mod_delta
      in
      { mb with
	mod_mp = mp_to;
	mod_expr = Algebraic (NoFunctor (MEident mp_from));
	mod_type = NoFunctor struc';
	mod_delta = add_mp_delta_resolver mp_to mp_from reso' }
  |MoreFunctor _ -&gt;
    let subst = add_mp mb.mod_mp mp_to empty_delta_resolver subst in
    subst_module subst do_delta_dom mb

and strengthen_and_subst_struct str subst mp_from mp_to alias incl reso =
  match str with
    | [] -&gt; empty_delta_resolver,[]
    | (l,SFBconst cb) as item :: rest -&gt;
        let cb' = subst_const_body subst cb in
        let cb' =
          if alias then cb'
          else strengthen_const mp_from l cb' reso
        in
        let item' = if cb' == cb then item else (l, SFBconst cb') in
	let reso',rest' =
	  strengthen_and_subst_struct rest subst mp_from mp_to alias incl reso
        in
        let str' =
          if rest' == rest &amp;&amp; item' == item then str
          else item' :: rest'
        in
	if incl then
          (* If we are performing an inclusion we need to add
             the fact that the constant mp_to.l is \Delta-equivalent
             to reso(mp_from.l) *)
          let kn_from = KerName.make mp_from l in
          let kn_to = KerName.make mp_to l in
          let old_name = kn_of_delta reso kn_from in
	  add_kn_delta_resolver kn_to old_name reso', str'
	else
	  (* In this case the fact that the constant mp_to.l is
	     \Delta-equivalent to resolver(mp_from.l) is already known
	     because reso' contains mp_to maps to reso(mp_from) *)
	  reso', str'
    | (l,SFBmind mib) as item :: rest -&gt;
        let mib' = subst_mind_body subst mib in
        let item' = if mib' == mib then item else (l, SFBmind mib') in
	let reso',rest' =
	  strengthen_and_subst_struct rest subst mp_from mp_to alias incl reso
        in
        let str' =
          if rest' == rest &amp;&amp; item' == item then str
          else item' :: rest'
        in
	(* Same as constant *)
	if incl then
          let kn_from = KerName.make mp_from l in
          let kn_to = KerName.make mp_to l in
	  let old_name = kn_of_delta reso kn_from in
          add_kn_delta_resolver kn_to old_name reso', str'
	else
          reso', str'
    | (l,SFBmodule mb) as item :: rest -&gt;
	let mp_from' = MPdot (mp_from,l) in
	let mp_to' = MPdot (mp_to,l) in
	let mb' = if alias then
	  subst_module subst do_delta_dom mb
	else
	  strengthen_and_subst_mod mb subst mp_from' mp_to'
	in
        let item' = if mb' == mb then item else (l, SFBmodule mb') in
	let reso',rest' =
	  strengthen_and_subst_struct rest subst mp_from mp_to alias incl reso
        in
        let str' =
          if rest' == rest &amp;&amp; item' == item then str
          else item' :: rest'
        in
        (* if mb is a functor we should not derive new equivalences
           on names, hence we add the fact that the functor can only
           be equivalent to itself. If we adopt an applicative
           semantic for functor this should be changed.*)
	if is_functor mb'.mod_type then
          add_mp_delta_resolver mp_to' mp_to' reso', str'
	else
          add_delta_resolver reso' mb'.mod_delta, str'
    | (l,SFBmodtype mty) as item :: rest -&gt;
	let mp_from' = MPdot (mp_from,l) in
	let mp_to' = MPdot(mp_to,l) in
	let subst' = add_mp mp_from' mp_to' empty_delta_resolver subst in
	let mty' = subst_modtype subst'
	  (fun resolver _ -&gt; subst_dom_codom_delta_resolver subst' resolver)
          mty
        in
        let item' = if mty' == mty then item else (l, SFBmodtype mty') in
	let reso',rest' =
          strengthen_and_subst_struct rest subst mp_from mp_to alias incl reso
        in
        let str' =
          if rest' == rest &amp;&amp; item' == item then str
          else item' :: rest'
        in
	add_mp_delta_resolver mp_to' mp_to' reso', str'


(** Let P be a module path when we write:
     &quot;Module M:=P.&quot; or &quot;Module M. Include P. End M.&quot;
    We need to perform two operations to compute the body of M.
    - The first one is applying the substitution {P &lt;- M} on the type of P
    - The second one is strengthening. *)

let strengthen_and_subst_mb mb mp include_b = match mb.mod_type with
  |NoFunctor struc -&gt;
    let mb_is_an_alias = mp_in_delta mb.mod_mp mb.mod_delta in
    (* if mb.mod_mp is an alias then the strengthening is useless
       (i.e. it is already done)*)
    let mp_alias = mp_of_delta mb.mod_delta mb.mod_mp in
    let subst_resolver = map_mp mb.mod_mp mp empty_delta_resolver in
    let new_resolver =
      add_mp_delta_resolver mp mp_alias
	(subst_dom_delta_resolver subst_resolver mb.mod_delta)
    in
    let subst = map_mp mb.mod_mp mp new_resolver in
    let reso',struc' =
      strengthen_and_subst_struct struc subst
	mb.mod_mp mp mb_is_an_alias include_b mb.mod_delta
    in
    { mb with
      mod_mp = mp;
      mod_type = NoFunctor struc';
      mod_expr = Algebraic (NoFunctor (MEident mb.mod_mp));
      mod_delta =
        if include_b then reso'
	else add_delta_resolver new_resolver reso' }
  |MoreFunctor _ -&gt;
    let subst = map_mp mb.mod_mp mp empty_delta_resolver in
    subst_module subst do_delta_dom_codom mb

let subst_modtype_and_resolver mtb mp =
  let subst = map_mp mtb.mod_mp mp empty_delta_resolver in
  let new_delta = subst_dom_codom_delta_resolver subst mtb.mod_delta in
  let full_subst = map_mp mtb.mod_mp mp new_delta in
  subst_modtype full_subst do_delta_dom_codom mtb

(** {6 Cleaning a module expression from bounded parts }

     For instance:
       functor(X:T)-&gt;struct module M:=X end)
     becomes:
       functor(X:T)-&gt;struct module M:=&lt;content of T&gt; end)
*)

let rec is_bounded_expr l = function
  | MEident (MPbound mbid) -&gt; MBIset.mem mbid l
  | MEapply (fexpr,mp) -&gt;
      is_bounded_expr l (MEident mp) || is_bounded_expr l fexpr
  | _ -&gt; false

let rec clean_module_body l mb =
  let impl, typ = mb.mod_expr, mb.mod_type in
  let typ' = clean_signature l typ in
  let impl' = match impl with
    | Algebraic (NoFunctor m) when is_bounded_expr l m -&gt; FullStruct
    | _ -&gt; implem_smartmap (clean_signature l) (clean_expression l) impl
  in
  if typ==typ' &amp;&amp; impl==impl' then mb
  else { mb with mod_type=typ'; mod_expr=impl' }

and clean_module_type l mb =
  let (), typ = mb.mod_expr, mb.mod_type in
  let typ' = clean_signature l typ in
  if typ==typ' then mb
  else { mb with mod_type=typ' }

and clean_field l field = match field with
  |(lab,SFBmodule mb) -&gt;
    let mb' = clean_module_body l mb in
    if mb==mb' then field else (lab,SFBmodule mb')
  |_ -&gt; field

and clean_structure l = List.Smart.map (clean_field l)

and clean_signature l =
  functor_smart_map (clean_module_type l) (clean_structure l)

and clean_expression l =
  functor_smart_map (clean_module_type l) (fun me -&gt; me)

let rec collect_mbid l sign =  match sign with
  |MoreFunctor (mbid,ty,m) -&gt;
    let m' = collect_mbid (MBIset.add mbid l) m in
    if m==m' then sign else MoreFunctor (mbid,ty,m')
  |NoFunctor struc -&gt;
    let struc' = clean_structure l struc in
    if struc==struc' then sign else NoFunctor struc'

let clean_bounded_mod_expr sign =
  if is_functor sign then collect_mbid MBIset.empty sign else sign

(** {6 Stm machinery } *)
let join_constant_body except otab cb =
  match cb.const_body with
  | OpaqueDef o -&gt; Opaqueproof.join_opaque ~except otab o
  | _ -&gt; ()

let join_structure except otab s =
  let rec join_module : 'a. 'a generic_module_body -&gt; unit = fun mb -&gt;
    Option.iter join_expression mb.mod_type_alg;
    join_signature mb.mod_type
  and join_field (_l,body) = match body with
    |SFBconst sb -&gt; join_constant_body except otab sb
    |SFBmind _ -&gt; ()
    |SFBmodule m -&gt;
      implem_iter join_signature join_expression m.mod_expr;
      join_module m
    |SFBmodtype m -&gt; join_module m
  and join_structure struc = List.iter join_field struc
  and join_signature sign =
    functor_iter join_module join_structure sign
  and join_expression me = functor_iter join_module (fun _ -&gt; ()) me in
  join_structure s

</pre>
          </div>
          <div class="col-md-6">
            <code>modops.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Util.

Import Names.

Import Constr.

Import Declarations.

Import Declareops.

Import Environ.

Import Entries.

Import Mod_subst.

Inductive signature_mismatch_error : Type :=
| InductiveFieldExpected : Declarations.mutual_inductive_body -&gt;
  signature_mismatch_error
| DefinitionFieldExpected : signature_mismatch_error
| ModuleFieldExpected : signature_mismatch_error
| ModuleTypeFieldExpected : signature_mismatch_error
| NotConvertibleInductiveField : Names.Id.t -&gt; signature_mismatch_error
| NotConvertibleConstructorField : Names.Id.t -&gt; signature_mismatch_error
| NotConvertibleBodyField : signature_mismatch_error
| NotConvertibleTypeField : Environ.env -&gt; Constr.types -&gt; Constr.types -&gt;
  signature_mismatch_error
| CumulativeStatusExpected : bool -&gt; signature_mismatch_error
| PolymorphicStatusExpected : bool -&gt; signature_mismatch_error
| NotSameConstructorNamesField : signature_mismatch_error
| NotSameInductiveNameInBlockField : signature_mismatch_error
| FiniteInductiveFieldExpected : bool -&gt; signature_mismatch_error
| InductiveNumbersFieldExpected : Z -&gt; signature_mismatch_error
| InductiveParamsNumberField : Z -&gt; signature_mismatch_error
| RecordFieldExpected : bool -&gt; signature_mismatch_error
| RecordProjectionsExpected : (list Names.Name.t) -&gt; signature_mismatch_error
| NotEqualInductiveAliases : signature_mismatch_error
| IncompatibleUniverses : Univ.univ_inconsistency -&gt; signature_mismatch_error
| IncompatiblePolymorphism : Environ.env -&gt; Constr.types -&gt; Constr.types -&gt;
  signature_mismatch_error
| IncompatibleConstraints : Univ.AUContext.t -&gt; Univ.AUContext.t -&gt;
  signature_mismatch_error
| IncompatibleVariance : signature_mismatch_error.

Inductive module_typing_error : Type :=
| SignatureMismatch : Names.Label.t -&gt; Declarations.structure_field_body -&gt;
  signature_mismatch_error -&gt; module_typing_error
| LabelAlreadyDeclared : Names.Label.t -&gt; module_typing_error
| ApplicationToNotPath : Entries.module_struct_entry -&gt; module_typing_error
| NotAFunctor : module_typing_error
| IsAFunctor : module_typing_error
| IncompatibleModuleTypes : Declarations.module_type_body -&gt;
  Declarations.module_type_body -&gt; module_typing_error
| NotEqualModulePaths : Names.ModPath.t -&gt; Names.ModPath.t -&gt;
  module_typing_error
| NoSuchLabel : Names.Label.t -&gt; module_typing_error
| IncompatibleLabels : Names.Label.t -&gt; Names.Label.t -&gt; module_typing_error
| NotAModule : string -&gt; module_typing_error
| NotAModuleType : string -&gt; module_typing_error
| NotAConstant : Names.Label.t -&gt; module_typing_error
| IncorrectWithConstraint : Names.Label.t -&gt; module_typing_error
| GenerativeModuleExpected : Names.Label.t -&gt; module_typing_error
| LabelMissing : Names.Label.t -&gt; string -&gt; module_typing_error
| IncludeRestrictedFunctor : Names.ModPath.t -&gt; module_typing_error.

Definition error_existing_label {A : Type} (l : Names.Label.t) : A :=
  Stdlib.raise (ModuleTypingError (LabelAlreadyDeclared l)).

Definition error_not_a_functor {A : Type} (function_parameter : unit) : A :=
  match function_parameter with
  | tt =&gt; Stdlib.raise (ModuleTypingError NotAFunctor)
  end.

Definition error_is_a_functor {A : Type} (function_parameter : unit) : A :=
  match function_parameter with
  | tt =&gt; Stdlib.raise (ModuleTypingError IsAFunctor)
  end.

Definition error_incompatible_modtypes {A : Type}
  (mexpr1 : Declarations.module_type_body)
  (mexpr2 : Declarations.module_type_body) : A :=
  Stdlib.raise (ModuleTypingError (IncompatibleModuleTypes mexpr1 mexpr2)).

Definition error_not_equal_modpaths {A : Type}
  (mp1 : Names.ModPath.t) (mp2 : Names.ModPath.t) : A :=
  Stdlib.raise (ModuleTypingError (NotEqualModulePaths mp1 mp2)).

Definition error_signature_mismatch {A : Type}
  (l : Names.Label.t) (spec : Declarations.structure_field_body)
  (why : signature_mismatch_error) : A :=
  Stdlib.raise (ModuleTypingError (SignatureMismatch l spec why)).

Definition error_no_such_label {A : Type} (l : Names.Label.t) : A :=
  Stdlib.raise (ModuleTypingError (NoSuchLabel l)).

Definition error_incompatible_labels {A : Type}
  (l : Names.Label.t) (l' : Names.Label.t) : A :=
  Stdlib.raise (ModuleTypingError (IncompatibleLabels l l')).

Definition error_not_a_module {A : Type} (s : string) : A :=
  Stdlib.raise (ModuleTypingError (NotAModule s)).

Definition error_not_a_constant {A : Type} (l : Names.Label.t) : A :=
  Stdlib.raise (ModuleTypingError (NotAConstant l)).

Definition error_incorrect_with_constraint {A : Type} (l : Names.Label.t) : A :=
  Stdlib.raise (ModuleTypingError (IncorrectWithConstraint l)).

Definition error_generative_module_expected {A : Type} (l : Names.Label.t)
  : A := Stdlib.raise (ModuleTypingError (GenerativeModuleExpected l)).

Definition error_no_such_label_sub {A : Type} (l : Names.Label.t) (l1 : string)
  : A := Stdlib.raise (ModuleTypingError (LabelMissing l l1)).

Definition error_include_restricted_functor {A : Type} (mp : Names.ModPath.t)
  : A := Stdlib.raise (ModuleTypingError (IncludeRestrictedFunctor mp)).

Definition is_functor {A B : Type}
  (function_parameter : Declarations.functorize A B) : bool :=
  match function_parameter with
  | NoFunctor _ =&gt; false
  | MoreFunctor _ _ _ =&gt; true
  end.

Definition destr_functor {A B : Type}
  (function_parameter : Declarations.functorize A B)
  : Names.MBId.t * A * (Declarations.functorize A B) :=
  match function_parameter with
  | NoFunctor _ =&gt; error_not_a_functor tt
  | MoreFunctor mbid ty x =&gt; (mbid, ty, x)
  end.

Definition destr_nofunctor {A B : Type}
  (function_parameter : Declarations.functorize A B) : B :=
  match function_parameter with
  | NoFunctor a =&gt; a
  | MoreFunctor _ _ _ =&gt; error_is_a_functor tt
  end.

Fixpoint functor_smart_map {A B : Type}
  (fty : A -&gt; A) (f0 : B -&gt; B) (funct : Declarations.functorize A B)
  : Declarations.functorize A B :=
  match funct with
  | MoreFunctor mbid ty e =&gt;
    let ty' := fty ty in
    let e' := functor_smart_map fty f0 e in
    if andb (Stdlib.op_eq_eq ty ty') (Stdlib.op_eq_eq e e') then
      funct
    else
      MoreFunctor mbid ty' e'
  | NoFunctor a =&gt;
    let a' := f0 a in
    if Stdlib.op_eq_eq a a' then
      funct
    else
      NoFunctor a'
  end.

Fixpoint functor_iter {A B C : Type}
  (fty : A -&gt; unit) (f0 : B -&gt; C)
  (function_parameter : Declarations.functorize A B) : C :=
  match function_parameter with
  | MoreFunctor _mbid ty e =&gt;
    fty ty;
    functor_iter fty f0 e
  | NoFunctor a =&gt; f0 a
  end.

Definition module_type_of_module {A : Type}
  (mb : Declarations.generic_module_body A)
  : Declarations.generic_module_body unit := record.

Definition module_body_of_type {A : Type}
  (mp : Names.ModPath.t) (mtb : Declarations.generic_module_body A)
  : Declarations.generic_module_body Declarations.module_implementation :=
  record.

Definition check_modpath_equiv
  (env : Environ.env) (mp1 : Names.ModPath.t) (mp2 : Names.ModPath.t) : unit :=
  if Names.ModPath.equal mp1 mp2 then
    tt
  else
    let mp1' :=
      Mod_subst.mp_of_delta (mod_delta (Environ.lookup_module mp1 env)) mp1 in
    let mp2' :=
      Mod_subst.mp_of_delta (mod_delta (Environ.lookup_module mp2 env)) mp2 in
    if Names.ModPath.equal mp1' mp2' then
      tt
    else
      error_not_equal_modpaths mp1 mp2.

Definition implem_smartmap
  (fs : Declarations.module_signature -&gt; Declarations.module_signature)
  (fa : Declarations.module_expression -&gt; Declarations.module_expression)
  (impl : Declarations.module_implementation)
  : Declarations.module_implementation :=
  match impl with
  | Struct e =&gt;
    let e' := fs e in
    if Stdlib.op_eq_eq e e' then
      impl
    else
      Struct e'
  | Algebraic a =&gt;
    let a' := fa a in
    if Stdlib.op_eq_eq a a' then
      impl
    else
      Algebraic a'
  | Abstract | FullStruct =&gt; impl
  end.

Definition implem_iter
  (fs : Declarations.module_signature -&gt; unit)
  (fa : Declarations.module_expression -&gt; unit)
  (impl : Declarations.module_implementation) : unit :=
  match impl with
  | Struct e =&gt; fs e
  | Algebraic a =&gt; fa a
  | Abstract | FullStruct =&gt; tt
  end.

Definition id_delta {A B : Type} (x : A) (_y : B) : A := x.

Definition subst_with_body
  (sub : Mod_subst.substitution)
  (function_parameter : Declarations.with_declaration)
  : Declarations.with_declaration :=
  match function_parameter with
  | (WithMod id mp) as orig =&gt;
    let mp' := Mod_subst.subst_mp sub mp in
    if Stdlib.op_eq_eq mp mp' then
      orig
    else
      WithMod id mp'
  | (WithDef id (c, ctx)) as orig =&gt;
    let c' := Mod_subst.subst_mps sub c in
    if Stdlib.op_eq_eq c c' then
      orig
    else
      WithDef id (c', ctx)
  end.

Fixpoint subst_structure
  (sub : Mod_subst.substitution)
  (do_delta :
    Mod_subst.delta_resolver -&gt;
      Mod_subst.substitution -&gt; Mod_subst.delta_resolver)
  (sign : Declarations.structure_body) : Declarations.structure_body :=
  let subst_body {A : Type}
    (function_parameter : A * Declarations.structure_field_body)
    : A * Declarations.structure_field_body :=
    match function_parameter with
    | (l, body) as orig =&gt;
      match body with
      | SFBconst cb =&gt;
        let cb' := Declareops.subst_const_body sub cb in
        if Stdlib.op_eq_eq cb cb' then
          orig
        else
          (l, (SFBconst cb'))
      | SFBmind mib =&gt;
        let mib' := Declareops.subst_mind_body sub mib in
        if Stdlib.op_eq_eq mib mib' then
          orig
        else
          (l, (SFBmind mib'))
      | SFBmodule mb =&gt;
        let mb' := subst_module sub do_delta mb in
        if Stdlib.op_eq_eq mb mb' then
          orig
        else
          (l, (SFBmodule mb'))
      | SFBmodtype mtb =&gt;
        let mtb' := subst_modtype sub do_delta mtb in
        if Stdlib.op_eq_eq mtb mtb' then
          orig
        else
          (l, (SFBmodtype mtb'))
      end
    end in
  Util.List.Smart.map subst_body sign

with subst_retro {a : Type}
  (subst : Mod_subst.substitution)
  (retro : Declarations.module_retroknowledge a)
  : Declarations.module_retroknowledge a :=
  match retro with
  | ModTypeRK as r =&gt; r
  | (ModBodyRK l) as r =&gt;
    let l' := Util.List.Smart.map (Mod_subst.subst_retro_action subst) l in
    if Stdlib.op_eq_eq l l' then
      r
    else
      ModBodyRK l
  end

with subst_body {a : Type}
  (is_mod : bool) (sub : Mod_subst.substitution)
  (subst_impl : Mod_subst.substitution -&gt; a -&gt; a)
  (do_delta :
    Mod_subst.delta_resolver -&gt;
      Mod_subst.substitution -&gt; Mod_subst.delta_resolver)
  (mb : Declarations.generic_module_body a)
  : Declarations.generic_module_body a :=
  match mb with
  | {|
    mod_mp := mp;
      mod_expr := me;
      mod_type := ty;
      mod_type_alg := aty;
      mod_retroknowledge := retro
      |} =&gt;
    let mp' := Mod_subst.subst_mp sub mp in
    let sub :=
      if Names.ModPath.equal mp mp' then
        sub
      else
        if andb is_mod (negb (is_functor ty)) then
          sub
        else
          Mod_subst.add_mp mp mp' Mod_subst.empty_delta_resolver sub in
    let ty' := subst_signature sub do_delta ty in
    let me' := subst_impl sub me in
    let aty' := Option.Smart.map (subst_expression sub id_delta) aty in
    let retro' := subst_retro sub retro in
    let delta' := do_delta (mod_delta mb) sub in
    if
      andb (Stdlib.op_eq_eq mp mp')
        (andb (Stdlib.op_eq_eq me me')
          (andb (Stdlib.op_eq_eq ty ty')
            (andb (Stdlib.op_eq_eq aty aty')
              (andb (Stdlib.op_eq_eq retro retro')
                (Stdlib.op_eq_eq delta' (mod_delta mb)))))) then
      mb
    else
      record
  end

with subst_module
  (sub : Mod_subst.substitution)
  (do_delta :
    Mod_subst.delta_resolver -&gt;
      Mod_subst.substitution -&gt; Mod_subst.delta_resolver)
  (mb : Declarations.module_body) : Declarations.module_body :=
  subst_body true sub subst_impl do_delta mb

with subst_impl
  (sub : Mod_subst.substitution) (me : Declarations.module_implementation)
  : Declarations.module_implementation :=
  implem_smartmap (subst_signature sub id_delta) (subst_expression sub id_delta)
    me

with subst_modtype
  (sub : Mod_subst.substitution)
  (do_delta :
    Mod_subst.delta_resolver -&gt;
      Mod_subst.substitution -&gt; Mod_subst.delta_resolver)
  (mtb : Declarations.module_type_body) : Declarations.module_type_body :=
  subst_body false sub
    (fun function_parameter =&gt;
      match function_parameter with
      | _ =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | tt =&gt; tt
          end
      end) do_delta mtb

with subst_expr
  (sub : Mod_subst.substitution)
  (do_delta :
    Mod_subst.delta_resolver -&gt;
      Mod_subst.substitution -&gt; Mod_subst.delta_resolver)
  (seb : Declarations.module_alg_expr) : Declarations.module_alg_expr :=
  match seb with
  | MEident mp =&gt;
    let mp' := Mod_subst.subst_mp sub mp in
    if Stdlib.op_eq_eq mp mp' then
      seb
    else
      MEident mp'
  | MEapply meb1 mp2 =&gt;
    let meb1' := subst_expr sub do_delta meb1 in
    let mp2' := Mod_subst.subst_mp sub mp2 in
    if andb (Stdlib.op_eq_eq meb1 meb1') (Stdlib.op_eq_eq mp2 mp2') then
      seb
    else
      MEapply meb1' mp2'
  | MEwith meb wdb =&gt;
    let meb' := subst_expr sub do_delta meb in
    let wdb' := subst_with_body sub wdb in
    if andb (Stdlib.op_eq_eq meb meb') (Stdlib.op_eq_eq wdb wdb') then
      seb
    else
      MEwith meb' wdb'
  end

with subst_expression
  (sub : Mod_subst.substitution)
  (do_delta :
    Mod_subst.delta_resolver -&gt;
      Mod_subst.substitution -&gt; Mod_subst.delta_resolver)
  : Declarations.module_expression -&gt; Declarations.module_expression :=
  functor_smart_map (subst_modtype sub do_delta) (subst_expr sub do_delta)

with subst_signature
  (sub : Mod_subst.substitution)
  (do_delta :
    Mod_subst.delta_resolver -&gt;
      Mod_subst.substitution -&gt; Mod_subst.delta_resolver)
  : Declarations.module_signature -&gt; Declarations.module_signature :=
  functor_smart_map (subst_modtype sub do_delta) (subst_structure sub do_delta).

Definition do_delta_dom
  (reso : Mod_subst.delta_resolver) (sub : Mod_subst.substitution)
  : Mod_subst.delta_resolver := Mod_subst.subst_dom_delta_resolver sub reso.

Definition do_delta_codom
  (reso : Mod_subst.delta_resolver) (sub : Mod_subst.substitution)
  : Mod_subst.delta_resolver := Mod_subst.subst_codom_delta_resolver sub reso.

Definition do_delta_dom_codom
  (reso : Mod_subst.delta_resolver) (sub : Mod_subst.substitution)
  : Mod_subst.delta_resolver :=
  Mod_subst.subst_dom_codom_delta_resolver sub reso.

Definition subst_signature (subst : Mod_subst.substitution)
  : Declarations.module_signature -&gt; Declarations.module_signature :=
  subst_signature subst do_delta_codom.

Definition subst_structure (subst : Mod_subst.substitution)
  : Declarations.structure_body -&gt; Declarations.structure_body :=
  subst_structure subst do_delta_codom.

Definition add_retroknowledge
  (r : Declarations.module_retroknowledge Declarations.module_implementation)
  (env : Environ.env) : Environ.env :=
  match r with
  | ModBodyRK l =&gt;
    Util.List.(CList.ExtS.fold_left) Primred.add_retroknowledge env l
  end.

Fixpoint add_structure
  (mp : Names.ModPath.t)
  (sign : list (Names.Label.t * Declarations.structure_field_body))
  (resolver : Mod_subst.delta_resolver) (linkinfo : Environ.link_info)
  (env : Environ.env) : Environ.env :=
  let add_one
    (env : Environ.env) (function_parameter :
    Names.Label.t * Declarations.structure_field_body) : Environ.env :=
    match function_parameter with
    | (l, elem) =&gt;
      match elem with
      | SFBconst cb =&gt;
        let c :=
          Mod_subst.constant_of_delta_kn resolver (Names.KerName.make mp l) in
        Environ.add_constant_key c cb linkinfo env
      | SFBmind mib =&gt;
        let mind :=
          Mod_subst.mind_of_delta_kn resolver (Names.KerName.make mp l) in
        let mib :=
          if Stdlib.op_exclamation_eq (mind_private mib) None then
            record
          else
            mib in
        Environ.add_mind_key mind (mib, (Stdlib.ref linkinfo)) env
      | SFBmodule mb =&gt; add_module mb linkinfo env
      | SFBmodtype mtb =&gt; Environ.add_modtype mtb env
      end
    end in
  Util.List.(CList.ExtS.fold_left) add_one env sign

with add_module
  (mb : Declarations.module_body) (linkinfo : Environ.link_info)
  (env : Environ.env) : Environ.env :=
  let mp := mod_mp mb in
  let env := Environ.shallow_add_module mb env in
  match mod_type mb with
  | NoFunctor struc =&gt;
    add_retroknowledge (mod_retroknowledge mb)
      (add_structure mp struc (mod_delta mb) linkinfo env)
  | MoreFunctor _ _ _ =&gt; env
  end.

Definition add_linked_module
  (mb : Declarations.module_body) (linkinfo : Environ.link_info)
  (env : Environ.env) : Environ.env := add_module mb linkinfo env.

Definition add_structure
  (mp : Names.ModPath.t)
  (sign : list (Names.Label.t * Declarations.structure_field_body))
  (resolver : Mod_subst.delta_resolver) (env : Environ.env) : Environ.env :=
  add_structure mp sign resolver Environ.no_link_info env.

Definition add_module (mb : Declarations.module_body) (env : Environ.env)
  : Environ.env := add_module mb Environ.no_link_info env.

Definition add_module_type {A : Type}
  (mp : Names.ModPath.t) (mtb : Declarations.generic_module_body A)
  (env : Environ.env) : Environ.env :=
  add_module (module_body_of_type mp mtb) env.

Definition strengthen_const {A : Type}
  (mp_from : Names.ModPath.t) (l : Names.Label.t)
  (cb : Declarations.constant_body A) (resolver : Mod_subst.delta_resolver)
  : Declarations.constant_body A :=
  match const_body cb with
  | Def _ =&gt; cb
  | _ =&gt;
    let kn := Names.KerName.make mp_from l in
    let con := Mod_subst.constant_of_delta_kn resolver kn in
    let u :=
      Univ.make_abstract_instance (Declareops.constant_polymorphic_context cb)
      in
    record
  end.

Fixpoint strengthen_mod
  (mp_from : Names.ModPath.t) (mp_to : Names.ModPath.t)
  (mb : Declarations.generic_module_body Declarations.module_implementation)
  : Declarations.generic_module_body Declarations.module_implementation :=
  if Mod_subst.mp_in_delta (mod_mp mb) (mod_delta mb) then
    mb
  else
    match mod_type mb with
    | NoFunctor struc =&gt;
      match strengthen_sig mp_from struc mp_to (mod_delta mb) with
      | (reso, struc') =&gt; record
      end
    | MoreFunctor _ _ _ =&gt; mb
    end

with strengthen_sig
  (mp_from : Names.ModPath.t) (struc : Declarations.structure_body)
  (mp_to : Names.ModPath.t) (reso : Mod_subst.delta_resolver)
  : Mod_subst.delta_resolver * Declarations.structure_body :=
  match struc with
  | [] =&gt; (Mod_subst.empty_delta_resolver, [])
  | cons (l, SFBconst cb) rest =&gt;
    let item' := (l, (SFBconst (strengthen_const mp_from l cb reso))) in
    match strengthen_sig mp_from rest mp_to reso with
    | (reso', rest') =&gt; (reso', (cons item' rest'))
    end
  | cons ((_, SFBmind _) as item) rest =&gt;
    match strengthen_sig mp_from rest mp_to reso with
    | (reso', rest') =&gt; (reso', (cons item rest'))
    end
  | cons (l, SFBmodule mb) rest =&gt;
    let mp_from' := MPdot mp_from l in
    let mp_to' := MPdot mp_to l in
    let mb' := strengthen_mod mp_from' mp_to' mb in
    let item' := (l, (SFBmodule mb')) in
    match strengthen_sig mp_from rest mp_to reso with
    | (reso', rest') =&gt;
      ((Mod_subst.add_delta_resolver reso' (mod_delta mb)), (cons item' rest'))
    end
  | cons ((_l, SFBmodtype _mty) as item) rest =&gt;
    match strengthen_sig mp_from rest mp_to reso with
    | (reso', rest') =&gt; (reso', (cons item rest'))
    end
  end.

Definition strengthen {A : Type}
  (mtb : Declarations.generic_module_body A) (mp : Names.ModPath.t)
  : Declarations.generic_module_body A :=
  if Mod_subst.mp_in_delta (mod_mp mtb) (mod_delta mtb) then
    mtb
  else
    match mod_type mtb with
    | NoFunctor struc =&gt;
      match strengthen_sig (mod_mp mtb) struc mp (mod_delta mtb) with
      | (reso', struc') =&gt; record
      end
    | MoreFunctor _ _ _ =&gt; mtb
    end.

Definition inline_delta_resolver {A : Type}
  (env : Environ.env) (inl : option Z) (mp : Names.ModPath.t)
  (mbid : Names.MBId.t) (mtb : Declarations.generic_module_body A)
  (delta : Mod_subst.delta_resolver) : Mod_subst.delta_resolver :=
  let constants := Mod_subst.inline_of_delta inl (mod_delta mtb) in
  let fix make_inline
    (delta : Mod_subst.delta_resolver) (function_parameter :
    list (Z * Names.KerName.t)) : Mod_subst.delta_resolver :=
    match function_parameter with
    | [] =&gt; delta
    | cons (lev, kn) r =&gt;
      let kn := Mod_subst.replace_mp_in_kn (MPbound mbid) mp kn in
      let con := Mod_subst.constant_of_delta_kn delta kn in
      try
    end in
  make_inline delta constants.

Fixpoint strengthen_and_subst_mod
  (mb : Declarations.generic_module_body Declarations.module_implementation)
  (subst : Mod_subst.substitution) (mp_from : Names.ModPath.t)
  (mp_to : Names.ModPath.t) : Declarations.module_body :=
  match mod_type mb with
  | NoFunctor struc =&gt;
    let mb_is_an_alias := Mod_subst.mp_in_delta (mod_mp mb) (mod_delta mb) in
    if mb_is_an_alias then
      subst_module subst do_delta_dom mb
    else
      match
        strengthen_and_subst_struct struc subst mp_from mp_to false false
          (mod_delta mb) with
      | (reso', struc') =&gt; record
      end
  | MoreFunctor _ _ _ =&gt;
    let subst :=
      Mod_subst.add_mp (mod_mp mb) mp_to Mod_subst.empty_delta_resolver subst in
    subst_module subst do_delta_dom mb
  end

with strengthen_and_subst_struct
  (str : Declarations.structure_body) (subst : Mod_subst.substitution)
  (mp_from : Names.ModPath.t) (mp_to : Names.ModPath.t) (alias : bool)
  (incl : bool) (reso : Mod_subst.delta_resolver)
  : Mod_subst.delta_resolver * Declarations.structure_body :=
  match str with
  | [] =&gt; (Mod_subst.empty_delta_resolver, [])
  | cons ((l, SFBconst cb) as item) rest =&gt;
    let cb' := Declareops.subst_const_body subst cb in
    let cb' :=
      if alias then
        cb'
      else
        strengthen_const mp_from l cb' reso in
    let item' :=
      if Stdlib.op_eq_eq cb' cb then
        item
      else
        (l, (SFBconst cb')) in
    match strengthen_and_subst_struct rest subst mp_from mp_to alias incl reso
      with
    | (reso', rest') =&gt;
      let str' :=
        if andb (Stdlib.op_eq_eq rest' rest) (Stdlib.op_eq_eq item' item) then
          str
        else
          cons item' rest' in
      if incl then
        let kn_from := Names.KerName.make mp_from l in
        let kn_to := Names.KerName.make mp_to l in
        let old_name := Mod_subst.kn_of_delta reso kn_from in
        ((Mod_subst.add_kn_delta_resolver kn_to old_name reso'), str')
      else
        (reso', str')
    end
  | cons ((l, SFBmind mib) as item) rest =&gt;
    let mib' := Declareops.subst_mind_body subst mib in
    let item' :=
      if Stdlib.op_eq_eq mib' mib then
        item
      else
        (l, (SFBmind mib')) in
    match strengthen_and_subst_struct rest subst mp_from mp_to alias incl reso
      with
    | (reso', rest') =&gt;
      let str' :=
        if andb (Stdlib.op_eq_eq rest' rest) (Stdlib.op_eq_eq item' item) then
          str
        else
          cons item' rest' in
      if incl then
        let kn_from := Names.KerName.make mp_from l in
        let kn_to := Names.KerName.make mp_to l in
        let old_name := Mod_subst.kn_of_delta reso kn_from in
        ((Mod_subst.add_kn_delta_resolver kn_to old_name reso'), str')
      else
        (reso', str')
    end
  | cons ((l, SFBmodule mb) as item) rest =&gt;
    let mp_from' := MPdot mp_from l in
    let mp_to' := MPdot mp_to l in
    let mb' :=
      if alias then
        subst_module subst do_delta_dom mb
      else
        strengthen_and_subst_mod mb subst mp_from' mp_to' in
    let item' :=
      if Stdlib.op_eq_eq mb' mb then
        item
      else
        (l, (SFBmodule mb')) in
    match strengthen_and_subst_struct rest subst mp_from mp_to alias incl reso
      with
    | (reso', rest') =&gt;
      let str' :=
        if andb (Stdlib.op_eq_eq rest' rest) (Stdlib.op_eq_eq item' item) then
          str
        else
          cons item' rest' in
      if is_functor (mod_type mb') then
        ((Mod_subst.add_mp_delta_resolver mp_to' mp_to' reso'), str')
      else
        ((Mod_subst.add_delta_resolver reso' (mod_delta mb')), str')
    end
  | cons ((l, SFBmodtype mty) as item) rest =&gt;
    let mp_from' := MPdot mp_from l in
    let mp_to' := MPdot mp_to l in
    let subst' :=
      Mod_subst.add_mp mp_from' mp_to' Mod_subst.empty_delta_resolver subst in
    let mty' :=
      subst_modtype subst'
        (fun resolver =&gt;
          fun function_parameter =&gt;
            match function_parameter with
            | _ =&gt; Mod_subst.subst_dom_codom_delta_resolver subst' resolver
            end) mty in
    let item' :=
      if Stdlib.op_eq_eq mty' mty then
        item
      else
        (l, (SFBmodtype mty')) in
    match strengthen_and_subst_struct rest subst mp_from mp_to alias incl reso
      with
    | (reso', rest') =&gt;
      let str' :=
        if andb (Stdlib.op_eq_eq rest' rest) (Stdlib.op_eq_eq item' item) then
          str
        else
          cons item' rest' in
      ((Mod_subst.add_mp_delta_resolver mp_to' mp_to' reso'), str')
    end
  end.

Definition strengthen_and_subst_mb
  (mb : Declarations.generic_module_body Declarations.module_implementation)
  (mp : Names.ModPath.t) (include_b : bool) : Declarations.module_body :=
  match mod_type mb with
  | NoFunctor struc =&gt;
    let mb_is_an_alias := Mod_subst.mp_in_delta (mod_mp mb) (mod_delta mb) in
    let mp_alias := Mod_subst.mp_of_delta (mod_delta mb) (mod_mp mb) in
    let subst_resolver :=
      Mod_subst.map_mp (mod_mp mb) mp Mod_subst.empty_delta_resolver in
    let new_resolver :=
      Mod_subst.add_mp_delta_resolver mp mp_alias
        (Mod_subst.subst_dom_delta_resolver subst_resolver (mod_delta mb)) in
    let subst := Mod_subst.map_mp (mod_mp mb) mp new_resolver in
    match
      strengthen_and_subst_struct struc subst (mod_mp mb) mp mb_is_an_alias
        include_b (mod_delta mb) with
    | (reso', struc') =&gt; record
    end
  | MoreFunctor _ _ _ =&gt;
    let subst := Mod_subst.map_mp (mod_mp mb) mp Mod_subst.empty_delta_resolver
      in
    subst_module subst do_delta_dom_codom mb
  end.

Definition subst_modtype_and_resolver
  (mtb : Declarations.module_type_body) (mp : Names.ModPath.t)
  : Declarations.module_type_body :=
  let subst := Mod_subst.map_mp (mod_mp mtb) mp Mod_subst.empty_delta_resolver
    in
  let new_delta :=
    Mod_subst.subst_dom_codom_delta_resolver subst (mod_delta mtb) in
  let full_subst := Mod_subst.map_mp (mod_mp mtb) mp new_delta in
  subst_modtype full_subst do_delta_dom_codom mtb.

Fixpoint is_bounded_expr
  (l : Names.MBIset.t) (function_parameter : Declarations.module_alg_expr)
  : bool :=
  match function_parameter with
  | MEident (MPbound mbid) =&gt; Names.MBIset.mem mbid l
  | MEapply fexpr mp =&gt;
    orb (is_bounded_expr l (MEident mp)) (is_bounded_expr l fexpr)
  | _ =&gt; false
  end.

Fixpoint clean_module_body
  (l : Names.MBIset.t)
  (mb : Declarations.generic_module_body Declarations.module_implementation)
  : Declarations.generic_module_body Declarations.module_implementation :=
  match ((mod_expr mb), (mod_type mb)) with
  | (impl, typ) =&gt;
    let typ' := clean_signature l typ in
    let impl' :=
      match impl with
      | _ =&gt; implem_smartmap (clean_signature l) (clean_expression l) impl
      end in
    if andb (Stdlib.op_eq_eq typ typ') (Stdlib.op_eq_eq impl impl') then
      mb
    else
      record
  end

with clean_module_type (l : Names.MBIset.t) (mb : Declarations.module_type_body)
  : Declarations.module_type_body :=
  match ((mod_expr mb), (mod_type mb)) with
  | (tt, typ) =&gt;
    let typ' := clean_signature l typ in
    if Stdlib.op_eq_eq typ typ' then
      mb
    else
      record
  end

with clean_field
  (l : Names.MBIset.t)
  (field : Names.Label.t * Declarations.structure_field_body)
  : Names.Label.t * Declarations.structure_field_body :=
  match field with
  | (lab, SFBmodule mb) =&gt;
    let mb' := clean_module_body l mb in
    if Stdlib.op_eq_eq mb mb' then
      field
    else
      (lab, (SFBmodule mb'))
  | _ =&gt; field
  end

with clean_structure (l : Names.MBIset.t)
  : Declarations.structure_body -&gt; Declarations.structure_body :=
  Util.List.Smart.map (clean_field l)

with clean_signature (l : Names.MBIset.t)
  : Declarations.module_signature -&gt; Declarations.module_signature :=
  functor_smart_map (clean_module_type l) (clean_structure l)

with clean_expression (l : Names.MBIset.t)
  : Declarations.module_expression -&gt; Declarations.module_expression :=
  functor_smart_map (clean_module_type l) (fun me =&gt; me).

Fixpoint collect_mbid {A : Type}
  (l : Names.MBIset.t)
  (sign : Declarations.functorize A Declarations.structure_body)
  : Declarations.functorize A Declarations.structure_body :=
  match sign with
  | MoreFunctor mbid ty m =&gt;
    let m' := collect_mbid (Names.MBIset.add mbid l) m in
    if Stdlib.op_eq_eq m m' then
      sign
    else
      MoreFunctor mbid ty m'
  | NoFunctor struc =&gt;
    let struc' := clean_structure l struc in
    if Stdlib.op_eq_eq struc struc' then
      sign
    else
      NoFunctor struc'
  end.

Definition clean_bounded_mod_expr {A : Type}
  (sign : Declarations.functorize A Declarations.structure_body)
  : Declarations.functorize A Declarations.structure_body :=
  if is_functor sign then
    collect_mbid Names.MBIset.empty sign
  else
    sign.

Definition join_constant_body
  (except : Future.UUIDSet.t) (otab : Opaqueproof.opaquetab)
  (cb : Declarations.constant_body Opaqueproof.opaque) : unit :=
  match const_body cb with
  | OpaqueDef o =&gt; Opaqueproof.join_opaque (Some except) otab o
  | _ =&gt; tt
  end.

Definition join_structure
  (except : Future.UUIDSet.t) (otab : Opaqueproof.opaquetab)
  (s : Declarations.structure_body) : unit :=
  let fix join_module {a : Type} (mb : Declarations.generic_module_body a)
    : unit :=
    Option.iter join_expression (mod_type_alg mb);
    join_signature (mod_type mb)
  with join_field
    (function_parameter : Names.Label.t * Declarations.structure_field_body)
    : unit :=
    match function_parameter with
    | (_l, body) =&gt;
      match body with
      | SFBconst sb =&gt; join_constant_body except otab sb
      | SFBmind _ =&gt; tt
      | SFBmodule m =&gt;
        implem_iter join_signature join_expression (mod_expr m);
        join_module m
      | SFBmodtype m =&gt; join_module m
      end
    end
  with join_structure (struc : Declarations.structure_body) : unit :=
    Util.List.(CList.ExtS.iter) join_field struc
  with join_signature (sign : Declarations.module_signature) : unit :=
    functor_iter join_module join_structure sign
  with join_expression (me : Declarations.module_expression) : unit :=
    functor_iter join_module
      (fun function_parameter =&gt;
        match function_parameter with
        | _ =&gt; tt
        end) me in
  join_structure s.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="names" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>names.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* File created around Apr 1994 for CiC V5.10.5 by Chet Murthy collecting
   parts of file initial.ml from CoC V4.8, Dec 1988, by G√©rard Huet,
   Thierry Coquand and Christine Paulin *)
(* Hash-consing by Bruno Barras in Feb 1998 *)
(* Extra functions for splitting/generation of identifiers by Hugo Herbelin *)
(* Restructuration by Jacek Chrzaszcz as part of the implementation of
   the module system, Aug 2002 *)
(* Abstraction over the type of constant for module inlining by Claudio
   Sacerdoti, Nov 2004 *)
(* Miscellaneous features or improvements by Hugo Herbelin,
   √âlie Soubiran, ... *)

open Pp
open Util

(** {6 Identifiers } *)

(** Representation and operations on identifiers. *)
module Id =
struct
  type t = string

  let equal = String.equal

  let compare = String.compare

  let hash = String.hash

  let check_valid ?(strict=true) x =
    let iter (fatal, x) = if fatal || strict then CErrors.user_err Pp.(str x) in
    Option.iter iter (Unicode.ident_refutation x)

  let is_valid s = match Unicode.ident_refutation s with
  | None -&gt; true
  | Some _ -&gt; false

  let of_bytes s =
    let s = Bytes.to_string s in
    check_valid s;
    String.hcons s

  let of_string s =
    let () = check_valid s in
    String.hcons s

  let of_string_soft s =
    let () = check_valid ~strict:false s in
    String.hcons s

  let to_string id = id

  let print id = str id

  module Self =
  struct
    type t = string
    let compare = compare
  end

  module Set = Set.Make(Self)
  module Map = CMap.Make(Self)

  module Pred = Predicate.Make(Self)

  module List = String.List

  let hcons = String.hcons

end

(** Representation and operations on identifiers that are allowed to be anonymous
    (i.e. &quot;_&quot; in concrete syntax). *)
module Name =
struct
  type t = Anonymous     (** anonymous identifier *)
	 | Name of Id.t  (** non-anonymous identifier *)

  let mk_name id =
    Name id

  let is_anonymous = function
    | Anonymous -&gt; true
    | Name _ -&gt; false

  let is_name = is_anonymous %&gt; not

  let compare n1 n2 = match n1, n2 with
    | Anonymous, Anonymous -&gt; 0
    | Name id1, Name id2 -&gt; Id.compare id1 id2
    | Anonymous, Name _ -&gt; -1
    | Name _, Anonymous -&gt; 1

  let equal n1 n2 = match n1, n2 with
    | Anonymous, Anonymous -&gt; true
    | Name id1, Name id2 -&gt; String.equal id1 id2
    | _ -&gt; false

  let hash = function
    | Anonymous -&gt; 0
    | Name id -&gt; Id.hash id

  let print = function
    | Anonymous -&gt; str &quot;_&quot;
    | Name id -&gt; Id.print id

  module Self_Hashcons =
    struct
      type nonrec t = t
      type u = Id.t -&gt; Id.t
      let hashcons hident = function
        | Name id -&gt; Name (hident id)
        | n -&gt; n
      let eq n1 n2 =
        n1 == n2 ||
        match (n1,n2) with
          | (Name id1, Name id2) -&gt; id1 == id2
          | (Anonymous,Anonymous) -&gt; true
          | _ -&gt; false
      let hash = hash
    end

  module Hname = Hashcons.Make(Self_Hashcons)

  let hcons = Hashcons.simple_hcons Hname.generate Hname.hcons Id.hcons

end

(** Alias, to import constructors. *)
type name = Name.t = Anonymous | Name of Id.t

(** {6 Various types based on identifiers } *)

type variable = Id.t

type module_ident = Id.t

module ModIdset = Id.Set
module ModIdmap = Id.Map

(** {6 Directory paths = section names paths } *)

(** Dirpaths are lists of module identifiers.
    The actual representation is reversed to optimise sharing:
    Coq.A.B is [&quot;B&quot;;&quot;A&quot;;&quot;Coq&quot;] *)

let default_module_name = &quot;If you see this, it's a bug&quot;

module DirPath =
struct
  type t = module_ident list

  let compare = List.compare Id.compare
  let equal = List.equal Id.equal

  let rec hash accu = function
  | [] -&gt; accu
  | id :: dp -&gt;
    let accu = Hashset.Combine.combine (Id.hash id) accu in
    hash accu dp

  let hash dp = hash 0 dp

  let make x = x
  let repr x = x

  let empty = []

  let is_empty = List.is_empty

  let to_string = function
    | [] -&gt; &quot;&lt;&gt;&quot;
    | sl -&gt; String.concat &quot;.&quot; (List.rev_map Id.to_string sl)

  let print dp = str (to_string dp)

  let initial = [default_module_name]

  module Hdir = Hashcons.Hlist(Id)

  let hcons = Hashcons.recursive_hcons Hdir.generate Hdir.hcons Id.hcons

end

(** {6 Unique names for bound modules } *)

module MBId =
struct
  type t = int * Id.t * DirPath.t

  let gen =
    let seed = ref 0 in fun () -&gt;
      let ans = !seed in
      let () = incr seed in
      ans

  let make dir s = (gen(), s, dir)

  let repr mbid = mbid

  let to_string (_i, s, p) =
    DirPath.to_string p ^ &quot;.&quot; ^ s

  let debug_to_string (i, s, p) =
    &quot;&lt;&quot;^DirPath.to_string p ^&quot;#&quot; ^ s ^&quot;#&quot;^ string_of_int i^&quot;&gt;&quot;

  let compare (x : t) (y : t) =
    if x == y then 0
    else match (x, y) with
    | (nl, idl, dpl), (nr, idr, dpr) -&gt;
      let ans = Int.compare nl nr in
      if not (Int.equal ans 0) then ans
      else
        let ans = Id.compare idl idr in
        if not (Int.equal ans 0) then ans
        else
          DirPath.compare dpl dpr

  let equal x y = x == y ||
    let (i1, id1, p1) = x in
    let (i2, id2, p2) = y in
    Int.equal i1 i2 &amp;&amp; Id.equal id1 id2 &amp;&amp; DirPath.equal p1 p2

  let to_id (_, s, _) = s

  open Hashset.Combine

  let hash (i, id, dp) =
    combine3 (Int.hash i) (Id.hash id) (DirPath.hash dp)

  module Self_Hashcons =
    struct
      type nonrec t = t
      type u = (Id.t -&gt; Id.t) * (DirPath.t -&gt; DirPath.t)
      let hashcons (hid,hdir) (n,s,dir) = (n,hid s,hdir dir)
      let eq ((n1,s1,dir1) as x) ((n2,s2,dir2) as y) =
        (x == y) ||
        (Int.equal n1 n2 &amp;&amp; s1 == s2 &amp;&amp; dir1 == dir2)
      let hash = hash
    end

  module HashMBId = Hashcons.Make(Self_Hashcons)

  let hcons = Hashcons.simple_hcons HashMBId.generate HashMBId.hcons (Id.hcons, DirPath.hcons)

end

module MBImap = CMap.Make(MBId)
module MBIset = Set.Make(MBId)

(** {6 Names of structure elements } *)

module Label =
struct
  include Id
  let make = Id.of_string
  let of_id id = id
  let to_id id = id
end

(** {6 The module part of the kernel name } *)

module ModPath = struct

  type t =
    | MPfile of DirPath.t
    | MPbound of MBId.t
    | MPdot of t * Label.t

  type module_path = t

  let rec is_bound = function
    | MPbound _ -&gt; true
    | MPdot(mp,_) -&gt; is_bound mp
    | _ -&gt; false

  let rec to_string = function
    | MPfile sl -&gt; DirPath.to_string sl
    | MPbound uid -&gt; MBId.to_string uid
    | MPdot (mp,l) -&gt; to_string mp ^ &quot;.&quot; ^ Label.to_string l

  let rec debug_to_string = function
    | MPfile sl -&gt; DirPath.to_string sl
    | MPbound uid -&gt; MBId.debug_to_string uid
    | MPdot (mp,l) -&gt; debug_to_string mp ^ &quot;.&quot; ^ Label.to_string l

  (** we compare labels first if both are MPdots *)
  let rec compare mp1 mp2 =
    if mp1 == mp2 then 0
    else match mp1, mp2 with
      | MPfile p1, MPfile p2 -&gt; DirPath.compare p1 p2
      | MPbound id1, MPbound id2 -&gt; MBId.compare id1 id2
      | MPdot (mp1, l1), MPdot (mp2, l2) -&gt;
        let c = String.compare l1 l2 in
        if not (Int.equal c 0) then c
        else compare mp1 mp2
      | MPfile _, _ -&gt; -1
      | MPbound _, MPfile _ -&gt; 1
      | MPbound _, MPdot _ -&gt; -1
      | MPdot _, _ -&gt; 1

  let rec equal mp1 mp2 = mp1 == mp2 ||
    match mp1, mp2 with
    | MPfile p1, MPfile p2 -&gt; DirPath.equal p1 p2
    | MPbound id1, MPbound id2 -&gt; MBId.equal id1 id2
    | MPdot (mp1, l1), MPdot (mp2, l2) -&gt; String.equal l1 l2 &amp;&amp; equal mp1 mp2
    | (MPfile _ | MPbound _ | MPdot _), _ -&gt; false

  open Hashset.Combine

  let rec hash = function
  | MPfile dp -&gt; combinesmall 1 (DirPath.hash dp)
  | MPbound id -&gt; combinesmall 2 (MBId.hash id)
  | MPdot (mp, lbl) -&gt;
    combinesmall 3 (combine (hash mp) (Label.hash lbl))

  let initial = MPfile DirPath.initial

  let rec dp = function
  | MPfile sl -&gt; sl
  | MPbound (_,_,dp) -&gt; dp
  | MPdot (mp,_l) -&gt; dp mp

  module Self_Hashcons = struct
    type t = module_path
    type u = (DirPath.t -&gt; DirPath.t) * (MBId.t -&gt; MBId.t) *
	(string -&gt; string)
    let rec hashcons (hdir,huniqid,hstr as hfuns) = function
      | MPfile dir -&gt; MPfile (hdir dir)
      | MPbound m -&gt; MPbound (huniqid m)
      | MPdot (md,l) -&gt; MPdot (hashcons hfuns md, hstr l)
    let eq d1 d2 =
      d1 == d2 ||
      match d1,d2 with
      | MPfile dir1, MPfile dir2 -&gt; dir1 == dir2
      | MPbound m1, MPbound m2 -&gt; m1 == m2
      | MPdot (mod1,l1), MPdot (mod2,l2) -&gt; l1 == l2 &amp;&amp; equal mod1 mod2
      | _ -&gt; false
    let hash = hash
  end

  module HashMP = Hashcons.Make(Self_Hashcons)

  let hcons =
    Hashcons.simple_hcons HashMP.generate HashMP.hcons
      (DirPath.hcons,MBId.hcons,String.hcons)

end

module DPset = Set.Make(DirPath)
module DPmap = Map.Make(DirPath)

module MPset = Set.Make(ModPath)
module MPmap = CMap.Make(ModPath)

(** {6 Kernel names } *)

module KerName = struct

  type t = {
    modpath : ModPath.t;
    knlabel : Label.t;
    mutable refhash : int;
    (** Lazily computed hash. If unset, it is set to negative values. *)
  }

  type kernel_name = t

  let make modpath knlabel =
    { modpath; knlabel; refhash = -1; }
  let repr kn = (kn.modpath, kn.knlabel)

  let modpath kn = kn.modpath
  let label kn = kn.knlabel

  let to_string_gen mp_to_string kn =
    mp_to_string kn.modpath ^ &quot;.&quot; ^ Label.to_string kn.knlabel

  let to_string kn = to_string_gen ModPath.to_string kn

  let debug_to_string kn = to_string_gen ModPath.debug_to_string kn

  let print kn = str (to_string kn)

  let debug_print kn = str (debug_to_string kn)

  let compare (kn1 : kernel_name) (kn2 : kernel_name) =
    if kn1 == kn2 then 0
    else
      let c = String.compare kn1.knlabel kn2.knlabel in
      if not (Int.equal c 0) then c
      else
        ModPath.compare kn1.modpath kn2.modpath

  let equal kn1 kn2 =
    let h1 = kn1.refhash in
    let h2 = kn2.refhash in
    if 0 &lt;= h1 &amp;&amp; 0 &lt;= h2 &amp;&amp; not (Int.equal h1 h2) then false
    else
      Label.equal kn1.knlabel kn2.knlabel &amp;&amp;
      ModPath.equal kn1.modpath kn2.modpath

  open Hashset.Combine

  let hash kn =
    let h = kn.refhash in
    if h &lt; 0 then
      let { modpath = mp; knlabel = lbl; _ } = kn in
      let h = combine (ModPath.hash mp) (Label.hash lbl) in
      (* Ensure positivity on all platforms. *)
      let h = h land 0x3FFFFFFF in
      let () = kn.refhash &lt;- h in
      h
    else h

  module Self_Hashcons = struct
    type t = kernel_name
    type u = (ModPath.t -&gt; ModPath.t) * (DirPath.t -&gt; DirPath.t)
        * (string -&gt; string)
    let hashcons (hmod,_hdir,hstr) kn =
      let { modpath = mp; knlabel = l; refhash; } = kn in
      { modpath = hmod mp; knlabel = hstr l; refhash; }
    let eq kn1 kn2 =
      kn1.modpath == kn2.modpath &amp;&amp; kn1.knlabel == kn2.knlabel
    let hash = hash
  end

  module HashKN = Hashcons.Make(Self_Hashcons)

  let hcons =
    Hashcons.simple_hcons HashKN.generate HashKN.hcons
      (ModPath.hcons,DirPath.hcons,String.hcons)
end

module KNmap = HMap.Make(KerName)
module KNpred = Predicate.Make(KerName)
module KNset = KNmap.Set

(** {6 Kernel pairs } *)

(** For constant and inductive names, we use a kernel name couple (kn1,kn2)
   where kn1 corresponds to the name used at toplevel (i.e. what the user see)
   and kn2 corresponds to the canonical kernel name i.e. in the environment
   we have {% kn1 \rhd_{\delta}^* kn2 \rhd_{\delta} t %}

   Invariants :
    - the user and canonical kn may differ only on their [module_path],
      the dirpaths and labels should be the same
    - when user and canonical parts differ, we cannot be in a section
      anymore, hence the dirpath must be empty
    - two pairs with the same user part should have the same canonical part
      in a given environment (though with backtracking, the hash-table can
      contains pairs with same user part but different canonical part from
      a previous state of the session)

   Note: since most of the time the canonical and user parts are equal,
   we handle this case with a particular constructor to spare some memory *)

module KerPair = struct

  type t =
    | Same of KerName.t (** user = canonical *)
    | Dual of KerName.t * KerName.t (** user then canonical *)

  type kernel_pair = t

  let canonical = function
    | Same kn -&gt; kn
    | Dual (_,kn) -&gt; kn

  let user = function
    | Same kn -&gt; kn
    | Dual (kn,_) -&gt; kn

  let same kn = Same kn
  let make knu knc = if KerName.equal knu knc then Same knc else Dual (knu,knc)

  let make1 = same
  let make2 mp l = same (KerName.make mp l)
  let repr2 kp = KerName.repr (user kp)
  let label kp = KerName.label (user kp)
  let modpath kp = KerName.modpath (user kp)

  let change_label kp lbl =
    let (mp1,l1) = KerName.repr (user kp)
    and (mp2,l2) = KerName.repr (canonical kp) in
    assert (String.equal l1 l2);
    if String.equal lbl l1 then kp
    else
      let kn = KerName.make mp1 lbl in
      if mp1 == mp2 then same kn
      else make kn (KerName.make mp2 lbl)

  let to_string kp = KerName.to_string (user kp)
  let print kp = str (to_string kp)

  let debug_to_string = function
    | Same kn -&gt; &quot;(&quot; ^ KerName.debug_to_string kn ^ &quot;)&quot;
    | Dual (knu,knc) -&gt;
      &quot;(&quot; ^ KerName.debug_to_string knu ^ &quot;,&quot; ^ KerName.debug_to_string knc ^ &quot;)&quot;

  let debug_print kp = str (debug_to_string kp)

  (** For ordering kernel pairs, both user or canonical parts may make
      sense, according to your needs: user for the environments, canonical
      for other uses (ex: non-logical things). *)

  module UserOrd = struct
    type t = kernel_pair
    let compare x y = KerName.compare (user x) (user y)
    let equal x y = x == y || KerName.equal (user x) (user y)
    let hash x = KerName.hash (user x)
  end

  module CanOrd = struct
    type t = kernel_pair
    let compare x y = KerName.compare (canonical x) (canonical y)
    let equal x y = x == y || KerName.equal (canonical x) (canonical y)
    let hash x = KerName.hash (canonical x)
  end

  module SyntacticOrd = struct
    let compare x y = match x, y with
      | Same knx, Same kny -&gt; KerName.compare knx kny
      | Dual (knux,kncx), Dual (knuy,kncy) -&gt;
        let c = KerName.compare knux knuy in
        if not (Int.equal c 0) then c
        else KerName.compare kncx kncy
      | Same _, _ -&gt; -1
      | Dual _, _ -&gt; 1
    let equal x y = x == y || compare x y = 0
    let hash = function
      | Same kn -&gt; KerName.hash kn
      | Dual (knu, knc) -&gt;
        Hashset.Combine.combine (KerName.hash knu) (KerName.hash knc)
  end

  (** Default (logical) comparison and hash is on the canonical part *)
  let equal = CanOrd.equal
  let hash = CanOrd.hash

  module Self_Hashcons =
    struct
      type t = kernel_pair
      type u = KerName.t -&gt; KerName.t
      let hashcons hkn = function
        | Same kn -&gt; Same (hkn kn)
        | Dual (knu,knc) -&gt; make (hkn knu) (hkn knc)
      let eq x y = (* physical comparison on subterms *)
        x == y ||
        match x,y with
        | Same x, Same y -&gt; x == y
        | Dual (ux,cx), Dual (uy,cy) -&gt; ux == uy &amp;&amp; cx == cy
        | (Same _ | Dual _), _ -&gt; false
      (** Hash-consing (despite having the same user part implies having
          the same canonical part is a logical invariant of the system, it
          is not necessarily an invariant in memory, so we treat kernel
          names as they are syntactically for hash-consing) *)
      let hash = function
      | Same kn -&gt; KerName.hash kn
      | Dual (knu, knc) -&gt;
        Hashset.Combine.combine (KerName.hash knu) (KerName.hash knc)
    end

  module HashKP = Hashcons.Make(Self_Hashcons)

end

(** {6 Constant Names} *)

module Constant = KerPair

module Cmap = HMap.Make(Constant.CanOrd)
(** A map whose keys are constants (values of the {!Constant.t} type).
    Keys are ordered wrt. &quot;canonical form&quot; of the constant. *)

module Cmap_env = HMap.Make(Constant.UserOrd)
(** A map whose keys are constants (values of the {!Constant.t} type).
    Keys are ordered wrt. &quot;user form&quot; of the constant. *)

module Cpred = Predicate.Make(Constant.CanOrd)
module Cset = Cmap.Set
module Cset_env = Cmap_env.Set

(** {6 Names of mutual inductive types } *)

module MutInd = KerPair

module Mindmap = HMap.Make(MutInd.CanOrd)
module Mindset = Mindmap.Set
module Mindmap_env = HMap.Make(MutInd.UserOrd)

(** Designation of a (particular) inductive type. *)
type inductive = MutInd.t      (* the name of the inductive type *)
               * int           (* the position of this inductive type
                                  within the block of mutually-recursive inductive types.
                                  BEWARE: indexing starts from 0. *)

(** Designation of a (particular) constructor of a (particular) inductive type. *)
type constructor = inductive   (* designates the inductive type *)
                 * int         (* the index of the constructor
                                  BEWARE: indexing starts from 1. *)

let ind_modpath (mind,_) = MutInd.modpath mind
let constr_modpath (ind,_) = ind_modpath ind

let ith_mutual_inductive (mind, _) i = (mind, i)
let ith_constructor_of_inductive ind i = (ind, i)
let inductive_of_constructor (ind, _i) = ind
let index_of_constructor (_ind, i) = i

let eq_ind (m1, i1) (m2, i2) = Int.equal i1 i2 &amp;&amp; MutInd.equal m1 m2
let eq_user_ind (m1, i1) (m2, i2) =
  Int.equal i1 i2 &amp;&amp; MutInd.UserOrd.equal m1 m2
let eq_syntactic_ind (m1, i1) (m2, i2) =
  Int.equal i1 i2 &amp;&amp; MutInd.SyntacticOrd.equal m1 m2

let ind_ord (m1, i1) (m2, i2) =
  let c = Int.compare i1 i2 in
  if Int.equal c 0 then MutInd.CanOrd.compare m1 m2 else c
let ind_user_ord (m1, i1) (m2, i2) =
  let c = Int.compare i1 i2 in
  if Int.equal c 0 then MutInd.UserOrd.compare m1 m2 else c
let ind_syntactic_ord (m1, i1) (m2, i2) =
  let c = Int.compare i1 i2 in
  if Int.equal c 0 then MutInd.SyntacticOrd.compare m1 m2 else c

let ind_hash (m, i) =
  Hashset.Combine.combine (MutInd.hash m) (Int.hash i)
let ind_user_hash (m, i) =
  Hashset.Combine.combine (MutInd.UserOrd.hash m) (Int.hash i)
let ind_syntactic_hash (m, i) =
  Hashset.Combine.combine (MutInd.SyntacticOrd.hash m) (Int.hash i)

let eq_constructor (ind1, j1) (ind2, j2) = Int.equal j1 j2 &amp;&amp; eq_ind ind1 ind2
let eq_user_constructor (ind1, j1) (ind2, j2) =
  Int.equal j1 j2 &amp;&amp; eq_user_ind ind1 ind2
let eq_syntactic_constructor (ind1, j1) (ind2, j2) =
  Int.equal j1 j2 &amp;&amp; eq_syntactic_ind ind1 ind2

let constructor_ord (ind1, j1) (ind2, j2) =
  let c = Int.compare j1 j2 in
  if Int.equal c 0 then ind_ord ind1 ind2 else c
let constructor_user_ord (ind1, j1) (ind2, j2) =
  let c = Int.compare j1 j2 in
  if Int.equal c 0 then ind_user_ord ind1 ind2 else c
let constructor_syntactic_ord (ind1, j1) (ind2, j2) =
  let c = Int.compare j1 j2 in
  if Int.equal c 0 then ind_syntactic_ord ind1 ind2 else c

let constructor_hash (ind, i) =
  Hashset.Combine.combine (ind_hash ind) (Int.hash i)
let constructor_user_hash (ind, i) =
  Hashset.Combine.combine (ind_user_hash ind) (Int.hash i)
let constructor_syntactic_hash (ind, i) =
  Hashset.Combine.combine (ind_syntactic_hash ind) (Int.hash i)

module InductiveOrdered = struct
  type t = inductive
  let compare = ind_ord
end

module InductiveOrdered_env = struct
  type t = inductive
  let compare = ind_user_ord
end

module Indset = Set.Make(InductiveOrdered)
module Indmap = Map.Make(InductiveOrdered)
module Indmap_env = Map.Make(InductiveOrdered_env)

module ConstructorOrdered = struct
  type t = constructor
  let compare = constructor_ord
end

module ConstructorOrdered_env = struct
  type t = constructor
  let compare = constructor_user_ord
end

module Constrmap = Map.Make(ConstructorOrdered)
module Constrmap_env = Map.Make(ConstructorOrdered_env)

(** {6 Hash-consing of name objects } *)

module Hind = Hashcons.Make(
  struct
    type t = inductive
    type u = MutInd.t -&gt; MutInd.t
    let hashcons hmind (mind, i) = (hmind mind, i)
    let eq (mind1,i1) (mind2,i2) = mind1 == mind2 &amp;&amp; Int.equal i1 i2
    let hash = ind_hash
  end)

module Hconstruct = Hashcons.Make(
  struct
    type t = constructor
    type u = inductive -&gt; inductive
    let hashcons hind (ind, j) = (hind ind, j)
    let eq (ind1, j1) (ind2, j2) = ind1 == ind2 &amp;&amp; Int.equal j1 j2
    let hash = constructor_hash
  end)

let hcons_con = Hashcons.simple_hcons Constant.HashKP.generate Constant.HashKP.hcons KerName.hcons
let hcons_mind = Hashcons.simple_hcons MutInd.HashKP.generate MutInd.HashKP.hcons KerName.hcons
let hcons_ind = Hashcons.simple_hcons Hind.generate Hind.hcons hcons_mind
let hcons_construct = Hashcons.simple_hcons Hconstruct.generate Hconstruct.hcons hcons_ind

(*****************)

type 'a tableKey =
  | ConstKey of 'a
  | VarKey of Id.t
  | RelKey of Int.t

type inv_rel_key = int (* index in the [rel_context] part of environment
			  starting by the end, {\em inverse}
			  of de Bruijn indice *)

let eq_table_key f ik1 ik2 =
  if ik1 == ik2 then true
  else match ik1,ik2 with
  | ConstKey c1, ConstKey c2 -&gt; f c1 c2
  | VarKey id1, VarKey id2 -&gt; Id.equal id1 id2
  | RelKey k1, RelKey k2 -&gt; Int.equal k1 k2
  | _ -&gt; false

let eq_mind_chk = MutInd.UserOrd.equal
let eq_ind_chk (kn1,i1) (kn2,i2) = Int.equal i1 i2 &amp;&amp; eq_mind_chk kn1 kn2

(*******************************************************************)
(** Compatibility layers *)

let eq_constant_key = Constant.UserOrd.equal

(** Compatibility layer for [ModPath] *)

type module_path = ModPath.t =
  | MPfile of DirPath.t
  | MPbound of MBId.t
  | MPdot of module_path * Label.t

(** Compatibility layer for [Constant] *)

module Projection =
struct
  module Repr = struct
    type t =
      { proj_ind : inductive;
        proj_npars : int;
        proj_arg : int;
        proj_name : Label.t; }

    let make proj_ind ~proj_npars ~proj_arg proj_name =
      {proj_ind;proj_npars;proj_arg;proj_name}

    let inductive c = c.proj_ind

    let mind c = fst c.proj_ind

    let constant c = KerPair.change_label (mind c) c.proj_name

    let label c = c.proj_name

    let npars c = c.proj_npars

    let arg c = c.proj_arg

    let equal a b =
      eq_ind a.proj_ind b.proj_ind &amp;&amp; Int.equal a.proj_arg b.proj_arg

    let hash p =
      Hashset.Combine.combinesmall p.proj_arg (ind_hash p.proj_ind)

    module SyntacticOrd = struct
      let compare a b =
        let c = ind_syntactic_ord a.proj_ind b.proj_ind in
        if c == 0 then Int.compare a.proj_arg b.proj_arg
        else c

      let equal a b =
        a.proj_arg == b.proj_arg &amp;&amp; eq_syntactic_ind a.proj_ind b.proj_ind

      let hash p =
        Hashset.Combine.combinesmall p.proj_arg (ind_hash p.proj_ind)
    end
    module CanOrd = struct
      let compare a b =
        let c = ind_ord a.proj_ind b.proj_ind in
        if c == 0 then Int.compare a.proj_arg b.proj_arg
        else c

      let equal a b =
        a.proj_arg == b.proj_arg &amp;&amp; eq_ind a.proj_ind b.proj_ind

      let hash p =
        Hashset.Combine.combinesmall p.proj_arg (ind_hash p.proj_ind)
    end
    module UserOrd = struct
      let compare a b =
        let c = ind_user_ord a.proj_ind b.proj_ind in
        if c == 0 then Int.compare a.proj_arg b.proj_arg
        else c

      let equal a b =
        a.proj_arg == b.proj_arg &amp;&amp; eq_user_ind a.proj_ind b.proj_ind

      let hash p =
        Hashset.Combine.combinesmall p.proj_arg (ind_user_hash p.proj_ind)
    end

    let compare a b =
      let c = ind_ord a.proj_ind b.proj_ind in
      if c == 0 then Int.compare a.proj_arg b.proj_arg
      else c

    module Self_Hashcons = struct
      type nonrec t = t
      type u = (inductive -&gt; inductive) * (Id.t -&gt; Id.t)
      let hashcons (hind,hid) p =
        { proj_ind = hind p.proj_ind;
          proj_npars = p.proj_npars;
          proj_arg = p.proj_arg;
          proj_name = hid p.proj_name }
      let eq p p' =
        p == p' || (p.proj_ind == p'.proj_ind &amp;&amp; p.proj_npars == p'.proj_npars &amp;&amp; p.proj_arg == p'.proj_arg &amp;&amp; p.proj_name == p'.proj_name)
      let hash = hash
    end
    module HashRepr = Hashcons.Make(Self_Hashcons)
    let hcons = Hashcons.simple_hcons HashRepr.generate HashRepr.hcons (hcons_ind,Id.hcons)

    let map_npars f p =
      let ind = fst p.proj_ind in
      let npars = p.proj_npars in
      let ind', npars' = f ind npars in
      if ind == ind' &amp;&amp; npars == npars' then p
      else {p with proj_ind = (ind',snd p.proj_ind); proj_npars = npars'}

    let map f p = map_npars (fun mind n -&gt; f mind, n) p

    let to_string p = Constant.to_string (constant p)
    let print p = Constant.print (constant p)
  end

  type t = Repr.t * bool

  let make c b = (c, b)

  let mind (c,_) = Repr.mind c
  let inductive (c,_) = Repr.inductive c
  let npars (c,_) = Repr.npars c
  let arg (c,_) = Repr.arg c
  let constant (c,_) = Repr.constant c
  let label (c,_) = Repr.label c
  let repr = fst
  let unfolded = snd
  let unfold (c, b as p) = if b then p else (c, true)

  let equal (c, b) (c', b') = Repr.equal c c' &amp;&amp; b == b'

  let repr_equal p p' = Repr.equal (repr p) (repr p')

  let hash (c, b) = (if b then 0 else 1) + Repr.hash c

  module SyntacticOrd = struct
    let compare (c, b) (c', b') =
      if b = b' then Repr.SyntacticOrd.compare c c' else -1
    let equal (c, b as x) (c', b' as x') =
      x == x' || b = b' &amp;&amp; Repr.SyntacticOrd.equal c c'
    let hash (c, b) = (if b then 0 else 1) + Repr.SyntacticOrd.hash c
  end
  module CanOrd = struct
    let compare (c, b) (c', b') =
      if b = b' then Repr.CanOrd.compare c c' else -1
    let equal (c, b as x) (c', b' as x') =
      x == x' || b = b' &amp;&amp; Repr.CanOrd.equal c c'
    let hash (c, b) = (if b then 0 else 1) + Repr.CanOrd.hash c
  end

  module Self_Hashcons =
    struct
      type nonrec t = t
      type u = Repr.t -&gt; Repr.t
      let hashcons hc (c,b) = (hc c,b)
      let eq ((c,b) as x) ((c',b') as y) =
        x == y || (c == c' &amp;&amp; b == b')
      let hash = hash
    end

  module HashProjection = Hashcons.Make(Self_Hashcons)

  let hcons = Hashcons.simple_hcons HashProjection.generate HashProjection.hcons Repr.hcons

  let compare (c, b) (c', b') =
    if b == b' then Repr.compare c c'
    else if b then 1 else -1

  let map f (c, b as x) =
    let c' = Repr.map f c in
    if c' == c then x else (c', b)

  let map_npars f (c, b as x) =
    let c' = Repr.map_npars f c in
    if c' == c then x else (c', b)

  let to_string p = Constant.to_string (constant p)
  let print p = Constant.print (constant p)

end

module GlobRefInternal = struct

  type t =
    | VarRef of variable           (** A reference to the section-context. *)
    | ConstRef of Constant.t       (** A reference to the environment. *)
    | IndRef of inductive          (** A reference to an inductive type. *)
    | ConstructRef of constructor  (** A reference to a constructor of an inductive type. *)

  let equal gr1 gr2 =
    gr1 == gr2 || match gr1,gr2 with
    | ConstRef con1, ConstRef con2 -&gt; Constant.equal con1 con2
    | IndRef kn1, IndRef kn2 -&gt; eq_ind kn1 kn2
    | ConstructRef kn1, ConstructRef kn2 -&gt; eq_constructor kn1 kn2
    | VarRef v1, VarRef v2 -&gt; Id.equal v1 v2
    | (ConstRef _ | IndRef _ | ConstructRef _ | VarRef _), _ -&gt; false

  let global_eq_gen eq_cst eq_ind eq_cons x y =
    x == y ||
    match x, y with
    | ConstRef cx, ConstRef cy -&gt; eq_cst cx cy
    | IndRef indx, IndRef indy -&gt; eq_ind indx indy
    | ConstructRef consx, ConstructRef consy -&gt; eq_cons consx consy
    | VarRef v1, VarRef v2 -&gt; Id.equal v1 v2
    | (VarRef _ | ConstRef _ | IndRef _ | ConstructRef _), _ -&gt; false

  let global_ord_gen ord_cst ord_ind ord_cons x y =
    if x == y then 0
    else match x, y with
    | VarRef v1, VarRef v2 -&gt; Id.compare v1 v2
    | VarRef _, _ -&gt; -1
    | _, VarRef _ -&gt; 1
    | ConstRef cx, ConstRef cy -&gt; ord_cst cx cy
    | ConstRef _, _ -&gt; -1
    | _, ConstRef _ -&gt; 1
    | IndRef indx, IndRef indy -&gt; ord_ind indx indy
    | IndRef _, _ -&gt; -1
    | _ , IndRef _ -&gt; 1
    | ConstructRef consx, ConstructRef consy -&gt; ord_cons consx consy

  let global_hash_gen hash_cst hash_ind hash_cons gr =
    let open Hashset.Combine in
    match gr with
    | ConstRef c -&gt; combinesmall 1 (hash_cst c)
    | IndRef i -&gt; combinesmall 2 (hash_ind i)
    | ConstructRef c -&gt; combinesmall 3 (hash_cons c)
    | VarRef id -&gt; combinesmall 4 (Id.hash id)

end

module GlobRef = struct

  type t = GlobRefInternal.t =
    | VarRef of variable           (** A reference to the section-context. *)
    | ConstRef of Constant.t       (** A reference to the environment. *)
    | IndRef of inductive          (** A reference to an inductive type. *)
    | ConstructRef of constructor  (** A reference to a constructor of an inductive type. *)

  let equal = GlobRefInternal.equal

  (* By default, [global_reference] are ordered on their canonical part *)

  module Ordered = struct
    open Constant.CanOrd
    type t = GlobRefInternal.t
    let compare gr1 gr2 =
      GlobRefInternal.global_ord_gen compare ind_ord constructor_ord gr1 gr2
    let equal gr1 gr2 = GlobRefInternal.global_eq_gen equal eq_ind eq_constructor gr1 gr2
    let hash gr = GlobRefInternal.global_hash_gen hash ind_hash constructor_hash gr
  end

  module Ordered_env = struct
    open Constant.UserOrd
    type t = GlobRefInternal.t
    let compare gr1 gr2 =
      GlobRefInternal.global_ord_gen compare ind_user_ord constructor_user_ord gr1 gr2
    let equal gr1 gr2 =
      GlobRefInternal.global_eq_gen equal eq_user_ind eq_user_constructor gr1 gr2
    let hash gr = GlobRefInternal.global_hash_gen hash ind_user_hash constructor_user_hash gr
  end

  module Map = HMap.Make(Ordered)
  module Set = Map.Set

  (* Alternative sets and maps indexed by the user part of the kernel names *)

  module Map_env = HMap.Make(Ordered_env)
  module Set_env = Map_env.Set

end

type evaluable_global_reference =
  | EvalVarRef of Id.t
  | EvalConstRef of Constant.t

(* Better to have it here that in closure, since used in grammar.cma *)
let eq_egr e1 e2 = match e1, e2 with
    EvalConstRef con1, EvalConstRef con2 -&gt; Constant.equal con1 con2
  | EvalVarRef id1, EvalVarRef id2 -&gt; Id.equal id1 id2
  | _, _ -&gt; false

(** Located identifiers and objects with syntax. *)

type lident = Id.t CAst.t
type lname = Name.t CAst.t
type lstring = string CAst.t
</pre>
          </div>
          <div class="col-md-6">
            <code>names.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Pp.

Import Util.

Module Id.
  Definition t := string.
  
  Definition equal
    : Util.String.(CString.ExtS.t) -&gt; Util.String.(CString.ExtS.t) -&gt; bool :=
    Util.String.(CString.ExtS.equal).
  
  Definition compare
    : Util.String.(CString.ExtS.t) -&gt; Util.String.(CString.ExtS.t) -&gt; Z :=
    Util.String.(CString.ExtS.compare).
  
  Definition hash : string -&gt; Z := Util.String.(CString.ExtS.hash).
  
  Definition check_valid (op_star_o_p_t_star : option bool) : string -&gt; unit :=
    let strict :=
      match op_star_o_p_t_star with
      | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
      | None =&gt; true
      end in
    fun x =&gt;
      let iter (function_parameter : bool * string) : unit :=
        match function_parameter with
        | (fatal, x) =&gt;
          if orb fatal strict then
            CErrors.user_err None None (Pp.str x)
          else
            tt
        end in
      Option.iter iter (Unicode.ident_refutation x).
  
  Definition is_valid (s : string) : bool :=
    match Unicode.ident_refutation s with
    | None =&gt; true
    | Some _ =&gt; false
    end.
  
  Definition of_bytes (s : string) : string :=
    let s := Stdlib.Bytes.to_string s in
    check_valid None s;
    Util.String.(CString.ExtS.hcons) s.
  
  Definition of_string (s : string) : string :=
    match check_valid None s with
    | tt =&gt; Util.String.(CString.ExtS.hcons) s
    end.
  
  Definition of_string_soft (s : string) : string :=
    match check_valid (Some false) s with
    | tt =&gt; Util.String.(CString.ExtS.hcons) s
    end.
  
  Definition to_string {A : Type} (id : A) : A := id.
  
  Definition print (id : string) : Pp.t := Pp.str id.
  
  Module Self.
    Definition t := string.
    
    Definition compare
      : Util.String.(CString.ExtS.t) -&gt; Util.String.(CString.ExtS.t) -&gt; Z :=
      compare.
  End Self.
  
  Definition hcons : string -&gt; string := Util.String.(CString.ExtS.hcons).
End Id.

Module Name.
  Inductive t : Type :=
  | Anonymous : t
  | Name : Id.t -&gt; t.
  
  Definition mk_name (id : Id.t) : t := Name id.
  
  Definition is_anonymous (function_parameter : t) : bool :=
    match function_parameter with
    | Anonymous =&gt; true
    | Name _ =&gt; false
    end.
  
  Definition is_name : t -&gt; bool := Util.op_percent_gt is_anonymous negb.
  
  Definition compare (n1 : t) (n2 : t) : Z :=
    match (n1, n2) with
    | (Anonymous, Anonymous) =&gt; 0
    | (Name id1, Name id2) =&gt; Id.compare id1 id2
    | (Anonymous, Name _) =&gt; (-1)
    | (Name _, Anonymous) =&gt; 1
    end.
  
  Definition equal (n1 : t) (n2 : t) : bool :=
    match (n1, n2) with
    | (Anonymous, Anonymous) =&gt; true
    | (Name id1, Name id2) =&gt; Util.String.(CString.ExtS.equal) id1 id2
    | _ =&gt; false
    end.
  
  Definition hash (function_parameter : t) : Z :=
    match function_parameter with
    | Anonymous =&gt; 0
    | Name id =&gt; Id.hash id
    end.
  
  Definition print (function_parameter : t) : Pp.t :=
    match function_parameter with
    | Anonymous =&gt; Pp.str &quot;_&quot; % string
    | Name id =&gt; Id.print id
    end.
  
  Module Self_Hashcons.
    Definition t := t.
    
    Definition u := Id.t -&gt; Id.t.
    
    Definition hashcons (hident : Id.t -&gt; Id.t) (function_parameter : t) : t :=
      match function_parameter with
      | Name id =&gt; Name (hident id)
      | n =&gt; n
      end.
    
    Definition eq (n1 : t) (n2 : t) : bool :=
      orb (Stdlib.op_eq_eq n1 n2)
        match (n1, n2) with
        | (Name id1, Name id2) =&gt; Stdlib.op_eq_eq id1 id2
        | (Anonymous, Anonymous) =&gt; true
        | _ =&gt; false
        end.
    
    Definition hash : t -&gt; Z := hash.
  End Self_Hashcons.
  
  Definition hcons : Hname.t -&gt; Hname.t :=
    Hashcons.simple_hcons Hname.(Hashcons.S.generate) Hname.(Hashcons.S.hcons)
      Id.hcons.
End Name.

Inductive name : Type :=
| Anonymous : name
| Name : Id.t -&gt; name.

Definition variable := Id.t.

Definition module_ident := Id.t.

Definition default_module_name : string :=
  &quot;If you see this, it's a bug&quot; % string.

Module DirPath.
  Definition t := list module_ident.
  
  Definition compare : CList.cmp (list Util.String.(CString.ExtS.t)) :=
    Util.List.(CList.ExtS.compare) Id.compare.
  
  Definition equal : CList.eq (list Util.String.(CString.ExtS.t)) :=
    Util.List.(CList.ExtS.equal) Id.equal.
  
  Fixpoint hash (accu : Z) (function_parameter : list string) : Z :=
    match function_parameter with
    | [] =&gt; accu
    | cons id dp =&gt;
      let accu := Hashset.Combine.combine (Id.hash id) accu in
      hash accu dp
    end.
  
  Definition hash (dp : list string) : Z := hash 0 dp.
  
  Definition make {A : Type} (x : A) : A := x.
  
  Definition repr {A : Type} (x : A) : A := x.
  
  Definition empty {A : Type} : list A := [].
  
  Definition is_empty {A : Type} : (list A) -&gt; bool :=
    Util.List.(CList.ExtS.is_empty).
  
  Definition to_string (function_parameter : list string) : string :=
    match function_parameter with
    | [] =&gt; &quot;&lt;&gt;&quot; % string
    | sl =&gt;
      Util.String.(CString.ExtS.concat) &quot;.&quot; % string
        (Util.List.(CList.ExtS.rev_map) Id.to_string sl)
    end.
  
  Definition print (dp : list string) : Pp.t := Pp.str (to_string dp).
  
  Definition initial : list string := cons default_module_name [].
  
  Definition hcons : Hdir.(Hashcons.S.t) -&gt; Hdir.(Hashcons.S.t) :=
    Hashcons.recursive_hcons Hdir.(Hashcons.S.generate) Hdir.(Hashcons.S.hcons)
      Id.hcons.
End DirPath.

Module MBId.
  Definition t := Z * Id.t * DirPath.t.
  
  Definition gen : unit -&gt; Z :=
    let seed := Stdlib.ref 0 in
    fun function_parameter =&gt;
      match function_parameter with
      | tt =&gt;
        let ans := Util.op_exclamation seed in
        match Stdlib.incr seed with
        | tt =&gt; ans
        end
      end.
  
  Definition make {A B : Type} (dir : A) (s : B) : Z * B * A :=
    ((gen tt), s, dir).
  
  Definition repr {A : Type} (mbid : A) : A := mbid.
  
  Definition to_string {A : Type}
    (function_parameter : A * string * (list string)) : string :=
    match function_parameter with
    | (_i, s, p) =&gt;
      String.append (DirPath.to_string p) (String.append &quot;.&quot; % string s)
    end.
  
  Definition debug_to_string (function_parameter : Z * string * (list string))
    : string :=
    match function_parameter with
    | (i, s, p) =&gt;
      String.append &quot;&lt;&quot; % string
        (String.append (DirPath.to_string p)
          (String.append &quot;#&quot; % string
            (String.append s
              (String.append &quot;#&quot; % string
                (String.append (OCaml.Stdlib.string_of_int i) &quot;&gt;&quot; % string)))))
    end.
  
  Definition compare (x : t) (y : t) : Z :=
    if Stdlib.op_eq_eq x y then
      0
    else
      match (x, y) with
      | ((nl, idl, dpl), (nr, idr, dpr)) =&gt;
        let ans := Int.compare nl nr in
        if negb (Int.equal ans 0) then
          ans
        else
          let ans := Id.compare idl idr in
          if negb (Int.equal ans 0) then
            ans
          else
            DirPath.compare dpl dpr
      end.
  
  Definition equal
    (x :
      Int.t * Util.String.(CString.ExtS.t) * (list Util.String.(CString.ExtS.t)))
    (y :
      Int.t * Util.String.(CString.ExtS.t) * (list Util.String.(CString.ExtS.t)))
    : bool :=
    orb (Stdlib.op_eq_eq x y)
      match x with
      | (i1, id1, p1) =&gt;
        match y with
        | (i2, id2, p2) =&gt;
          andb (Int.equal i1 i2) (andb (Id.equal id1 id2) (DirPath.equal p1 p2))
        end
      end.
  
  Definition to_id {A B C : Type} (function_parameter : A * B * C) : B :=
    match function_parameter with
    | (_, s, _) =&gt; s
    end.
  
  Import Hashset.Combine.
  
  Definition hash (function_parameter : Int.t * string * (list string)) : Z :=
    match function_parameter with
    | (i, id, dp) =&gt;
      Hashset.Combine.combine3 (Int.hash i) (Id.hash id) (DirPath.hash dp)
    end.
  
  Module Self_Hashcons.
    Definition t := t.
    
    Definition u := (Id.t -&gt; Id.t) * (DirPath.t -&gt; DirPath.t).
    
    Definition hashcons {A B C D E : Type}
      (function_parameter : (A -&gt; B) * (C -&gt; D)) : (E * A * C) -&gt; E * B * D :=
      match function_parameter with
      | (hid, hdir) =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | (n, s, dir) =&gt; (n, (hid s), (hdir dir))
          end
      end.
    
    Definition eq {A B : Type} (function_parameter : Int.t * A * B)
      : (Int.t * A * B) -&gt; bool :=
      match function_parameter with
      | (n1, s1, dir1) as x =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | (n2, s2, dir2) as y =&gt;
            orb (Stdlib.op_eq_eq x y)
              (andb (Int.equal n1 n2)
                (andb (Stdlib.op_eq_eq s1 s2) (Stdlib.op_eq_eq dir1 dir2)))
          end
      end.
    
    Definition hash : (Int.t * string * (list string)) -&gt; Z := hash.
  End Self_Hashcons.
  
  Definition hcons : HashMBId.(Hashcons.S.t) -&gt; HashMBId.(Hashcons.S.t) :=
    Hashcons.simple_hcons HashMBId.(Hashcons.S.generate)
      HashMBId.(Hashcons.S.hcons) (Id.hcons, DirPath.hcons).
End MBId.

Module Label.
  Definition make : string -&gt; string := Id.of_string.
  
  Definition of_id {A : Type} (id : A) : A := id.
  
  Definition to_id {A : Type} (id : A) : A := id.
End Label.

Module ModPath.
  Inductive t : Type :=
  | MPfile : DirPath.t -&gt; t
  | MPbound : MBId.t -&gt; t
  | MPdot : t -&gt; Label.t -&gt; t.
  
  Definition module_path := t.
  
  Fixpoint is_bound (function_parameter : t) : bool :=
    match function_parameter with
    | MPbound _ =&gt; true
    | MPdot mp _ =&gt; is_bound mp
    | _ =&gt; false
    end.
  
  Fixpoint to_string (function_parameter : t) : string :=
    match function_parameter with
    | MPfile sl =&gt; DirPath.to_string sl
    | MPbound uid =&gt; MBId.to_string uid
    | MPdot mp l =&gt;
      String.append (to_string mp)
        (String.append &quot;.&quot; % string (Label.to_string l))
    end.
  
  Fixpoint debug_to_string (function_parameter : t) : string :=
    match function_parameter with
    | MPfile sl =&gt; DirPath.to_string sl
    | MPbound uid =&gt; MBId.debug_to_string uid
    | MPdot mp l =&gt;
      String.append (debug_to_string mp)
        (String.append &quot;.&quot; % string (Label.to_string l))
    end.
  
  Fixpoint compare (mp1 : t) (mp2 : t) : Z :=
    if Stdlib.op_eq_eq mp1 mp2 then
      0
    else
      match (mp1, mp2) with
      | (MPfile p1, MPfile p2) =&gt; DirPath.compare p1 p2
      | (MPbound id1, MPbound id2) =&gt; MBId.compare id1 id2
      | (MPdot mp1 l1, MPdot mp2 l2) =&gt;
        let c := Util.String.(CString.ExtS.compare) l1 l2 in
        if negb (Int.equal c 0) then
          c
        else
          compare mp1 mp2
      | (MPfile _, _) =&gt; (-1)
      | (MPbound _, MPfile _) =&gt; 1
      | (MPbound _, MPdot _ _) =&gt; (-1)
      | (MPdot _ _, _) =&gt; 1
      end.
  
  Fixpoint equal (mp1 : t) (mp2 : t) : bool :=
    orb (Stdlib.op_eq_eq mp1 mp2)
      match (mp1, mp2) with
      | (MPfile p1, MPfile p2) =&gt; DirPath.equal p1 p2
      | (MPbound id1, MPbound id2) =&gt; MBId.equal id1 id2
      | (MPdot mp1 l1, MPdot mp2 l2) =&gt;
        andb (Util.String.(CString.ExtS.equal) l1 l2) (equal mp1 mp2)
      | (MPfile _ | MPbound _ | MPdot _ _, _) =&gt; false
      end.
  
  Import Hashset.Combine.
  
  Fixpoint hash (function_parameter : t) : Z :=
    match function_parameter with
    | MPfile dp =&gt; Hashset.Combine.combinesmall 1 (DirPath.hash dp)
    | MPbound id =&gt; Hashset.Combine.combinesmall 2 (MBId.hash id)
    | MPdot mp lbl =&gt;
      Hashset.Combine.combinesmall 3
        (Hashset.Combine.combine (hash mp) (Label.hash lbl))
    end.
  
  Definition initial : t := MPfile DirPath.initial.
  
  Fixpoint dp (function_parameter : t) : DirPath.t :=
    match function_parameter with
    | MPfile sl =&gt; sl
    | MPbound (_, _, dp) =&gt; dp
    | MPdot mp _l =&gt; dp mp
    end.
  
  Module Self_Hashcons.
    Definition t := module_path.
    
    Definition u :=
      (DirPath.t -&gt; DirPath.t) * (MBId.t -&gt; MBId.t) * (string -&gt; string).
    
    Fixpoint hashcons
      (function_parameter :
        (DirPath.t -&gt; DirPath.t) * (MBId.t -&gt; MBId.t) * (Label.t -&gt; Label.t))
      : t -&gt; t :=
      match function_parameter with
      | (hdir, huniqid, hstr) as hfuns =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | MPfile dir =&gt; MPfile (hdir dir)
          | MPbound m =&gt; MPbound (huniqid m)
          | MPdot md l =&gt; MPdot (hashcons hfuns md) (hstr l)
          end
      end.
    
    Definition eq (d1 : t) (d2 : t) : bool :=
      orb (Stdlib.op_eq_eq d1 d2)
        match (d1, d2) with
        | (MPfile dir1, MPfile dir2) =&gt; Stdlib.op_eq_eq dir1 dir2
        | (MPbound m1, MPbound m2) =&gt; Stdlib.op_eq_eq m1 m2
        | (MPdot mod1 l1, MPdot mod2 l2) =&gt;
          andb (Stdlib.op_eq_eq l1 l2) (equal mod1 mod2)
        | _ =&gt; false
        end.
    
    Definition hash : t -&gt; Z := hash.
  End Self_Hashcons.
  
  Definition hcons : HashMP.(Hashcons.S.t) -&gt; HashMP.(Hashcons.S.t) :=
    Hashcons.simple_hcons HashMP.(Hashcons.S.generate) HashMP.(Hashcons.S.hcons)
      (DirPath.hcons, MBId.hcons, Util.String.(CString.ExtS.hcons)).
End ModPath.

Module KerName.
  Record t := {
    modpath : ModPath.t;
    knlabel : Label.t;
    refhash : Z }.
  
  Definition kernel_name := t.
  
  Definition make (modpath : ModPath.t) (knlabel : Label.t) : t :=
    {| modpath := modpath; knlabel := knlabel; refhash := (-1) |}.
  
  Definition repr (kn : t) : ModPath.t * Label.t := ((modpath kn), (knlabel kn)).
  
  Definition modpath (kn : t) : ModPath.t := modpath kn.
  
  Definition label (kn : t) : Label.t := knlabel kn.
  
  Definition to_string_gen (mp_to_string : ModPath.t -&gt; string) (kn : t)
    : string :=
    String.append (mp_to_string (modpath kn))
      (String.append &quot;.&quot; % string (Label.to_string (knlabel kn))).
  
  Definition to_string (kn : t) : string := to_string_gen ModPath.to_string kn.
  
  Definition debug_to_string (kn : t) : string :=
    to_string_gen ModPath.debug_to_string kn.
  
  Definition print (kn : t) : Pp.t := Pp.str (to_string kn).
  
  Definition debug_print (kn : t) : Pp.t := Pp.str (debug_to_string kn).
  
  Definition compare (kn1 : kernel_name) (kn2 : kernel_name) : Z :=
    if Stdlib.op_eq_eq kn1 kn2 then
      0
    else
      let c := Util.String.(CString.ExtS.compare) (knlabel kn1) (knlabel kn2) in
      if negb (Int.equal c 0) then
        c
      else
        ModPath.compare (modpath kn1) (modpath kn2).
  
  Definition equal (kn1 : t) (kn2 : t) : bool :=
    let h1 := refhash kn1 in
    let h2 := refhash kn2 in
    if
      andb (OCaml.Stdlib.le 0 h1)
        (andb (OCaml.Stdlib.le 0 h2) (negb (Int.equal h1 h2))) then
      false
    else
      andb (Label.equal (knlabel kn1) (knlabel kn2))
        (ModPath.equal (modpath kn1) (modpath kn2)).
  
  Import Hashset.Combine.
  
  Definition hash (kn : t) : Z :=
    let h := refhash kn in
    if OCaml.Stdlib.lt h 0 then
      match kn with
      | {| modpath := mp; knlabel := lbl |} =&gt;
        let h := Hashset.Combine.combine (ModPath.hash mp) (Label.hash lbl) in
        let h := Z.land h 1073741823 in
        match set_field with
        | tt =&gt; h
        end
      end
    else
      h.
  
  Module Self_Hashcons.
    Definition t := kernel_name.
    
    Definition u :=
      (ModPath.t -&gt; ModPath.t) * (DirPath.t -&gt; DirPath.t) * (string -&gt; string).
    
    Definition hashcons {A : Type}
      (function_parameter : (ModPath.t -&gt; ModPath.t) * A * (Label.t -&gt; Label.t))
      : t -&gt; t :=
      match function_parameter with
      | (hmod, _hdir, hstr) =&gt;
        fun kn =&gt;
          match kn with
          | {| modpath := mp; knlabel := l; refhash := refhash |} =&gt;
            {| modpath := hmod mp; knlabel := hstr l; refhash := refhash |}
          end
      end.
    
    Definition eq (kn1 : t) (kn2 : t) : bool :=
      andb (Stdlib.op_eq_eq (modpath kn1) (modpath kn2))
        (Stdlib.op_eq_eq (knlabel kn1) (knlabel kn2)).
    
    Definition hash : t -&gt; Z := hash.
  End Self_Hashcons.
  
  Definition hcons : HashKN.(Hashcons.S.t) -&gt; HashKN.(Hashcons.S.t) :=
    Hashcons.simple_hcons HashKN.(Hashcons.S.generate) HashKN.(Hashcons.S.hcons)
      (ModPath.hcons, DirPath.hcons, Util.String.(CString.ExtS.hcons)).
End KerName.

Module KerPair.
  Inductive t : Type :=
  | Same : KerName.t -&gt; t
  | Dual : KerName.t -&gt; KerName.t -&gt; t.
  
  Definition kernel_pair := t.
  
  Definition canonical (function_parameter : t) : KerName.t :=
    match function_parameter with
    | Same kn =&gt; kn
    | Dual _ kn =&gt; kn
    end.
  
  Definition user (function_parameter : t) : KerName.t :=
    match function_parameter with
    | Same kn =&gt; kn
    | Dual kn _ =&gt; kn
    end.
  
  Definition same (kn : KerName.t) : t := Same kn.
  
  Definition make (knu : KerName.t) (knc : KerName.t) : t :=
    if KerName.equal knu knc then
      Same knc
    else
      Dual knu knc.
  
  Definition make1 : KerName.t -&gt; t := same.
  
  Definition make2 (mp : ModPath.t) (l : Label.t) : t :=
    same (KerName.make mp l).
  
  Definition repr2 (kp : t) : ModPath.t * Label.t := KerName.repr (user kp).
  
  Definition label (kp : t) : Label.t := KerName.label (user kp).
  
  Definition modpath (kp : t) : ModPath.t := KerName.modpath (user kp).
  
  Definition change_label (kp : t) (lbl : Util.String.(CString.ExtS.t)) : t :=
    in
    Util.String.(CString.ExtS.equal) l1 l2;
    if Util.String.(CString.ExtS.equal) lbl l1 then
      kp
    else
      let kn := KerName.make mp1 lbl in
      if Stdlib.op_eq_eq mp1 mp2 then
        same kn
      else
        make kn (KerName.make mp2 lbl).
  
  Definition to_string (kp : t) : string := KerName.to_string (user kp).
  
  Definition print (kp : t) : Pp.t := Pp.str (to_string kp).
  
  Definition debug_to_string (function_parameter : t) : string :=
    match function_parameter with
    | Same kn =&gt;
      String.append &quot;(&quot; % string
        (String.append (KerName.debug_to_string kn) &quot;)&quot; % string)
    | Dual knu knc =&gt;
      String.append &quot;(&quot; % string
        (String.append (KerName.debug_to_string knu)
          (String.append &quot;,&quot; % string
            (String.append (KerName.debug_to_string knc) &quot;)&quot; % string)))
    end.
  
  Definition debug_print (kp : t) : Pp.t := Pp.str (debug_to_string kp).
  
  Module UserOrd.
    Definition t := kernel_pair.
    
    Definition compare (x : t) (y : t) : Z := KerName.compare (user x) (user y).
    
    Definition equal (x : t) (y : t) : bool :=
      orb (Stdlib.op_eq_eq x y) (KerName.equal (user x) (user y)).
    
    Definition hash (x : t) : Z := KerName.hash (user x).
  End UserOrd.
  
  Module CanOrd.
    Definition t := kernel_pair.
    
    Definition compare (x : t) (y : t) : Z :=
      KerName.compare (canonical x) (canonical y).
    
    Definition equal (x : t) (y : t) : bool :=
      orb (Stdlib.op_eq_eq x y) (KerName.equal (canonical x) (canonical y)).
    
    Definition hash (x : t) : Z := KerName.hash (canonical x).
  End CanOrd.
  
  Module SyntacticOrd.
    Definition compare (x : t) (y : t) : Z :=
      match (x, y) with
      | (Same knx, Same kny) =&gt; KerName.compare knx kny
      | (Dual knux kncx, Dual knuy kncy) =&gt;
        let c := KerName.compare knux knuy in
        if negb (Int.equal c 0) then
          c
        else
          KerName.compare kncx kncy
      | (Same _, _) =&gt; (-1)
      | (Dual _ _, _) =&gt; 1
      end.
    
    Definition equal (x : t) (y : t) : bool :=
      orb (Stdlib.op_eq_eq x y) (equiv_decb (compare x y) 0).
    
    Definition hash (function_parameter : t) : Z :=
      match function_parameter with
      | Same kn =&gt; KerName.hash kn
      | Dual knu knc =&gt;
        Hashset.Combine.combine (KerName.hash knu) (KerName.hash knc)
      end.
  End SyntacticOrd.
  
  Definition equal : t -&gt; t -&gt; bool := CanOrd.equal.
  
  Definition hash : t -&gt; Z := CanOrd.hash.
  
  Module Self_Hashcons.
    Definition t := kernel_pair.
    
    Definition u := KerName.t -&gt; KerName.t.
    
    Definition hashcons (hkn : KerName.t -&gt; KerName.t) (function_parameter : t)
      : t :=
      match function_parameter with
      | Same kn =&gt; Same (hkn kn)
      | Dual knu knc =&gt; make (hkn knu) (hkn knc)
      end.
    
    Definition eq (x : t) (y : t) : bool :=
      orb (Stdlib.op_eq_eq x y)
        match (x, y) with
        | (Same x, Same y) =&gt; Stdlib.op_eq_eq x y
        | (Dual ux cx, Dual uy cy) =&gt;
          andb (Stdlib.op_eq_eq ux uy) (Stdlib.op_eq_eq cx cy)
        | (Same _ | Dual _ _, _) =&gt; false
        end.
    
    Definition hash (function_parameter : t) : Z :=
      match function_parameter with
      | Same kn =&gt; KerName.hash kn
      | Dual knu knc =&gt;
        Hashset.Combine.combine (KerName.hash knu) (KerName.hash knc)
      end.
  End Self_Hashcons.
End KerPair.

Definition inductive := MutInd.t * Z.

Definition constructor := inductive * Z.

Definition ind_modpath {A : Type} (function_parameter : MutInd.t * A)
  : ModPath.t :=
  match function_parameter with
  | (mind, _) =&gt; MutInd.modpath mind
  end.

Definition constr_modpath {A B : Type} (function_parameter : (MutInd.t * A) * B)
  : ModPath.t :=
  match function_parameter with
  | (ind, _) =&gt; ind_modpath ind
  end.

Definition ith_mutual_inductive {A B C : Type} (function_parameter : A * B)
  : C -&gt; A * C :=
  match function_parameter with
  | (mind, _) =&gt; fun i =&gt; (mind, i)
  end.

Definition ith_constructor_of_inductive {A B : Type} (ind : A) (i : B)
  : A * B := (ind, i).

Definition inductive_of_constructor {A B : Type} (function_parameter : A * B)
  : A :=
  match function_parameter with
  | (ind, _i) =&gt; ind
  end.

Definition index_of_constructor {A B : Type} (function_parameter : A * B) : B :=
  match function_parameter with
  | (_ind, i) =&gt; i
  end.

Definition eq_ind (function_parameter : MutInd.t * Int.t)
  : (MutInd.t * Int.t) -&gt; bool :=
  match function_parameter with
  | (m1, i1) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (m2, i2) =&gt; andb (Int.equal i1 i2) (MutInd.equal m1 m2)
      end
  end.

Definition eq_user_ind (function_parameter : KerPair.t * Int.t)
  : (KerPair.t * Int.t) -&gt; bool :=
  match function_parameter with
  | (m1, i1) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (m2, i2) =&gt; andb (Int.equal i1 i2) (MutInd.UserOrd.equal m1 m2)
      end
  end.

Definition eq_syntactic_ind (function_parameter : KerPair.t * Int.t)
  : (KerPair.t * Int.t) -&gt; bool :=
  match function_parameter with
  | (m1, i1) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (m2, i2) =&gt; andb (Int.equal i1 i2) (MutInd.SyntacticOrd.equal m1 m2)
      end
  end.

Definition ind_ord (function_parameter : KerPair.t * Int.t)
  : (KerPair.t * Int.t) -&gt; Z :=
  match function_parameter with
  | (m1, i1) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (m2, i2) =&gt;
        let c := Int.compare i1 i2 in
        if Int.equal c 0 then
          MutInd.CanOrd.compare m1 m2
        else
          c
      end
  end.

Definition ind_user_ord (function_parameter : KerPair.t * Int.t)
  : (KerPair.t * Int.t) -&gt; Z :=
  match function_parameter with
  | (m1, i1) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (m2, i2) =&gt;
        let c := Int.compare i1 i2 in
        if Int.equal c 0 then
          MutInd.UserOrd.compare m1 m2
        else
          c
      end
  end.

Definition ind_syntactic_ord (function_parameter : KerPair.t * Int.t)
  : (KerPair.t * Int.t) -&gt; Z :=
  match function_parameter with
  | (m1, i1) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (m2, i2) =&gt;
        let c := Int.compare i1 i2 in
        if Int.equal c 0 then
          MutInd.SyntacticOrd.compare m1 m2
        else
          c
      end
  end.

Definition ind_hash (function_parameter : MutInd.t * Int.t) : Z :=
  match function_parameter with
  | (m, i) =&gt; Hashset.Combine.combine (MutInd.hash m) (Int.hash i)
  end.

Definition ind_user_hash (function_parameter : KerPair.t * Int.t) : Z :=
  match function_parameter with
  | (m, i) =&gt; Hashset.Combine.combine (MutInd.UserOrd.hash m) (Int.hash i)
  end.

Definition ind_syntactic_hash (function_parameter : KerPair.t * Int.t) : Z :=
  match function_parameter with
  | (m, i) =&gt; Hashset.Combine.combine (MutInd.SyntacticOrd.hash m) (Int.hash i)
  end.

Definition eq_constructor (function_parameter : (MutInd.t * Int.t) * Int.t)
  : ((MutInd.t * Int.t) * Int.t) -&gt; bool :=
  match function_parameter with
  | (ind1, j1) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (ind2, j2) =&gt; andb (Int.equal j1 j2) (eq_ind ind1 ind2)
      end
  end.

Definition eq_user_constructor
  (function_parameter : (KerPair.t * Int.t) * Int.t)
  : ((KerPair.t * Int.t) * Int.t) -&gt; bool :=
  match function_parameter with
  | (ind1, j1) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (ind2, j2) =&gt; andb (Int.equal j1 j2) (eq_user_ind ind1 ind2)
      end
  end.

Definition eq_syntactic_constructor
  (function_parameter : (KerPair.t * Int.t) * Int.t)
  : ((KerPair.t * Int.t) * Int.t) -&gt; bool :=
  match function_parameter with
  | (ind1, j1) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (ind2, j2) =&gt; andb (Int.equal j1 j2) (eq_syntactic_ind ind1 ind2)
      end
  end.

Definition constructor_ord (function_parameter : (KerPair.t * Int.t) * Int.t)
  : ((KerPair.t * Int.t) * Int.t) -&gt; Z :=
  match function_parameter with
  | (ind1, j1) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (ind2, j2) =&gt;
        let c := Int.compare j1 j2 in
        if Int.equal c 0 then
          ind_ord ind1 ind2
        else
          c
      end
  end.

Definition constructor_user_ord
  (function_parameter : (KerPair.t * Int.t) * Int.t)
  : ((KerPair.t * Int.t) * Int.t) -&gt; Z :=
  match function_parameter with
  | (ind1, j1) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (ind2, j2) =&gt;
        let c := Int.compare j1 j2 in
        if Int.equal c 0 then
          ind_user_ord ind1 ind2
        else
          c
      end
  end.

Definition constructor_syntactic_ord
  (function_parameter : (KerPair.t * Int.t) * Int.t)
  : ((KerPair.t * Int.t) * Int.t) -&gt; Z :=
  match function_parameter with
  | (ind1, j1) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (ind2, j2) =&gt;
        let c := Int.compare j1 j2 in
        if Int.equal c 0 then
          ind_syntactic_ord ind1 ind2
        else
          c
      end
  end.

Definition constructor_hash (function_parameter : (MutInd.t * Int.t) * Int.t)
  : Z :=
  match function_parameter with
  | (ind, i) =&gt; Hashset.Combine.combine (ind_hash ind) (Int.hash i)
  end.

Definition constructor_user_hash
  (function_parameter : (KerPair.t * Int.t) * Int.t) : Z :=
  match function_parameter with
  | (ind, i) =&gt; Hashset.Combine.combine (ind_user_hash ind) (Int.hash i)
  end.

Definition constructor_syntactic_hash
  (function_parameter : (KerPair.t * Int.t) * Int.t) : Z :=
  match function_parameter with
  | (ind, i) =&gt; Hashset.Combine.combine (ind_syntactic_hash ind) (Int.hash i)
  end.

Module InductiveOrdered.
  Definition t := inductive.
  
  Definition compare : (KerPair.t * Int.t) -&gt; (KerPair.t * Int.t) -&gt; Z :=
    ind_ord.
End InductiveOrdered.

Module InductiveOrdered_env.
  Definition t := inductive.
  
  Definition compare : (KerPair.t * Int.t) -&gt; (KerPair.t * Int.t) -&gt; Z :=
    ind_user_ord.
End InductiveOrdered_env.

Module ConstructorOrdered.
  Definition t := constructor.
  
  Definition compare
    : ((KerPair.t * Int.t) * Int.t) -&gt; ((KerPair.t * Int.t) * Int.t) -&gt; Z :=
    constructor_ord.
End ConstructorOrdered.

Module ConstructorOrdered_env.
  Definition t := constructor.
  
  Definition compare
    : ((KerPair.t * Int.t) * Int.t) -&gt; ((KerPair.t * Int.t) * Int.t) -&gt; Z :=
    constructor_user_ord.
End ConstructorOrdered_env.

Definition hcons_con : Constant.HashKP.t -&gt; Constant.HashKP.t :=
  Hashcons.simple_hcons Constant.HashKP.generate Constant.HashKP.hcons
    KerName.hcons.

Definition hcons_mind : MutInd.HashKP.t -&gt; MutInd.HashKP.t :=
  Hashcons.simple_hcons MutInd.HashKP.generate MutInd.HashKP.hcons KerName.hcons.

Definition hcons_ind : Hind.(Hashcons.S.t) -&gt; Hind.(Hashcons.S.t) :=
  Hashcons.simple_hcons Hind.(Hashcons.S.generate) Hind.(Hashcons.S.hcons)
    hcons_mind.

Definition hcons_construct
  : Hconstruct.(Hashcons.S.t) -&gt; Hconstruct.(Hashcons.S.t) :=
  Hashcons.simple_hcons Hconstruct.(Hashcons.S.generate)
    Hconstruct.(Hashcons.S.hcons) hcons_ind.

Inductive tableKey (a : Type) : Type :=
| ConstKey : a -&gt; tableKey a
| VarKey : Id.t -&gt; tableKey a
| RelKey : Int.t -&gt; tableKey a.

Arguments ConstKey {_}.
Arguments VarKey {_}.
Arguments RelKey {_}.

Definition inv_rel_key := Z.

Definition eq_table_key {A : Type}
  (f : A -&gt; A -&gt; bool) (ik1 : tableKey A) (ik2 : tableKey A) : bool :=
  if Stdlib.op_eq_eq ik1 ik2 then
    true
  else
    match (ik1, ik2) with
    | (ConstKey c1, ConstKey c2) =&gt; f c1 c2
    | (VarKey id1, VarKey id2) =&gt; Id.equal id1 id2
    | (RelKey k1, RelKey k2) =&gt; Int.equal k1 k2
    | _ =&gt; false
    end.

Definition eq_mind_chk : KerPair.t -&gt; KerPair.t -&gt; bool := MutInd.UserOrd.equal.

Definition eq_ind_chk (function_parameter : KerPair.t * Int.t)
  : (KerPair.t * Int.t) -&gt; bool :=
  match function_parameter with
  | (kn1, i1) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (kn2, i2) =&gt; andb (Int.equal i1 i2) (eq_mind_chk kn1 kn2)
      end
  end.

Definition eq_constant_key : KerPair.t -&gt; KerPair.t -&gt; bool :=
  Constant.UserOrd.equal.

Inductive module_path : Type :=
| MPfile : DirPath.t -&gt; module_path
| MPbound : MBId.t -&gt; module_path
| MPdot : module_path -&gt; Label.t -&gt; module_path.

Module Projection.
  Module Repr.
    Record t := {
      proj_ind : inductive;
      proj_npars : Z;
      proj_arg : Z;
      proj_name : Label.t }.
    
    Definition make
      (proj_ind : inductive) (proj_npars : Z) (proj_arg : Z)
      (proj_name : Label.t) : t :=
      {| proj_ind := proj_ind; proj_npars := proj_npars; proj_arg := proj_arg;
        proj_name := proj_name |}.
    
    Definition inductive (c : t) : inductive := proj_ind c.
    
    Definition mind (c : t) : MutInd.t := fst (proj_ind c).
    
    Definition constant (c : t) : MutInd.t :=
      KerPair.change_label (mind c) (proj_name c).
    
    Definition label (c : t) : Label.t := proj_name c.
    
    Definition npars (c : t) : Z := proj_npars c.
    
    Definition arg (c : t) : Z := proj_arg c.
    
    Definition equal (a : t) (b : t) : bool :=
      andb (eq_ind (proj_ind a) (proj_ind b))
        (Int.equal (proj_arg a) (proj_arg b)).
    
    Definition hash (p : t) : Z :=
      Hashset.Combine.combinesmall (proj_arg p) (ind_hash (proj_ind p)).
    
    Module SyntacticOrd.
      Definition compare (a : t) (b : t) : Z :=
        let c := ind_syntactic_ord (proj_ind a) (proj_ind b) in
        if Stdlib.op_eq_eq c 0 then
          Int.compare (proj_arg a) (proj_arg b)
        else
          c.
      
      Definition equal (a : t) (b : t) : bool :=
        andb (Stdlib.op_eq_eq (proj_arg a) (proj_arg b))
          (eq_syntactic_ind (proj_ind a) (proj_ind b)).
      
      Definition hash (p : t) : Z :=
        Hashset.Combine.combinesmall (proj_arg p) (ind_hash (proj_ind p)).
    End SyntacticOrd.
    
    Module CanOrd.
      Definition compare (a : t) (b : t) : Z :=
        let c := ind_ord (proj_ind a) (proj_ind b) in
        if Stdlib.op_eq_eq c 0 then
          Int.compare (proj_arg a) (proj_arg b)
        else
          c.
      
      Definition equal (a : t) (b : t) : bool :=
        andb (Stdlib.op_eq_eq (proj_arg a) (proj_arg b))
          (eq_ind (proj_ind a) (proj_ind b)).
      
      Definition hash (p : t) : Z :=
        Hashset.Combine.combinesmall (proj_arg p) (ind_hash (proj_ind p)).
    End CanOrd.
    
    Module UserOrd.
      Definition compare (a : t) (b : t) : Z :=
        let c := ind_user_ord (proj_ind a) (proj_ind b) in
        if Stdlib.op_eq_eq c 0 then
          Int.compare (proj_arg a) (proj_arg b)
        else
          c.
      
      Definition equal (a : t) (b : t) : bool :=
        andb (Stdlib.op_eq_eq (proj_arg a) (proj_arg b))
          (eq_user_ind (proj_ind a) (proj_ind b)).
      
      Definition hash (p : t) : Z :=
        Hashset.Combine.combinesmall (proj_arg p) (ind_user_hash (proj_ind p)).
    End UserOrd.
    
    Definition compare (a : t) (b : t) : Z :=
      let c := ind_ord (proj_ind a) (proj_ind b) in
      if Stdlib.op_eq_eq c 0 then
        Int.compare (proj_arg a) (proj_arg b)
      else
        c.
    
    Module Self_Hashcons.
      Definition t := t.
      
      Definition u := (inductive -&gt; inductive) * (Id.t -&gt; Id.t).
      
      Definition hashcons
        (function_parameter : (inductive -&gt; inductive) * (Label.t -&gt; Label.t))
        : t -&gt; t :=
        match function_parameter with
        | (hind, hid) =&gt;
          fun p =&gt;
            {| proj_ind := hind (proj_ind p); proj_npars := proj_npars p;
              proj_arg := proj_arg p; proj_name := hid (proj_name p) |}
        end.
      
      Definition eq (p : t) (p' : t) : bool :=
        orb (Stdlib.op_eq_eq p p')
          (andb (Stdlib.op_eq_eq (proj_ind p) (proj_ind p'))
            (andb (Stdlib.op_eq_eq (proj_npars p) (proj_npars p'))
              (andb (Stdlib.op_eq_eq (proj_arg p) (proj_arg p'))
                (Stdlib.op_eq_eq (proj_name p) (proj_name p'))))).
      
      Definition hash : t -&gt; Z := hash.
    End Self_Hashcons.
    
    Definition hcons : HashRepr.(Hashcons.S.t) -&gt; HashRepr.(Hashcons.S.t) :=
      Hashcons.simple_hcons HashRepr.(Hashcons.S.generate)
        HashRepr.(Hashcons.S.hcons) (hcons_ind, Id.hcons).
    
    Definition map_npars (f : MutInd.t -&gt; Z -&gt; MutInd.t * Z) (p : t) : t :=
      let ind := fst (proj_ind p) in
      let npars := proj_npars p in
      match f ind npars with
      | (ind', npars') =&gt;
        if andb (Stdlib.op_eq_eq ind ind') (Stdlib.op_eq_eq npars npars') then
          p
        else
          record
      end.
    
    Definition map (f : MutInd.t -&gt; MutInd.t) (p : t) : t :=
      map_npars (fun mind =&gt; fun n =&gt; ((f mind), n)) p.
    
    Definition to_string (p : t) : string := Constant.to_string (constant p).
    
    Definition print (p : t) : Pp.t := Constant.print (constant p).
  End Repr.
  
  Definition t := Repr.t * bool.
  
  Definition make {A B : Type} (c : A) (b : B) : A * B := (c, b).
  
  Definition mind {A : Type} (function_parameter : Repr.t * A) : MutInd.t :=
    match function_parameter with
    | (c, _) =&gt; Repr.mind c
    end.
  
  Definition inductive {A : Type} (function_parameter : Repr.t * A)
    : inductive :=
    match function_parameter with
    | (c, _) =&gt; Repr.inductive c
    end.
  
  Definition npars {A : Type} (function_parameter : Repr.t * A) : Z :=
    match function_parameter with
    | (c, _) =&gt; Repr.npars c
    end.
  
  Definition arg {A : Type} (function_parameter : Repr.t * A) : Z :=
    match function_parameter with
    | (c, _) =&gt; Repr.arg c
    end.
  
  Definition constant {A : Type} (function_parameter : Repr.t * A) : MutInd.t :=
    match function_parameter with
    | (c, _) =&gt; Repr.constant c
    end.
  
  Definition label {A : Type} (function_parameter : Repr.t * A) : Label.t :=
    match function_parameter with
    | (c, _) =&gt; Repr.label c
    end.
  
  Definition repr {A B : Type} : (A * B) -&gt; A := fst.
  
  Definition unfolded {A B : Type} : (A * B) -&gt; B := snd.
  
  Definition unfold {A : Type} (function_parameter : A * bool) : A * bool :=
    match function_parameter with
    | (c, b) as p =&gt;
      if b then
        p
      else
        (c, true)
    end.
  
  Definition equal {A : Type} (function_parameter : Repr.t * A)
    : (Repr.t * A) -&gt; bool :=
    match function_parameter with
    | (c, b) =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | (c', b') =&gt; andb (Repr.equal c c') (Stdlib.op_eq_eq b b')
        end
    end.
  
  Definition repr_equal {A B : Type} (p : Repr.t * A) (p' : Repr.t * B)
    : bool := Repr.equal (repr p) (repr p').
  
  Definition hash (function_parameter : Repr.t * bool) : Z :=
    match function_parameter with
    | (c, b) =&gt;
      Util.op_plus
        (if b then
          0
        else
          1) (Repr.hash c)
    end.
  
  Module SyntacticOrd.
    Definition compare {A : Type} (function_parameter : Repr.t * A)
      : (Repr.t * A) -&gt; Z :=
      match function_parameter with
      | (c, b) =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | (c', b') =&gt;
            if equiv_decb b b' then
              Repr.SyntacticOrd.compare c c'
            else
              (-1)
          end
      end.
    
    Definition equal {A : Type} (function_parameter : Repr.t * A)
      : (Repr.t * A) -&gt; bool :=
      match function_parameter with
      | (c, b) as x =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | (c', b') as x' =&gt;
            orb (Stdlib.op_eq_eq x x')
              (andb (equiv_decb b b') (Repr.SyntacticOrd.equal c c'))
          end
      end.
    
    Definition hash (function_parameter : Repr.t * bool) : Z :=
      match function_parameter with
      | (c, b) =&gt;
        Util.op_plus
          (if b then
            0
          else
            1) (Repr.SyntacticOrd.hash c)
      end.
  End SyntacticOrd.
  
  Module CanOrd.
    Definition compare {A : Type} (function_parameter : Repr.t * A)
      : (Repr.t * A) -&gt; Z :=
      match function_parameter with
      | (c, b) =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | (c', b') =&gt;
            if equiv_decb b b' then
              Repr.CanOrd.compare c c'
            else
              (-1)
          end
      end.
    
    Definition equal {A : Type} (function_parameter : Repr.t * A)
      : (Repr.t * A) -&gt; bool :=
      match function_parameter with
      | (c, b) as x =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | (c', b') as x' =&gt;
            orb (Stdlib.op_eq_eq x x')
              (andb (equiv_decb b b') (Repr.CanOrd.equal c c'))
          end
      end.
    
    Definition hash (function_parameter : Repr.t * bool) : Z :=
      match function_parameter with
      | (c, b) =&gt;
        Util.op_plus
          (if b then
            0
          else
            1) (Repr.CanOrd.hash c)
      end.
  End CanOrd.
  
  Module Self_Hashcons.
    Definition t := t.
    
    Definition u := Repr.t -&gt; Repr.t.
    
    Definition hashcons {A B C : Type}
      (hc : A -&gt; B) (function_parameter : A * C) : B * C :=
      match function_parameter with
      | (c, b) =&gt; ((hc c), b)
      end.
    
    Definition eq {A B : Type} (function_parameter : A * B) : (A * B) -&gt; bool :=
      match function_parameter with
      | (c, b) as x =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | (c', b') as y =&gt;
            orb (Stdlib.op_eq_eq x y)
              (andb (Stdlib.op_eq_eq c c') (Stdlib.op_eq_eq b b'))
          end
      end.
    
    Definition hash : (Repr.t * bool) -&gt; Z := hash.
  End Self_Hashcons.
  
  Definition hcons
    : HashProjection.(Hashcons.S.t) -&gt; HashProjection.(Hashcons.S.t) :=
    Hashcons.simple_hcons HashProjection.(Hashcons.S.generate)
      HashProjection.(Hashcons.S.hcons) Repr.hcons.
  
  Definition compare (function_parameter : Repr.t * bool)
    : (Repr.t * bool) -&gt; Z :=
    match function_parameter with
    | (c, b) =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | (c', b') =&gt;
          if Stdlib.op_eq_eq b b' then
            Repr.compare c c'
          else
            if b then
              1
            else
              (-1)
        end
    end.
  
  Definition map {A : Type}
    (f : MutInd.t -&gt; MutInd.t) (function_parameter : Repr.t * A) : Repr.t * A :=
    match function_parameter with
    | (c, b) as x =&gt;
      let c' := Repr.map f c in
      if Stdlib.op_eq_eq c' c then
        x
      else
        (c', b)
    end.
  
  Definition map_npars {A : Type}
    (f : MutInd.t -&gt; Z -&gt; MutInd.t * Z) (function_parameter : Repr.t * A)
    : Repr.t * A :=
    match function_parameter with
    | (c, b) as x =&gt;
      let c' := Repr.map_npars f c in
      if Stdlib.op_eq_eq c' c then
        x
      else
        (c', b)
    end.
  
  Definition to_string {A : Type} (p : Repr.t * A) : string :=
    Constant.to_string (constant p).
  
  Definition print {A : Type} (p : Repr.t * A) : Pp.t :=
    Constant.print (constant p).
End Projection.

Module GlobRefInternal.
  Inductive t : Type :=
  | VarRef : variable -&gt; t
  | ConstRef : Constant.t -&gt; t
  | IndRef : inductive -&gt; t
  | ConstructRef : constructor -&gt; t.
  
  Definition equal (gr1 : t) (gr2 : t) : bool :=
    orb (Stdlib.op_eq_eq gr1 gr2)
      match (gr1, gr2) with
      | (ConstRef con1, ConstRef con2) =&gt; Constant.equal con1 con2
      | (IndRef kn1, IndRef kn2) =&gt; eq_ind kn1 kn2
      | (ConstructRef kn1, ConstructRef kn2) =&gt; eq_constructor kn1 kn2
      | (VarRef v1, VarRef v2) =&gt; Id.equal v1 v2
      | (ConstRef _ | IndRef _ | ConstructRef _ | VarRef _, _) =&gt; false
      end.
  
  Definition global_eq_gen
    (eq_cst : Constant.t -&gt; Constant.t -&gt; bool)
    (eq_ind : inductive -&gt; inductive -&gt; bool)
    (eq_cons : constructor -&gt; constructor -&gt; bool) (x : t) (y : t) : bool :=
    orb (Stdlib.op_eq_eq x y)
      match (x, y) with
      | (ConstRef cx, ConstRef cy) =&gt; eq_cst cx cy
      | (IndRef indx, IndRef indy) =&gt; eq_ind indx indy
      | (ConstructRef consx, ConstructRef consy) =&gt; eq_cons consx consy
      | (VarRef v1, VarRef v2) =&gt; Id.equal v1 v2
      | (VarRef _ | ConstRef _ | IndRef _ | ConstructRef _, _) =&gt; false
      end.
  
  Definition global_ord_gen
    (ord_cst : Constant.t -&gt; Constant.t -&gt; Z)
    (ord_ind : inductive -&gt; inductive -&gt; Z)
    (ord_cons : constructor -&gt; constructor -&gt; Z) (x : t) (y : t) : Z :=
    if Stdlib.op_eq_eq x y then
      0
    else
      match (x, y) with
      | (VarRef v1, VarRef v2) =&gt; Id.compare v1 v2
      | (VarRef _, _) =&gt; (-1)
      | (_, VarRef _) =&gt; 1
      | (ConstRef cx, ConstRef cy) =&gt; ord_cst cx cy
      | (ConstRef _, _) =&gt; (-1)
      | (_, ConstRef _) =&gt; 1
      | (IndRef indx, IndRef indy) =&gt; ord_ind indx indy
      | (IndRef _, _) =&gt; (-1)
      | (_, IndRef _) =&gt; 1
      | (ConstructRef consx, ConstructRef consy) =&gt; ord_cons consx consy
      end.
  
  Definition global_hash_gen
    (hash_cst : Constant.t -&gt; Z) (hash_ind : inductive -&gt; Z)
    (hash_cons : constructor -&gt; Z) (gr : t) : Z :=
    match gr with
    | ConstRef c =&gt; Hashset.Combine.combinesmall 1 (hash_cst c)
    | IndRef i =&gt; Hashset.Combine.combinesmall 2 (hash_ind i)
    | ConstructRef c =&gt; Hashset.Combine.combinesmall 3 (hash_cons c)
    | VarRef id =&gt; Hashset.Combine.combinesmall 4 (Id.hash id)
    end.
End GlobRefInternal.

Module GlobRef.
  Inductive t : Type :=
  | VarRef : variable -&gt; t
  | ConstRef : Constant.t -&gt; t
  | IndRef : inductive -&gt; t
  | ConstructRef : constructor -&gt; t.
  
  Definition equal : GlobRefInternal.t -&gt; GlobRefInternal.t -&gt; bool :=
    GlobRefInternal.equal.
  
  Module Ordered.
    Import Constant.CanOrd.
    
    Definition t := GlobRefInternal.t.
    
    Definition compare (gr1 : GlobRefInternal.t) (gr2 : GlobRefInternal.t)
      : Z :=
      GlobRefInternal.global_ord_gen Constant.CanOrd.compare ind_ord
        constructor_ord gr1 gr2.
    
    Definition equal (gr1 : GlobRefInternal.t) (gr2 : GlobRefInternal.t)
      : bool :=
      GlobRefInternal.global_eq_gen Constant.CanOrd.equal eq_ind eq_constructor
        gr1 gr2.
    
    Definition hash (gr : GlobRefInternal.t) : Z :=
      GlobRefInternal.global_hash_gen Constant.CanOrd.hash ind_hash
        constructor_hash gr.
  End Ordered.
  
  Module Ordered_env.
    Import Constant.UserOrd.
    
    Definition t := GlobRefInternal.t.
    
    Definition compare (gr1 : GlobRefInternal.t) (gr2 : GlobRefInternal.t)
      : Z :=
      GlobRefInternal.global_ord_gen Constant.UserOrd.compare ind_user_ord
        constructor_user_ord gr1 gr2.
    
    Definition equal (gr1 : GlobRefInternal.t) (gr2 : GlobRefInternal.t)
      : bool :=
      GlobRefInternal.global_eq_gen Constant.UserOrd.equal eq_user_ind
        eq_user_constructor gr1 gr2.
    
    Definition hash (gr : GlobRefInternal.t) : Z :=
      GlobRefInternal.global_hash_gen Constant.UserOrd.hash ind_user_hash
        constructor_user_hash gr.
  End Ordered_env.
End GlobRef.

Inductive evaluable_global_reference : Type :=
| EvalVarRef : Id.t -&gt; evaluable_global_reference
| EvalConstRef : Constant.t -&gt; evaluable_global_reference.

Definition eq_egr
  (e1 : evaluable_global_reference) (e2 : evaluable_global_reference) : bool :=
  match (e1, e2) with
  | (EvalConstRef con1, EvalConstRef con2) =&gt; Constant.equal con1 con2
  | (EvalVarRef id1, EvalVarRef id2) =&gt; Id.equal id1 id2
  | (_, _) =&gt; false
  end.

Definition lident := CAst.t Id.t.

Definition lname := CAst.t Name.t.

Definition lstring := CAst.t string.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="nativecode" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>nativecode.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open CErrors
open Names
open Constr
open Context
open Declarations
open Util
open Nativevalues
open Nativelambda
open Environ

[@@@ocaml.warning &quot;-32-37&quot;]

(** This file defines the mllambda code generation phase of the native
compiler. mllambda represents a fragment of ML, and can easily be printed
to OCaml code. *)

(** Local names **)

(* The first component is there for debugging purposes only *)
type lname = { lname : Name.t; luid : int }

let eq_lname ln1 ln2 =
  Int.equal ln1.luid ln2.luid

let dummy_lname = { lname = Anonymous; luid = -1 }

module LNord = 
  struct 
    type t = lname 
    let compare l1 l2 = l1.luid - l2.luid
  end
module LNmap = Map.Make(LNord)
module LNset = Set.Make(LNord)

let lname_ctr = ref (-1)

let fresh_lname n = 
  incr lname_ctr;
  { lname = n; luid = !lname_ctr }

(** Global names **)
type gname = 
  | Gind of string * inductive (* prefix, inductive name *)
  | Gconstant of string * Constant.t (* prefix, constant name *)
  | Gproj of string * inductive * int (* prefix, inductive, index (start from 0) *)
  | Gcase of Label.t option * int
  | Gpred of Label.t option * int
  | Gfixtype of Label.t option * int
  | Gnorm of Label.t option * int
  | Gnormtbl of Label.t option * int
  | Ginternal of string
  | Grel of int
  | Gnamed of Id.t

let eq_gname gn1 gn2 =
  match gn1, gn2 with
  | Gind (s1, ind1), Gind (s2, ind2) -&gt;
     String.equal s1 s2 &amp;&amp; eq_ind ind1 ind2
  | Gconstant (s1, c1), Gconstant (s2, c2) -&gt;
      String.equal s1 s2 &amp;&amp; Constant.equal c1 c2
  | Gproj (s1, ind1, i1), Gproj (s2, ind2, i2) -&gt;
    String.equal s1 s2 &amp;&amp; eq_ind ind1 ind2 &amp;&amp; Int.equal i1 i2
  | Gcase (None, i1), Gcase (None, i2) -&gt; Int.equal i1 i2
  | Gcase (Some l1, i1), Gcase (Some l2, i2) -&gt; Int.equal i1 i2 &amp;&amp; Label.equal l1 l2
  | Gpred (None, i1), Gpred (None, i2) -&gt; Int.equal i1 i2
  | Gpred (Some l1, i1), Gpred (Some l2, i2) -&gt; Int.equal i1 i2 &amp;&amp; Label.equal l1 l2
  | Gfixtype (None, i1), Gfixtype (None, i2) -&gt; Int.equal i1 i2
  | Gfixtype (Some l1, i1), Gfixtype (Some l2, i2) -&gt;
      Int.equal i1 i2 &amp;&amp; Label.equal l1 l2
  | Gnorm (None, i1), Gnorm (None, i2) -&gt; Int.equal i1 i2
  | Gnorm (Some l1, i1), Gnorm (Some l2, i2) -&gt; Int.equal i1 i2 &amp;&amp; Label.equal l1 l2
  | Gnormtbl (None, i1), Gnormtbl (None, i2) -&gt; Int.equal i1 i2
  | Gnormtbl (Some l1, i1), Gnormtbl (Some l2, i2) -&gt;
      Int.equal i1 i2 &amp;&amp; Label.equal l1 l2
  | Ginternal s1, Ginternal s2 -&gt; String.equal s1 s2
  | Grel i1, Grel i2 -&gt; Int.equal i1 i2
  | Gnamed id1, Gnamed id2 -&gt; Id.equal id1 id2
  | (Gind _| Gconstant _ | Gproj _ | Gcase _ | Gpred _
    | Gfixtype _ | Gnorm _ | Gnormtbl _ | Ginternal _ | Grel _ | Gnamed _), _ -&gt;
      false

let dummy_gname =
  Grel 0

open Hashset.Combine

let gname_hash gn = match gn with
| Gind (s, ind) -&gt;
   combinesmall 1 (combine (String.hash s) (ind_hash ind))
| Gconstant (s, c) -&gt;
   combinesmall 2 (combine (String.hash s) (Constant.hash c))
| Gcase (l, i) -&gt; combinesmall 3 (combine (Option.hash Label.hash l) (Int.hash i))
| Gpred (l, i) -&gt; combinesmall 4 (combine (Option.hash Label.hash l) (Int.hash i))
| Gfixtype (l, i) -&gt; combinesmall 5 (combine (Option.hash Label.hash l) (Int.hash i))
| Gnorm (l, i) -&gt; combinesmall 6 (combine (Option.hash Label.hash l) (Int.hash i))
| Gnormtbl (l, i) -&gt; combinesmall 7 (combine (Option.hash Label.hash l) (Int.hash i))
| Ginternal s -&gt; combinesmall 8 (String.hash s)
| Grel i -&gt; combinesmall 9 (Int.hash i)
| Gnamed id -&gt; combinesmall 10 (Id.hash id)
| Gproj (s, p, i) -&gt; combinesmall 11 (combine (String.hash s) (combine (ind_hash p) i))

let case_ctr = ref (-1)

let fresh_gcase l =
  incr case_ctr;
  Gcase (l,!case_ctr)

let pred_ctr = ref (-1)

let fresh_gpred l = 
  incr pred_ctr;
  Gpred (l,!pred_ctr)

let fixtype_ctr = ref (-1)

let fresh_gfixtype l =
  incr fixtype_ctr;
  Gfixtype (l,!fixtype_ctr)

let norm_ctr = ref (-1)

let fresh_gnorm l =
  incr norm_ctr;
  Gnorm (l,!norm_ctr)

let normtbl_ctr = ref (-1)

let fresh_gnormtbl l =
  incr normtbl_ctr;
  Gnormtbl (l,!normtbl_ctr)

(** Symbols (pre-computed values) **)

let dummy_symb = SymbValue (dummy_value ())

let eq_symbol sy1 sy2 =
  match sy1, sy2 with
  | SymbValue v1, SymbValue v2 -&gt; (=) v1 v2 (** FIXME: how is this even valid? *)
  | SymbSort s1, SymbSort s2 -&gt; Sorts.equal s1 s2
  | SymbName n1, SymbName n2 -&gt; Name.equal n1 n2
  | SymbConst kn1, SymbConst kn2 -&gt; Constant.equal kn1 kn2
  | SymbMatch sw1, SymbMatch sw2 -&gt; eq_annot_sw sw1 sw2
  | SymbInd ind1, SymbInd ind2 -&gt; eq_ind ind1 ind2
  | SymbMeta m1, SymbMeta m2 -&gt; Int.equal m1 m2
  | SymbEvar evk1, SymbEvar evk2 -&gt; Evar.equal evk1 evk2
  | SymbLevel l1, SymbLevel l2 -&gt; Univ.Level.equal l1 l2
  | SymbProj (i1, k1), SymbProj (i2, k2) -&gt; eq_ind i1 i2 &amp;&amp; Int.equal k1 k2
  | _, _ -&gt; false

let hash_symbol symb =
  match symb with
  | SymbValue v -&gt; combinesmall 1 (Hashtbl.hash v) (** FIXME *)
  | SymbSort s -&gt; combinesmall 2 (Sorts.hash s)
  | SymbName name -&gt; combinesmall 3 (Name.hash name)
  | SymbConst c -&gt; combinesmall 4 (Constant.hash c)
  | SymbMatch sw -&gt; combinesmall 5 (hash_annot_sw sw)
  | SymbInd ind -&gt; combinesmall 6 (ind_hash ind)
  | SymbMeta m -&gt; combinesmall 7 m
  | SymbEvar evk -&gt; combinesmall 8 (Evar.hash evk)
  | SymbLevel l -&gt; combinesmall 9 (Univ.Level.hash l)
  | SymbProj (i, k) -&gt; combinesmall 10 (combine (ind_hash i) k)

module HashedTypeSymbol = struct
  type t = symbol
  let equal = eq_symbol
  let hash = hash_symbol
end

module HashtblSymbol = Hashtbl.Make(HashedTypeSymbol)

let symb_tbl = HashtblSymbol.create 211

let clear_symbols () = HashtblSymbol.clear symb_tbl

let get_value tbl i =
  match tbl.(i) with
    | SymbValue v -&gt; v
    | _ -&gt; anomaly (Pp.str &quot;get_value failed.&quot;)

let get_sort tbl i =
  match tbl.(i) with
    | SymbSort s -&gt; s
    | _ -&gt; anomaly (Pp.str &quot;get_sort failed.&quot;)

let get_name tbl i =
  match tbl.(i) with
    | SymbName id -&gt; id
    | _ -&gt; anomaly (Pp.str &quot;get_name failed.&quot;)

let get_const tbl i =
  match tbl.(i) with
    | SymbConst kn -&gt; kn
    | _ -&gt; anomaly (Pp.str &quot;get_const failed.&quot;)

let get_match tbl i =
  match tbl.(i) with
    | SymbMatch case_info -&gt; case_info
    | _ -&gt; anomaly (Pp.str &quot;get_match failed.&quot;)

let get_ind tbl i =
  match tbl.(i) with
    | SymbInd ind -&gt; ind
    | _ -&gt; anomaly (Pp.str &quot;get_ind failed.&quot;)

let get_meta tbl i =
  match tbl.(i) with
    | SymbMeta m -&gt; m
    | _ -&gt; anomaly (Pp.str &quot;get_meta failed.&quot;)

let get_evar tbl i =
  match tbl.(i) with
    | SymbEvar ev -&gt; ev
    | _ -&gt; anomaly (Pp.str &quot;get_evar failed.&quot;)

let get_level tbl i =
  match tbl.(i) with
    | SymbLevel u -&gt; u
    | _ -&gt; anomaly (Pp.str &quot;get_level failed.&quot;)

let get_proj tbl i =
  match tbl.(i) with
    | SymbProj p -&gt; p
    | _ -&gt; anomaly (Pp.str &quot;get_proj failed.&quot;)

let push_symbol x =
  try HashtblSymbol.find symb_tbl x
  with Not_found -&gt;
    let i = HashtblSymbol.length symb_tbl in
    HashtblSymbol.add symb_tbl x i; i

let symbols_tbl_name = Ginternal &quot;symbols_tbl&quot;

let get_symbols () =
  let tbl = Array.make (HashtblSymbol.length symb_tbl) dummy_symb in
  HashtblSymbol.iter (fun x i -&gt; tbl.(i) &lt;- x) symb_tbl; tbl

(** Lambda to Mllambda **)

type primitive =
  | Mk_prod
  | Mk_sort
  | Mk_ind
  | Mk_const
  | Mk_sw
  | Mk_fix of rec_pos * int 
  | Mk_cofix of int
  | Mk_rel of int
  | Mk_var of Id.t
  | Mk_proj
  | Is_int
  | Cast_accu
  | Upd_cofix
  | Force_cofix
  | Mk_uint
  | Mk_int
  | Mk_bool
  | Val_to_int
  | Mk_meta
  | Mk_evar
  | MLand
  | MLle
  | MLlt
  | MLinteq
  | MLlsl
  | MLlsr
  | MLland
  | MLlor
  | MLlxor
  | MLadd
  | MLsub
  | MLmul
  | MLmagic
  | MLarrayget
  | Mk_empty_instance
  | Coq_primitive of CPrimitives.t * (prefix * pconstant) option

let eq_primitive p1 p2 =
  match p1, p2 with
  | Mk_prod, Mk_prod -&gt; true
  | Mk_sort, Mk_sort -&gt; true
  | Mk_ind, Mk_ind -&gt; true
  | Mk_const, Mk_const -&gt; true
  | Mk_sw, Mk_sw -&gt; true
  | Mk_fix (rp1, i1), Mk_fix (rp2, i2) -&gt; Int.equal i1 i2 &amp;&amp; eq_rec_pos rp1 rp2
  | Mk_cofix i1, Mk_cofix i2 -&gt; Int.equal i1 i2
  | Mk_rel i1, Mk_rel i2 -&gt; Int.equal i1 i2
  | Mk_var id1, Mk_var id2 -&gt; Id.equal id1 id2
  | Cast_accu, Cast_accu -&gt; true
  | Upd_cofix, Upd_cofix -&gt; true
  | Force_cofix, Force_cofix -&gt; true
  | Mk_meta, Mk_meta -&gt; true
  | Mk_evar, Mk_evar -&gt; true
  | Mk_proj, Mk_proj -&gt; true
  | MLarrayget, MLarrayget -&gt; true

  | _ -&gt; false

let primitive_hash = function
  | Mk_prod -&gt; 1
  | Mk_sort -&gt; 2
  | Mk_ind -&gt; 3
  | Mk_const -&gt; 4
  | Mk_sw -&gt; 5
  | Mk_fix (r, i) -&gt;
     let h = Array.fold_left (fun h i -&gt; combine h (Int.hash i)) 0 r in
     combinesmall 6 (combine h (Int.hash i))
  | Mk_cofix i -&gt;
     combinesmall 7 (Int.hash i)
  | Mk_rel i -&gt;
     combinesmall 8 (Int.hash i)
  | Mk_var id -&gt;
     combinesmall 9 (Id.hash id)
  | Is_int -&gt; 11
  | Cast_accu -&gt; 12
  | Upd_cofix -&gt; 13
  | Force_cofix -&gt; 14
  | Mk_uint -&gt; 15
  | Mk_int -&gt; 16
  | Mk_bool -&gt; 17
  | Val_to_int -&gt; 18
  | Mk_meta -&gt; 19
  | Mk_evar -&gt; 20
  | MLand -&gt; 21
  | MLle -&gt; 22
  | MLlt -&gt; 23
  | MLinteq -&gt; 24
  | MLlsl -&gt; 25
  | MLlsr -&gt; 26
  | MLland -&gt; 27
  | MLlor -&gt; 28
  | MLlxor -&gt; 29
  | MLadd -&gt; 30
  | MLsub -&gt; 31
  | MLmul -&gt; 32
  | MLmagic -&gt; 33
  | Coq_primitive (prim, None) -&gt; combinesmall 34 (CPrimitives.hash prim)
  | Coq_primitive (prim, Some (prefix,(kn,_))) -&gt;
     combinesmall 35 (combine3 (String.hash prefix) (Constant.hash kn) (CPrimitives.hash prim))
  | Mk_proj -&gt; 36
  | MLarrayget -&gt; 37
  | Mk_empty_instance -&gt; 38

type mllambda =
  | MLlocal        of lname 
  | MLglobal       of gname 
  | MLprimitive    of primitive
  | MLlam          of lname array * mllambda 
  | MLletrec       of (lname * lname array * mllambda) array * mllambda
  | MLlet          of lname * mllambda * mllambda
  | MLapp          of mllambda * mllambda array
  | MLif           of mllambda * mllambda * mllambda
  | MLmatch        of annot_sw * mllambda * mllambda * mllam_branches
                              (* argument, prefix, accu branch, branches *)
  | MLconstruct    of string * inductive * int * mllambda array
                   (* prefix, inductive name, tag, arguments *)
  | MLint          of int
  | MLuint         of Uint63.t
  | MLsetref       of string * mllambda
  | MLsequence     of mllambda * mllambda
  | MLarray        of mllambda array
  | MLisaccu       of string * inductive * mllambda

and 'a mllam_pattern =
  | ConstPattern of int
  | NonConstPattern of tag * 'a array

and mllam_branches = (lname option mllam_pattern list * mllambda) array

let push_lnames n env lns =
  snd (Array.fold_left (fun (i,r) x -&gt; (i+1, LNmap.add x i r)) (n,env) lns)

let opush_lnames n env lns =
  let oadd x i r = match x with Some ln -&gt; LNmap.add ln i r | None -&gt; r in
  snd (Array.fold_left (fun (i,r) x -&gt; (i+1, oadd x i r)) (n,env) lns)

(* Alpha-equivalence on mllambda *)
(* eq_mllambda gn1 gn2 n env1 env2 t1 t2 tests if t1 = t2 modulo gn1 = gn2 *)
let rec eq_mllambda gn1 gn2 n env1 env2 t1 t2 =
  match t1, t2 with
  | MLlocal ln1, MLlocal ln2 -&gt;
     (try
      Int.equal (LNmap.find ln1 env1) (LNmap.find ln2 env2)
     with Not_found -&gt;
      eq_lname ln1 ln2)
  | MLglobal gn1', MLglobal gn2' -&gt;
      eq_gname gn1' gn2' || (eq_gname gn1 gn1' &amp;&amp; eq_gname gn2 gn2')
      || (eq_gname gn1 gn2' &amp;&amp; eq_gname gn2 gn1')
  | MLprimitive prim1, MLprimitive prim2 -&gt; eq_primitive prim1 prim2
  | MLlam (lns1, ml1), MLlam (lns2, ml2) -&gt;
      Int.equal (Array.length lns1) (Array.length lns2) &amp;&amp;
      let env1 = push_lnames n env1 lns1 in
      let env2 = push_lnames n env2 lns2 in
      eq_mllambda gn1 gn2 (n+Array.length lns1) env1 env2 ml1 ml2
  | MLletrec (defs1, body1), MLletrec (defs2, body2) -&gt;
      Int.equal (Array.length defs1) (Array.length defs2) &amp;&amp;
      let lns1 = Array.map (fun (x,_,_) -&gt; x) defs1 in
      let lns2 = Array.map (fun (x,_,_) -&gt; x) defs2 in
      let env1 = push_lnames n env1 lns1 in
      let env2 = push_lnames n env2 lns2 in
      let n = n + Array.length defs1 in
      eq_letrec gn1 gn2 n env1 env2 defs1 defs2 &amp;&amp;
      eq_mllambda gn1 gn2 n env1 env2 body1 body2
  | MLlet (ln1, def1, body1), MLlet (ln2, def2, body2) -&gt;
      eq_mllambda gn1 gn2 n env1 env2 def1 def2 &amp;&amp;
      let env1 = LNmap.add ln1 n env1 in
      let env2 = LNmap.add ln2 n env2 in
      eq_mllambda gn1 gn2 (n+1) env1 env2 body1 body2
  | MLapp (ml1, args1), MLapp (ml2, args2) -&gt;
      eq_mllambda gn1 gn2 n env1 env2 ml1 ml2 &amp;&amp;
      Array.equal (eq_mllambda gn1 gn2 n env1 env2) args1 args2
  | MLif (cond1,br1,br'1), MLif (cond2,br2,br'2) -&gt;
      eq_mllambda gn1 gn2 n env1 env2 cond1 cond2 &amp;&amp;
      eq_mllambda gn1 gn2 n env1 env2 br1 br2 &amp;&amp;
      eq_mllambda gn1 gn2 n env1 env2 br'1 br'2
  | MLmatch (annot1, c1, accu1, br1), MLmatch (annot2, c2, accu2, br2) -&gt;
      eq_annot_sw annot1 annot2 &amp;&amp;
      eq_mllambda gn1 gn2 n env1 env2 c1 c2 &amp;&amp;
      eq_mllambda gn1 gn2 n env1 env2 accu1 accu2 &amp;&amp;
      eq_mllam_branches gn1 gn2 n env1 env2 br1 br2
  | MLconstruct (pf1, ind1, tag1, args1), MLconstruct (pf2, ind2, tag2, args2) -&gt;
      String.equal pf1 pf2 &amp;&amp;
      eq_ind ind1 ind2 &amp;&amp;
      Int.equal tag1 tag2 &amp;&amp;
      Array.equal (eq_mllambda gn1 gn2 n env1 env2) args1 args2
  | MLint i1, MLint i2 -&gt;
      Int.equal i1 i2
  | MLuint i1, MLuint i2 -&gt;
      Uint63.equal i1 i2
  | MLsetref (id1, ml1), MLsetref (id2, ml2) -&gt;
      String.equal id1 id2 &amp;&amp;
      eq_mllambda gn1 gn2 n env1 env2 ml1 ml2
  | MLsequence (ml1, ml'1), MLsequence (ml2, ml'2) -&gt;
      eq_mllambda gn1 gn2 n env1 env2 ml1 ml2 &amp;&amp;
      eq_mllambda gn1 gn2 n env1 env2 ml'1 ml'2
  | MLarray arr1, MLarray arr2 -&gt;
      Array.equal (eq_mllambda gn1 gn2 n env1 env2) arr1 arr2

  | MLisaccu (s1, ind1, ml1), MLisaccu (s2, ind2, ml2) -&gt;
    String.equal s1 s2 &amp;&amp; eq_ind ind1 ind2 &amp;&amp;
    eq_mllambda gn1 gn2 n env1 env2 ml1 ml2
  | (MLlocal _ | MLglobal _ | MLprimitive _ | MLlam _ | MLletrec _ | MLlet _ |
    MLapp _ | MLif _ | MLmatch _ | MLconstruct _ | MLint _ | MLuint _ |
    MLsetref _ | MLsequence _ | MLarray _ | MLisaccu _), _ -&gt; false

and eq_letrec gn1 gn2 n env1 env2 defs1 defs2 =
  let eq_def (_,args1,ml1) (_,args2,ml2) =
    Int.equal (Array.length args1) (Array.length args2) &amp;&amp;
    let env1 = push_lnames n env1 args1 in
    let env2 = push_lnames n env2 args2 in
    eq_mllambda gn1 gn2 (n + Array.length args1) env1 env2 ml1 ml2
  in
  Array.equal eq_def defs1 defs2

(* we require here that patterns have the same order, which may be too strong *)
and eq_mllam_branches gn1 gn2 n env1 env2 br1 br2 =
  let eq_cargs args1 args2 body1 body2 =
    Int.equal (Array.length args1) (Array.length args2) &amp;&amp;
    let env1 = opush_lnames n env1 args1 in
    let env2 = opush_lnames n env2 args2 in
    eq_mllambda gn1 gn2 (n + Array.length args1) env1 env2 body1 body2
  in
  let eq_pattern pat1 pat2 body1 body2 =
    match pat1, pat2 with
    | ConstPattern tag1, ConstPattern tag2 -&gt;
      Int.equal tag1 tag2 &amp;&amp; eq_mllambda gn1 gn2 n env1 env2 body1 body2
    | NonConstPattern (tag1,args1), NonConstPattern (tag2,args2) -&gt;
      Int.equal tag1 tag2 &amp;&amp; eq_cargs args1 args2 body1 body2
    | (ConstPattern _ | NonConstPattern _), _ -&gt; false
  in
  let eq_branch (patl1,body1) (patl2,body2) =
    List.equal (fun pt1 pt2 -&gt; eq_pattern pt1 pt2 body1 body2) patl1 patl2
  in
  Array.equal eq_branch br1 br2

(* hash_mllambda gn n env t computes the hash for t ignoring occurrences of gn *)
let rec hash_mllambda gn n env t =
  match t with
  | MLlocal ln -&gt; combinesmall 1 (LNmap.find ln env)
  | MLglobal gn' -&gt; combinesmall 2 (if eq_gname gn gn' then 0 else gname_hash gn')
  | MLprimitive prim -&gt; combinesmall 3 (primitive_hash prim)
  | MLlam (lns, ml) -&gt;
      let env = push_lnames n env lns in
      combinesmall 4 (combine (Array.length lns) (hash_mllambda gn (n+1) env ml))
  | MLletrec (defs, body) -&gt;
      let lns = Array.map (fun (x,_,_) -&gt; x) defs in
      let env = push_lnames n env lns in
      let n = n + Array.length defs in
      let h = combine (hash_mllambda gn n env body) (Array.length defs) in
      combinesmall 5 (hash_mllambda_letrec gn n env h defs)
  | MLlet (ln, def, body) -&gt;
      let hdef = hash_mllambda gn n env def in
      let env = LNmap.add ln n env in
      combinesmall 6 (combine hdef (hash_mllambda gn (n+1) env body))
  | MLapp (ml, args) -&gt;
      let h = hash_mllambda gn n env ml in
      combinesmall 7 (hash_mllambda_array gn n env h args)
  | MLif (cond,br,br') -&gt;
      let hcond = hash_mllambda gn n env cond in
      let hbr = hash_mllambda gn n env br in
      let hbr' = hash_mllambda gn n env br' in
      combinesmall 8 (combine3 hcond hbr hbr')
  | MLmatch (annot, c, accu, br) -&gt;
      let hannot = hash_annot_sw annot in
      let hc = hash_mllambda gn n env c in
      let haccu = hash_mllambda gn n env accu in
      combinesmall 9 (hash_mllam_branches gn n env (combine3 hannot hc haccu) br)
  | MLconstruct (pf, ind, tag, args) -&gt;
      let hpf = String.hash pf in
      let hcs = ind_hash ind in
      let htag = Int.hash tag in
      combinesmall 10 (hash_mllambda_array gn n env (combine3 hpf hcs htag) args)
  | MLint i -&gt;
      combinesmall 11 i
  | MLuint i -&gt;
      combinesmall 12 (Uint63.hash i)
  | MLsetref (id, ml) -&gt;
      let hid = String.hash id in
      let hml = hash_mllambda gn n env ml in
      combinesmall 13 (combine hid hml)
  | MLsequence (ml, ml') -&gt;
      let hml = hash_mllambda gn n env ml in
      let hml' = hash_mllambda gn n env ml' in
      combinesmall 14 (combine hml hml')
  | MLarray arr -&gt;
      combinesmall 15 (hash_mllambda_array gn n env 1 arr)
  | MLisaccu (s, ind, c) -&gt;
      combinesmall 16 (combine (String.hash s) (combine (ind_hash ind) (hash_mllambda gn n env c)))

and hash_mllambda_letrec gn n env init defs =
  let hash_def (_,args,ml) =
    let env = push_lnames n env args in
    let nargs = Array.length args in
    combine nargs (hash_mllambda gn (n + nargs) env ml)
  in
  Array.fold_left (fun acc t -&gt; combine (hash_def t) acc) init defs

and hash_mllambda_array gn n env init arr =
  Array.fold_left (fun acc t -&gt; combine (hash_mllambda gn n env t) acc) init arr

and hash_mllam_branches gn n env init br =
  let hash_cargs args body =
    let nargs = Array.length args in
    let env = opush_lnames n env args in
    let hbody = hash_mllambda gn (n + nargs) env body in
    combine nargs hbody
  in
  let hash_pattern pat body = match pat with
    | ConstPattern i -&gt; combinesmall 1 (Int.hash i)
    | NonConstPattern (tag,args) -&gt; combinesmall 2 (combine (Int.hash tag) (hash_cargs args body))
  in
  let hash_branch acc (ptl,body) =
    List.fold_left (fun acc t -&gt; combine (hash_pattern t body) acc) acc ptl
  in
  Array.fold_left hash_branch init br

let fv_lam l =
  let rec aux l bind fv =
    match l with
    | MLlocal l -&gt;
	if LNset.mem l bind then fv else LNset.add l fv
    | MLglobal _ | MLprimitive _  | MLint _ | MLuint _ -&gt; fv
    | MLlam (ln,body) -&gt;
	let bind = Array.fold_right LNset.add ln bind in
	aux body bind fv
    | MLletrec(bodies,def) -&gt;
	let bind = 
	  Array.fold_right (fun (id,_,_) b -&gt; LNset.add id b) bodies bind in
	let fv_body (_,ln,body) fv =
	  let bind = Array.fold_right LNset.add ln bind in
	  aux body bind fv in
	Array.fold_right fv_body bodies (aux def bind fv)
    | MLlet(l,def,body) -&gt;
	aux body (LNset.add l bind) (aux def bind fv)
    | MLapp(f,args) -&gt;
	let fv_arg arg fv = aux arg bind fv in
	Array.fold_right fv_arg args (aux f bind fv)
    | MLif(t,b1,b2) -&gt;
	aux t bind (aux b1 bind (aux b2 bind fv))
    | MLmatch(_,a,p,bs) -&gt;
      let fv = aux a bind (aux p bind fv) in
      let fv_bs (cargs, body) fv =
        let bind =
          List.fold_right (fun pat bind -&gt;
              match pat with
              | ConstPattern _ -&gt; bind
              | NonConstPattern(_,args) -&gt;
                Array.fold_right
                  (fun o bind -&gt; match o with
                     | Some l -&gt; LNset.add l bind
                     | _ -&gt; bind) args bind)
            cargs bind in
        aux body bind fv in
      Array.fold_right fv_bs bs fv
    (* argument, accu branch, branches *)
    | MLconstruct (_,_,_,p) -&gt;
	Array.fold_right (fun a fv -&gt; aux a bind fv) p fv
    | MLsetref(_,l) -&gt; aux l bind fv
    | MLsequence(l1,l2) -&gt; aux l1 bind (aux l2 bind fv)
    | MLarray arr -&gt; Array.fold_right (fun a fv -&gt; aux a bind fv) arr fv
    | MLisaccu (_, _, body) -&gt; aux body bind fv
  in
  aux l LNset.empty LNset.empty


let mkMLlam params body =
  if Array.is_empty params then body 
  else
    match body with
    | MLlam (params', body) -&gt; MLlam(Array.append params params', body)
    | _ -&gt; MLlam(params,body)

let mkMLapp f args =
  if Array.is_empty args then f
  else
    match f with
    | MLapp(f,args') -&gt; MLapp(f,Array.append args' args)
    | _ -&gt; MLapp(f,args)

let mkForceCofix prefix ind arg =
  let name = fresh_lname Anonymous in
  MLlet (name, arg,
    MLif (
      MLisaccu (prefix, ind, MLlocal name),
      MLapp (MLprimitive Force_cofix, [|MLlocal name|]),
      MLlocal name))

let empty_params = [||]

let decompose_MLlam c =
  match c with
  | MLlam(ids,c) -&gt; ids,c
  | _ -&gt; empty_params,c

(*s Global declaration *)
type global =
(*  | Gtblname of gname * Id.t array *)
  | Gtblnorm of gname * lname array * mllambda array 
  | Gtblfixtype of gname * lname array * mllambda array
  | Glet of gname * mllambda
  | Gletcase of 
      gname * lname array * annot_sw * mllambda * mllambda * mllam_branches
  | Gopen of string
  | Gtype of inductive * (tag * int) array
    (* ind name, tag and arities of constructors *)
  | Gcomment of string

(* Alpha-equivalence on globals *)
let eq_global g1 g2 =
  match g1, g2 with
  | Gtblnorm (gn1,lns1,mls1), Gtblnorm (gn2,lns2,mls2)
  | Gtblfixtype (gn1,lns1,mls1), Gtblfixtype (gn2,lns2,mls2) -&gt;
      Int.equal (Array.length lns1) (Array.length lns2) &amp;&amp;
      Int.equal (Array.length mls1) (Array.length mls2) &amp;&amp;
      let env1 = push_lnames 0 LNmap.empty lns1 in
      let env2 = push_lnames 0 LNmap.empty lns2 in
      Array.for_all2 (eq_mllambda gn1 gn2 (Array.length lns1) env1 env2) mls1 mls2
  | Glet (gn1, def1), Glet (gn2, def2) -&gt;
      eq_mllambda gn1 gn2 0 LNmap.empty LNmap.empty def1 def2
  | Gletcase (gn1,lns1,annot1,c1,accu1,br1),
      Gletcase (gn2,lns2,annot2,c2,accu2,br2) -&gt;
      Int.equal (Array.length lns1) (Array.length lns2) &amp;&amp;
      let env1 = push_lnames 0 LNmap.empty lns1 in
      let env2 = push_lnames 0 LNmap.empty lns2 in
      let t1 = MLmatch (annot1,c1,accu1,br1) in
      let t2 = MLmatch (annot2,c2,accu2,br2) in
      eq_mllambda gn1 gn2 (Array.length lns1) env1 env2 t1 t2
  | Gopen s1, Gopen s2 -&gt; String.equal s1 s2
  | Gtype (ind1, arr1), Gtype (ind2, arr2) -&gt;
    eq_ind ind1 ind2 &amp;&amp;
    Array.equal (fun (tag1,ar1) (tag2,ar2) -&gt; Int.equal tag1 tag2 &amp;&amp; Int.equal ar1 ar2) arr1 arr2
  | Gcomment s1, Gcomment s2 -&gt; String.equal s1 s2
  | _, _ -&gt; false

let hash_global g =
  match g with
  | Gtblnorm (gn,lns,mls) -&gt;
      let nlns = Array.length lns in
      let nmls = Array.length mls in
      let env = push_lnames 0 LNmap.empty lns in
      let hmls = hash_mllambda_array gn nlns env (combine nlns nmls) mls in
      combinesmall 1 hmls
  | Gtblfixtype (gn,lns,mls) -&gt;
      let nlns = Array.length lns in
      let nmls = Array.length mls in
      let env = push_lnames 0 LNmap.empty lns in
      let hmls = hash_mllambda_array gn nlns env (combine nlns nmls) mls in
      combinesmall 2 hmls
  | Glet (gn, def) -&gt;
      combinesmall 3 (hash_mllambda gn 0 LNmap.empty def)
  | Gletcase (gn,lns,annot,c,accu,br) -&gt;
      let nlns = Array.length lns in
      let env = push_lnames 0 LNmap.empty lns in
      let t = MLmatch (annot,c,accu,br) in
      combinesmall 4 (combine nlns (hash_mllambda gn nlns env t))
  | Gopen s -&gt; combinesmall 5 (String.hash s)
  | Gtype (ind, arr) -&gt;
    let hash_aux acc (tag,ar) =
      combine3 acc (Int.hash tag) (Int.hash ar)
    in
    combinesmall 6 (combine (ind_hash ind) (Array.fold_left hash_aux 0 arr))
  | Gcomment s -&gt; combinesmall 7 (String.hash s)
  
let global_stack = ref ([] : global list)

module HashedTypeGlobal = struct
  type t = global
  let equal = eq_global
  let hash = hash_global
end

module HashtblGlobal = Hashtbl.Make(HashedTypeGlobal)

let global_tbl = HashtblGlobal.create 19991

let clear_global_tbl () = HashtblGlobal.clear global_tbl

let push_global gn t =
  try HashtblGlobal.find global_tbl t
  with Not_found -&gt;
    (global_stack := t :: !global_stack;
    HashtblGlobal.add global_tbl t gn; gn)

let push_global_let gn body =
  push_global gn (Glet (gn,body))

let push_global_fixtype gn params body =
  push_global gn (Gtblfixtype (gn,params,body))

let push_global_norm gn params body =
  push_global gn (Gtblnorm (gn, params, body))

let push_global_case gn params annot a accu bs =
  push_global gn (Gletcase (gn, params, annot, a, accu, bs))

(* Compares [t1] and [t2] up to alpha-equivalence. [t1] and [t2] may contain
   free variables. *)
let eq_mllambda t1 t2 =
  eq_mllambda dummy_gname dummy_gname 0 LNmap.empty LNmap.empty t1 t2

(*s Compilation environment *)

type env =
    { env_rel : mllambda list; (* (MLlocal lname) list *)
      env_bound : int; (* length of env_rel *)
      (* free variables *)
      env_urel : (int * mllambda) list ref; (* list of unbound rel *)
      env_named : (Id.t * mllambda) list ref;
      env_univ : lname option}

let empty_env univ () =
  { env_rel = [];
    env_bound = 0;
    env_urel = ref [];
    env_named = ref [];
    env_univ = univ
  }

let push_rel env id = 
  let local = fresh_lname id.binder_name in
  local, { env with 
	   env_rel = MLlocal local :: env.env_rel;
	   env_bound = env.env_bound + 1
	 }

let push_rels env ids =
  let lnames, env_rel = 
    Array.fold_left (fun (names,env_rel) id -&gt;
      let local = fresh_lname id.binder_name in
      (local::names, MLlocal local::env_rel)) ([],env.env_rel) ids in
  Array.of_list (List.rev lnames), { env with 
			  env_rel = env_rel;
			  env_bound = env.env_bound + Array.length ids
			}

let get_rel env id i =
  if i &lt;= env.env_bound then
    List.nth env.env_rel (i-1)
  else 
    let i = i - env.env_bound in
    try Int.List.assoc i !(env.env_urel)
    with Not_found -&gt;
      let local = MLlocal (fresh_lname id) in
      env.env_urel := (i,local) :: !(env.env_urel);
      local

let get_var env id =
  try Id.List.assoc id !(env.env_named)
  with Not_found -&gt;
    let local = MLlocal (fresh_lname (Name id)) in
    env.env_named := (id, local)::!(env.env_named);
    local

let fresh_univ () =
  fresh_lname (Name (Id.of_string &quot;univ&quot;))

(*s Traduction of lambda to mllambda *)

let get_prod_name codom = 
  match codom with
  | MLlam(ids,_) -&gt; ids.(0).lname
  | _ -&gt; assert false

let get_lname (_,l) = 
  match l with
  | MLlocal id -&gt; id
  | _ -&gt; invalid_arg &quot;Nativecode.get_lname&quot;

(* Collects free variables from env in an array of local names *)
let fv_params env = 
  let fvn, fvr = !(env.env_named), !(env.env_urel) in 
  let size = List.length fvn + List.length fvr in
  let start,params = match env.env_univ with
    | None -&gt; 0, Array.make size dummy_lname
    | Some u -&gt; 1, let t = Array.make (size + 1) dummy_lname in t.(0) &lt;- u; t
  in
  if Array.is_empty params then empty_params
  else begin
    let fvn = ref fvn in
    let i = ref start in
    while not (List.is_empty !fvn) do
      params.(!i) &lt;- get_lname (List.hd !fvn);
      fvn := List.tl !fvn;
      incr i
    done;
    let fvr = ref fvr in
    while not (List.is_empty !fvr) do
      params.(!i) &lt;- get_lname (List.hd !fvr);
      fvr := List.tl !fvr;
      incr i
    done;
    params
  end

let generalize_fv env body = 
  mkMLlam (fv_params env) body

let empty_args = [||]

let fv_args env fvn fvr =
  let size = List.length fvn + List.length fvr in
  let start,args = match env.env_univ with
    | None -&gt; 0, Array.make size (MLint 0)
    | Some u -&gt; 1, let t = Array.make (size + 1) (MLint 0) in t.(0) &lt;- MLlocal u; t
  in
  if Array.is_empty args then empty_args
  else 
    begin
      let fvn = ref fvn in
      let i = ref start in
      while not (List.is_empty !fvn) do
	args.(!i) &lt;- get_var env (fst (List.hd !fvn));
	fvn := List.tl !fvn;
	incr i
      done;
      let fvr = ref fvr in
      while not (List.is_empty !fvr) do
	let (k,_ as kml) = List.hd !fvr in
	let n = get_lname kml in 
	args.(!i) &lt;- get_rel env n.lname k;
	fvr := List.tl !fvr;
	incr i
      done;
      args
    end

let get_value_code i =
  MLapp (MLglobal (Ginternal &quot;get_value&quot;),
    [|MLglobal symbols_tbl_name; MLint i|])

let get_sort_code i =
  MLapp (MLglobal (Ginternal &quot;get_sort&quot;),
    [|MLglobal symbols_tbl_name; MLint i|])

let get_name_code i =
  MLapp (MLglobal (Ginternal &quot;get_name&quot;),
    [|MLglobal symbols_tbl_name; MLint i|])

let get_const_code i =
  MLapp (MLglobal (Ginternal &quot;get_const&quot;),
    [|MLglobal symbols_tbl_name; MLint i|])

let get_match_code i =
  MLapp (MLglobal (Ginternal &quot;get_match&quot;),
    [|MLglobal symbols_tbl_name; MLint i|])

let get_ind_code i =
  MLapp (MLglobal (Ginternal &quot;get_ind&quot;),
    [|MLglobal symbols_tbl_name; MLint i|])

let get_meta_code i =
  MLapp (MLglobal (Ginternal &quot;get_meta&quot;),
    [|MLglobal symbols_tbl_name; MLint i|])

let get_evar_code i =
  MLapp (MLglobal (Ginternal &quot;get_evar&quot;),
    [|MLglobal symbols_tbl_name; MLint i|])

let get_level_code i =
  MLapp (MLglobal (Ginternal &quot;get_level&quot;),
    [|MLglobal symbols_tbl_name; MLint i|])

let get_proj_code i =
  MLapp (MLglobal (Ginternal &quot;get_proj&quot;),
    [|MLglobal symbols_tbl_name; MLint i|])

type rlist =
  | Rnil
  | Rcons of lname option mllam_pattern list ref * LNset.t * mllambda * rlist'
and rlist' = rlist ref

let rm_params fv params =
  Array.map (fun l -&gt; if LNset.mem l fv then Some l else None) params

let rec insert pat body rl =
 match !rl with
 | Rnil -&gt;
     let fv = fv_lam body in
     begin match pat with
     | ConstPattern _ as p -&gt;
       rl:= Rcons(ref [p], fv, body, ref Rnil)
     | NonConstPattern (tag,args) -&gt;
       let args = rm_params fv args in
       rl:= Rcons(ref [NonConstPattern (tag,args)], fv, body, ref Rnil)
     end
 | Rcons(l,fv,body',rl) -&gt;
   if eq_mllambda body body' then
     match pat with
     | ConstPattern _ as p -&gt;
       l := p::!l
     | NonConstPattern (tag,args) -&gt;
       let args = rm_params fv args in
       l := NonConstPattern (tag,args)::!l
   else insert pat body rl

let rec to_list rl =
  match !rl with
  | Rnil -&gt; []
  | Rcons(l,_,body,tl) -&gt; (!l,body)::to_list tl

let merge_branches t =
  let newt = ref Rnil in
  Array.iter (fun (pat,body) -&gt; insert pat body newt) t;
  Array.of_list (to_list newt)

let app_prim p args = MLapp(MLprimitive p, args)

type prim_aux =
  | PAprim of string * pconstant * CPrimitives.t * prim_aux array
  | PAml of mllambda

let add_check cond args =
  let aux cond a = 
    match a with
    | PAml(MLint _) -&gt; cond
    | PAml ml -&gt;
       (* FIXME: use explicit equality function *)
       if List.mem ml cond then cond else ml::cond 
    | _ -&gt; cond
  in
  Array.fold_left aux cond args

let extract_prim ml_of l =
  let decl = ref [] in
  let cond = ref [] in
  let rec aux l =
    match l with
    | Lprim(prefix,kn,p,args) -&gt;
      let args = Array.map aux args in
      cond := add_check !cond args;
      PAprim(prefix,kn,p,args)
    | Lrel _ | Lvar _ | Luint _ | Lval _ | Lconst _ -&gt; PAml (ml_of l)
    | _ -&gt;
      let x = fresh_lname Anonymous in
      decl := (x,ml_of l)::!decl;
      PAml (MLlocal x) in
  let res = aux l in
  (!decl, !cond, res)

let cast_to_int v =
  match v with
  | MLint _ -&gt; v
  | _ -&gt; MLapp(MLprimitive Val_to_int, [|v|])

let compile_prim decl cond paux =

  let rec opt_prim_aux paux =
    match paux with
    | PAprim(_prefix, _kn, op, args) -&gt;
      let args = Array.map opt_prim_aux args in
      app_prim (Coq_primitive(op,None)) args
    | PAml ml -&gt; ml

  and naive_prim_aux paux =
    match paux with
    | PAprim(prefix, kn, op, args) -&gt;
      app_prim (Coq_primitive(op, Some (prefix,kn))) (Array.map naive_prim_aux args)
    | PAml ml -&gt; ml
  in

  let compile_cond cond paux =
    match cond with
    | [] -&gt; opt_prim_aux paux
    | [c1] -&gt;
      MLif(app_prim Is_int [|c1|], opt_prim_aux paux, naive_prim_aux paux)
    | c1::cond -&gt;
      let cond =
        List.fold_left
          (fun ml c -&gt; app_prim MLland [| ml; cast_to_int c|])
          (app_prim MLland [| cast_to_int c1; MLint 0 |]) cond in
      let cond = app_prim MLmagic [|cond|] in
      MLif(cond, naive_prim_aux paux, opt_prim_aux paux) in

  let add_decl decl body =
    List.fold_left (fun body (x,d) -&gt; MLlet(x,d,body)) body decl in

  (* The optimizations done for checking if integer values are closed are valid
     only on 64-bit architectures. So on 32-bit architectures, we fall back to less optimized checks. *)
  if max_int = 1073741823 (* 32-bits *) then
    add_decl decl (naive_prim_aux paux)
  else
    add_decl decl (compile_cond cond paux)

let ml_of_instance instance u =
  let ml_of_level l =
    match Univ.Level.var_index l with
    | Some i -&gt;
       let univ = MLapp(MLprimitive MLmagic, [|MLlocal (Option.get instance)|]) in
       mkMLapp (MLprimitive MLarrayget) [|univ; MLint i|]
    | None -&gt; let i = push_symbol (SymbLevel l) in get_level_code i
  in
  let u = Univ.Instance.to_array u in
  if Array.is_empty u then [||]
  else let u = Array.map ml_of_level u in
       [|MLapp (MLprimitive MLmagic, [|MLarray u|])|]

 let rec ml_of_lam env l t =
  match t with
  | Lrel(id ,i) -&gt; get_rel env id i
  | Lvar id -&gt; get_var env id
  | Lmeta(mv,_ty) -&gt;
     let tyn = fresh_lname Anonymous in
     let i = push_symbol (SymbMeta mv) in
     MLapp(MLprimitive Mk_meta, [|get_meta_code i; MLlocal tyn|])
  | Levar(evk, args) -&gt;
     let i = push_symbol (SymbEvar evk) in
     (** Arguments are *not* reversed in evar instances in native compilation *)
     let args = MLarray(Array.map (ml_of_lam env l) args) in
     MLapp(MLprimitive Mk_evar, [|get_evar_code i; args|])
  | Lprod(dom,codom) -&gt;
      let dom = ml_of_lam env l dom in
      let codom = ml_of_lam env l codom in
      let n = get_prod_name codom in
      let i = push_symbol (SymbName n) in
      MLapp(MLprimitive Mk_prod, [|get_name_code i;dom;codom|])
  | Llam(ids,body) -&gt;
    let lnames,env = push_rels env ids in
    MLlam(lnames, ml_of_lam env l body)
  | Lrec(id,body) -&gt;
      let ids,body = decompose_Llam body in
      let lname, env = push_rel env id in
      let lnames, env = push_rels env ids in
      MLletrec([|lname, lnames, ml_of_lam env l body|], MLlocal lname)
  | Llet(id,def,body) -&gt;
      let def = ml_of_lam env l def in
      let lname, env = push_rel env id in
      let body = ml_of_lam env l body in
      MLlet(lname,def,body)
  | Lapp(f,args) -&gt;
      MLapp(ml_of_lam env l f, Array.map (ml_of_lam env l) args)
  | Lconst (prefix, (c, u)) -&gt;
     let args = ml_of_instance env.env_univ u in
     mkMLapp (MLglobal(Gconstant (prefix, c))) args
  | Lproj (prefix, ind, i) -&gt; MLglobal(Gproj (prefix, ind, i))
  | Lprim _ -&gt;
    let decl,cond,paux = extract_prim (ml_of_lam env l) t in
    compile_prim decl cond paux
  | Lcase (annot,p,a,bs) -&gt;
      (* let predicate_uid fv_pred = compilation of p 
         let rec case_uid fv a_uid = 
           match a_uid with
           | Accu _ =&gt; mk_sw (predicate_uid fv_pred) (case_uid fv) a_uid
           | Ci argsi =&gt; compilation of branches 
         compile case = case_uid fv (compilation of a) *)
      (* Compilation of the predicate *)
         (* Remark: if we do not want to compile the predicate we 
            should a least compute the fv, then store the lambda representation
            of the predicate (not the mllambda) *)
      let env_p = empty_env env.env_univ () in
      let pn = fresh_gpred l in
      let mlp = ml_of_lam env_p l p in
      let mlp = generalize_fv env_p mlp in
      let (pfvn,pfvr) = !(env_p.env_named), !(env_p.env_urel) in
      let pn = push_global_let pn mlp in
      (* Compilation of the case *)
      let env_c = empty_env env.env_univ () in
      let a_uid = fresh_lname Anonymous in
      let la_uid = MLlocal a_uid in
      (* compilation of branches *)
      let nbconst = Array.length bs.constant_branches in
      let nbtotal = nbconst + Array.length bs.nonconstant_branches in
      let br = Array.init nbtotal (fun i -&gt; if i &lt; Array.length bs.constant_branches then
                                  (ConstPattern i, ml_of_lam env_c l bs.constant_branches.(i))
                                else
                                  let (params, body) = bs.nonconstant_branches.(i-nbconst) in
                                  let lnames, env_c = push_rels env_c params in
                                  (NonConstPattern (i-nbconst+1,lnames), ml_of_lam env_c l body)
                              )
      in
      let cn = fresh_gcase l in
      (* Compilation of accu branch *)
      let pred = MLapp(MLglobal pn, fv_args env_c pfvn pfvr) in
      let (fvn, fvr) = !(env_c.env_named), !(env_c.env_urel) in
      let cn_fv = mkMLapp (MLglobal cn) (fv_args env_c fvn fvr) in
         (* remark : the call to fv_args does not add free variables in env_c *)
      let i = push_symbol (SymbMatch annot) in
      let accu =
	MLapp(MLprimitive Mk_sw,
	      [| get_match_code i; MLapp (MLprimitive Cast_accu, [|la_uid|]);
		 pred;
		 cn_fv |]) in
(*      let body = MLlam([|a_uid|], MLmatch(annot, la_uid, accu, bs)) in
      let case = generalize_fv env_c body in *)
      let cn = push_global_case cn (Array.append (fv_params env_c) [|a_uid|])
        annot la_uid accu (merge_branches br)
      in
      (* Final result *)
      let arg = ml_of_lam env l a in
      let force =
	if annot.asw_finite then arg
        else mkForceCofix annot.asw_prefix annot.asw_ind arg in
      mkMLapp (MLapp (MLglobal cn, fv_args env fvn fvr)) [|force|]
  | Lif(t,bt,bf) -&gt; 
      MLif(ml_of_lam env l t, ml_of_lam env l bt, ml_of_lam env l bf)
  | Lfix ((rec_pos, inds, start), (ids, tt, tb)) -&gt;
      (* let type_f fvt = [| type fix |] 
         let norm_f1 fv f1 .. fn params1 = body1
	 ..
         let norm_fn fv f1 .. fn paramsn = bodyn
         let norm fv f1 .. fn = 
	    [|norm_f1 fv f1 .. fn; ..; norm_fn fv f1 .. fn|]
         compile fix = 
	   let rec f1 params1 = 
             if is_accu rec_pos.(1) then mk_fix (type_f fvt) (norm fv) params1
	     else norm_f1 fv f1 .. fn params1
           and .. and fn paramsn = 
	     if is_accu rec_pos.(n) then mk_fix (type_f fvt) (norm fv) paramsn
             else norm_fn fv f1 .. fv paramsn in
	   start
      *)
      (* Compilation of type *)
      let env_t = empty_env env.env_univ () in
      let ml_t = Array.map (ml_of_lam env_t l) tt in
      let params_t = fv_params env_t in
      let args_t = fv_args env !(env_t.env_named) !(env_t.env_urel) in
      let gft = fresh_gfixtype l in
      let gft = push_global_fixtype gft params_t ml_t in
      let mk_type = MLapp(MLglobal gft, args_t) in
      (* Compilation of norm_i *)
      let ndef = Array.length ids in
      let lf,env_n = push_rels (empty_env env.env_univ ()) ids in
      let t_params = Array.make ndef [||] in
      let t_norm_f = Array.make ndef (Gnorm (l,-1)) in
      let mk_let _envi (id,def) t = MLlet (id,def,t) in
      let mk_lam_or_let (params,lets,env) (id,def) =
        let ln,env' = push_rel env id in
        match def with
        | None -&gt; (ln::params,lets,env')
        | Some lam -&gt; (params, (ln,ml_of_lam env l lam)::lets,env')
      in
      let ml_of_fix i body =
        let varsi, bodyi = decompose_Llam_Llet body in
        let paramsi,letsi,envi = 
          Array.fold_left mk_lam_or_let ([],[],env_n) varsi
        in
        let paramsi,letsi =
          Array.of_list (List.rev paramsi), Array.of_list (List.rev letsi)
        in
        t_norm_f.(i) &lt;- fresh_gnorm l;
        let bodyi = ml_of_lam envi l bodyi in
        t_params.(i) &lt;- paramsi;
        let bodyi = Array.fold_right (mk_let envi) letsi bodyi in
        mkMLlam paramsi bodyi
      in
      let tnorm = Array.mapi ml_of_fix tb in
      let fvn,fvr = !(env_n.env_named), !(env_n.env_urel) in
      let fv_params = fv_params env_n in
      let fv_args' = Array.map (fun id -&gt; MLlocal id) fv_params in
      let norm_params = Array.append fv_params lf in
      let t_norm_f = Array.mapi (fun i body -&gt;
	push_global_let (t_norm_f.(i)) (mkMLlam norm_params body)) tnorm in
      let norm = fresh_gnormtbl l in
      let norm = push_global_norm norm fv_params 
         (Array.map (fun g -&gt; mkMLapp (MLglobal g) fv_args') t_norm_f) in
      (* Compilation of fix *)
      let fv_args = fv_args env fvn fvr in      
      let lf, _env = push_rels env ids in
      let lf_args = Array.map (fun id -&gt; MLlocal id) lf in
      let mk_norm = MLapp(MLglobal norm, fv_args) in
      let mkrec i lname = 
	let paramsi = t_params.(i) in
	let reci = MLlocal (paramsi.(rec_pos.(i))) in
	let pargsi = Array.map (fun id -&gt; MLlocal id) paramsi in
        let (prefix, ind) = inds.(i) in
	let body = 
          MLif(MLisaccu (prefix, ind, reci),
	       mkMLapp 
		 (MLapp(MLprimitive (Mk_fix(rec_pos,i)), 
			[|mk_type; mk_norm|]))
		 pargsi,
	       MLapp(MLglobal t_norm_f.(i), 
		     Array.concat [fv_args;lf_args;pargsi])) 
	in
	(lname, paramsi, body) in
      MLletrec(Array.mapi mkrec lf, lf_args.(start))
  | Lcofix (start, (ids, tt, tb)) -&gt; 
      (* Compilation of type *)
      let env_t = empty_env env.env_univ () in
      let ml_t = Array.map (ml_of_lam env_t l) tt in
      let params_t = fv_params env_t in
      let args_t = fv_args env !(env_t.env_named) !(env_t.env_urel) in
      let gft = fresh_gfixtype l in
      let gft = push_global_fixtype gft params_t ml_t in
      let mk_type = MLapp(MLglobal gft, args_t) in
      (* Compilation of norm_i *) 
      let ndef = Array.length ids in
      let lf,env_n = push_rels (empty_env env.env_univ ()) ids in
      let t_params = Array.make ndef [||] in
      let t_norm_f = Array.make ndef (Gnorm (l,-1)) in
      let ml_of_fix i body =
        let idsi,bodyi = decompose_Llam body in
        let paramsi, envi = push_rels env_n idsi in
        t_norm_f.(i) &lt;- fresh_gnorm l;
        let bodyi = ml_of_lam envi l bodyi in
        t_params.(i) &lt;- paramsi;
        mkMLlam paramsi bodyi in
      let tnorm = Array.mapi ml_of_fix tb in
      let fvn,fvr = !(env_n.env_named), !(env_n.env_urel) in
      let fv_params = fv_params env_n in
      let fv_args' = Array.map (fun id -&gt; MLlocal id) fv_params in
      let norm_params = Array.append fv_params lf in
      let t_norm_f = Array.mapi (fun i body -&gt;
	push_global_let (t_norm_f.(i)) (mkMLlam norm_params body)) tnorm in
      let norm = fresh_gnormtbl l in
      let norm = push_global_norm norm fv_params
        (Array.map (fun g -&gt; mkMLapp (MLglobal g) fv_args') t_norm_f) in
      (* Compilation of fix *)
      let fv_args = fv_args env fvn fvr in      
      let mk_norm = MLapp(MLglobal norm, fv_args) in
      let lnorm = fresh_lname Anonymous in
      let ltype = fresh_lname Anonymous in
      let lf, _env = push_rels env ids in
      let lf_args = Array.map (fun id -&gt; MLlocal id) lf in
      let upd i _lname cont =
	let paramsi = t_params.(i) in
	let pargsi = Array.map (fun id -&gt; MLlocal id) paramsi in
	let uniti = fresh_lname Anonymous in
	let body =
	  MLlam(Array.append paramsi [|uniti|],
		MLapp(MLglobal t_norm_f.(i),
		      Array.concat [fv_args;lf_args;pargsi])) in
	MLsequence(MLapp(MLprimitive Upd_cofix, [|lf_args.(i);body|]),
		   cont) in
      let upd = Array.fold_right_i upd lf lf_args.(start) in
      let mk_let i lname cont =
	MLlet(lname,
	      MLapp(MLprimitive(Mk_cofix i),[| MLlocal ltype; MLlocal lnorm|]),
	      cont) in
      let init = Array.fold_right_i mk_let lf upd in 
      MLlet(lnorm, mk_norm, MLlet(ltype, mk_type, init))
  (*    	    
      let mkrec i lname = 
	let paramsi = t_params.(i) in
	let pargsi = Array.map (fun id -&gt; MLlocal id) paramsi in
	let uniti = fresh_lname Anonymous in
	let body = 
	  MLapp( MLprimitive(Mk_cofix i),
		 [|mk_type;mk_norm; 
		   MLlam([|uniti|],
			 MLapp(MLglobal t_norm_f.(i),
			       Array.concat [fv_args;lf_args;pargsi]))|]) in
	(lname, paramsi, body) in
      MLletrec(Array.mapi mkrec lf, lf_args.(start)) *)

  | Lint tag -&gt; MLapp(MLprimitive Mk_int, [|MLint tag|])

  | Lmakeblock (prefix,cn,tag,args) -&gt;
     let args = Array.map (ml_of_lam env l) args in
     MLconstruct(prefix,cn,tag,args)
  | Luint i -&gt; MLapp(MLprimitive Mk_uint, [|MLuint i|])
  | Lval v -&gt;
      let i = push_symbol (SymbValue v) in get_value_code i
  | Lsort s -&gt;
    let i = push_symbol (SymbSort s) in
    let uarg = match env.env_univ with
      | None -&gt; MLarray [||]
      | Some u -&gt; MLlocal u
    in
    let uarg = MLapp(MLprimitive MLmagic, [|uarg|]) in
    MLapp(MLprimitive Mk_sort, [|get_sort_code i; uarg|])
  | Lind (prefix, (ind, u)) -&gt;
     let uargs = ml_of_instance env.env_univ u in
     mkMLapp (MLglobal (Gind (prefix, ind))) uargs
  | Llazy -&gt; MLglobal (Ginternal &quot;lazy&quot;)
  | Lforce -&gt; MLglobal (Ginternal &quot;Lazy.force&quot;)

let mllambda_of_lambda univ auxdefs l t =
  let env = empty_env univ () in
  global_stack := auxdefs;
  let ml = ml_of_lam env l t in
  let fv_rel = !(env.env_urel) in
  let fv_named = !(env.env_named) in
  (* build the free variables *)
  let get_lname (_,t) = 
   match t with
   | MLlocal x -&gt; x
   | _ -&gt; assert false in
  let params = 
    List.append (List.map get_lname fv_rel) (List.map get_lname fv_named) in
  if List.is_empty params then
    (!global_stack, ([],[]), ml)
  (* final result : global list, fv, ml *)
  else
    (!global_stack, (fv_named, fv_rel), mkMLlam (Array.of_list params) ml)

(** Code optimization **)

(** Optimization of match and fix *)

let can_subst l = 
  match l with
  | MLlocal _ | MLint _ | MLuint _ | MLglobal _ -&gt; true
  | _ -&gt; false

let subst s l =
  if LNmap.is_empty s then l 
  else
    let rec aux l =
      match l with
      | MLlocal id -&gt; (try LNmap.find id s with Not_found -&gt; l)
      | MLglobal _ | MLprimitive _ | MLint _ | MLuint _ -&gt; l
      | MLlam(params,body) -&gt; MLlam(params, aux body)
      | MLletrec(defs,body) -&gt;
	let arec (f,params,body) = (f,params,aux body) in
	MLletrec(Array.map arec defs, aux body)
      | MLlet(id,def,body) -&gt; MLlet(id,aux def, aux body)
      | MLapp(f,args) -&gt; MLapp(aux f, Array.map aux args)
      | MLif(t,b1,b2) -&gt; MLif(aux t, aux b1, aux b2)
      | MLmatch(annot,a,accu,bs) -&gt;
	  let auxb (cargs,body) = (cargs,aux body) in
	  MLmatch(annot,a,aux accu, Array.map auxb bs)
      | MLconstruct(prefix,c,tag,args) -&gt; MLconstruct(prefix,c,tag,Array.map aux args)
      | MLsetref(s,l1) -&gt; MLsetref(s,aux l1) 
      | MLsequence(l1,l2) -&gt; MLsequence(aux l1, aux l2)
      | MLarray arr -&gt; MLarray (Array.map aux arr)
      | MLisaccu (s, ind, l) -&gt; MLisaccu (s, ind, aux l)
    in
    aux l

let add_subst id v s =
  match v with
  | MLlocal id' when Int.equal id.luid id'.luid -&gt; s
  | _ -&gt; LNmap.add id v s

let subst_norm params args s =
  let len = Array.length params in
  assert (Int.equal (Array.length args) len &amp;&amp; Array.for_all can_subst args);
  let s = ref s in
  for i = 0 to len - 1 do
    s := add_subst params.(i) args.(i) !s
  done;
  !s

let subst_case params args s =
  let len = Array.length params in
  assert (len &gt; 0 &amp;&amp; 
	  Int.equal (Array.length args) len &amp;&amp; 
	  let r = ref true and i = ref 0 in
	  (* we test all arguments excepted the last *)
	  while !i &lt; len - 1  &amp;&amp; !r do r := can_subst args.(!i); incr i done;
	  !r);
  let s = ref s in
  for i = 0 to len - 2 do
    s := add_subst params.(i) args.(i) !s
  done;
  !s, params.(len-1), args.(len-1)
    
let empty_gdef = Int.Map.empty, Int.Map.empty
let get_norm (gnorm, _) i = Int.Map.find i gnorm
let get_case (_, gcase) i = Int.Map.find i gcase

let all_lam n bs = 
  let f (_, l) = 
    match l with
    | MLlam(params, _) -&gt; Int.equal (Array.length params) n
    | _ -&gt; false in
  Array.for_all f bs

let commutative_cut annot a accu bs args =
  let mkb (c,b) =
     match b with
     | MLlam(params, body) -&gt; 
         (c, Array.fold_left2 (fun body x v -&gt; MLlet(x,v,body)) body params args)
     | _ -&gt; assert false in
  MLmatch(annot, a, mkMLapp accu args, Array.map mkb bs)

let optimize gdef l =   
  let rec optimize s l =
    match l with
    | MLlocal id -&gt; (try LNmap.find id s with Not_found -&gt; l)
    | MLglobal _ | MLprimitive _ | MLint _ | MLuint _ -&gt; l
    | MLlam(params,body) -&gt; 
	MLlam(params, optimize s body)
    | MLletrec(decls,body) -&gt;
	let opt_rec (f,params,body) = (f,params,optimize s body ) in 
	MLletrec(Array.map opt_rec decls, optimize s body)
    | MLlet(id,def,body) -&gt;
	let def = optimize s def in
	if can_subst def then optimize (add_subst id def s) body 
	else MLlet(id,def,optimize s body)
    | MLapp(f, args) -&gt;
	let args = Array.map (optimize s) args in
	begin match f with
	| MLglobal (Gnorm (_,i)) -&gt;
	    (try
	      let params,body = get_norm gdef i in
	      let s = subst_norm params args s in
	      optimize s body	    
	    with Not_found -&gt; MLapp(optimize s f, args))
	| MLglobal (Gcase (_,i)) -&gt;
	    (try 
	      let params,body = get_case gdef i in
	      let s, id, arg = subst_case params args s in
	      if can_subst arg then optimize (add_subst id arg s) body
	      else MLlet(id, arg, optimize s body)
	    with Not_found -&gt;  MLapp(optimize s f, args))
	| _ -&gt; 
            let f = optimize s f in
            match f with
            | MLmatch (annot,a,accu,bs) -&gt;
              if all_lam (Array.length args) bs then  
                commutative_cut annot a accu bs args 
              else MLapp(f, args)
            | _ -&gt; MLapp(f, args)

	end
    | MLif(t,b1,b2) -&gt;
       (* This optimization is critical: it applies to all fixpoints that start
       by matching on their recursive argument *)
	let t = optimize s t in
	let b1 = optimize s b1 in
	let b2 = optimize s b2 in
	begin match t, b2 with
        | MLisaccu (_, _, l1), MLmatch(annot, l2, _, bs)
	    when eq_mllambda l1 l2 -&gt; MLmatch(annot, l1, b1, bs)
        | _, _ -&gt; MLif(t, b1, b2)
	end
    | MLmatch(annot,a,accu,bs) -&gt;
	let opt_b (cargs,body) = (cargs,optimize s body) in
	MLmatch(annot, optimize s a, subst s accu, Array.map opt_b bs)
    | MLconstruct(prefix,c,tag,args) -&gt;
        MLconstruct(prefix,c,tag,Array.map (optimize s) args)
    | MLsetref(r,l) -&gt; MLsetref(r, optimize s l) 
    | MLsequence(l1,l2) -&gt; MLsequence(optimize s l1, optimize s l2)
    | MLarray arr -&gt; MLarray (Array.map (optimize s) arr)
    | MLisaccu (pf, ind, l) -&gt; MLisaccu (pf, ind, optimize s l)
  in
  optimize LNmap.empty l

let optimize_stk stk =
  let add_global gdef g =
    match g with
    | Glet (Gnorm (_,i), body) -&gt;
	let (gnorm, gcase) = gdef in
	(Int.Map.add i (decompose_MLlam body) gnorm, gcase)
    | Gletcase(Gcase (_,i), params, annot,a,accu,bs) -&gt;
	let (gnorm,gcase) = gdef in
	(gnorm, Int.Map.add i (params,MLmatch(annot,a,accu,bs)) gcase)
    | Gletcase _ -&gt; assert false
    | _ -&gt; gdef in
  let gdef = List.fold_left add_global empty_gdef stk in
  let optimize_global g = 
    match g with
    | Glet(Gconstant (prefix, c), body) -&gt;
        Glet(Gconstant (prefix, c), optimize gdef body)
    | _ -&gt; g in
  List.map optimize_global stk

(** Printing to ocaml **)
(* Redefine a bunch of functions in module Names to generate names
   acceptable to OCaml. *)
let string_of_id s = Unicode.ascii_of_ident (Id.to_string s)
let string_of_label l = string_of_id (Label.to_id l)

let string_of_dirpath = function
  | [] -&gt; &quot;_&quot;
  | sl -&gt; String.concat &quot;_&quot; (List.rev_map string_of_id sl)

(* The first letter of the file name has to be a capital to be accepted by *)
(* OCaml as a module identifier.                                           *)
let string_of_dirpath s = &quot;N&quot;^string_of_dirpath s

let mod_uid_of_dirpath dir = string_of_dirpath (DirPath.repr dir)

let link_info_of_dirpath dir =
  Linked (mod_uid_of_dirpath dir ^ &quot;.&quot;)

let string_of_name x =
  match x with
    | Anonymous -&gt; &quot;anonymous&quot; (* assert false *)
    | Name id -&gt; string_of_id id

let string_of_label_def l =
  match l with
    | None -&gt; &quot;&quot;
    | Some l -&gt; string_of_label l

(* Relativization of module paths *)
let rec list_of_mp acc = function
  | MPdot (mp,l) -&gt; list_of_mp (string_of_label l::acc) mp
  | MPfile dp -&gt;
      let dp = DirPath.repr dp in
      string_of_dirpath dp :: acc
  | MPbound mbid -&gt; (&quot;X&quot;^string_of_id (MBId.to_id mbid))::acc

let list_of_mp mp = list_of_mp [] mp

let string_of_kn kn =
  let (mp,l) = KerName.repr kn in
  let mp = list_of_mp mp in
  String.concat &quot;_&quot; mp ^ &quot;_&quot; ^ string_of_label l

let string_of_con c = string_of_kn (Constant.user c)
let string_of_mind mind = string_of_kn (MutInd.user mind)
let string_of_ind (mind,i) = string_of_kn (MutInd.user mind) ^ &quot;_&quot; ^ string_of_int i

let string_of_gname g =
  match g with
  | Gind (prefix, (mind, i)) -&gt;
      Format.sprintf &quot;%sindaccu_%s_%i&quot; prefix (string_of_mind mind) i
  | Gconstant (prefix, c) -&gt;
      Format.sprintf &quot;%sconst_%s&quot; prefix (string_of_con c)
  | Gproj (prefix, (mind, n), i) -&gt;
      Format.sprintf &quot;%sproj_%s_%i_%i&quot; prefix (string_of_mind mind) n i
  | Gcase (l,i) -&gt;
      Format.sprintf &quot;case_%s_%i&quot; (string_of_label_def l) i
  | Gpred (l,i) -&gt;
      Format.sprintf &quot;pred_%s_%i&quot; (string_of_label_def l) i
  | Gfixtype (l,i) -&gt;
      Format.sprintf &quot;fixtype_%s_%i&quot; (string_of_label_def l) i
  | Gnorm (l,i) -&gt;
      Format.sprintf &quot;norm_%s_%i&quot; (string_of_label_def l) i
  | Ginternal s -&gt; Format.sprintf &quot;%s&quot; s
  | Gnormtbl (l,i) -&gt; 
      Format.sprintf &quot;normtbl_%s_%i&quot; (string_of_label_def l) i
  | Grel i -&gt;
      Format.sprintf &quot;rel_%i&quot; i
  | Gnamed id -&gt;
      Format.sprintf &quot;named_%s&quot; (string_of_id id)

let pp_gname fmt g =
  Format.fprintf fmt &quot;%s&quot; (string_of_gname g)

let pp_lname fmt ln =
  Format.fprintf fmt &quot;x_%s_%i&quot; (string_of_name ln.lname) ln.luid

let pp_ldecls fmt ids =
  let len = Array.length ids in
  for i = 0 to len - 1 do
    Format.fprintf fmt &quot; (%a : Nativevalues.t)&quot; pp_lname ids.(i)
  done

let string_of_construct prefix ~constant ind tag =
  let base = if constant then &quot;Int&quot; else &quot;Construct&quot; in
  Format.sprintf &quot;%s%s_%s_%i&quot; prefix base (string_of_ind ind) tag

let string_of_accu_construct prefix ind =
  Format.sprintf &quot;%sAccu_%s&quot; prefix (string_of_ind ind)

let pp_int fmt i =
  if i &lt; 0 then Format.fprintf fmt &quot;(%i)&quot; i else Format.fprintf fmt &quot;%i&quot; i

let pp_mllam fmt l =

  let rec pp_mllam fmt l =
    match l with
    | MLlocal ln -&gt; Format.fprintf fmt &quot;@[%a@]&quot; pp_lname ln
    | MLglobal g -&gt; Format.fprintf fmt &quot;@[%a@]&quot; pp_gname g
    | MLprimitive p -&gt; Format.fprintf fmt &quot;@[%a@]&quot; pp_primitive p
    | MLlam(ids,body) -&gt;
	Format.fprintf fmt &quot;@[(fun%a@ -&gt;@\n %a)@]&quot;
	  pp_ldecls ids pp_mllam body
    | MLletrec(defs, body) -&gt;
	Format.fprintf fmt &quot;@[%a@ in@\n%a@]&quot; pp_letrec defs 
	  pp_mllam body
    | MLlet(id,def,body) -&gt;
	Format.fprintf fmt &quot;@[(let@ %a@ =@\n %a@ in@\n%a)@]&quot;
          pp_lname id pp_mllam def pp_mllam body
    | MLapp(f, args) -&gt;
	Format.fprintf fmt &quot;@[%a@ %a@]&quot; pp_mllam f (pp_args true) args
    | MLif(t,l1,l2) -&gt;
	Format.fprintf fmt &quot;@[(if %a then@\n  %a@\nelse@\n  %a)@]&quot;
	  pp_mllam t pp_mllam l1 pp_mllam l2 
    | MLmatch (annot, c, accu_br, br) -&gt;
      let ind = annot.asw_ind in
      let prefix = annot.asw_prefix in
      let accu = string_of_accu_construct prefix ind in
      Format.fprintf fmt
        &quot;@[begin match Obj.magic (%a) with@\n| %s _ -&gt;@\n  %a@\n%aend@]&quot;
        pp_mllam c accu pp_mllam accu_br (pp_branches prefix ind) br

    | MLconstruct(prefix,ind,tag,args) -&gt;
        Format.fprintf fmt &quot;@[(Obj.magic (%s%a) : Nativevalues.t)@]&quot; 
          (string_of_construct prefix ~constant:false ind tag) pp_cargs args
    | MLint i -&gt; pp_int fmt i
    | MLuint i -&gt; Format.fprintf fmt &quot;(%s)&quot; (Uint63.compile i)
    | MLsetref (s, body) -&gt;
	Format.fprintf fmt &quot;@[%s@ :=@\n %a@]&quot; s pp_mllam body
    | MLsequence(l1,l2) -&gt;
	Format.fprintf fmt &quot;@[%a;@\n%a@]&quot; pp_mllam l1 pp_mllam l2
    | MLarray arr -&gt;
       let len = Array.length arr in
       Format.fprintf fmt &quot;@[[|&quot;;
       if 0 &lt; len then begin
	 for i = 0 to len - 2 do
           Format.fprintf fmt &quot;%a;&quot; pp_mllam arr.(i)
	 done;
         pp_mllam fmt arr.(len-1)
       end;
       Format.fprintf fmt &quot;|]@]&quot;
    | MLisaccu (prefix, ind, c) -&gt;
        let accu = string_of_accu_construct prefix ind in
        Format.fprintf fmt
          &quot;@[begin match Obj.magic (%a) with@\n| %s _ -&gt;@\n  true@\n| _ -&gt;@\n  false@\nend@]&quot;
        pp_mllam c accu

  and pp_letrec fmt defs =
    let len = Array.length defs in
    let pp_one_rec (fn, argsn, body) =
      Format.fprintf fmt &quot;%a%a =@\n  %a&quot;
	pp_lname fn 
	pp_ldecls argsn pp_mllam body in
    Format.fprintf fmt &quot;@[let rec &quot;;
    pp_one_rec defs.(0);
    for i = 1 to len - 1 do
      Format.fprintf fmt &quot;@\nand &quot;;
      pp_one_rec defs.(i)
    done;

  and pp_blam fmt l =
    match l with
    | MLprimitive (Mk_prod | Mk_sort) (* FIXME: why this special case? *)
    | MLlam _ | MLletrec _ | MLlet _ | MLapp _ | MLif _ -&gt;
	Format.fprintf fmt &quot;(%a)&quot; pp_mllam l
    | MLconstruct(_,_,_,args) when Array.length args &gt; 0 -&gt;
	Format.fprintf fmt &quot;(%a)&quot; pp_mllam l
    | _ -&gt; pp_mllam fmt l

  and pp_args sep fmt args =
    let sep = if sep then &quot; &quot; else &quot;,&quot; in
    let len = Array.length args in
    if len &gt; 0 then begin
      Format.fprintf fmt &quot;%a&quot; pp_blam args.(0);
      for i = 1 to len - 1 do
	Format.fprintf fmt &quot;%s%a&quot; sep pp_blam args.(i)
      done
    end

  and pp_cargs fmt args =
    let len = Array.length args in
    match len with
    | 0 -&gt; ()
    | 1 -&gt; Format.fprintf fmt &quot; %a&quot; pp_blam args.(0)
    | _ -&gt; Format.fprintf fmt &quot;(%a)&quot; (pp_args false) args

  and pp_cparam fmt param = 
    match param with
    | Some l -&gt; pp_mllam fmt (MLlocal l)
    | None -&gt; Format.fprintf fmt &quot;_&quot;

  and pp_cparams fmt params =
    let len = Array.length params in
    match len with
    | 0 -&gt; ()
    | 1 -&gt; Format.fprintf fmt &quot; %a&quot; pp_cparam params.(0)
    | _ -&gt; 
	let aux fmt params =
	  Format.fprintf fmt &quot;%a&quot; pp_cparam params.(0);
	  for i = 1 to len - 1 do
	    Format.fprintf fmt &quot;,%a&quot; pp_cparam params.(i)
	  done in 
	Format.fprintf fmt &quot;(%a)&quot; aux params

  and pp_branches prefix ind fmt bs =
    let pp_branch (cargs,body) =
      let pp_pat fmt = function
        | ConstPattern i -&gt;
          Format.fprintf fmt &quot;| %s &quot;
            (string_of_construct prefix ~constant:true ind i)
        | NonConstPattern (tag,args) -&gt;
          Format.fprintf fmt &quot;| %s%a &quot;
            (string_of_construct prefix ~constant:false ind tag) pp_cparams args in
      let rec pp_pats fmt pats =
        match pats with
        | [] -&gt; ()
        | pat::pats -&gt;
          Format.fprintf fmt &quot;%a%a&quot; pp_pat pat pp_pats pats
      in
      Format.fprintf fmt &quot;%a -&gt;@\n  %a@\n&quot; pp_pats cargs pp_mllam body
    in
    Array.iter pp_branch bs

  and pp_primitive fmt = function
    | Mk_prod -&gt; Format.fprintf fmt &quot;mk_prod_accu&quot; 
    | Mk_sort -&gt; Format.fprintf fmt &quot;mk_sort_accu&quot;
    | Mk_ind -&gt; Format.fprintf fmt &quot;mk_ind_accu&quot;
    | Mk_const -&gt; Format.fprintf fmt &quot;mk_constant_accu&quot;
    | Mk_sw -&gt; Format.fprintf fmt &quot;mk_sw_accu&quot;
    | Mk_fix(rec_pos,start) -&gt; 
	let pp_rec_pos fmt rec_pos = 
	  Format.fprintf fmt &quot;@[[| %i&quot; rec_pos.(0);
	  for i = 1 to Array.length rec_pos - 1 do
	    Format.fprintf fmt &quot;; %i&quot; rec_pos.(i) 
	  done;
	  Format.fprintf fmt &quot; |]@]&quot; in
	Format.fprintf fmt &quot;mk_fix_accu %a %i&quot; pp_rec_pos rec_pos start
    | Mk_cofix(start) -&gt; Format.fprintf fmt &quot;mk_cofix_accu %i&quot; start
    | Mk_rel i -&gt; Format.fprintf fmt &quot;mk_rel_accu %i&quot; i
    | Mk_var id -&gt;
        Format.fprintf fmt &quot;mk_var_accu (Names.Id.of_string \&quot;%s\&quot;)&quot; (string_of_id id)
    | Mk_proj -&gt; Format.fprintf fmt &quot;mk_proj_accu&quot;
    | Is_int -&gt; Format.fprintf fmt &quot;is_int&quot;
    | Cast_accu -&gt; Format.fprintf fmt &quot;cast_accu&quot;
    | Upd_cofix -&gt; Format.fprintf fmt &quot;upd_cofix&quot;
    | Force_cofix -&gt; Format.fprintf fmt &quot;force_cofix&quot;
    | Mk_uint -&gt; Format.fprintf fmt &quot;mk_uint&quot;
    | Mk_int -&gt; Format.fprintf fmt &quot;mk_int&quot;
    | Mk_bool -&gt; Format.fprintf fmt &quot;mk_bool&quot;
    | Val_to_int -&gt; Format.fprintf fmt &quot;val_to_int&quot;
    | Mk_meta -&gt; Format.fprintf fmt &quot;mk_meta_accu&quot;
    | Mk_evar -&gt; Format.fprintf fmt &quot;mk_evar_accu&quot;
    | MLand -&gt; Format.fprintf fmt &quot;(&amp;&amp;)&quot;
    | MLle -&gt; Format.fprintf fmt &quot;(&lt;=)&quot;
    | MLlt -&gt; Format.fprintf fmt &quot;(&lt;)&quot;
    | MLinteq -&gt; Format.fprintf fmt &quot;(==)&quot;
    | MLlsl -&gt; Format.fprintf fmt &quot;(lsl)&quot;
    | MLlsr -&gt; Format.fprintf fmt &quot;(lsr)&quot;
    | MLland -&gt; Format.fprintf fmt &quot;(land)&quot;
    | MLlor -&gt; Format.fprintf fmt &quot;(lor)&quot;
    | MLlxor -&gt; Format.fprintf fmt &quot;(lxor)&quot;
    | MLadd -&gt; Format.fprintf fmt &quot;(+)&quot;
    | MLsub -&gt; Format.fprintf fmt &quot;(-)&quot;
    | MLmul -&gt; Format.fprintf fmt &quot;( * )&quot;
    | MLmagic -&gt; Format.fprintf fmt &quot;Obj.magic&quot;
    | MLarrayget -&gt; Format.fprintf fmt &quot;Array.get&quot;
    | Mk_empty_instance -&gt; Format.fprintf fmt &quot;Univ.Instance.empty&quot;
    | Coq_primitive (op,None) -&gt;
       Format.fprintf fmt &quot;no_check_%s&quot; (CPrimitives.to_string op)
    | Coq_primitive (op, Some (prefix,(c,_))) -&gt;
        Format.fprintf fmt &quot;%s %a&quot; (CPrimitives.to_string op)
                       pp_mllam (MLglobal (Gconstant (prefix,c)))
  in
  Format.fprintf fmt &quot;@[%a@]&quot; pp_mllam l
  
let pp_array fmt t =
  let len = Array.length t in
  Format.fprintf fmt &quot;@[[|&quot;;
  for i = 0 to len - 2 do
    Format.fprintf fmt &quot;%a; &quot; pp_mllam t.(i)
  done;
  if len &gt; 0 then
    Format.fprintf fmt &quot;%a&quot; pp_mllam t.(len - 1);
  Format.fprintf fmt &quot;|]@]&quot;
  
let pp_global fmt g =
  match g with
  | Glet (gn, c) -&gt;
      let ids, c = decompose_MLlam c in
      Format.fprintf fmt &quot;@[let %a%a =@\n  %a@]@\n@.&quot; pp_gname gn 
	pp_ldecls ids
	pp_mllam c
  | Gopen s -&gt;
      Format.fprintf fmt &quot;@[open %s@]@.&quot; s
  | Gtype (ind, lar) -&gt;
    let rec aux s arity =
      if Int.equal arity 0 then s else aux (s^&quot; * Nativevalues.t&quot;) (arity-1) in
    let pp_const_sig fmt (tag,arity) =
      if arity &gt; 0 then
        let sig_str = aux &quot;of Nativevalues.t&quot; (arity-1) in
        let cstr = string_of_construct &quot;&quot; ~constant:false ind tag in
        Format.fprintf fmt &quot;  | %s %s@\n&quot; cstr sig_str
      else
        let sig_str = if arity &gt; 0 then aux &quot;of Nativevalues.t&quot; (arity-1) else &quot;&quot; in
        let cstr = string_of_construct &quot;&quot; ~constant:true ind tag in
        Format.fprintf fmt &quot;  | %s %s@\n&quot; cstr sig_str
    in
    let pp_const_sigs fmt lar =
      Format.fprintf fmt &quot;  | %s of Nativevalues.t@\n&quot; (string_of_accu_construct &quot;&quot; ind);
      Array.iter (pp_const_sig fmt) lar
    in
    Format.fprintf fmt &quot;@[type ind_%s =@\n%a@]@\n@.&quot; (string_of_ind ind) pp_const_sigs lar
  | Gtblfixtype (g, params, t) -&gt;
      Format.fprintf fmt &quot;@[let %a %a =@\n  %a@]@\n@.&quot; pp_gname g
	pp_ldecls params pp_array t
  | Gtblnorm (g, params, t) -&gt;
      Format.fprintf fmt &quot;@[let %a %a =@\n  %a@]@\n@.&quot; pp_gname g
	pp_ldecls params pp_array t 
  | Gletcase(gn,params,annot,a,accu,bs) -&gt;
      Format.fprintf fmt &quot;@[(* Hash = %i *)@\nlet rec %a %a =@\n  %a@]@\n@.&quot;
      (hash_global g)
	pp_gname gn pp_ldecls params 
	pp_mllam (MLmatch(annot,a,accu,bs))
  | Gcomment s -&gt;
      Format.fprintf fmt &quot;@[(* %s *)@]@.&quot; s

(** Compilation of elements in environment **)
let rec compile_with_fv env sigma univ auxdefs l t =
  let (auxdefs,(fv_named,fv_rel),ml) = mllambda_of_lambda univ auxdefs l t in
  if List.is_empty fv_named &amp;&amp; List.is_empty fv_rel then (auxdefs,ml)
  else apply_fv env sigma univ (fv_named,fv_rel) auxdefs ml

and apply_fv env sigma univ (fv_named,fv_rel) auxdefs ml =
  let get_rel_val (n,_) auxdefs =
    (*
    match !(lookup_rel_native_val n env) with
    | NVKnone -&gt;
    *)
        compile_rel env sigma univ auxdefs n
(*    | NVKvalue (v,d) -&gt; assert false *)
  in
  let get_named_val (id,_) auxdefs =
    (*
    match !(lookup_named_native_val id env) with
    | NVKnone -&gt;
        *)
        compile_named env sigma univ auxdefs id
(*    | NVKvalue (v,d) -&gt; assert false *)
  in
  let auxdefs = List.fold_right get_rel_val fv_rel auxdefs in
  let auxdefs = List.fold_right get_named_val fv_named auxdefs in
  let lvl = Context.Rel.length (rel_context env) in
  let fv_rel = List.map (fun (n,_) -&gt; MLglobal (Grel (lvl-n))) fv_rel in
  let fv_named = List.map (fun (id,_) -&gt; MLglobal (Gnamed id)) fv_named in
  let aux_name = fresh_lname Anonymous in
  auxdefs, MLlet(aux_name, ml, mkMLapp (MLlocal aux_name) (Array.of_list (fv_rel@fv_named)))

and compile_rel env sigma univ auxdefs n =
  let open Context.Rel.Declaration in
  let decl = lookup_rel n env in
  let n = List.length (rel_context env) - n in
  match decl with
  | LocalDef (_,t,_) -&gt;
      let code = lambda_of_constr env sigma t in
      let auxdefs,code = compile_with_fv env sigma univ auxdefs None code in
      Glet(Grel n, code)::auxdefs
  | LocalAssum _ -&gt;
      Glet(Grel n, MLprimitive (Mk_rel n))::auxdefs

and compile_named env sigma univ auxdefs id =
  let open Context.Named.Declaration in
  match lookup_named id env with
  | LocalDef (_,t,_) -&gt;
      let code = lambda_of_constr env sigma t in
      let auxdefs,code = compile_with_fv env sigma univ auxdefs None code in
      Glet(Gnamed id, code)::auxdefs
  | LocalAssum _ -&gt;
      Glet(Gnamed id, MLprimitive (Mk_var id))::auxdefs

let compile_constant env sigma prefix ~interactive con cb =
    let no_univs = 0 = Univ.AUContext.size (Declareops.constant_polymorphic_context cb) in
    begin match cb.const_body with
    | Def t -&gt;
      let t = Mod_subst.force_constr t in
      let code = lambda_of_constr env sigma t in
      if !Flags.debug then Feedback.msg_debug (Pp.str &quot;Generated lambda code&quot;);
      let is_lazy = is_lazy t in
      let code = if is_lazy then mk_lazy code else code in
      let name =
        if interactive then LinkedInteractive prefix
        else Linked prefix
      in
      let l = Constant.label con in
      let auxdefs,code =
	if no_univs then compile_with_fv env sigma None [] (Some l) code
	else
	  let univ = fresh_univ () in
	  let (auxdefs,code) = compile_with_fv env sigma (Some univ) [] (Some l) code in
          (auxdefs,mkMLlam [|univ|] code)
      in
      if !Flags.debug then Feedback.msg_debug (Pp.str &quot;Generated mllambda code&quot;);
      let code =
        optimize_stk (Glet(Gconstant (&quot;&quot;, con),code)::auxdefs)
      in
      if !Flags.debug then Feedback.msg_debug (Pp.str &quot;Optimized mllambda code&quot;);
      code, name
    | _ -&gt; 
        let i = push_symbol (SymbConst con) in
	let args =
	  if no_univs then [|get_const_code i; MLarray [||]|]
	  else [|get_const_code i|]
	in
	(*
	let t = mkMLlam [|univ|] (mkMLapp (MLprimitive Mk_const)
	 *)
        [Glet(Gconstant (&quot;&quot;, con), mkMLapp (MLprimitive Mk_const) args)],
	  if interactive then LinkedInteractive prefix
	  else Linked prefix
    end

module StringOrd = struct type t = string let compare = String.compare end
module StringSet = Set.Make(StringOrd)

let loaded_native_files = ref StringSet.empty

let is_loaded_native_file s = StringSet.mem s !loaded_native_files

let register_native_file s =
  loaded_native_files := StringSet.add s !loaded_native_files

let is_code_loaded ~interactive name =
  match !name with
  | NotLinked -&gt; false
  | LinkedInteractive s -&gt;
      if (interactive &amp;&amp; is_loaded_native_file s) then true
      else (name := NotLinked; false)
  | Linked s -&gt;
      if is_loaded_native_file s then true
      else (name := NotLinked; false)

let param_name = Name (Id.of_string &quot;params&quot;)
let arg_name = Name (Id.of_string &quot;arg&quot;)

let compile_mind mb mind stack =
  let u = Declareops.inductive_polymorphic_context mb in
  (** Generate data for every block *)
  let f i stack ob =
    let ind = (mind, i) in
    let gtype = Gtype(ind, ob.mind_reloc_tbl) in
    let j = push_symbol (SymbInd ind) in
    let name = Gind (&quot;&quot;, ind) in
    let accu =
      let args =
	if Int.equal (Univ.AUContext.size u) 0 then
	  [|get_ind_code j; MLarray [||]|]
	else [|get_ind_code j|]
      in
      Glet(name, MLapp (MLprimitive Mk_ind, args))
    in
    let nparams = mb.mind_nparams in
    let add_proj proj_arg acc _pb =
      let tbl = ob.mind_reloc_tbl in
      (* Building info *)
      let ci = { ci_ind = ind; ci_npar = nparams;
                 ci_cstr_nargs = [|0|]; ci_relevance = ob.mind_relevance;
                 ci_cstr_ndecls = [||] (*FIXME*);
                 ci_pp_info = { ind_tags = []; cstr_tags = [||] (*FIXME*); style = RegularStyle } } in
      let asw = { asw_ind = ind; asw_prefix = &quot;&quot;; asw_ci = ci;
                  asw_reloc = tbl; asw_finite = true } in
      let c_uid = fresh_lname Anonymous in
      let cf_uid = fresh_lname Anonymous in
      let tag, arity = tbl.(0) in
      assert (arity &gt; 0);
      let ci_uid = fresh_lname Anonymous in
      let cargs = Array.init arity
        (fun i -&gt; if Int.equal i proj_arg then Some ci_uid else None)
      in
      let i = push_symbol (SymbProj (ind, proj_arg)) in
      let accu = MLapp (MLprimitive Cast_accu, [|MLlocal cf_uid|]) in
      let accu_br = MLapp (MLprimitive Mk_proj, [|get_proj_code i;accu|]) in
      let code = MLmatch(asw,MLlocal cf_uid,accu_br,[|[NonConstPattern (tag,cargs)],MLlocal ci_uid|]) in
      let code = MLlet(cf_uid, mkForceCofix &quot;&quot; ind (MLlocal c_uid), code) in
      let gn = Gproj (&quot;&quot;, ind, proj_arg) in
      Glet (gn, mkMLlam [|c_uid|] code) :: acc
    in
    let projs = match mb.mind_record with
    | NotRecord | FakeRecord -&gt; []
    | PrimRecord info -&gt;
      let _, _, _, pbs = info.(i) in
      Array.fold_left_i add_proj [] pbs
    in
    projs @ gtype :: accu :: stack
  in
  Array.fold_left_i f stack mb.mind_packets

type code_location_update =
    link_info ref * link_info
type code_location_updates =
  code_location_update Mindmap_env.t * code_location_update Cmap_env.t

type linkable_code = global list * code_location_updates

let empty_updates = Mindmap_env.empty, Cmap_env.empty

let compile_mind_deps env prefix ~interactive
    (comp_stack, (mind_updates, const_updates) as init) mind =
  let mib,nameref = lookup_mind_key mind env in
  if is_code_loaded ~interactive nameref
    || Mindmap_env.mem mind mind_updates
  then init
  else
    let comp_stack =
      compile_mind mib mind comp_stack
    in
    let name =
      if interactive then LinkedInteractive prefix
      else Linked prefix
    in
    let upd = (nameref, name) in
    let mind_updates = Mindmap_env.add mind upd mind_updates in
    (comp_stack, (mind_updates, const_updates))

(* This function compiles all necessary dependencies of t, and generates code in
   reverse order, as well as linking information updates *)
let compile_deps env sigma prefix ~interactive init t =
  let rec aux env lvl init t =
  match kind t with
  | Ind ((mind,_),_u) -&gt; compile_mind_deps env prefix ~interactive init mind
  | Const c -&gt;
    let c,_u = get_alias env c in
    let cb,(nameref,_) = lookup_constant_key c env in
    let (_, (_, const_updates)) = init in
    if is_code_loaded ~interactive nameref
    || (Cmap_env.mem c const_updates)
    then init
    else
      let comp_stack, (mind_updates, const_updates) =
        match cb.const_body with
        | Def t -&gt;
           aux env lvl init (Mod_subst.force_constr t)
        | _ -&gt; init
      in
      let code, name =
	compile_constant env sigma prefix ~interactive c cb
      in
      let comp_stack = code@comp_stack in
      let const_updates = Cmap_env.add c (nameref, name) const_updates in
      comp_stack, (mind_updates, const_updates)
  | Construct (((mind,_),_),_u) -&gt; compile_mind_deps env prefix ~interactive init mind
  | Proj (p,c) -&gt;
    let init = compile_mind_deps env prefix ~interactive init (Projection.mind p) in
    aux env lvl init c
  | Case (ci, _p, _c, _ac) -&gt;
      let mind = fst ci.ci_ind in
      let init = compile_mind_deps env prefix ~interactive init mind in
      fold_constr_with_binders succ (aux env) lvl init t
  | Var id -&gt;
    let open Context.Named.Declaration in
    begin match lookup_named id env with
      | LocalDef (_,t,_) -&gt;
        aux env lvl init t
      | _ -&gt; init
    end
  | Rel n when n &gt; lvl -&gt;
    let open Context.Rel.Declaration in
    let decl = lookup_rel n env in
    let env = env_of_rel n env in
    begin match decl with
    | LocalDef (_,t,_) -&gt;
      aux env lvl init t
    | LocalAssum _ -&gt; init
    end
  | _ -&gt; fold_constr_with_binders succ (aux env) lvl init t
  in
  aux env 0 init t

let compile_constant_field env prefix con acc cb =
    let (gl, _) =
      compile_constant ~interactive:false env empty_evars prefix
        con cb
    in
    gl@acc

let compile_mind_field mp l acc mb =
  let mind = MutInd.make2 mp l in
  compile_mind mb mind acc

let mk_open s = Gopen s

let mk_internal_let s code =
  Glet(Ginternal s, code)

(* ML Code for conversion function *)
let mk_conv_code env sigma prefix t1 t2 =
  clear_symbols ();
  clear_global_tbl ();
  let gl, (mind_updates, const_updates) =
    let init = ([], empty_updates) in
    compile_deps env sigma prefix ~interactive:true init t1
  in
  let gl, (mind_updates, const_updates) =
    let init = (gl, (mind_updates, const_updates)) in
    compile_deps env sigma prefix ~interactive:true init t2
  in
  let code1 = lambda_of_constr env sigma t1 in
  let code2 = lambda_of_constr env sigma t2 in
  let (gl,code1) = compile_with_fv env sigma None gl None code1 in
  let (gl,code2) = compile_with_fv env sigma None gl None code2 in
  let t1 = mk_internal_let &quot;t1&quot; code1 in
  let t2 = mk_internal_let &quot;t2&quot; code2 in
  let g1 = MLglobal (Ginternal &quot;t1&quot;) in
  let g2 = MLglobal (Ginternal &quot;t2&quot;) in
  let setref1 = Glet(Ginternal &quot;_&quot;, MLsetref(&quot;rt1&quot;,g1)) in
  let setref2 = Glet(Ginternal &quot;_&quot;, MLsetref(&quot;rt2&quot;,g2)) in
  let gl = List.rev (setref2 :: setref1 :: t2 :: t1 :: gl) in
  let header = Glet(Ginternal &quot;symbols_tbl&quot;,
    MLapp (MLglobal (Ginternal &quot;get_symbols&quot;),
      [|MLglobal (Ginternal &quot;()&quot;)|])) in
  header::gl, (mind_updates, const_updates)

let mk_norm_code env sigma prefix t =
  clear_symbols ();
  clear_global_tbl ();
  let gl, (mind_updates, const_updates) =
    let init = ([], empty_updates) in
    compile_deps env sigma prefix ~interactive:true init t
  in
  let code = lambda_of_constr env sigma t in
  let (gl,code) = compile_with_fv env sigma None gl None code in
  let t1 = mk_internal_let &quot;t1&quot; code in
  let g1 = MLglobal (Ginternal &quot;t1&quot;) in
  let setref = Glet(Ginternal &quot;_&quot;, MLsetref(&quot;rt1&quot;,g1)) in
  let gl = List.rev (setref :: t1 :: gl) in
  let header = Glet(Ginternal &quot;symbols_tbl&quot;,
    MLapp (MLglobal (Ginternal &quot;get_symbols&quot;),
      [|MLglobal (Ginternal &quot;()&quot;)|])) in
  header::gl, (mind_updates, const_updates)

let mk_library_header dir =
  let libname = Format.sprintf &quot;(str_decode \&quot;%s\&quot;)&quot; (str_encode dir) in
  [Glet(Ginternal &quot;symbols_tbl&quot;,
    MLapp (MLglobal (Ginternal &quot;get_library_native_symbols&quot;),
    [|MLglobal (Ginternal libname)|]))]

let update_location (r,v) = r := v

let update_locations (ind_updates,const_updates) =
  Mindmap_env.iter (fun _ -&gt; update_location) ind_updates;
  Cmap_env.iter (fun _ -&gt; update_location) const_updates

let add_header_comment mlcode s =
  Gcomment s :: mlcode

(* vim: set filetype=ocaml foldmethod=marker: *)
</pre>
          </div>
          <div class="col-md-6">
            <code>nativecode.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import CErrors.

Import Names.

Import Constr.

Import Context.

Import Declarations.

Import Util.

Import Nativevalues.

Import Nativelambda.

Import Environ.

Record lname := {
  lname : Names.Name.t;
  luid : Z }.

Definition eq_lname (ln1 : lname) (ln2 : lname) : bool :=
  Int.equal (luid ln1) (luid ln2).

Definition dummy_lname : lname := {| lname := Anonymous; luid := (-1) |}.

Module LNord.
  Definition t := lname.
  
  Definition compare (l1 : lname) (l2 : lname) : Z :=
    Util.op_minus (luid l1) (luid l2).
End LNord.

Definition lname_ctr : Stdlib.ref Z := Stdlib.ref (-1).

Definition fresh_lname (n : Names.Name.t) : lname :=
  Stdlib.incr lname_ctr;
  {| lname := n; luid := Util.op_exclamation lname_ctr |}.

Inductive gname : Type :=
| Gind : string -&gt; Names.inductive -&gt; gname
| Gconstant : string -&gt; Names.Constant.t -&gt; gname
| Gproj : string -&gt; Names.inductive -&gt; Z -&gt; gname
| Gcase : (option Names.Label.t) -&gt; Z -&gt; gname
| Gpred : (option Names.Label.t) -&gt; Z -&gt; gname
| Gfixtype : (option Names.Label.t) -&gt; Z -&gt; gname
| Gnorm : (option Names.Label.t) -&gt; Z -&gt; gname
| Gnormtbl : (option Names.Label.t) -&gt; Z -&gt; gname
| Ginternal : string -&gt; gname
| Grel : Z -&gt; gname
| Gnamed : Names.Id.t -&gt; gname.

Definition eq_gname (gn1 : gname) (gn2 : gname) : bool :=
  match (gn1, gn2) with
  | (Gind s1 ind1, Gind s2 ind2) =&gt;
    andb (Util.String.(CString.ExtS.equal) s1 s2) (Names.eq_ind ind1 ind2)
  | (Gconstant s1 c1, Gconstant s2 c2) =&gt;
    andb (Util.String.(CString.ExtS.equal) s1 s2) (Names.Constant.equal c1 c2)
  | (Gproj s1 ind1 i1, Gproj s2 ind2 i2) =&gt;
    andb (Util.String.(CString.ExtS.equal) s1 s2)
      (andb (Names.eq_ind ind1 ind2) (Int.equal i1 i2))
  | (Gcase None i1, Gcase None i2) =&gt; Int.equal i1 i2
  | (Gcase (Some l1) i1, Gcase (Some l2) i2) =&gt;
    andb (Int.equal i1 i2) (Names.Label.equal l1 l2)
  | (Gpred None i1, Gpred None i2) =&gt; Int.equal i1 i2
  | (Gpred (Some l1) i1, Gpred (Some l2) i2) =&gt;
    andb (Int.equal i1 i2) (Names.Label.equal l1 l2)
  | (Gfixtype None i1, Gfixtype None i2) =&gt; Int.equal i1 i2
  | (Gfixtype (Some l1) i1, Gfixtype (Some l2) i2) =&gt;
    andb (Int.equal i1 i2) (Names.Label.equal l1 l2)
  | (Gnorm None i1, Gnorm None i2) =&gt; Int.equal i1 i2
  | (Gnorm (Some l1) i1, Gnorm (Some l2) i2) =&gt;
    andb (Int.equal i1 i2) (Names.Label.equal l1 l2)
  | (Gnormtbl None i1, Gnormtbl None i2) =&gt; Int.equal i1 i2
  | (Gnormtbl (Some l1) i1, Gnormtbl (Some l2) i2) =&gt;
    andb (Int.equal i1 i2) (Names.Label.equal l1 l2)
  | (Ginternal s1, Ginternal s2) =&gt; Util.String.(CString.ExtS.equal) s1 s2
  | (Grel i1, Grel i2) =&gt; Int.equal i1 i2
  | (Gnamed id1, Gnamed id2) =&gt; Names.Id.equal id1 id2
  |
    (Gind _ _ | Gconstant _ _ | Gproj _ _ _ | Gcase _ _ | Gpred _ _ |
      Gfixtype _ _ | Gnorm _ _ | Gnormtbl _ _ | Ginternal _ | Grel _ | Gnamed _,
      _) =&gt; false
  end.

Definition dummy_gname : gname := Grel 0.

Import Hashset.Combine.

Definition gname_hash (gn : gname) : Z :=
  match gn with
  | Gind s ind =&gt;
    Hashset.Combine.combinesmall 1
      (Hashset.Combine.combine (Util.String.(CString.ExtS.hash) s)
        (Names.ind_hash ind))
  | Gconstant s c =&gt;
    Hashset.Combine.combinesmall 2
      (Hashset.Combine.combine (Util.String.(CString.ExtS.hash) s)
        (Names.Constant.hash c))
  | Gcase l i =&gt;
    Hashset.Combine.combinesmall 3
      (Hashset.Combine.combine (Option.hash Names.Label.hash l) (Int.hash i))
  | Gpred l i =&gt;
    Hashset.Combine.combinesmall 4
      (Hashset.Combine.combine (Option.hash Names.Label.hash l) (Int.hash i))
  | Gfixtype l i =&gt;
    Hashset.Combine.combinesmall 5
      (Hashset.Combine.combine (Option.hash Names.Label.hash l) (Int.hash i))
  | Gnorm l i =&gt;
    Hashset.Combine.combinesmall 6
      (Hashset.Combine.combine (Option.hash Names.Label.hash l) (Int.hash i))
  | Gnormtbl l i =&gt;
    Hashset.Combine.combinesmall 7
      (Hashset.Combine.combine (Option.hash Names.Label.hash l) (Int.hash i))
  | Ginternal s =&gt;
    Hashset.Combine.combinesmall 8 (Util.String.(CString.ExtS.hash) s)
  | Grel i =&gt; Hashset.Combine.combinesmall 9 (Int.hash i)
  | Gnamed id =&gt; Hashset.Combine.combinesmall 10 (Names.Id.hash id)
  | Gproj s p i =&gt;
    Hashset.Combine.combinesmall 11
      (Hashset.Combine.combine (Util.String.(CString.ExtS.hash) s)
        (Hashset.Combine.combine (Names.ind_hash p) i))
  end.

Definition case_ctr : Stdlib.ref Z := Stdlib.ref (-1).

Definition fresh_gcase (l : option Names.Label.t) : gname :=
  Stdlib.incr case_ctr;
  Gcase l (Util.op_exclamation case_ctr).

Definition pred_ctr : Stdlib.ref Z := Stdlib.ref (-1).

Definition fresh_gpred (l : option Names.Label.t) : gname :=
  Stdlib.incr pred_ctr;
  Gpred l (Util.op_exclamation pred_ctr).

Definition fixtype_ctr : Stdlib.ref Z := Stdlib.ref (-1).

Definition fresh_gfixtype (l : option Names.Label.t) : gname :=
  Stdlib.incr fixtype_ctr;
  Gfixtype l (Util.op_exclamation fixtype_ctr).

Definition norm_ctr : Stdlib.ref Z := Stdlib.ref (-1).

Definition fresh_gnorm (l : option Names.Label.t) : gname :=
  Stdlib.incr norm_ctr;
  Gnorm l (Util.op_exclamation norm_ctr).

Definition normtbl_ctr : Stdlib.ref Z := Stdlib.ref (-1).

Definition fresh_gnormtbl (l : option Names.Label.t) : gname :=
  Stdlib.incr normtbl_ctr;
  Gnormtbl l (Util.op_exclamation normtbl_ctr).

Definition dummy_symb : Nativevalues.symbol :=
  SymbValue (Nativevalues.dummy_value tt).

Definition eq_symbol (sy1 : Nativevalues.symbol) (sy2 : Nativevalues.symbol)
  : bool :=
  match (sy1, sy2) with
  | (SymbValue v1, SymbValue v2) =&gt; equiv_decb v1 v2
  | (SymbSort s1, SymbSort s2) =&gt; Sorts.equal s1 s2
  | (SymbName n1, SymbName n2) =&gt; Names.Name.equal n1 n2
  | (SymbConst kn1, SymbConst kn2) =&gt; Names.Constant.equal kn1 kn2
  | (SymbMatch sw1, SymbMatch sw2) =&gt; Nativevalues.eq_annot_sw sw1 sw2
  | (SymbInd ind1, SymbInd ind2) =&gt; Names.eq_ind ind1 ind2
  | (SymbMeta m1, SymbMeta m2) =&gt; Int.equal m1 m2
  | (SymbEvar evk1, SymbEvar evk2) =&gt; Evar.equal evk1 evk2
  | (SymbLevel l1, SymbLevel l2) =&gt; Univ.Level.equal l1 l2
  | (SymbProj (i1, k1), SymbProj (i2, k2)) =&gt;
    andb (Names.eq_ind i1 i2) (Int.equal k1 k2)
  | (_, _) =&gt; false
  end.

Definition hash_symbol (symb : Nativevalues.symbol) : Z :=
  match symb with
  | SymbValue v =&gt; Hashset.Combine.combinesmall 1 (Stdlib.Hashtbl.hash v)
  | SymbSort s =&gt; Hashset.Combine.combinesmall 2 (Sorts.hash s)
  | SymbName name =&gt; Hashset.Combine.combinesmall 3 (Names.Name.hash name)
  | SymbConst c =&gt; Hashset.Combine.combinesmall 4 (Names.Constant.hash c)
  | SymbMatch sw =&gt;
    Hashset.Combine.combinesmall 5 (Nativevalues.hash_annot_sw sw)
  | SymbInd ind =&gt; Hashset.Combine.combinesmall 6 (Names.ind_hash ind)
  | SymbMeta m =&gt; Hashset.Combine.combinesmall 7 m
  | SymbEvar evk =&gt; Hashset.Combine.combinesmall 8 (Evar.hash evk)
  | SymbLevel l =&gt; Hashset.Combine.combinesmall 9 (Univ.Level.hash l)
  | SymbProj (i, k) =&gt;
    Hashset.Combine.combinesmall 10
      (Hashset.Combine.combine (Names.ind_hash i) k)
  end.

Module HashedTypeSymbol.
  Definition t := Nativevalues.symbol.
  
  Definition equal : Nativevalues.symbol -&gt; Nativevalues.symbol -&gt; bool :=
    eq_symbol.
  
  Definition hash : Nativevalues.symbol -&gt; Z := hash_symbol.
End HashedTypeSymbol.

Definition symb_tbl : HashtblSymbol.t Z := HashtblSymbol.create 211.

Definition clear_symbols (function_parameter : unit) : unit :=
  match function_parameter with
  | tt =&gt; HashtblSymbol.clear symb_tbl
  end.

Definition get_value (tbl : array Nativevalues.symbol) (i : Z)
  : Nativevalues.t :=
  match Util.Array.(CArray.ExtS.get) tbl i with
  | SymbValue v =&gt; v
  | _ =&gt; CErrors.anomaly None None (Pp.str &quot;get_value failed.&quot; % string)
  end.

Definition get_sort (tbl : array Nativevalues.symbol) (i : Z) : Sorts.t :=
  match Util.Array.(CArray.ExtS.get) tbl i with
  | SymbSort s =&gt; s
  | _ =&gt; CErrors.anomaly None None (Pp.str &quot;get_sort failed.&quot; % string)
  end.

Definition get_name (tbl : array Nativevalues.symbol) (i : Z) : Names.Name.t :=
  match Util.Array.(CArray.ExtS.get) tbl i with
  | SymbName id =&gt; id
  | _ =&gt; CErrors.anomaly None None (Pp.str &quot;get_name failed.&quot; % string)
  end.

Definition get_const (tbl : array Nativevalues.symbol) (i : Z)
  : Names.Constant.t :=
  match Util.Array.(CArray.ExtS.get) tbl i with
  | SymbConst kn =&gt; kn
  | _ =&gt; CErrors.anomaly None None (Pp.str &quot;get_const failed.&quot; % string)
  end.

Definition get_match (tbl : array Nativevalues.symbol) (i : Z)
  : Nativevalues.annot_sw :=
  match Util.Array.(CArray.ExtS.get) tbl i with
  | SymbMatch case_info =&gt; case_info
  | _ =&gt; CErrors.anomaly None None (Pp.str &quot;get_match failed.&quot; % string)
  end.

Definition get_ind (tbl : array Nativevalues.symbol) (i : Z)
  : Names.inductive :=
  match Util.Array.(CArray.ExtS.get) tbl i with
  | SymbInd ind =&gt; ind
  | _ =&gt; CErrors.anomaly None None (Pp.str &quot;get_ind failed.&quot; % string)
  end.

Definition get_meta (tbl : array Nativevalues.symbol) (i : Z)
  : Constr.metavariable :=
  match Util.Array.(CArray.ExtS.get) tbl i with
  | SymbMeta m =&gt; m
  | _ =&gt; CErrors.anomaly None None (Pp.str &quot;get_meta failed.&quot; % string)
  end.

Definition get_evar (tbl : array Nativevalues.symbol) (i : Z) : Evar.t :=
  match Util.Array.(CArray.ExtS.get) tbl i with
  | SymbEvar ev =&gt; ev
  | _ =&gt; CErrors.anomaly None None (Pp.str &quot;get_evar failed.&quot; % string)
  end.

Definition get_level (tbl : array Nativevalues.symbol) (i : Z) : Univ.Level.t :=
  match Util.Array.(CArray.ExtS.get) tbl i with
  | SymbLevel u =&gt; u
  | _ =&gt; CErrors.anomaly None None (Pp.str &quot;get_level failed.&quot; % string)
  end.

Definition get_proj (tbl : array Nativevalues.symbol) (i : Z)
  : Names.inductive * Z :=
  match Util.Array.(CArray.ExtS.get) tbl i with
  | SymbProj p =&gt; p
  | _ =&gt; CErrors.anomaly None None (Pp.str &quot;get_proj failed.&quot; % string)
  end.

Definition push_symbol (x : HashtblSymbol.key) : Z := try.

Definition symbols_tbl_name : gname := Ginternal &quot;symbols_tbl&quot; % string.

Definition get_symbols (function_parameter : unit)
  : array Nativevalues.symbol :=
  match function_parameter with
  | tt =&gt;
    let tbl :=
      Util.Array.(CArray.ExtS.make) (HashtblSymbol.length symb_tbl) dummy_symb
      in
    HashtblSymbol.iter (fun x =&gt; fun i =&gt; Util.Array.(CArray.ExtS.set) tbl i x)
      symb_tbl;
    tbl
  end.

Inductive primitive : Type :=
| Mk_prod : primitive
| Mk_sort : primitive
| Mk_ind : primitive
| Mk_const : primitive
| Mk_sw : primitive
| Mk_fix : Nativevalues.rec_pos -&gt; Z -&gt; primitive
| Mk_cofix : Z -&gt; primitive
| Mk_rel : Z -&gt; primitive
| Mk_var : Names.Id.t -&gt; primitive
| Mk_proj : primitive
| Is_int : primitive
| Cast_accu : primitive
| Upd_cofix : primitive
| Force_cofix : primitive
| Mk_uint : primitive
| Mk_int : primitive
| Mk_bool : primitive
| Val_to_int : primitive
| Mk_meta : primitive
| Mk_evar : primitive
| MLand : primitive
| MLle : primitive
| MLlt : primitive
| MLinteq : primitive
| MLlsl : primitive
| MLlsr : primitive
| MLland : primitive
| MLlor : primitive
| MLlxor : primitive
| MLadd : primitive
| MLsub : primitive
| MLmul : primitive
| MLmagic : primitive
| MLarrayget : primitive
| Mk_empty_instance : primitive
| Coq_primitive : CPrimitives.t -&gt;
  (option (Nativelambda.prefix * Constr.pconstant)) -&gt; primitive.

Definition eq_primitive (p1 : primitive) (p2 : primitive) : bool :=
  match (p1, p2) with
  | (Mk_prod, Mk_prod) =&gt; true
  | (Mk_sort, Mk_sort) =&gt; true
  | (Mk_ind, Mk_ind) =&gt; true
  | (Mk_const, Mk_const) =&gt; true
  | (Mk_sw, Mk_sw) =&gt; true
  | (Mk_fix rp1 i1, Mk_fix rp2 i2) =&gt;
    andb (Int.equal i1 i2) (Nativevalues.eq_rec_pos rp1 rp2)
  | (Mk_cofix i1, Mk_cofix i2) =&gt; Int.equal i1 i2
  | (Mk_rel i1, Mk_rel i2) =&gt; Int.equal i1 i2
  | (Mk_var id1, Mk_var id2) =&gt; Names.Id.equal id1 id2
  | (Cast_accu, Cast_accu) =&gt; true
  | (Upd_cofix, Upd_cofix) =&gt; true
  | (Force_cofix, Force_cofix) =&gt; true
  | (Mk_meta, Mk_meta) =&gt; true
  | (Mk_evar, Mk_evar) =&gt; true
  | (Mk_proj, Mk_proj) =&gt; true
  | (MLarrayget, MLarrayget) =&gt; true
  | _ =&gt; false
  end.

Definition primitive_hash (function_parameter : primitive) : Z :=
  match function_parameter with
  | Mk_prod =&gt; 1
  | Mk_sort =&gt; 2
  | Mk_ind =&gt; 3
  | Mk_const =&gt; 4
  | Mk_sw =&gt; 5
  | Mk_fix r i =&gt;
    let h :=
      Util.Array.(CArray.ExtS.fold_left)
        (fun h =&gt; fun i =&gt; Hashset.Combine.combine h (Int.hash i)) 0 r in
    Hashset.Combine.combinesmall 6 (Hashset.Combine.combine h (Int.hash i))
  | Mk_cofix i =&gt; Hashset.Combine.combinesmall 7 (Int.hash i)
  | Mk_rel i =&gt; Hashset.Combine.combinesmall 8 (Int.hash i)
  | Mk_var id =&gt; Hashset.Combine.combinesmall 9 (Names.Id.hash id)
  | Is_int =&gt; 11
  | Cast_accu =&gt; 12
  | Upd_cofix =&gt; 13
  | Force_cofix =&gt; 14
  | Mk_uint =&gt; 15
  | Mk_int =&gt; 16
  | Mk_bool =&gt; 17
  | Val_to_int =&gt; 18
  | Mk_meta =&gt; 19
  | Mk_evar =&gt; 20
  | MLand =&gt; 21
  | MLle =&gt; 22
  | MLlt =&gt; 23
  | MLinteq =&gt; 24
  | MLlsl =&gt; 25
  | MLlsr =&gt; 26
  | MLland =&gt; 27
  | MLlor =&gt; 28
  | MLlxor =&gt; 29
  | MLadd =&gt; 30
  | MLsub =&gt; 31
  | MLmul =&gt; 32
  | MLmagic =&gt; 33
  | Coq_primitive prim None =&gt;
    Hashset.Combine.combinesmall 34 (CPrimitives.hash prim)
  | Coq_primitive prim (Some (prefix, (kn, _))) =&gt;
    Hashset.Combine.combinesmall 35
      (Hashset.Combine.combine3 (Util.String.(CString.ExtS.hash) prefix)
        (Names.Constant.hash kn) (CPrimitives.hash prim))
  | Mk_proj =&gt; 36
  | MLarrayget =&gt; 37
  | Mk_empty_instance =&gt; 38
  end.

Reserved Notation &quot;'mllam_branches&quot;.

Inductive mllambda : Type :=
| MLlocal : lname -&gt; mllambda
| MLglobal : gname -&gt; mllambda
| MLprimitive : primitive -&gt; mllambda
| MLlam : (array lname) -&gt; mllambda -&gt; mllambda
| MLletrec : (array (lname * (array lname) * mllambda)) -&gt; mllambda -&gt; mllambda
| MLlet : lname -&gt; mllambda -&gt; mllambda -&gt; mllambda
| MLapp : mllambda -&gt; (array mllambda) -&gt; mllambda
| MLif : mllambda -&gt; mllambda -&gt; mllambda -&gt; mllambda
| MLmatch : Nativevalues.annot_sw -&gt; mllambda -&gt; mllambda -&gt; 'mllam_branches -&gt;
  mllambda
| MLconstruct : string -&gt; Names.inductive -&gt; Z -&gt; (array mllambda) -&gt; mllambda
| MLint : Z -&gt; mllambda
| MLuint : Uint63.t -&gt; mllambda
| MLsetref : string -&gt; mllambda -&gt; mllambda
| MLsequence : mllambda -&gt; mllambda -&gt; mllambda
| MLarray : (array mllambda) -&gt; mllambda
| MLisaccu : string -&gt; Names.inductive -&gt; mllambda -&gt; mllambda

with mllam_pattern (a : Type) : Type :=
| ConstPattern : Z -&gt; mllam_pattern a
| NonConstPattern : Nativevalues.tag -&gt; (array a) -&gt; mllam_pattern a

where &quot;'mllam_branches&quot; := (
  array ((list (mllam_pattern (option lname))) * mllambda)).

Definition mllam_branches := 'mllam_branches.

Arguments ConstPattern {_}.
Arguments NonConstPattern {_}.

Definition push_lnames (n : Z) (env : LNmap.t Z) (lns : array LNmap.key)
  : LNmap.t Z :=
  snd
    (Util.Array.(CArray.ExtS.fold_left)
      (fun function_parameter =&gt;
        match function_parameter with
        | (i, r) =&gt; fun x =&gt; ((Util.op_plus i 1), (LNmap.add x i r))
        end) (n, env) lns).

Definition opush_lnames
  (n : Z) (env : LNmap.t Z) (lns : array (option LNmap.key)) : LNmap.t Z :=
  let oadd {A : Type} (x : option LNmap.key) (i : A) (r : LNmap.t A)
    : LNmap.t A :=
    match x with
    | Some ln =&gt; LNmap.add ln i r
    | None =&gt; r
    end in
  snd
    (Util.Array.(CArray.ExtS.fold_left)
      (fun function_parameter =&gt;
        match function_parameter with
        | (i, r) =&gt; fun x =&gt; ((Util.op_plus i 1), (oadd x i r))
        end) (n, env) lns).

Fixpoint eq_mllambda
  (gn1 : gname) (gn2 : gname) (n : Int.t) (env1 : LNmap.t Int.t)
  (env2 : LNmap.t Int.t) (t1 : mllambda) (t2 : mllambda) : bool :=
  match (t1, t2) with
  | (MLlocal ln1, MLlocal ln2) =&gt; try
  | (MLglobal gn1', MLglobal gn2') =&gt;
    orb (eq_gname gn1' gn2')
      (orb (andb (eq_gname gn1 gn1') (eq_gname gn2 gn2'))
        (andb (eq_gname gn1 gn2') (eq_gname gn2 gn1')))
  | (MLprimitive prim1, MLprimitive prim2) =&gt; eq_primitive prim1 prim2
  | (MLlam lns1 ml1, MLlam lns2 ml2) =&gt;
    andb
      (Int.equal (Util.Array.(CArray.ExtS.length) lns1)
        (Util.Array.(CArray.ExtS.length) lns2))
      (let env1 := push_lnames n env1 lns1 in
      let env2 := push_lnames n env2 lns2 in
      eq_mllambda gn1 gn2
        (Util.op_plus n (Util.Array.(CArray.ExtS.length) lns1)) env1 env2 ml1
        ml2)
  | (MLletrec defs1 body1, MLletrec defs2 body2) =&gt;
    andb
      (Int.equal (Util.Array.(CArray.ExtS.length) defs1)
        (Util.Array.(CArray.ExtS.length) defs2))
      (let lns1 :=
        Util.Array.(CArray.ExtS.map)
          (fun function_parameter =&gt;
            match function_parameter with
            | (x, _, _) =&gt; x
            end) defs1 in
      let lns2 :=
        Util.Array.(CArray.ExtS.map)
          (fun function_parameter =&gt;
            match function_parameter with
            | (x, _, _) =&gt; x
            end) defs2 in
      let env1 := push_lnames n env1 lns1 in
      let env2 := push_lnames n env2 lns2 in
      let n := Util.op_plus n (Util.Array.(CArray.ExtS.length) defs1) in
      andb (eq_letrec gn1 gn2 n env1 env2 defs1 defs2)
        (eq_mllambda gn1 gn2 n env1 env2 body1 body2))
  | (MLlet ln1 def1 body1, MLlet ln2 def2 body2) =&gt;
    andb (eq_mllambda gn1 gn2 n env1 env2 def1 def2)
      (let env1 := LNmap.add ln1 n env1 in
      let env2 := LNmap.add ln2 n env2 in
      eq_mllambda gn1 gn2 (Util.op_plus n 1) env1 env2 body1 body2)
  | (MLapp ml1 args1, MLapp ml2 args2) =&gt;
    andb (eq_mllambda gn1 gn2 n env1 env2 ml1 ml2)
      (Util.Array.(CArray.ExtS.equal) (eq_mllambda gn1 gn2 n env1 env2) args1
        args2)
  | (MLif cond1 br1 br'1, MLif cond2 br2 br'2) =&gt;
    andb (eq_mllambda gn1 gn2 n env1 env2 cond1 cond2)
      (andb (eq_mllambda gn1 gn2 n env1 env2 br1 br2)
        (eq_mllambda gn1 gn2 n env1 env2 br'1 br'2))
  | (MLmatch annot1 c1 accu1 br1, MLmatch annot2 c2 accu2 br2) =&gt;
    andb (Nativevalues.eq_annot_sw annot1 annot2)
      (andb (eq_mllambda gn1 gn2 n env1 env2 c1 c2)
        (andb (eq_mllambda gn1 gn2 n env1 env2 accu1 accu2)
          (eq_mllam_branches gn1 gn2 n env1 env2 br1 br2)))
  | (MLconstruct pf1 ind1 tag1 args1, MLconstruct pf2 ind2 tag2 args2) =&gt;
    andb (Util.String.(CString.ExtS.equal) pf1 pf2)
      (andb (Names.eq_ind ind1 ind2)
        (andb (Int.equal tag1 tag2)
          (Util.Array.(CArray.ExtS.equal) (eq_mllambda gn1 gn2 n env1 env2)
            args1 args2)))
  | (MLint i1, MLint i2) =&gt; Int.equal i1 i2
  | (MLuint i1, MLuint i2) =&gt; Uint63.equal i1 i2
  | (MLsetref id1 ml1, MLsetref id2 ml2) =&gt;
    andb (Util.String.(CString.ExtS.equal) id1 id2)
      (eq_mllambda gn1 gn2 n env1 env2 ml1 ml2)
  | (MLsequence ml1 ml'1, MLsequence ml2 ml'2) =&gt;
    andb (eq_mllambda gn1 gn2 n env1 env2 ml1 ml2)
      (eq_mllambda gn1 gn2 n env1 env2 ml'1 ml'2)
  | (MLarray arr1, MLarray arr2) =&gt;
    Util.Array.(CArray.ExtS.equal) (eq_mllambda gn1 gn2 n env1 env2) arr1 arr2
  | (MLisaccu s1 ind1 ml1, MLisaccu s2 ind2 ml2) =&gt;
    andb (Util.String.(CString.ExtS.equal) s1 s2)
      (andb (Names.eq_ind ind1 ind2) (eq_mllambda gn1 gn2 n env1 env2 ml1 ml2))
  |
    (MLlocal _ | MLglobal _ | MLprimitive _ | MLlam _ _ | MLletrec _ _ |
      MLlet _ _ _ | MLapp _ _ | MLif _ _ _ | MLmatch _ _ _ _ |
      MLconstruct _ _ _ _ | MLint _ | MLuint _ | MLsetref _ _ | MLsequence _ _ |
      MLarray _ | MLisaccu _ _ _, _) =&gt; false
  end

with eq_letrec
  (gn1 : gname) (gn2 : gname) (n : Int.t) (env1 : LNmap.t Int.t)
  (env2 : LNmap.t Int.t) (defs1 : array (lname * (array LNmap.key) * mllambda))
  (defs2 : array (lname * (array LNmap.key) * mllambda)) : bool :=
  let eq_def {A B : Type}
    (function_parameter : A * (array LNmap.key) * mllambda)
    : (B * (array LNmap.key) * mllambda) -&gt; bool :=
    match function_parameter with
    | (_, args1, ml1) =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | (_, args2, ml2) =&gt;
          andb
            (Int.equal (Util.Array.(CArray.ExtS.length) args1)
              (Util.Array.(CArray.ExtS.length) args2))
            (let env1 := push_lnames n env1 args1 in
            let env2 := push_lnames n env2 args2 in
            eq_mllambda gn1 gn2
              (Util.op_plus n (Util.Array.(CArray.ExtS.length) args1)) env1 env2
              ml1 ml2)
        end
    end in
  Util.Array.(CArray.ExtS.equal) eq_def defs1 defs2

with eq_mllam_branches
  (gn1 : gname) (gn2 : gname) (n : Int.t) (env1 : LNmap.t Int.t)
  (env2 : LNmap.t Int.t) (br1 : mllam_branches) (br2 : mllam_branches) : bool :=
  let eq_cargs
    (args1 : array (option LNmap.key)) (args2 : array (option LNmap.key)) (body1
    : mllambda) (body2 : mllambda) : bool :=
    andb
      (Int.equal (Util.Array.(CArray.ExtS.length) args1)
        (Util.Array.(CArray.ExtS.length) args2))
      (let env1 := opush_lnames n env1 args1 in
      let env2 := opush_lnames n env2 args2 in
      eq_mllambda gn1 gn2
        (Util.op_plus n (Util.Array.(CArray.ExtS.length) args1)) env1 env2 body1
        body2) in
  let eq_pattern
    (pat1 : mllam_pattern (option LNmap.key)) (pat2 :
    mllam_pattern (option LNmap.key)) (body1 : mllambda) (body2 : mllambda)
    : bool :=
    match (pat1, pat2) with
    | (ConstPattern tag1, ConstPattern tag2) =&gt;
      andb (Int.equal tag1 tag2) (eq_mllambda gn1 gn2 n env1 env2 body1 body2)
    | (NonConstPattern tag1 args1, NonConstPattern tag2 args2) =&gt;
      andb (Int.equal tag1 tag2) (eq_cargs args1 args2 body1 body2)
    | (ConstPattern _ | NonConstPattern _ _, _) =&gt; false
    end in
  let eq_branch
    (function_parameter : (list (mllam_pattern (option LNmap.key))) * mllambda)
    : ((list (mllam_pattern (option LNmap.key))) * mllambda) -&gt; bool :=
    match function_parameter with
    | (patl1, body1) =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | (patl2, body2) =&gt;
          Util.List.(CList.ExtS.equal)
            (fun pt1 =&gt; fun pt2 =&gt; eq_pattern pt1 pt2 body1 body2) patl1 patl2
        end
    end in
  Util.Array.(CArray.ExtS.equal) eq_branch br1 br2.

Fixpoint hash_mllambda (gn : gname) (n : Z) (env : LNmap.t Z) (t : mllambda)
  : Z :=
  match t with
  | MLlocal ln =&gt; Hashset.Combine.combinesmall 1 (LNmap.find ln env)
  | MLglobal gn' =&gt;
    Hashset.Combine.combinesmall 2
      (if eq_gname gn gn' then
        0
      else
        gname_hash gn')
  | MLprimitive prim =&gt; Hashset.Combine.combinesmall 3 (primitive_hash prim)
  | MLlam lns ml =&gt;
    let env := push_lnames n env lns in
    Hashset.Combine.combinesmall 4
      (Hashset.Combine.combine (Util.Array.(CArray.ExtS.length) lns)
        (hash_mllambda gn (Util.op_plus n 1) env ml))
  | MLletrec defs body =&gt;
    let lns :=
      Util.Array.(CArray.ExtS.map)
        (fun function_parameter =&gt;
          match function_parameter with
          | (x, _, _) =&gt; x
          end) defs in
    let env := push_lnames n env lns in
    let n := Util.op_plus n (Util.Array.(CArray.ExtS.length) defs) in
    let h :=
      Hashset.Combine.combine (hash_mllambda gn n env body)
        (Util.Array.(CArray.ExtS.length) defs) in
    Hashset.Combine.combinesmall 5 (hash_mllambda_letrec gn n env h defs)
  | MLlet ln def body =&gt;
    let hdef := hash_mllambda gn n env def in
    let env := LNmap.add ln n env in
    Hashset.Combine.combinesmall 6
      (Hashset.Combine.combine hdef
        (hash_mllambda gn (Util.op_plus n 1) env body))
  | MLapp ml args =&gt;
    let h := hash_mllambda gn n env ml in
    Hashset.Combine.combinesmall 7 (hash_mllambda_array gn n env h args)
  | MLif cond br br' =&gt;
    let hcond := hash_mllambda gn n env cond in
    let hbr := hash_mllambda gn n env br in
    let hbr' := hash_mllambda gn n env br' in
    Hashset.Combine.combinesmall 8 (Hashset.Combine.combine3 hcond hbr hbr')
  | MLmatch annot c accu br =&gt;
    let hannot := Nativevalues.hash_annot_sw annot in
    let hc := hash_mllambda gn n env c in
    let haccu := hash_mllambda gn n env accu in
    Hashset.Combine.combinesmall 9
      (hash_mllam_branches gn n env (Hashset.Combine.combine3 hannot hc haccu)
        br)
  | MLconstruct pf ind tag args =&gt;
    let hpf := Util.String.(CString.ExtS.hash) pf in
    let hcs := Names.ind_hash ind in
    let htag := Int.hash tag in
    Hashset.Combine.combinesmall 10
      (hash_mllambda_array gn n env (Hashset.Combine.combine3 hpf hcs htag) args)
  | MLint i =&gt; Hashset.Combine.combinesmall 11 i
  | MLuint i =&gt; Hashset.Combine.combinesmall 12 (Uint63.hash i)
  | MLsetref id ml =&gt;
    let hid := Util.String.(CString.ExtS.hash) id in
    let hml := hash_mllambda gn n env ml in
    Hashset.Combine.combinesmall 13 (Hashset.Combine.combine hid hml)
  | MLsequence ml ml' =&gt;
    let hml := hash_mllambda gn n env ml in
    let hml' := hash_mllambda gn n env ml' in
    Hashset.Combine.combinesmall 14 (Hashset.Combine.combine hml hml')
  | MLarray arr =&gt;
    Hashset.Combine.combinesmall 15 (hash_mllambda_array gn n env 1 arr)
  | MLisaccu s ind c =&gt;
    Hashset.Combine.combinesmall 16
      (Hashset.Combine.combine (Util.String.(CString.ExtS.hash) s)
        (Hashset.Combine.combine (Names.ind_hash ind) (hash_mllambda gn n env c)))
  end

with hash_mllambda_letrec
  (gn : gname) (n : Z) (env : LNmap.t Z) (init : Z)
  (defs : array (lname * (array LNmap.key) * mllambda)) : Z :=
  let hash_def {A : Type}
    (function_parameter : A * (array LNmap.key) * mllambda) : Z :=
    match function_parameter with
    | (_, args, ml) =&gt;
      let env := push_lnames n env args in
      let nargs := Util.Array.(CArray.ExtS.length) args in
      Hashset.Combine.combine nargs
        (hash_mllambda gn (Util.op_plus n nargs) env ml)
    end in
  Util.Array.(CArray.ExtS.fold_left)
    (fun acc =&gt; fun t =&gt; Hashset.Combine.combine (hash_def t) acc) init defs

with hash_mllambda_array
  (gn : gname) (n : Z) (env : LNmap.t Z) (init : Z) (arr : array mllambda)
  : Z :=
  Util.Array.(CArray.ExtS.fold_left)
    (fun acc =&gt; fun t =&gt; Hashset.Combine.combine (hash_mllambda gn n env t) acc)
    init arr

with hash_mllam_branches
  (gn : gname) (n : Z) (env : LNmap.t Z) (init : Z) (br : mllam_branches) : Z :=
  let hash_cargs (args : array (option LNmap.key)) (body : mllambda) : Z :=
    let nargs := Util.Array.(CArray.ExtS.length) args in
    let env := opush_lnames n env args in
    let hbody := hash_mllambda gn (Util.op_plus n nargs) env body in
    Hashset.Combine.combine nargs hbody in
  let hash_pattern (pat : mllam_pattern (option LNmap.key)) (body : mllambda)
    : Z :=
    match pat with
    | ConstPattern i =&gt; Hashset.Combine.combinesmall 1 (Int.hash i)
    | NonConstPattern tag args =&gt;
      Hashset.Combine.combinesmall 2
        (Hashset.Combine.combine (Int.hash tag) (hash_cargs args body))
    end in
  let hash_branch
    (acc : Z) (function_parameter :
    (list (mllam_pattern (option LNmap.key))) * mllambda) : Z :=
    match function_parameter with
    | (ptl, body) =&gt;
      Util.List.(CList.ExtS.fold_left)
        (fun acc =&gt; fun t =&gt; Hashset.Combine.combine (hash_pattern t body) acc)
        acc ptl
    end in
  Util.Array.(CArray.ExtS.fold_left) hash_branch init br.

Definition fv_lam (l : mllambda) : LNset.t :=
  let fix aux (l : mllambda) (bind : LNset.t) (fv : LNset.t) : LNset.t :=
    match l with
    | MLlocal l =&gt;
      if LNset.mem l bind then
        fv
      else
        LNset.add l fv
    | MLglobal _ | MLprimitive _ | MLint _ | MLuint _ =&gt; fv
    | MLlam ln body =&gt;
      let bind := Util.Array.(CArray.ExtS.fold_right) LNset.add ln bind in
      aux body bind fv
    | MLletrec bodies def =&gt;
      let bind :=
        Util.Array.(CArray.ExtS.fold_right)
          (fun function_parameter =&gt;
            match function_parameter with
            | (id, _, _) =&gt; fun b =&gt; LNset.add id b
            end) bodies bind in
      let fv_body {A : Type}
        (function_parameter : A * (array LNset.elt) * mllambda)
        : LNset.t -&gt; LNset.t :=
        match function_parameter with
        | (_, ln, body) =&gt;
          fun fv =&gt;
            let bind := Util.Array.(CArray.ExtS.fold_right) LNset.add ln bind in
            aux body bind fv
        end in
      Util.Array.(CArray.ExtS.fold_right) fv_body bodies (aux def bind fv)
    | MLlet l def body =&gt; aux body (LNset.add l bind) (aux def bind fv)
    | MLapp f args =&gt;
      let fv_arg (arg : mllambda) (fv : LNset.t) : LNset.t :=
        aux arg bind fv in
      Util.Array.(CArray.ExtS.fold_right) fv_arg args (aux f bind fv)
    | MLif t b1 b2 =&gt; aux t bind (aux b1 bind (aux b2 bind fv))
    | MLmatch _ a p bs =&gt;
      let fv := aux a bind (aux p bind fv) in
      let fv_bs
        (function_parameter :
        (list (mllam_pattern (option LNset.elt))) * mllambda)
        : LNset.t -&gt; LNset.t :=
        match function_parameter with
        | (cargs, body) =&gt;
          fun fv =&gt;
            let bind :=
              Util.List.(CList.ExtS.fold_right)
                (fun pat =&gt;
                  fun bind =&gt;
                    match pat with
                    | ConstPattern _ =&gt; bind
                    | NonConstPattern _ args =&gt;
                      Util.Array.(CArray.ExtS.fold_right)
                        (fun o =&gt;
                          fun bind =&gt;
                            match o with
                            | Some l =&gt; LNset.add l bind
                            | _ =&gt; bind
                            end) args bind
                    end) cargs bind in
            aux body bind fv
        end in
      Util.Array.(CArray.ExtS.fold_right) fv_bs bs fv
    | MLconstruct _ _ _ p =&gt;
      Util.Array.(CArray.ExtS.fold_right) (fun a =&gt; fun fv =&gt; aux a bind fv) p
        fv
    | MLsetref _ l =&gt; aux l bind fv
    | MLsequence l1 l2 =&gt; aux l1 bind (aux l2 bind fv)
    | MLarray arr =&gt;
      Util.Array.(CArray.ExtS.fold_right) (fun a =&gt; fun fv =&gt; aux a bind fv) arr
        fv
    | MLisaccu _ _ body =&gt; aux body bind fv
    end in
  aux l LNset.empty LNset.empty.

Definition mkMLlam (params : array lname) (body : mllambda) : mllambda :=
  if Util.Array.(CArray.ExtS.is_empty) params then
    body
  else
    match body with
    | MLlam params' body =&gt;
      MLlam (Util.Array.(CArray.ExtS.append) params params') body
    | _ =&gt; MLlam params body
    end.

Definition mkMLapp (f : mllambda) (args : array mllambda) : mllambda :=
  if Util.Array.(CArray.ExtS.is_empty) args then
    f
  else
    match f with
    | MLapp f args' =&gt; MLapp f (Util.Array.(CArray.ExtS.append) args' args)
    | _ =&gt; MLapp f args
    end.

Definition mkForceCofix
  (prefix : string) (ind : Names.inductive) (arg : mllambda) : mllambda :=
  let name := fresh_lname Anonymous in
  MLlet name arg
    (MLif (MLisaccu prefix ind (MLlocal name))
      (MLapp (MLprimitive Force_cofix) ((MLlocal name))) (MLlocal name)).

Definition empty_params {A : Type} : array A := tt.

Definition decompose_MLlam (c : mllambda) : (array lname) * mllambda :=
  match c with
  | MLlam ids c =&gt; (ids, c)
  | _ =&gt; (empty_params, c)
  end.

Inductive global : Type :=
| Gtblnorm : gname -&gt; (array lname) -&gt; (array mllambda) -&gt; global
| Gtblfixtype : gname -&gt; (array lname) -&gt; (array mllambda) -&gt; global
| Glet : gname -&gt; mllambda -&gt; global
| Gletcase : gname -&gt; (array lname) -&gt; Nativevalues.annot_sw -&gt; mllambda -&gt;
  mllambda -&gt; mllam_branches -&gt; global
| Gopen : string -&gt; global
| Gtype : Names.inductive -&gt; (array (Nativevalues.tag * Z)) -&gt; global
| Gcomment : string -&gt; global.

Definition eq_global (g1 : global) (g2 : global) : bool :=
  match (g1, g2) with
  |
    (Gtblnorm gn1 lns1 mls1, Gtblnorm gn2 lns2 mls2) |
      (Gtblfixtype gn1 lns1 mls1, Gtblfixtype gn2 lns2 mls2) =&gt;
    andb
      (Int.equal (Util.Array.(CArray.ExtS.length) lns1)
        (Util.Array.(CArray.ExtS.length) lns2))
      (andb
        (Int.equal (Util.Array.(CArray.ExtS.length) mls1)
          (Util.Array.(CArray.ExtS.length) mls2))
        (let env1 := push_lnames 0 LNmap.empty lns1 in
        let env2 := push_lnames 0 LNmap.empty lns2 in
        Util.Array.(CArray.ExtS.for_all2)
          (eq_mllambda gn1 gn2 (Util.Array.(CArray.ExtS.length) lns1) env1 env2)
          mls1 mls2))
  | (Glet gn1 def1, Glet gn2 def2) =&gt;
    eq_mllambda gn1 gn2 0 LNmap.empty LNmap.empty def1 def2
  |
    (Gletcase gn1 lns1 annot1 c1 accu1 br1,
      Gletcase gn2 lns2 annot2 c2 accu2 br2) =&gt;
    andb
      (Int.equal (Util.Array.(CArray.ExtS.length) lns1)
        (Util.Array.(CArray.ExtS.length) lns2))
      (let env1 := push_lnames 0 LNmap.empty lns1 in
      let env2 := push_lnames 0 LNmap.empty lns2 in
      let t1 := MLmatch annot1 c1 accu1 br1 in
      let t2 := MLmatch annot2 c2 accu2 br2 in
      eq_mllambda gn1 gn2 (Util.Array.(CArray.ExtS.length) lns1) env1 env2 t1 t2)
  | (Gopen s1, Gopen s2) =&gt; Util.String.(CString.ExtS.equal) s1 s2
  | (Gtype ind1 arr1, Gtype ind2 arr2) =&gt;
    andb (Names.eq_ind ind1 ind2)
      (Util.Array.(CArray.ExtS.equal)
        (fun function_parameter =&gt;
          match function_parameter with
          | (tag1, ar1) =&gt;
            fun function_parameter =&gt;
              match function_parameter with
              | (tag2, ar2) =&gt; andb (Int.equal tag1 tag2) (Int.equal ar1 ar2)
              end
          end) arr1 arr2)
  | (Gcomment s1, Gcomment s2) =&gt; Util.String.(CString.ExtS.equal) s1 s2
  | (_, _) =&gt; false
  end.

Definition hash_global (g : global) : Z :=
  match g with
  | Gtblnorm gn lns mls =&gt;
    let nlns := Util.Array.(CArray.ExtS.length) lns in
    let nmls := Util.Array.(CArray.ExtS.length) mls in
    let env := push_lnames 0 LNmap.empty lns in
    let hmls :=
      hash_mllambda_array gn nlns env (Hashset.Combine.combine nlns nmls) mls in
    Hashset.Combine.combinesmall 1 hmls
  | Gtblfixtype gn lns mls =&gt;
    let nlns := Util.Array.(CArray.ExtS.length) lns in
    let nmls := Util.Array.(CArray.ExtS.length) mls in
    let env := push_lnames 0 LNmap.empty lns in
    let hmls :=
      hash_mllambda_array gn nlns env (Hashset.Combine.combine nlns nmls) mls in
    Hashset.Combine.combinesmall 2 hmls
  | Glet gn def =&gt;
    Hashset.Combine.combinesmall 3 (hash_mllambda gn 0 LNmap.empty def)
  | Gletcase gn lns annot c accu br =&gt;
    let nlns := Util.Array.(CArray.ExtS.length) lns in
    let env := push_lnames 0 LNmap.empty lns in
    let t := MLmatch annot c accu br in
    Hashset.Combine.combinesmall 4
      (Hashset.Combine.combine nlns (hash_mllambda gn nlns env t))
  | Gopen s =&gt;
    Hashset.Combine.combinesmall 5 (Util.String.(CString.ExtS.hash) s)
  | Gtype ind arr =&gt;
    let hash_aux (acc : Z) (function_parameter : Int.t * Int.t) : Z :=
      match function_parameter with
      | (tag, ar) =&gt; Hashset.Combine.combine3 acc (Int.hash tag) (Int.hash ar)
      end in
    Hashset.Combine.combinesmall 6
      (Hashset.Combine.combine (Names.ind_hash ind)
        (Util.Array.(CArray.ExtS.fold_left) hash_aux 0 arr))
  | Gcomment s =&gt;
    Hashset.Combine.combinesmall 7 (Util.String.(CString.ExtS.hash) s)
  end.

Definition global_stack : Stdlib.ref (list global) := Stdlib.ref [].

Module HashedTypeGlobal.
  Definition t := global.
  
  Definition equal : global -&gt; global -&gt; bool := eq_global.
  
  Definition hash : global -&gt; Z := hash_global.
End HashedTypeGlobal.

Definition global_tbl : HashtblGlobal.t gname := HashtblGlobal.create 19991.

Definition clear_global_tbl (function_parameter : unit) : unit :=
  match function_parameter with
  | tt =&gt; HashtblGlobal.clear global_tbl
  end.

Definition push_global (gn : gname) (t : HashtblGlobal.key) : gname := try.

Definition push_global_let (gn : gname) (body : mllambda) : gname :=
  push_global gn (Glet gn body).

Definition push_global_fixtype
  (gn : gname) (params : array lname) (body : array mllambda) : gname :=
  push_global gn (Gtblfixtype gn params body).

Definition push_global_norm
  (gn : gname) (params : array lname) (body : array mllambda) : gname :=
  push_global gn (Gtblnorm gn params body).

Definition push_global_case
  (gn : gname) (params : array lname) (annot : Nativevalues.annot_sw)
  (a : mllambda) (accu : mllambda) (bs : mllam_branches) : gname :=
  push_global gn (Gletcase gn params annot a accu bs).

Definition eq_mllambda (t1 : mllambda) (t2 : mllambda) : bool :=
  eq_mllambda dummy_gname dummy_gname 0 LNmap.empty LNmap.empty t1 t2.

Record env := {
  env_rel : list mllambda;
  env_bound : Z;
  env_urel : Stdlib.ref (list (Z * mllambda));
  env_named : Stdlib.ref (list (Names.Id.t * mllambda));
  env_univ : option lname }.

Definition empty_env (univ : option lname) (function_parameter : unit) : env :=
  match function_parameter with
  | tt =&gt;
    {| env_rel := []; env_bound := 0; env_urel := Stdlib.ref [];
      env_named := Stdlib.ref []; env_univ := univ |}
  end.

Definition push_rel (env : env) (id : Context.binder_annot Names.Name.t)
  : lname * env :=
  let local := fresh_lname (binder_name id) in
  (local, record).

Definition push_rels
  (env : env) (ids : array (Context.binder_annot Names.Name.t))
  : (array lname) * env :=
  match
    Util.Array.(CArray.ExtS.fold_left)
      (fun function_parameter =&gt;
        match function_parameter with
        | (names, env_rel) =&gt;
          fun id =&gt;
            let local := fresh_lname (binder_name id) in
            ((cons local names), (cons (MLlocal local) env_rel))
        end) ([], (env_rel env)) ids with
  | (lnames, env_rel) =&gt;
    ((Util.Array.(CArray.ExtS.of_list) (Util.List.(CList.ExtS.rev) lnames)),
      record)
  end.

Definition get_rel (env : env) (id : Names.Name.t) (i : Z) : mllambda :=
  if OCaml.Stdlib.le i (env_bound env) then
    Util.List.(CList.ExtS.nth) (env_rel env) (Util.op_minus i 1)
  else
    let i := Util.op_minus i (env_bound env) in
    try.

Definition get_var (env : env) (id : Names.Id.List.(CList.MonoS.elt))
  : mllambda := try.

Definition fresh_univ (function_parameter : unit) : lname :=
  match function_parameter with
  | tt =&gt; fresh_lname (Name (Names.Id.of_string &quot;univ&quot; % string))
  end.

Definition get_prod_name (codom : mllambda) : Names.Name.t :=
  match codom with
  | MLlam ids _ =&gt; lname (Util.Array.(CArray.ExtS.get) ids 0)
  | _ =&gt; false
  end.

Definition get_lname {A : Type} (function_parameter : A * mllambda) : lname :=
  match function_parameter with
  | (_, l) =&gt;
    match l with
    | MLlocal id =&gt; id
    | _ =&gt; OCaml.Stdlib.invalid_arg &quot;Nativecode.get_lname&quot; % string
    end
  end.

Definition fv_params (env : env) : array lname :=
  match
    ((Util.op_exclamation (env_named env)), (Util.op_exclamation (env_urel env)))
    with
  | (fvn, fvr) =&gt;
    let size :=
      Util.op_plus (Util.List.(CList.ExtS.length) fvn)
        (Util.List.(CList.ExtS.length) fvr) in
    match
      match env_univ env with
      | None =&gt; (0, (Util.Array.(CArray.ExtS.make) size dummy_lname))
      | Some u =&gt;
        (1,
          (let t :=
            Util.Array.(CArray.ExtS.make) (Util.op_plus size 1) dummy_lname in
          Util.Array.(CArray.ExtS.set) t 0 u;
          t))
      end with
    | (start, params) =&gt;
      if Util.Array.(CArray.ExtS.is_empty) params then
        empty_params
      else
        let fvn := Stdlib.ref fvn in
        let i := Stdlib.ref start in
        while;
        let fvr := Stdlib.ref fvr in
        while;
        params
    end
  end.

Definition generalize_fv (env : env) (body : mllambda) : mllambda :=
  mkMLlam (fv_params env) body.

Definition empty_args {A : Type} : array A := tt.

Definition fv_args {A : Type}
  (env : env) (fvn : list (Names.Id.List.(CList.MonoS.elt) * A))
  (fvr : list (Z * mllambda)) : array mllambda :=
  let size :=
    Util.op_plus (Util.List.(CList.ExtS.length) fvn)
      (Util.List.(CList.ExtS.length) fvr) in
  match
    match env_univ env with
    | None =&gt; (0, (Util.Array.(CArray.ExtS.make) size (MLint 0)))
    | Some u =&gt;
      (1,
        (let t := Util.Array.(CArray.ExtS.make) (Util.op_plus size 1) (MLint 0)
          in
        Util.Array.(CArray.ExtS.set) t 0 (MLlocal u);
        t))
    end with
  | (start, args) =&gt;
    if Util.Array.(CArray.ExtS.is_empty) args then
      empty_args
    else
      let fvn := Stdlib.ref fvn in
      let i := Stdlib.ref start in
      while;
      let fvr := Stdlib.ref fvr in
      while;
      args
  end.

Definition get_value_code (i : Z) : mllambda :=
  MLapp (MLglobal (Ginternal &quot;get_value&quot; % string))
    ((MLglobal symbols_tbl_name), (MLint i)).

Definition get_sort_code (i : Z) : mllambda :=
  MLapp (MLglobal (Ginternal &quot;get_sort&quot; % string))
    ((MLglobal symbols_tbl_name), (MLint i)).

Definition get_name_code (i : Z) : mllambda :=
  MLapp (MLglobal (Ginternal &quot;get_name&quot; % string))
    ((MLglobal symbols_tbl_name), (MLint i)).

Definition get_const_code (i : Z) : mllambda :=
  MLapp (MLglobal (Ginternal &quot;get_const&quot; % string))
    ((MLglobal symbols_tbl_name), (MLint i)).

Definition get_match_code (i : Z) : mllambda :=
  MLapp (MLglobal (Ginternal &quot;get_match&quot; % string))
    ((MLglobal symbols_tbl_name), (MLint i)).

Definition get_ind_code (i : Z) : mllambda :=
  MLapp (MLglobal (Ginternal &quot;get_ind&quot; % string))
    ((MLglobal symbols_tbl_name), (MLint i)).

Definition get_meta_code (i : Z) : mllambda :=
  MLapp (MLglobal (Ginternal &quot;get_meta&quot; % string))
    ((MLglobal symbols_tbl_name), (MLint i)).

Definition get_evar_code (i : Z) : mllambda :=
  MLapp (MLglobal (Ginternal &quot;get_evar&quot; % string))
    ((MLglobal symbols_tbl_name), (MLint i)).

Definition get_level_code (i : Z) : mllambda :=
  MLapp (MLglobal (Ginternal &quot;get_level&quot; % string))
    ((MLglobal symbols_tbl_name), (MLint i)).

Definition get_proj_code (i : Z) : mllambda :=
  MLapp (MLglobal (Ginternal &quot;get_proj&quot; % string))
    ((MLglobal symbols_tbl_name), (MLint i)).

Reserved Notation &quot;'rlist'&quot;.

Inductive rlist : Type :=
| Rnil : rlist
| Rcons : (Stdlib.ref (list (mllam_pattern (option lname)))) -&gt; LNset.t -&gt;
  mllambda -&gt; 'rlist' -&gt; rlist

where &quot;'rlist'&quot; := ( Stdlib.ref rlist).

Definition rlist' := 'rlist'.

Definition rm_params (fv : LNset.t) (params : array LNset.elt)
  : array (option LNset.elt) :=
  Util.Array.(CArray.ExtS.map)
    (fun l =&gt;
      if LNset.mem l fv then
        Some l
      else
        None) params.

Fixpoint insert
  (pat : mllam_pattern LNset.elt) (body : mllambda) (rl : Stdlib.ref rlist)
  : unit :=
  match Util.op_exclamation rl with
  | Rnil =&gt;
    let fv := fv_lam body in
    match pat with
    | (ConstPattern _) as p =&gt;
      Stdlib.op_colon_eq rl
        (Rcons (Stdlib.ref (cons p [])) fv body (Stdlib.ref Rnil))
    | NonConstPattern tag args =&gt;
      let args := rm_params fv args in
      Stdlib.op_colon_eq rl
        (Rcons (Stdlib.ref (cons (NonConstPattern tag args) [])) fv body
          (Stdlib.ref Rnil))
    end
  | Rcons l fv body' rl =&gt;
    if eq_mllambda body body' then
      match pat with
      | (ConstPattern _) as p =&gt;
        Stdlib.op_colon_eq l (cons p (Util.op_exclamation l))
      | NonConstPattern tag args =&gt;
        let args := rm_params fv args in
        Stdlib.op_colon_eq l
          (cons (NonConstPattern tag args) (Util.op_exclamation l))
      end
    else
      insert pat body rl
  end.

Fixpoint to_list (rl : Stdlib.ref rlist)
  : list ((list (mllam_pattern (option lname))) * mllambda) :=
  match Util.op_exclamation rl with
  | Rnil =&gt; []
  | Rcons l _ body tl =&gt; cons ((Util.op_exclamation l), body) (to_list tl)
  end.

Definition merge_branches (t : array ((mllam_pattern LNset.elt) * mllambda))
  : array ((list (mllam_pattern (option lname))) * mllambda) :=
  let newt := Stdlib.ref Rnil in
  Util.Array.(CArray.ExtS.iter)
    (fun function_parameter =&gt;
      match function_parameter with
      | (pat, body) =&gt; insert pat body newt
      end) t;
  Util.Array.(CArray.ExtS.of_list) (to_list newt).

Definition app_prim (p : primitive) (args : array mllambda) : mllambda :=
  MLapp (MLprimitive p) args.

Inductive prim_aux : Type :=
| PAprim : string -&gt; Constr.pconstant -&gt; CPrimitives.t -&gt; (array prim_aux) -&gt;
  prim_aux
| PAml : mllambda -&gt; prim_aux.

Definition add_check (cond : list mllambda) (args : array prim_aux)
  : list mllambda :=
  let aux (cond : list mllambda) (a : prim_aux) : list mllambda :=
    match a with
    | PAml (MLint _) =&gt; cond
    | PAml ml =&gt;
      if Util.List.(CList.ExtS.mem) ml cond then
        cond
      else
        cons ml cond
    | _ =&gt; cond
    end in
  Util.Array.(CArray.ExtS.fold_left) aux cond args.

Definition extract_prim
  (ml_of : Nativelambda.lambda -&gt; mllambda) (l : Nativelambda.lambda)
  : (list (lname * mllambda)) * (list mllambda) * prim_aux :=
  let decl := Stdlib.ref [] in
  let cond := Stdlib.ref [] in
  let fix aux (l : Nativelambda.lambda) : prim_aux :=
    match l with
    | Lprim prefix kn p args =&gt;
      let args := Util.Array.(CArray.ExtS.map) aux args in
      Stdlib.op_colon_eq cond (add_check (Util.op_exclamation cond) args);
      PAprim prefix kn p args
    | Lrel _ _ | Lvar _ | Luint _ | Lval _ | Lconst _ _ =&gt; PAml (ml_of l)
    | _ =&gt;
      let x := fresh_lname Anonymous in
      Stdlib.op_colon_eq decl (cons (x, (ml_of l)) (Util.op_exclamation decl));
      PAml (MLlocal x)
    end in
  let res := aux l in
  ((Util.op_exclamation decl), (Util.op_exclamation cond), res).

Definition cast_to_int (v : mllambda) : mllambda :=
  match v with
  | MLint _ =&gt; v
  | _ =&gt; MLapp (MLprimitive Val_to_int) (v)
  end.

Definition compile_prim
  (decl : list (lname * mllambda)) (cond : list mllambda) (paux : prim_aux)
  : mllambda :=
  let fix opt_prim_aux (paux : prim_aux) : mllambda :=
    match paux with
    | PAprim _prefix _kn op args =&gt;
      let args := Util.Array.(CArray.ExtS.map) opt_prim_aux args in
      app_prim (Coq_primitive op None) args
    | PAml ml =&gt; ml
    end
  with naive_prim_aux (paux : prim_aux) : mllambda :=
    match paux with
    | PAprim prefix kn op args =&gt;
      app_prim (Coq_primitive op (Some (prefix, kn)))
        (Util.Array.(CArray.ExtS.map) naive_prim_aux args)
    | PAml ml =&gt; ml
    end in
  let compile_cond (cond : list mllambda) (paux : prim_aux) : mllambda :=
    match cond with
    | [] =&gt; opt_prim_aux paux
    | cons c1 [] =&gt;
      MLif (app_prim Is_int (c1)) (opt_prim_aux paux) (naive_prim_aux paux)
    | cons c1 cond =&gt;
      let cond :=
        Util.List.(CList.ExtS.fold_left)
          (fun ml =&gt; fun c =&gt; app_prim MLland (ml, (cast_to_int c)))
          (app_prim MLland ((cast_to_int c1), (MLint 0))) cond in
      let cond := app_prim MLmagic (cond) in
      MLif cond (naive_prim_aux paux) (opt_prim_aux paux)
    end in
  let add_decl (decl : list (lname * mllambda)) (body : mllambda) : mllambda :=
    Util.List.(CList.ExtS.fold_left)
      (fun body =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | (x, d) =&gt; MLlet x d body
          end) body decl in
  if equiv_decb Stdlib.max_int 1073741823 then
    add_decl decl (naive_prim_aux paux)
  else
    add_decl decl (compile_cond cond paux).

Definition ml_of_instance (instance : option lname) (u : Univ.Instance.t)
  : array mllambda :=
  let ml_of_level (l : Univ.Level.t) : mllambda :=
    match Univ.Level.var_index l with
    | Some i =&gt;
      let univ := MLapp (MLprimitive MLmagic) ((MLlocal (Option.get instance)))
        in
      mkMLapp (MLprimitive MLarrayget) (univ, (MLint i))
    | None =&gt;
      let i := push_symbol (SymbLevel l) in
      get_level_code i
    end in
  let u := Univ.Instance.to_array u in
  if Util.Array.(CArray.ExtS.is_empty) u then
    tt
  else
    let u := Util.Array.(CArray.ExtS.map) ml_of_level u in
    ((MLapp (MLprimitive MLmagic) ((MLarray u)))).

Fixpoint ml_of_lam
  (env : env) (l : option Names.Label.t) (t : Nativelambda.lambda) : mllambda :=
  match t with
  | Lrel id i =&gt; get_rel env id i
  | Lvar id =&gt; get_var env id
  | Lmeta mv _ty =&gt;
    let tyn := fresh_lname Anonymous in
    let i := push_symbol (SymbMeta mv) in
    MLapp (MLprimitive Mk_meta) ((get_meta_code i), (MLlocal tyn))
  | Levar evk args =&gt;
    let i := push_symbol (SymbEvar evk) in
    let args := MLarray (Util.Array.(CArray.ExtS.map) (ml_of_lam env l) args) in
    MLapp (MLprimitive Mk_evar) ((get_evar_code i), args)
  | Lprod dom codom =&gt;
    let dom := ml_of_lam env l dom in
    let codom := ml_of_lam env l codom in
    let n := get_prod_name codom in
    let i := push_symbol (SymbName n) in
    MLapp (MLprimitive Mk_prod) ((get_name_code i), dom, codom)
  | Llam ids body =&gt;
    match push_rels env ids with
    | (lnames, env) =&gt; MLlam lnames (ml_of_lam env l body)
    end
  | Lrec id body =&gt;
    match Nativelambda.decompose_Llam body with
    | (ids, body) =&gt;
      match push_rel env id with
      | (lname, env) =&gt;
        match push_rels env ids with
        | (lnames, env) =&gt;
          MLletrec ((lname, lnames, (ml_of_lam env l body))) (MLlocal lname)
        end
      end
    end
  | Llet id def body =&gt;
    let def := ml_of_lam env l def in
    match push_rel env id with
    | (lname, env) =&gt;
      let body := ml_of_lam env l body in
      MLlet lname def body
    end
  | Lapp f args =&gt;
    MLapp (ml_of_lam env l f)
      (Util.Array.(CArray.ExtS.map) (ml_of_lam env l) args)
  | Lconst prefix (c, u) =&gt;
    let args := ml_of_instance (env_univ env) u in
    mkMLapp (MLglobal (Gconstant prefix c)) args
  | Lproj prefix ind i =&gt; MLglobal (Gproj prefix ind i)
  | Lprim _ _ _ _ =&gt;
    match extract_prim (ml_of_lam env l) t with
    | (decl, cond, paux) =&gt; compile_prim decl cond paux
    end
  | Lcase annot p a bs =&gt;
    let env_p := empty_env (env_univ env) tt in
    let pn := fresh_gpred l in
    let mlp := ml_of_lam env_p l p in
    let mlp := generalize_fv env_p mlp in
    match
      ((Util.op_exclamation (env_named env_p)),
        (Util.op_exclamation (env_urel env_p))) with
    | (pfvn, pfvr) =&gt;
      let pn := push_global_let pn mlp in
      let env_c := empty_env (env_univ env) tt in
      let a_uid := fresh_lname Anonymous in
      let la_uid := MLlocal a_uid in
      let nbconst := Util.Array.(CArray.ExtS.length) (constant_branches bs) in
      let nbtotal :=
        Util.op_plus nbconst
          (Util.Array.(CArray.ExtS.length) (nonconstant_branches bs)) in
      let br :=
        Util.Array.(CArray.ExtS.init) nbtotal
          (fun i =&gt;
            if
              OCaml.Stdlib.lt i
                (Util.Array.(CArray.ExtS.length) (constant_branches bs)) then
              ((ConstPattern i),
                (ml_of_lam env_c l
                  (Util.Array.(CArray.ExtS.get) (constant_branches bs) i)))
            else
              match
                Util.Array.(CArray.ExtS.get) (nonconstant_branches bs)
                  (Util.op_minus i nbconst) with
              | (params, body) =&gt;
                match push_rels env_c params with
                | (lnames, env_c) =&gt;
                  ((NonConstPattern (Util.op_plus (Util.op_minus i nbconst) 1)
                    lnames), (ml_of_lam env_c l body))
                end
              end) in
      let cn := fresh_gcase l in
      let pred := MLapp (MLglobal pn) (fv_args env_c pfvn pfvr) in
      match
        ((Util.op_exclamation (env_named env_c)),
          (Util.op_exclamation (env_urel env_c))) with
      | (fvn, fvr) =&gt;
        let cn_fv := mkMLapp (MLglobal cn) (fv_args env_c fvn fvr) in
        let i := push_symbol (SymbMatch annot) in
        let accu :=
          MLapp (MLprimitive Mk_sw)
            ((get_match_code i), (MLapp (MLprimitive Cast_accu) (la_uid)), pred,
              cn_fv) in
        let cn :=
          push_global_case cn
            (Util.Array.(CArray.ExtS.append) (fv_params env_c) (a_uid)) annot
            la_uid accu (merge_branches br) in
        let arg := ml_of_lam env l a in
        let force :=
          if asw_finite annot then
            arg
          else
            mkForceCofix (asw_prefix annot) (asw_ind annot) arg in
        mkMLapp (MLapp (MLglobal cn) (fv_args env fvn fvr)) (force)
      end
    end
  | Lif t bt bf =&gt;
    MLif (ml_of_lam env l t) (ml_of_lam env l bt) (ml_of_lam env l bf)
  | Lfix (rec_pos, inds, start) (ids, tt, tb) =&gt;
    let env_t := empty_env (env_univ env) tt in
    let ml_t := Util.Array.(CArray.ExtS.map) (ml_of_lam env_t l) tt in
    let params_t := fv_params env_t in
    let args_t :=
      fv_args env (Util.op_exclamation (env_named env_t))
        (Util.op_exclamation (env_urel env_t)) in
    let gft := fresh_gfixtype l in
    let gft := push_global_fixtype gft params_t ml_t in
    let mk_type := MLapp (MLglobal gft) args_t in
    let ndef := Util.Array.(CArray.ExtS.length) ids in
    match push_rels (empty_env (env_univ env) tt) ids with
    | (lf, env_n) =&gt;
      let t_params := Util.Array.(CArray.ExtS.make) ndef tt in
      let t_norm_f := Util.Array.(CArray.ExtS.make) ndef (Gnorm l (-1)) in
      let mk_let {A : Type} (_envi : A) (function_parameter : lname * mllambda)
        : mllambda -&gt; mllambda :=
        match function_parameter with
        | (id, def) =&gt; fun t =&gt; MLlet id def t
        end in
      let mk_lam_or_let
        (function_parameter : (list lname) * (list (lname * mllambda)) * env)
        : ((Context.binder_annot Names.Name.t) * (option Nativelambda.lambda))
          -&gt; (list lname) * (list (lname * mllambda)) * env :=
        match function_parameter with
        | (params, lets, env) =&gt;
          fun function_parameter =&gt;
            match function_parameter with
            | (id, def) =&gt;
              match push_rel env id with
              | (ln, env') =&gt;
                match def with
                | None =&gt; ((cons ln params), lets, env')
                | Some lam =&gt;
                  (params, (cons (ln, (ml_of_lam env l lam)) lets), env')
                end
              end
            end
        end in
      let ml_of_fix (i : Z) (body : Nativelambda.lambda) : mllambda :=
        match Nativelambda.decompose_Llam_Llet body with
        | (varsi, bodyi) =&gt;
          match
            Util.Array.(CArray.ExtS.fold_left) mk_lam_or_let ([], [], env_n)
              varsi with
          | (paramsi, letsi, envi) =&gt;
            match
              ((Util.Array.(CArray.ExtS.of_list)
                (Util.List.(CList.ExtS.rev) paramsi)),
                (Util.Array.(CArray.ExtS.of_list)
                  (Util.List.(CList.ExtS.rev) letsi))) with
            | (paramsi, letsi) =&gt;
              Util.Array.(CArray.ExtS.set) t_norm_f i (fresh_gnorm l);
              let bodyi := ml_of_lam envi l bodyi in
              Util.Array.(CArray.ExtS.set) t_params i paramsi;
              let bodyi :=
                Util.Array.(CArray.ExtS.fold_right) (mk_let envi) letsi bodyi in
              mkMLlam paramsi bodyi
            end
          end
        end in
      let tnorm := Util.Array.(CArray.ExtS.mapi) ml_of_fix tb in
      match
        ((Util.op_exclamation (env_named env_n)),
          (Util.op_exclamation (env_urel env_n))) with
      | (fvn, fvr) =&gt;
        let fv_params := fv_params env_n in
        let fv_args' :=
          Util.Array.(CArray.ExtS.map) (fun id =&gt; MLlocal id) fv_params in
        let norm_params := Util.Array.(CArray.ExtS.append) fv_params lf in
        let t_norm_f :=
          Util.Array.(CArray.ExtS.mapi)
            (fun i =&gt;
              fun body =&gt;
                push_global_let (Util.Array.(CArray.ExtS.get) t_norm_f i)
                  (mkMLlam norm_params body)) tnorm in
        let norm := fresh_gnormtbl l in
        let norm :=
          push_global_norm norm fv_params
            (Util.Array.(CArray.ExtS.map)
              (fun g =&gt; mkMLapp (MLglobal g) fv_args') t_norm_f) in
        let fv_args := fv_args env fvn fvr in
        match push_rels env ids with
        | (lf, _env) =&gt;
          let lf_args := Util.Array.(CArray.ExtS.map) (fun id =&gt; MLlocal id) lf
            in
          let mk_norm := MLapp (MLglobal norm) fv_args in
          let mkrec {A : Type} (i : Z) (lname : A)
            : A * (array lname) * mllambda :=
            let paramsi := Util.Array.(CArray.ExtS.get) t_params i in
            let reci :=
              MLlocal
                (Util.Array.(CArray.ExtS.get) paramsi
                  (Util.Array.(CArray.ExtS.get) rec_pos i)) in
            let pargsi :=
              Util.Array.(CArray.ExtS.map) (fun id =&gt; MLlocal id) paramsi in
            match Util.Array.(CArray.ExtS.get) inds i with
            | (prefix, ind) =&gt;
              let body :=
                MLif (MLisaccu prefix ind reci)
                  (mkMLapp
                    (MLapp (MLprimitive (Mk_fix rec_pos i)) (mk_type, mk_norm))
                    pargsi)
                  (MLapp (MLglobal (Util.Array.(CArray.ExtS.get) t_norm_f i))
                    (Util.Array.(CArray.ExtS.concat)
                      (cons fv_args (cons lf_args (cons pargsi []))))) in
              (lname, paramsi, body)
            end in
          MLletrec (Util.Array.(CArray.ExtS.mapi) mkrec lf)
            (Util.Array.(CArray.ExtS.get) lf_args start)
        end
      end
    end
  | Lcofix start (ids, tt, tb) =&gt;
    let env_t := empty_env (env_univ env) tt in
    let ml_t := Util.Array.(CArray.ExtS.map) (ml_of_lam env_t l) tt in
    let params_t := fv_params env_t in
    let args_t :=
      fv_args env (Util.op_exclamation (env_named env_t))
        (Util.op_exclamation (env_urel env_t)) in
    let gft := fresh_gfixtype l in
    let gft := push_global_fixtype gft params_t ml_t in
    let mk_type := MLapp (MLglobal gft) args_t in
    let ndef := Util.Array.(CArray.ExtS.length) ids in
    match push_rels (empty_env (env_univ env) tt) ids with
    | (lf, env_n) =&gt;
      let t_params := Util.Array.(CArray.ExtS.make) ndef tt in
      let t_norm_f := Util.Array.(CArray.ExtS.make) ndef (Gnorm l (-1)) in
      let ml_of_fix (i : Z) (body : Nativelambda.lambda) : mllambda :=
        match Nativelambda.decompose_Llam body with
        | (idsi, bodyi) =&gt;
          match push_rels env_n idsi with
          | (paramsi, envi) =&gt;
            Util.Array.(CArray.ExtS.set) t_norm_f i (fresh_gnorm l);
            let bodyi := ml_of_lam envi l bodyi in
            Util.Array.(CArray.ExtS.set) t_params i paramsi;
            mkMLlam paramsi bodyi
          end
        end in
      let tnorm := Util.Array.(CArray.ExtS.mapi) ml_of_fix tb in
      match
        ((Util.op_exclamation (env_named env_n)),
          (Util.op_exclamation (env_urel env_n))) with
      | (fvn, fvr) =&gt;
        let fv_params := fv_params env_n in
        let fv_args' :=
          Util.Array.(CArray.ExtS.map) (fun id =&gt; MLlocal id) fv_params in
        let norm_params := Util.Array.(CArray.ExtS.append) fv_params lf in
        let t_norm_f :=
          Util.Array.(CArray.ExtS.mapi)
            (fun i =&gt;
              fun body =&gt;
                push_global_let (Util.Array.(CArray.ExtS.get) t_norm_f i)
                  (mkMLlam norm_params body)) tnorm in
        let norm := fresh_gnormtbl l in
        let norm :=
          push_global_norm norm fv_params
            (Util.Array.(CArray.ExtS.map)
              (fun g =&gt; mkMLapp (MLglobal g) fv_args') t_norm_f) in
        let fv_args := fv_args env fvn fvr in
        let mk_norm := MLapp (MLglobal norm) fv_args in
        let lnorm := fresh_lname Anonymous in
        let ltype := fresh_lname Anonymous in
        match push_rels env ids with
        | (lf, _env) =&gt;
          let lf_args := Util.Array.(CArray.ExtS.map) (fun id =&gt; MLlocal id) lf
            in
          let upd {A : Type} (i : Z) (_lname : A) (cont : mllambda)
            : mllambda :=
            let paramsi := Util.Array.(CArray.ExtS.get) t_params i in
            let pargsi :=
              Util.Array.(CArray.ExtS.map) (fun id =&gt; MLlocal id) paramsi in
            let uniti := fresh_lname Anonymous in
            let body :=
              MLlam (Util.Array.(CArray.ExtS.append) paramsi (uniti))
                (MLapp (MLglobal (Util.Array.(CArray.ExtS.get) t_norm_f i))
                  (Util.Array.(CArray.ExtS.concat)
                    (cons fv_args (cons lf_args (cons pargsi []))))) in
            MLsequence
              (MLapp (MLprimitive Upd_cofix)
                ((Util.Array.(CArray.ExtS.get) lf_args i), body)) cont in
          let upd :=
            Util.Array.(CArray.ExtS.fold_right_i) upd lf
              (Util.Array.(CArray.ExtS.get) lf_args start) in
          let mk_let (i : Z) (lname : lname) (cont : mllambda) : mllambda :=
            MLlet lname
              (MLapp (MLprimitive (Mk_cofix i))
                ((MLlocal ltype), (MLlocal lnorm))) cont in
          let init := Util.Array.(CArray.ExtS.fold_right_i) mk_let lf upd in
          MLlet lnorm mk_norm (MLlet ltype mk_type init)
        end
      end
    end
  | Lint tag =&gt; MLapp (MLprimitive Mk_int) ((MLint tag))
  | Lmakeblock prefix cn tag args =&gt;
    let args := Util.Array.(CArray.ExtS.map) (ml_of_lam env l) args in
    MLconstruct prefix cn tag args
  | Luint i =&gt; MLapp (MLprimitive Mk_uint) ((MLuint i))
  | Lval v =&gt;
    let i := push_symbol (SymbValue v) in
    get_value_code i
  | Lsort s =&gt;
    let i := push_symbol (SymbSort s) in
    let uarg :=
      match env_univ env with
      | None =&gt; MLarray tt
      | Some u =&gt; MLlocal u
      end in
    let uarg := MLapp (MLprimitive MLmagic) (uarg) in
    MLapp (MLprimitive Mk_sort) ((get_sort_code i), uarg)
  | Lind prefix (ind, u) =&gt;
    let uargs := ml_of_instance (env_univ env) u in
    mkMLapp (MLglobal (Gind prefix ind)) uargs
  | Llazy =&gt; MLglobal (Ginternal &quot;lazy&quot; % string)
  | Lforce =&gt; MLglobal (Ginternal &quot;Lazy.force&quot; % string)
  end.

Definition mllambda_of_lambda
  (univ : option lname) (auxdefs : list global) (l : option Names.Label.t)
  (t : Nativelambda.lambda)
  : (list global) * ((list (Names.Id.t * mllambda)) * (list (Z * mllambda))) *
    mllambda :=
  let env := empty_env univ tt in
  Stdlib.op_colon_eq global_stack auxdefs;
  let ml := ml_of_lam env l t in
  let fv_rel := Util.op_exclamation (env_urel env) in
  let fv_named := Util.op_exclamation (env_named env) in
  let get_lname {A : Type} (function_parameter : A * mllambda) : lname :=
    match function_parameter with
    | (_, t) =&gt;
      match t with
      | MLlocal x =&gt; x
      | _ =&gt; false
      end
    end in
  let params :=
    Util.List.(CList.ExtS.append) (Util.List.(CList.ExtS.map) get_lname fv_rel)
      (Util.List.(CList.ExtS.map) get_lname fv_named) in
  if Util.List.(CList.ExtS.is_empty) params then
    ((Util.op_exclamation global_stack), ([], []), ml)
  else
    ((Util.op_exclamation global_stack), (fv_named, fv_rel),
      (mkMLlam (Util.Array.(CArray.ExtS.of_list) params) ml)).

Definition can_subst (l : mllambda) : bool :=
  match l with
  | MLlocal _ | MLint _ | MLuint _ | MLglobal _ =&gt; true
  | _ =&gt; false
  end.

Definition subst (s : LNmap.t mllambda) (l : mllambda) : mllambda :=
  if LNmap.is_empty s then
    l
  else
    let fix aux (l : mllambda) : mllambda :=
      match l with
      | MLlocal id =&gt; try
      | MLglobal _ | MLprimitive _ | MLint _ | MLuint _ =&gt; l
      | MLlam params body =&gt; MLlam params (aux body)
      | MLletrec defs body =&gt;
        let arec {A B : Type} (function_parameter : A * B * mllambda)
          : A * B * mllambda :=
          match function_parameter with
          | (f, params, body) =&gt; (f, params, (aux body))
          end in
        MLletrec (Util.Array.(CArray.ExtS.map) arec defs) (aux body)
      | MLlet id def body =&gt; MLlet id (aux def) (aux body)
      | MLapp f args =&gt; MLapp (aux f) (Util.Array.(CArray.ExtS.map) aux args)
      | MLif t b1 b2 =&gt; MLif (aux t) (aux b1) (aux b2)
      | MLmatch annot a accu bs =&gt;
        let auxb {A : Type} (function_parameter : A * mllambda)
          : A * mllambda :=
          match function_parameter with
          | (cargs, body) =&gt; (cargs, (aux body))
          end in
        MLmatch annot a (aux accu) (Util.Array.(CArray.ExtS.map) auxb bs)
      | MLconstruct prefix c tag args =&gt;
        MLconstruct prefix c tag (Util.Array.(CArray.ExtS.map) aux args)
      | MLsetref s l1 =&gt; MLsetref s (aux l1)
      | MLsequence l1 l2 =&gt; MLsequence (aux l1) (aux l2)
      | MLarray arr =&gt; MLarray (Util.Array.(CArray.ExtS.map) aux arr)
      | MLisaccu s ind l =&gt; MLisaccu s ind (aux l)
      end in
    aux l.

Definition add_subst (id : LNmap.key) (v : mllambda) (s : LNmap.t mllambda)
  : LNmap.t mllambda :=
  match v with
  | _ =&gt; LNmap.add id v s
  end.

Definition subst_norm
  (params : array LNmap.key) (args : array mllambda) (s : LNmap.t mllambda)
  : LNmap.t mllambda :=
  let len := Util.Array.(CArray.ExtS.length) params in
  andb (Int.equal (Util.Array.(CArray.ExtS.length) args) len)
    (Util.Array.(CArray.ExtS.for_all) can_subst args);
  let s := Stdlib.ref s in
  for;
  Util.op_exclamation s.

Definition subst_case
  (params : array LNmap.key) (args : array mllambda) (s : LNmap.t mllambda)
  : (LNmap.t mllambda) * LNmap.key * mllambda :=
  let len := Util.Array.(CArray.ExtS.length) params in
  andb (OCaml.Stdlib.gt len 0)
    (andb (Int.equal (Util.Array.(CArray.ExtS.length) args) len)
      (let r : Stdlib.ref bool :=
        Stdlib.ref true
      with i : Stdlib.ref Z :=
        Stdlib.ref 0 in
      while;
      Util.op_exclamation r));
  let s := Stdlib.ref s in
  for;
  ((Util.op_exclamation s),
    (Util.Array.(CArray.ExtS.get) params (Util.op_minus len 1)),
    (Util.Array.(CArray.ExtS.get) args (Util.op_minus len 1))).

Definition empty_gdef {A B : Type} : (Int.Map.t A) * (Int.Map.t B) :=
  (Int.Map.empty, Int.Map.empty).

Definition get_norm {A B : Type} (function_parameter : (Int.Map.t A) * B)
  : Int.Map.key -&gt; A :=
  match function_parameter with
  | (gnorm, _) =&gt; fun i =&gt; Int.Map.find i gnorm
  end.

Definition get_case {A B : Type} (function_parameter : A * (Int.Map.t B))
  : Int.Map.key -&gt; B :=
  match function_parameter with
  | (_, gcase) =&gt; fun i =&gt; Int.Map.find i gcase
  end.

Definition all_lam {A : Type} (n : Int.t) (bs : array (A * mllambda)) : bool :=
  let f {B : Type} (function_parameter : B * mllambda) : bool :=
    match function_parameter with
    | (_, l) =&gt;
      match l with
      | MLlam params _ =&gt; Int.equal (Util.Array.(CArray.ExtS.length) params) n
      | _ =&gt; false
      end
    end in
  Util.Array.(CArray.ExtS.for_all) f bs.

Definition commutative_cut
  (annot : Nativevalues.annot_sw) (a : mllambda) (accu : mllambda)
  (bs : array ((list (mllam_pattern (option lname))) * mllambda))
  (args : array mllambda) : mllambda :=
  let mkb {A : Type} (function_parameter : A * mllambda) : A * mllambda :=
    match function_parameter with
    | (c, b) =&gt;
      match b with
      | MLlam params body =&gt;
        (c,
          (Util.Array.(CArray.ExtS.fold_left2)
            (fun body =&gt; fun x =&gt; fun v =&gt; MLlet x v body) body params args))
      | _ =&gt; false
      end
    end in
  MLmatch annot a (mkMLapp accu args) (Util.Array.(CArray.ExtS.map) mkb bs).

Definition optimize
  (gdef :
    (Int.Map.t ((array LNmap.key) * mllambda)) *
      (Int.Map.t ((array LNmap.key) * mllambda))) (l : mllambda) : mllambda :=
  let fix optimize (s : LNmap.t mllambda) (l : mllambda) : mllambda :=
    match l with
    | MLlocal id =&gt; try
    | MLglobal _ | MLprimitive _ | MLint _ | MLuint _ =&gt; l
    | MLlam params body =&gt; MLlam params (optimize s body)
    | MLletrec decls body =&gt;
      let opt_rec {A B : Type} (function_parameter : A * B * mllambda)
        : A * B * mllambda :=
        match function_parameter with
        | (f, params, body) =&gt; (f, params, (optimize s body))
        end in
      MLletrec (Util.Array.(CArray.ExtS.map) opt_rec decls) (optimize s body)
    | MLlet id def body =&gt;
      let def := optimize s def in
      if can_subst def then
        optimize (add_subst id def s) body
      else
        MLlet id def (optimize s body)
    | MLapp f args =&gt;
      let args := Util.Array.(CArray.ExtS.map) (optimize s) args in
      match f with
      | MLglobal (Gnorm _ i) =&gt; try
      | MLglobal (Gcase _ i) =&gt; try
      | _ =&gt;
        let f := optimize s f in
        match f with
        | MLmatch annot a accu bs =&gt;
          if all_lam (Util.Array.(CArray.ExtS.length) args) bs then
            commutative_cut annot a accu bs args
          else
            MLapp f args
        | _ =&gt; MLapp f args
        end
      end
    | MLif t b1 b2 =&gt;
      let t := optimize s t in
      let b1 := optimize s b1 in
      let b2 := optimize s b2 in
      match (t, b2) with
      | (_, _) =&gt; MLif t b1 b2
      end
    | MLmatch annot a accu bs =&gt;
      let opt_b {A : Type} (function_parameter : A * mllambda) : A * mllambda :=
        match function_parameter with
        | (cargs, body) =&gt; (cargs, (optimize s body))
        end in
      MLmatch annot (optimize s a) (subst s accu)
        (Util.Array.(CArray.ExtS.map) opt_b bs)
    | MLconstruct prefix c tag args =&gt;
      MLconstruct prefix c tag (Util.Array.(CArray.ExtS.map) (optimize s) args)
    | MLsetref r l =&gt; MLsetref r (optimize s l)
    | MLsequence l1 l2 =&gt; MLsequence (optimize s l1) (optimize s l2)
    | MLarray arr =&gt; MLarray (Util.Array.(CArray.ExtS.map) (optimize s) arr)
    | MLisaccu pf ind l =&gt; MLisaccu pf ind (optimize s l)
    end in
  optimize LNmap.empty l.

Definition optimize_stk (stk : list global) : list global :=
  let add_global
    (gdef :
    (Int.Map.t ((array lname) * mllambda)) *
      (Int.Map.t ((array lname) * mllambda))) (g : global)
    : (Int.Map.t ((array lname) * mllambda)) *
      (Int.Map.t ((array lname) * mllambda)) :=
    match g with
    | Glet (Gnorm _ i) body =&gt;
      match gdef with
      | (gnorm, gcase) =&gt; ((Int.Map.add i (decompose_MLlam body) gnorm), gcase)
      end
    | Gletcase (Gcase _ i) params annot a accu bs =&gt;
      match gdef with
      | (gnorm, gcase) =&gt;
        (gnorm, (Int.Map.add i (params, (MLmatch annot a accu bs)) gcase))
      end
    | Gletcase _ _ _ _ _ _ =&gt; false
    | _ =&gt; gdef
    end in
  let gdef := Util.List.(CList.ExtS.fold_left) add_global empty_gdef stk in
  let optimize_global (g : global) : global :=
    match g with
    | Glet (Gconstant prefix c) body =&gt;
      Glet (Gconstant prefix c) (optimize gdef body)
    | _ =&gt; g
    end in
  Util.List.(CList.ExtS.map) optimize_global stk.

Definition string_of_id (s : Names.Id.t) : string :=
  Unicode.ascii_of_ident (Names.Id.to_string s).

Definition string_of_label (l : Names.Label.t) : string :=
  string_of_id (Names.Label.to_id l).

Definition string_of_dirpath (function_parameter : list Names.Id.t) : string :=
  match function_parameter with
  | [] =&gt; &quot;_&quot; % string
  | sl =&gt;
    Util.String.(CString.ExtS.concat) &quot;_&quot; % string
      (Util.List.(CList.ExtS.rev_map) string_of_id sl)
  end.

Definition string_of_dirpath (s : list Names.Id.t) : string :=
  String.append &quot;N&quot; % string (string_of_dirpath s).

Definition mod_uid_of_dirpath (dir : Names.DirPath.t) : string :=
  string_of_dirpath (Names.DirPath.repr dir).

Definition link_info_of_dirpath (dir : Names.DirPath.t) : Environ.link_info :=
  Linked (String.append (mod_uid_of_dirpath dir) &quot;.&quot; % string).

Definition string_of_name (x : Names.name) : string :=
  match x with
  | Anonymous =&gt; &quot;anonymous&quot; % string
  | Name id =&gt; string_of_id id
  end.

Definition string_of_label_def (l : option Names.Label.t) : string :=
  match l with
  | None =&gt; &quot;&quot; % string
  | Some l =&gt; string_of_label l
  end.

Fixpoint list_of_mp (acc : list string) (function_parameter : Names.module_path)
  : list string :=
  match function_parameter with
  | MPdot mp l =&gt; list_of_mp (cons (string_of_label l) acc) mp
  | MPfile dp =&gt;
    let dp := Names.DirPath.repr dp in
    cons (string_of_dirpath dp) acc
  | MPbound mbid =&gt;
    cons (String.append &quot;X&quot; % string (string_of_id (Names.MBId.to_id mbid))) acc
  end.

Definition list_of_mp (mp : Names.module_path) : list string := list_of_mp [] mp.

Definition string_of_kn (kn : Names.KerName.t) : string :=
  match Names.KerName.repr kn with
  | (mp, l) =&gt;
    let mp := list_of_mp mp in
    String.append (Util.String.(CString.ExtS.concat) &quot;_&quot; % string mp)
      (String.append &quot;_&quot; % string (string_of_label l))
  end.

Definition string_of_con (c : Names.Constant.t) : string :=
  string_of_kn (Names.Constant.user c).

Definition string_of_mind (mind : Names.MutInd.t) : string :=
  string_of_kn (Names.MutInd.user mind).

Definition string_of_ind (function_parameter : Names.MutInd.t * Z) : string :=
  match function_parameter with
  | (mind, i) =&gt;
    String.append (string_of_kn (Names.MutInd.user mind))
      (String.append &quot;_&quot; % string (OCaml.Stdlib.string_of_int i))
  end.

Definition string_of_gname (g : gname) : string :=
  match g with
  | Gind prefix (mind, i) =&gt;
    Stdlib.Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
          (CamlinternalFormatBasics.String_literal &quot;indaccu_&quot; % string
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
                (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                  CamlinternalFormatBasics.No_padding
                  CamlinternalFormatBasics.No_precision
                  CamlinternalFormatBasics.End_of_format)))))
        &quot;%sindaccu_%s_%i&quot; % string) prefix (string_of_mind mind) i
  | Gconstant prefix c =&gt;
    Stdlib.Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
          (CamlinternalFormatBasics.String_literal &quot;const_&quot; % string
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              CamlinternalFormatBasics.End_of_format))) &quot;%sconst_%s&quot; % string)
      prefix (string_of_con c)
  | Gproj prefix (mind, n) i =&gt;
    Stdlib.Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
          (CamlinternalFormatBasics.String_literal &quot;proj_&quot; % string
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
                (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                  CamlinternalFormatBasics.No_padding
                  CamlinternalFormatBasics.No_precision
                  (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
                    (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                      CamlinternalFormatBasics.No_padding
                      CamlinternalFormatBasics.No_precision
                      CamlinternalFormatBasics.End_of_format)))))))
        &quot;%sproj_%s_%i_%i&quot; % string) prefix (string_of_mind mind) n i
  | Gcase l i =&gt;
    Stdlib.Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;case_&quot; % string
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
              (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                CamlinternalFormatBasics.No_padding
                CamlinternalFormatBasics.No_precision
                CamlinternalFormatBasics.End_of_format)))) &quot;case_%s_%i&quot; % string)
      (string_of_label_def l) i
  | Gpred l i =&gt;
    Stdlib.Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;pred_&quot; % string
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
              (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                CamlinternalFormatBasics.No_padding
                CamlinternalFormatBasics.No_precision
                CamlinternalFormatBasics.End_of_format)))) &quot;pred_%s_%i&quot; % string)
      (string_of_label_def l) i
  | Gfixtype l i =&gt;
    Stdlib.Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;fixtype_&quot; % string
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
              (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                CamlinternalFormatBasics.No_padding
                CamlinternalFormatBasics.No_precision
                CamlinternalFormatBasics.End_of_format))))
        &quot;fixtype_%s_%i&quot; % string) (string_of_label_def l) i
  | Gnorm l i =&gt;
    Stdlib.Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;norm_&quot; % string
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
              (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                CamlinternalFormatBasics.No_padding
                CamlinternalFormatBasics.No_precision
                CamlinternalFormatBasics.End_of_format)))) &quot;norm_%s_%i&quot; % string)
      (string_of_label_def l) i
  | Ginternal s =&gt;
    Stdlib.Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
          CamlinternalFormatBasics.End_of_format) &quot;%s&quot; % string) s
  | Gnormtbl l i =&gt;
    Stdlib.Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;normtbl_&quot; % string
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
              (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                CamlinternalFormatBasics.No_padding
                CamlinternalFormatBasics.No_precision
                CamlinternalFormatBasics.End_of_format))))
        &quot;normtbl_%s_%i&quot; % string) (string_of_label_def l) i
  | Grel i =&gt;
    Stdlib.Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;rel_&quot; % string
          (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
            CamlinternalFormatBasics.No_padding
            CamlinternalFormatBasics.No_precision
            CamlinternalFormatBasics.End_of_format)) &quot;rel_%i&quot; % string) i
  | Gnamed id =&gt;
    Stdlib.Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;named_&quot; % string
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            CamlinternalFormatBasics.End_of_format)) &quot;named_%s&quot; % string)
      (string_of_id id)
  end.

Definition pp_gname (fmt : Stdlib.Format.formatter) (g : gname) : unit :=
  Stdlib.Format.fprintf fmt
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
        CamlinternalFormatBasics.End_of_format) &quot;%s&quot; % string)
    (string_of_gname g).

Definition pp_lname (fmt : Stdlib.Format.formatter) (ln : lname) : unit :=
  Stdlib.Format.fprintf fmt
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.String_literal &quot;x_&quot; % string
        (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
          (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
            (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
              CamlinternalFormatBasics.No_padding
              CamlinternalFormatBasics.No_precision
              CamlinternalFormatBasics.End_of_format)))) &quot;x_%s_%i&quot; % string)
    (string_of_name (lname ln)) (luid ln).

Definition pp_ldecls (fmt : Stdlib.Format.formatter) (ids : array lname)
  : unit :=
  let len := Util.Array.(CArray.ExtS.length) ids in
  for.

Definition string_of_construct
  (prefix : string) (constant : bool) (ind : Names.MutInd.t * Z) (tag : Z)
  : string :=
  let base :=
    if constant then
      &quot;Int&quot; % string
    else
      &quot;Construct&quot; % string in
  Stdlib.Format.sprintf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
        (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
          (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
                (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                  CamlinternalFormatBasics.No_padding
                  CamlinternalFormatBasics.No_precision
                  CamlinternalFormatBasics.End_of_format))))))
      &quot;%s%s_%s_%i&quot; % string) prefix base (string_of_ind ind) tag.

Definition string_of_accu_construct (prefix : string) (ind : Names.MutInd.t * Z)
  : string :=
  Stdlib.Format.sprintf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
        (CamlinternalFormatBasics.String_literal &quot;Accu_&quot; % string
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            CamlinternalFormatBasics.End_of_format))) &quot;%sAccu_%s&quot; % string)
    prefix (string_of_ind ind).

Definition pp_int (fmt : Stdlib.Format.formatter) (i : Z) : unit :=
  if OCaml.Stdlib.lt i 0 then
    Stdlib.Format.fprintf fmt
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.Char_literal &quot;(&quot; % char
          (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
            CamlinternalFormatBasics.No_padding
            CamlinternalFormatBasics.No_precision
            (CamlinternalFormatBasics.Char_literal &quot;)&quot; % char
              CamlinternalFormatBasics.End_of_format))) &quot;(%i)&quot; % string) i
  else
    Stdlib.Format.fprintf fmt
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
          CamlinternalFormatBasics.No_padding
          CamlinternalFormatBasics.No_precision
          CamlinternalFormatBasics.End_of_format) &quot;%i&quot; % string) i.

Definition pp_mllam (fmt : Stdlib.Format.formatter) (l : mllambda) : unit :=
  let fix pp_mllam (fmt : Stdlib.Format.formatter) (l : mllambda) : unit :=
    match l with
    | MLlocal ln =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Formatting_lit
                CamlinternalFormatBasics.Close_box
                CamlinternalFormatBasics.End_of_format))) &quot;@[%a@]&quot; % string)
        pp_lname ln
    | MLglobal g =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Formatting_lit
                CamlinternalFormatBasics.Close_box
                CamlinternalFormatBasics.End_of_format))) &quot;@[%a@]&quot; % string)
        pp_gname g
    | MLprimitive p =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Formatting_lit
                CamlinternalFormatBasics.Close_box
                CamlinternalFormatBasics.End_of_format))) &quot;@[%a@]&quot; % string)
        pp_primitive p
    | MLlam ids body =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
            (CamlinternalFormatBasics.String_literal &quot;(fun&quot; % string
              (CamlinternalFormatBasics.Alpha
                (CamlinternalFormatBasics.Formatting_lit
                  (CamlinternalFormatBasics.Break &quot;@ &quot; % string 1 0)
                  (CamlinternalFormatBasics.String_literal &quot;-&gt;&quot; % string
                    (CamlinternalFormatBasics.Formatting_lit
                      CamlinternalFormatBasics.Force_newline
                      (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
                        (CamlinternalFormatBasics.Alpha
                          (CamlinternalFormatBasics.Char_literal &quot;)&quot; % char
                            (CamlinternalFormatBasics.Formatting_lit
                              CamlinternalFormatBasics.Close_box
                              CamlinternalFormatBasics.End_of_format))))))))))
          &quot;@[(fun%a@ -&gt;@
 %a)@]&quot; % string) pp_ldecls ids pp_mllam body
    | MLletrec defs body =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Formatting_lit
                (CamlinternalFormatBasics.Break &quot;@ &quot; % string 1 0)
                (CamlinternalFormatBasics.String_literal &quot;in&quot; % string
                  (CamlinternalFormatBasics.Formatting_lit
                    CamlinternalFormatBasics.Force_newline
                    (CamlinternalFormatBasics.Alpha
                      (CamlinternalFormatBasics.Formatting_lit
                        CamlinternalFormatBasics.Close_box
                        CamlinternalFormatBasics.End_of_format)))))))
          &quot;@[%a@ in@
%a@]&quot; % string) pp_letrec defs pp_mllam body
    | MLlet id def body =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
            (CamlinternalFormatBasics.String_literal &quot;(let&quot; % string
              (CamlinternalFormatBasics.Formatting_lit
                (CamlinternalFormatBasics.Break &quot;@ &quot; % string 1 0)
                (CamlinternalFormatBasics.Alpha
                  (CamlinternalFormatBasics.Formatting_lit
                    (CamlinternalFormatBasics.Break &quot;@ &quot; % string 1 0)
                    (CamlinternalFormatBasics.Char_literal &quot;=&quot; % char
                      (CamlinternalFormatBasics.Formatting_lit
                        CamlinternalFormatBasics.Force_newline
                        (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
                          (CamlinternalFormatBasics.Alpha
                            (CamlinternalFormatBasics.Formatting_lit
                              (CamlinternalFormatBasics.Break &quot;@ &quot; % string 1 0)
                              (CamlinternalFormatBasics.String_literal
                                &quot;in&quot; % string
                                (CamlinternalFormatBasics.Formatting_lit
                                  CamlinternalFormatBasics.Force_newline
                                  (CamlinternalFormatBasics.Alpha
                                    (CamlinternalFormatBasics.Char_literal
                                      &quot;)&quot; % char
                                      (CamlinternalFormatBasics.Formatting_lit
                                        CamlinternalFormatBasics.Close_box
                                        CamlinternalFormatBasics.End_of_format)))))))))))))))
          &quot;@[(let@ %a@ =@
 %a@ in@
%a)@]&quot; % string) pp_lname id pp_mllam def
        pp_mllam body
    | MLapp f args =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Formatting_lit
                (CamlinternalFormatBasics.Break &quot;@ &quot; % string 1 0)
                (CamlinternalFormatBasics.Alpha
                  (CamlinternalFormatBasics.Formatting_lit
                    CamlinternalFormatBasics.Close_box
                    CamlinternalFormatBasics.End_of_format)))))
          &quot;@[%a@ %a@]&quot; % string) pp_mllam f (pp_args true) args
    | MLif t l1 l2 =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
            (CamlinternalFormatBasics.String_literal &quot;(if &quot; % string
              (CamlinternalFormatBasics.Alpha
                (CamlinternalFormatBasics.String_literal &quot; then&quot; % string
                  (CamlinternalFormatBasics.Formatting_lit
                    CamlinternalFormatBasics.Force_newline
                    (CamlinternalFormatBasics.String_literal &quot;  &quot; % string
                      (CamlinternalFormatBasics.Alpha
                        (CamlinternalFormatBasics.Formatting_lit
                          CamlinternalFormatBasics.Force_newline
                          (CamlinternalFormatBasics.String_literal
                            &quot;else&quot; % string
                            (CamlinternalFormatBasics.Formatting_lit
                              CamlinternalFormatBasics.Force_newline
                              (CamlinternalFormatBasics.String_literal
                                &quot;  &quot; % string
                                (CamlinternalFormatBasics.Alpha
                                  (CamlinternalFormatBasics.Char_literal
                                    &quot;)&quot; % char
                                    (CamlinternalFormatBasics.Formatting_lit
                                      CamlinternalFormatBasics.Close_box
                                      CamlinternalFormatBasics.End_of_format))))))))))))))
          &quot;@[(if %a then@
  %a@
else@
  %a)@]&quot; % string) pp_mllam t pp_mllam l1
        pp_mllam l2
    | MLmatch annot c accu_br br =&gt;
      let ind := asw_ind annot in
      let prefix := asw_prefix annot in
      let accu := string_of_accu_construct prefix ind in
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
            (CamlinternalFormatBasics.String_literal
              &quot;begin match Obj.magic (&quot; % string
              (CamlinternalFormatBasics.Alpha
                (CamlinternalFormatBasics.String_literal &quot;) with&quot; % string
                  (CamlinternalFormatBasics.Formatting_lit
                    CamlinternalFormatBasics.Force_newline
                    (CamlinternalFormatBasics.String_literal &quot;| &quot; % string
                      (CamlinternalFormatBasics.String
                        CamlinternalFormatBasics.No_padding
                        (CamlinternalFormatBasics.String_literal
                          &quot; _ -&gt;&quot; % string
                          (CamlinternalFormatBasics.Formatting_lit
                            CamlinternalFormatBasics.Force_newline
                            (CamlinternalFormatBasics.String_literal
                              &quot;  &quot; % string
                              (CamlinternalFormatBasics.Alpha
                                (CamlinternalFormatBasics.Formatting_lit
                                  CamlinternalFormatBasics.Force_newline
                                  (CamlinternalFormatBasics.Alpha
                                    (CamlinternalFormatBasics.String_literal
                                      &quot;end&quot; % string
                                      (CamlinternalFormatBasics.Formatting_lit
                                        CamlinternalFormatBasics.Close_box
                                        CamlinternalFormatBasics.End_of_format)))))))))))))))
          &quot;@[begin match Obj.magic (%a) with@
| %s _ -&gt;@
  %a@
%aend@]&quot; % string)
        pp_mllam c accu pp_mllam accu_br (pp_branches prefix ind) br
    | MLconstruct prefix ind tag args =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
            (CamlinternalFormatBasics.String_literal &quot;(Obj.magic (&quot; % string
              (CamlinternalFormatBasics.String
                CamlinternalFormatBasics.No_padding
                (CamlinternalFormatBasics.Alpha
                  (CamlinternalFormatBasics.String_literal
                    &quot;) : Nativevalues.t)&quot; % string
                    (CamlinternalFormatBasics.Formatting_lit
                      CamlinternalFormatBasics.Close_box
                      CamlinternalFormatBasics.End_of_format))))))
          &quot;@[(Obj.magic (%s%a) : Nativevalues.t)@]&quot; % string)
        (string_of_construct prefix false ind tag) pp_cargs args
    | MLint i =&gt; pp_int fmt i
    | MLuint i =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Char_literal &quot;(&quot; % char
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.Char_literal &quot;)&quot; % char
                CamlinternalFormatBasics.End_of_format))) &quot;(%s)&quot; % string)
        (Uint63.compile i)
    | MLsetref s body =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.Formatting_lit
                (CamlinternalFormatBasics.Break &quot;@ &quot; % string 1 0)
                (CamlinternalFormatBasics.String_literal &quot;:=&quot; % string
                  (CamlinternalFormatBasics.Formatting_lit
                    CamlinternalFormatBasics.Force_newline
                    (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
                      (CamlinternalFormatBasics.Alpha
                        (CamlinternalFormatBasics.Formatting_lit
                          CamlinternalFormatBasics.Close_box
                          CamlinternalFormatBasics.End_of_format))))))))
          &quot;@[%s@ :=@
 %a@]&quot; % string) s pp_mllam body
    | MLsequence l1 l2 =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Char_literal &quot;;&quot; % char
                (CamlinternalFormatBasics.Formatting_lit
                  CamlinternalFormatBasics.Force_newline
                  (CamlinternalFormatBasics.Alpha
                    (CamlinternalFormatBasics.Formatting_lit
                      CamlinternalFormatBasics.Close_box
                      CamlinternalFormatBasics.End_of_format))))))
          &quot;@[%a;@
%a@]&quot; % string) pp_mllam l1 pp_mllam l2
    | MLarray arr =&gt;
      let len := Util.Array.(CArray.ExtS.length) arr in
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
            (CamlinternalFormatBasics.String_literal &quot;[|&quot; % string
              CamlinternalFormatBasics.End_of_format)) &quot;@[[|&quot; % string);
      if OCaml.Stdlib.lt 0 len then
        for;
        pp_mllam fmt (Util.Array.(CArray.ExtS.get) arr (Util.op_minus len 1))
      else
        tt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;|]&quot; % string
            (CamlinternalFormatBasics.Formatting_lit
              CamlinternalFormatBasics.Close_box
              CamlinternalFormatBasics.End_of_format)) &quot;|]@]&quot; % string)
    | MLisaccu prefix ind c =&gt;
      let accu := string_of_accu_construct prefix ind in
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
            (CamlinternalFormatBasics.String_literal
              &quot;begin match Obj.magic (&quot; % string
              (CamlinternalFormatBasics.Alpha
                (CamlinternalFormatBasics.String_literal &quot;) with&quot; % string
                  (CamlinternalFormatBasics.Formatting_lit
                    CamlinternalFormatBasics.Force_newline
                    (CamlinternalFormatBasics.String_literal &quot;| &quot; % string
                      (CamlinternalFormatBasics.String
                        CamlinternalFormatBasics.No_padding
                        (CamlinternalFormatBasics.String_literal
                          &quot; _ -&gt;&quot; % string
                          (CamlinternalFormatBasics.Formatting_lit
                            CamlinternalFormatBasics.Force_newline
                            (CamlinternalFormatBasics.String_literal
                              &quot;  true&quot; % string
                              (CamlinternalFormatBasics.Formatting_lit
                                CamlinternalFormatBasics.Force_newline
                                (CamlinternalFormatBasics.String_literal
                                  &quot;| _ -&gt;&quot; % string
                                  (CamlinternalFormatBasics.Formatting_lit
                                    CamlinternalFormatBasics.Force_newline
                                    (CamlinternalFormatBasics.String_literal
                                      &quot;  false&quot; % string
                                      (CamlinternalFormatBasics.Formatting_lit
                                        CamlinternalFormatBasics.Force_newline
                                        (CamlinternalFormatBasics.String_literal
                                          &quot;end&quot; % string
                                          (CamlinternalFormatBasics.Formatting_lit
                                            CamlinternalFormatBasics.Close_box
                                            CamlinternalFormatBasics.End_of_format)))))))))))))))))
          &quot;@[begin match Obj.magic (%a) with@
| %s _ -&gt;@
  true@
| _ -&gt;@
  false@
end@]&quot;
            % string) pp_mllam c accu
    end
  with pp_letrec
    (fmt : Stdlib.Format.formatter) (defs :
    array (lname * (array lname) * mllambda)) : unit :=
    let len := Util.Array.(CArray.ExtS.length) defs in
    let pp_one_rec (function_parameter : lname * (array lname) * mllambda)
      : unit :=
      match function_parameter with
      | (fn, argsn, body) =&gt;
        Stdlib.Format.fprintf fmt
          (CamlinternalFormatBasics.Format
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Alpha
                (CamlinternalFormatBasics.String_literal &quot; =&quot; % string
                  (CamlinternalFormatBasics.Formatting_lit
                    CamlinternalFormatBasics.Force_newline
                    (CamlinternalFormatBasics.String_literal &quot;  &quot; % string
                      (CamlinternalFormatBasics.Alpha
                        CamlinternalFormatBasics.End_of_format))))))
            &quot;%a%a =@
  %a&quot; % string) pp_lname fn pp_ldecls argsn pp_mllam body
      end in
    Stdlib.Format.fprintf fmt
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.Formatting_gen
          (CamlinternalFormatBasics.Open_box
            (CamlinternalFormatBasics.Format
              CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
          (CamlinternalFormatBasics.String_literal &quot;let rec &quot; % string
            CamlinternalFormatBasics.End_of_format)) &quot;@[let rec &quot; % string);
    pp_one_rec (Util.Array.(CArray.ExtS.get) defs 0);
    for
  with pp_blam (fmt : Stdlib.Format.formatter) (l : mllambda) : unit :=
    match l with
    |
      MLprimitive (Mk_prod | Mk_sort) | MLlam _ _ | MLletrec _ _ | MLlet _ _ _ |
        MLapp _ _ | MLif _ _ _ =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Char_literal &quot;(&quot; % char
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Char_literal &quot;)&quot; % char
                CamlinternalFormatBasics.End_of_format))) &quot;(%a)&quot; % string)
        pp_mllam l
    | _ =&gt; pp_mllam fmt l
    end
  with pp_args
    (sep : bool) (fmt : Stdlib.Format.formatter) (args : array mllambda)
    : unit :=
    let sep :=
      if sep then
        &quot; &quot; % string
      else
        &quot;,&quot; % string in
    let len := Util.Array.(CArray.ExtS.length) args in
    if OCaml.Stdlib.gt len 0 then
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Alpha CamlinternalFormatBasics.End_of_format)
          &quot;%a&quot; % string) pp_blam (Util.Array.(CArray.ExtS.get) args 0);
      for
    else
      tt
  with pp_cargs (fmt : Stdlib.Format.formatter) (args : array mllambda)
    : unit :=
    let len := Util.Array.(CArray.ExtS.length) args in
    match len with
    | 0 =&gt; tt
    | 1 =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
            (CamlinternalFormatBasics.Alpha
              CamlinternalFormatBasics.End_of_format)) &quot; %a&quot; % string) pp_blam
        (Util.Array.(CArray.ExtS.get) args 0)
    | _ =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Char_literal &quot;(&quot; % char
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Char_literal &quot;)&quot; % char
                CamlinternalFormatBasics.End_of_format))) &quot;(%a)&quot; % string)
        (pp_args false) args
    end
  with pp_cparam (fmt : Stdlib.Format.formatter) (param : option lname)
    : unit :=
    match param with
    | Some l =&gt; pp_mllam fmt (MLlocal l)
    | None =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
            CamlinternalFormatBasics.End_of_format) &quot;_&quot; % string)
    end
  with pp_cparams
    (fmt : Stdlib.Format.formatter) (params : array (option lname)) : unit :=
    let len := Util.Array.(CArray.ExtS.length) params in
    match len with
    | 0 =&gt; tt
    | 1 =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
            (CamlinternalFormatBasics.Alpha
              CamlinternalFormatBasics.End_of_format)) &quot; %a&quot; % string) pp_cparam
        (Util.Array.(CArray.ExtS.get) params 0)
    | _ =&gt;
      let aux (fmt : Stdlib.Format.formatter) (params : array (option lname))
        : unit :=
        Stdlib.Format.fprintf fmt
          (CamlinternalFormatBasics.Format
            (CamlinternalFormatBasics.Alpha
              CamlinternalFormatBasics.End_of_format) &quot;%a&quot; % string) pp_cparam
          (Util.Array.(CArray.ExtS.get) params 0);
        for in
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Char_literal &quot;(&quot; % char
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Char_literal &quot;)&quot; % char
                CamlinternalFormatBasics.End_of_format))) &quot;(%a)&quot; % string) aux
        params
    end
  with pp_branches
    (prefix : string) (ind : Names.inductive) (fmt : Stdlib.Format.formatter)
    (bs : mllam_branches) : unit :=
    let pp_branch
      (function_parameter : (list (mllam_pattern (option lname))) * mllambda)
      : unit :=
      match function_parameter with
      | (cargs, body) =&gt;
        let pp_pat
          (fmt : Stdlib.Format.formatter) (function_parameter :
          mllam_pattern (option lname)) : unit :=
          match function_parameter with
          | ConstPattern i =&gt;
            Stdlib.Format.fprintf fmt
              (CamlinternalFormatBasics.Format
                (CamlinternalFormatBasics.String_literal &quot;| &quot; % string
                  (CamlinternalFormatBasics.String
                    CamlinternalFormatBasics.No_padding
                    (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
                      CamlinternalFormatBasics.End_of_format))) &quot;| %s &quot; % string)
              (string_of_construct prefix true ind i)
          | NonConstPattern tag args =&gt;
            Stdlib.Format.fprintf fmt
              (CamlinternalFormatBasics.Format
                (CamlinternalFormatBasics.String_literal &quot;| &quot; % string
                  (CamlinternalFormatBasics.String
                    CamlinternalFormatBasics.No_padding
                    (CamlinternalFormatBasics.Alpha
                      (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
                        CamlinternalFormatBasics.End_of_format))))
                &quot;| %s%a &quot; % string) (string_of_construct prefix false ind tag)
              pp_cparams args
          end in
        let fix pp_pats
          (fmt : Stdlib.Format.formatter) (pats :
          list (mllam_pattern (option lname))) : unit :=
          match pats with
          | [] =&gt; tt
          | cons pat pats =&gt;
            Stdlib.Format.fprintf fmt
              (CamlinternalFormatBasics.Format
                (CamlinternalFormatBasics.Alpha
                  (CamlinternalFormatBasics.Alpha
                    CamlinternalFormatBasics.End_of_format)) &quot;%a%a&quot; % string)
              pp_pat pat pp_pats pats
          end in
        Stdlib.Format.fprintf fmt
          (CamlinternalFormatBasics.Format
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.String_literal &quot; -&gt;&quot; % string
                (CamlinternalFormatBasics.Formatting_lit
                  CamlinternalFormatBasics.Force_newline
                  (CamlinternalFormatBasics.String_literal &quot;  &quot; % string
                    (CamlinternalFormatBasics.Alpha
                      (CamlinternalFormatBasics.Formatting_lit
                        CamlinternalFormatBasics.Force_newline
                        CamlinternalFormatBasics.End_of_format))))))
            &quot;%a -&gt;@
  %a@
&quot; % string) pp_pats cargs pp_mllam body
      end in
    Util.Array.(CArray.ExtS.iter) pp_branch bs
  with pp_primitive
    (fmt : Stdlib.Format.formatter) (function_parameter : primitive) : unit :=
    match function_parameter with
    | Mk_prod =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_prod_accu&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;mk_prod_accu&quot; % string)
    | Mk_sort =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_sort_accu&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;mk_sort_accu&quot; % string)
    | Mk_ind =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_ind_accu&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;mk_ind_accu&quot; % string)
    | Mk_const =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_constant_accu&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;mk_constant_accu&quot; % string)
    | Mk_sw =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_sw_accu&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;mk_sw_accu&quot; % string)
    | Mk_fix rec_pos start =&gt;
      let pp_rec_pos (fmt : Stdlib.Format.formatter) (rec_pos : array Z)
        : unit :=
        Stdlib.Format.fprintf fmt
          (CamlinternalFormatBasics.Format
            (CamlinternalFormatBasics.Formatting_gen
              (CamlinternalFormatBasics.Open_box
                (CamlinternalFormatBasics.Format
                  CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
              (CamlinternalFormatBasics.String_literal &quot;[| &quot; % string
                (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                  CamlinternalFormatBasics.No_padding
                  CamlinternalFormatBasics.No_precision
                  CamlinternalFormatBasics.End_of_format))) &quot;@[[| %i&quot; % string)
          (Util.Array.(CArray.ExtS.get) rec_pos 0);
        for;
        Stdlib.Format.fprintf fmt
          (CamlinternalFormatBasics.Format
            (CamlinternalFormatBasics.String_literal &quot; |]&quot; % string
              (CamlinternalFormatBasics.Formatting_lit
                CamlinternalFormatBasics.Close_box
                CamlinternalFormatBasics.End_of_format)) &quot; |]@]&quot; % string) in
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_fix_accu &quot; % string
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
                (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                  CamlinternalFormatBasics.No_padding
                  CamlinternalFormatBasics.No_precision
                  CamlinternalFormatBasics.End_of_format))))
          &quot;mk_fix_accu %a %i&quot; % string) pp_rec_pos rec_pos start
    | Mk_cofix start =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_cofix_accu &quot; % string
            (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
              CamlinternalFormatBasics.No_padding
              CamlinternalFormatBasics.No_precision
              CamlinternalFormatBasics.End_of_format))
          &quot;mk_cofix_accu %i&quot; % string) start
    | Mk_rel i =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_rel_accu &quot; % string
            (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
              CamlinternalFormatBasics.No_padding
              CamlinternalFormatBasics.No_precision
              CamlinternalFormatBasics.End_of_format)) &quot;mk_rel_accu %i&quot; % string)
        i
    | Mk_var id =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal
            &quot;mk_var_accu (Names.Id.of_string &quot;&quot;&quot; % string
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.String_literal &quot;&quot;&quot;)&quot; % string
                CamlinternalFormatBasics.End_of_format)))
          &quot;mk_var_accu (Names.Id.of_string &quot;&quot;%s&quot;&quot;)&quot; % string) (string_of_id id)
    | Mk_proj =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_proj_accu&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;mk_proj_accu&quot; % string)
    | Is_int =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;is_int&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;is_int&quot; % string)
    | Cast_accu =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;cast_accu&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;cast_accu&quot; % string)
    | Upd_cofix =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;upd_cofix&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;upd_cofix&quot; % string)
    | Force_cofix =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;force_cofix&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;force_cofix&quot; % string)
    | Mk_uint =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_uint&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;mk_uint&quot; % string)
    | Mk_int =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_int&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;mk_int&quot; % string)
    | Mk_bool =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_bool&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;mk_bool&quot; % string)
    | Val_to_int =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;val_to_int&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;val_to_int&quot; % string)
    | Mk_meta =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_meta_accu&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;mk_meta_accu&quot; % string)
    | Mk_evar =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_evar_accu&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;mk_evar_accu&quot; % string)
    | MLand =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;(&amp;&amp;)&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;(&amp;&amp;)&quot; % string)
    | MLle =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;(&lt;=)&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;(&lt;=)&quot; % string)
    | MLlt =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;(&lt;)&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;(&lt;)&quot; % string)
    | MLinteq =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;(==)&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;(==)&quot; % string)
    | MLlsl =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;(lsl)&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;(lsl)&quot; % string)
    | MLlsr =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;(lsr)&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;(lsr)&quot; % string)
    | MLland =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;(land)&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;(land)&quot; % string)
    | MLlor =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;(lor)&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;(lor)&quot; % string)
    | MLlxor =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;(lxor)&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;(lxor)&quot; % string)
    | MLadd =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;(+)&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;(+)&quot; % string)
    | MLsub =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;(-)&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;(-)&quot; % string)
    | MLmul =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;( * )&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;( * )&quot; % string)
    | MLmagic =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;Obj.magic&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;Obj.magic&quot; % string)
    | MLarrayget =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;Array.get&quot; % string
            CamlinternalFormatBasics.End_of_format) &quot;Array.get&quot; % string)
    | Mk_empty_instance =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal
            &quot;Univ.Instance.empty&quot; % string
            CamlinternalFormatBasics.End_of_format)
          &quot;Univ.Instance.empty&quot; % string)
    | Coq_primitive op None =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;no_check_&quot; % string
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              CamlinternalFormatBasics.End_of_format)) &quot;no_check_%s&quot; % string)
        (CPrimitives.to_string op)
    | Coq_primitive op (Some (prefix, (c, _))) =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
              (CamlinternalFormatBasics.Alpha
                CamlinternalFormatBasics.End_of_format))) &quot;%s %a&quot; % string)
        (CPrimitives.to_string op) pp_mllam (MLglobal (Gconstant prefix c))
    end in
  Stdlib.Format.fprintf fmt
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.Formatting_gen
        (CamlinternalFormatBasics.Open_box
          (CamlinternalFormatBasics.Format
            CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
        (CamlinternalFormatBasics.Alpha
          (CamlinternalFormatBasics.Formatting_lit
            CamlinternalFormatBasics.Close_box
            CamlinternalFormatBasics.End_of_format))) &quot;@[%a@]&quot; % string)
    pp_mllam l.

Definition pp_array (fmt : Stdlib.Format.formatter) (t : array mllambda)
  : unit :=
  let len := Util.Array.(CArray.ExtS.length) t in
  Stdlib.Format.fprintf fmt
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.Formatting_gen
        (CamlinternalFormatBasics.Open_box
          (CamlinternalFormatBasics.Format
            CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
        (CamlinternalFormatBasics.String_literal &quot;[|&quot; % string
          CamlinternalFormatBasics.End_of_format)) &quot;@[[|&quot; % string);
  for;
  if OCaml.Stdlib.gt len 0 then
    Stdlib.Format.fprintf fmt
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.Alpha CamlinternalFormatBasics.End_of_format)
        &quot;%a&quot; % string) pp_mllam
      (Util.Array.(CArray.ExtS.get) t (Util.op_minus len 1))
  else
    tt;
  Stdlib.Format.fprintf fmt
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.String_literal &quot;|]&quot; % string
        (CamlinternalFormatBasics.Formatting_lit
          CamlinternalFormatBasics.Close_box
          CamlinternalFormatBasics.End_of_format)) &quot;|]@]&quot; % string).

Definition pp_global (fmt : Stdlib.Format.formatter) (g : global) : unit :=
  match g with
  | Glet gn c =&gt;
    match decompose_MLlam c with
    | (ids, c) =&gt;
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
            (CamlinternalFormatBasics.String_literal &quot;let &quot; % string
              (CamlinternalFormatBasics.Alpha
                (CamlinternalFormatBasics.Alpha
                  (CamlinternalFormatBasics.String_literal &quot; =&quot; % string
                    (CamlinternalFormatBasics.Formatting_lit
                      CamlinternalFormatBasics.Force_newline
                      (CamlinternalFormatBasics.String_literal &quot;  &quot; % string
                        (CamlinternalFormatBasics.Alpha
                          (CamlinternalFormatBasics.Formatting_lit
                            CamlinternalFormatBasics.Close_box
                            (CamlinternalFormatBasics.Formatting_lit
                              CamlinternalFormatBasics.Force_newline
                              (CamlinternalFormatBasics.Formatting_lit
                                CamlinternalFormatBasics.Flush_newline
                                CamlinternalFormatBasics.End_of_format)))))))))))
          &quot;@[let %a%a =@
  %a@]@
@.&quot; % string) pp_gname gn pp_ldecls ids
        pp_mllam c
    end
  | Gopen s =&gt;
    Stdlib.Format.fprintf fmt
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.Formatting_gen
          (CamlinternalFormatBasics.Open_box
            (CamlinternalFormatBasics.Format
              CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
          (CamlinternalFormatBasics.String_literal &quot;open &quot; % string
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.Formatting_lit
                CamlinternalFormatBasics.Close_box
                (CamlinternalFormatBasics.Formatting_lit
                  CamlinternalFormatBasics.Flush_newline
                  CamlinternalFormatBasics.End_of_format)))))
        &quot;@[open %s@]@.&quot; % string) s
  | Gtype ind lar =&gt;
    let fix aux (s : string) (arity : Int.t) : string :=
      if Int.equal arity 0 then
        s
      else
        aux (String.append s &quot; * Nativevalues.t&quot; % string)
          (Util.op_minus arity 1) in
    let pp_const_sig
      (fmt : Stdlib.Format.formatter) (function_parameter : Z * Z) : unit :=
      match function_parameter with
      | (tag, arity) =&gt;
        if OCaml.Stdlib.gt arity 0 then
          let sig_str :=
            aux &quot;of Nativevalues.t&quot; % string (Util.op_minus arity 1) in
          let cstr := string_of_construct &quot;&quot; % string false ind tag in
          Stdlib.Format.fprintf fmt
            (CamlinternalFormatBasics.Format
              (CamlinternalFormatBasics.String_literal &quot;  | &quot; % string
                (CamlinternalFormatBasics.String
                  CamlinternalFormatBasics.No_padding
                  (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
                    (CamlinternalFormatBasics.String
                      CamlinternalFormatBasics.No_padding
                      (CamlinternalFormatBasics.Formatting_lit
                        CamlinternalFormatBasics.Force_newline
                        CamlinternalFormatBasics.End_of_format)))))
              &quot;  | %s %s@
&quot; % string) cstr sig_str
        else
          let sig_str :=
            if OCaml.Stdlib.gt arity 0 then
              aux &quot;of Nativevalues.t&quot; % string (Util.op_minus arity 1)
            else
              &quot;&quot; % string in
          let cstr := string_of_construct &quot;&quot; % string true ind tag in
          Stdlib.Format.fprintf fmt
            (CamlinternalFormatBasics.Format
              (CamlinternalFormatBasics.String_literal &quot;  | &quot; % string
                (CamlinternalFormatBasics.String
                  CamlinternalFormatBasics.No_padding
                  (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
                    (CamlinternalFormatBasics.String
                      CamlinternalFormatBasics.No_padding
                      (CamlinternalFormatBasics.Formatting_lit
                        CamlinternalFormatBasics.Force_newline
                        CamlinternalFormatBasics.End_of_format)))))
              &quot;  | %s %s@
&quot; % string) cstr sig_str
      end in
    let pp_const_sigs (fmt : Stdlib.Format.formatter) (lar : array (Z * Z))
      : unit :=
      Stdlib.Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;  | &quot; % string
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.String_literal
                &quot; of Nativevalues.t&quot; % string
                (CamlinternalFormatBasics.Formatting_lit
                  CamlinternalFormatBasics.Force_newline
                  CamlinternalFormatBasics.End_of_format))))
          &quot;  | %s of Nativevalues.t@
&quot; % string)
        (string_of_accu_construct &quot;&quot; % string ind);
      Util.Array.(CArray.ExtS.iter) (pp_const_sig fmt) lar in
    Stdlib.Format.fprintf fmt
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.Formatting_gen
          (CamlinternalFormatBasics.Open_box
            (CamlinternalFormatBasics.Format
              CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
          (CamlinternalFormatBasics.String_literal &quot;type ind_&quot; % string
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.String_literal &quot; =&quot; % string
                (CamlinternalFormatBasics.Formatting_lit
                  CamlinternalFormatBasics.Force_newline
                  (CamlinternalFormatBasics.Alpha
                    (CamlinternalFormatBasics.Formatting_lit
                      CamlinternalFormatBasics.Close_box
                      (CamlinternalFormatBasics.Formatting_lit
                        CamlinternalFormatBasics.Force_newline
                        (CamlinternalFormatBasics.Formatting_lit
                          CamlinternalFormatBasics.Flush_newline
                          CamlinternalFormatBasics.End_of_format)))))))))
        &quot;@[type ind_%s =@
%a@]@
@.&quot; % string) (string_of_ind ind) pp_const_sigs
      lar
  | Gtblfixtype g params t =&gt;
    Stdlib.Format.fprintf fmt
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.Formatting_gen
          (CamlinternalFormatBasics.Open_box
            (CamlinternalFormatBasics.Format
              CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
          (CamlinternalFormatBasics.String_literal &quot;let &quot; % string
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
                (CamlinternalFormatBasics.Alpha
                  (CamlinternalFormatBasics.String_literal &quot; =&quot; % string
                    (CamlinternalFormatBasics.Formatting_lit
                      CamlinternalFormatBasics.Force_newline
                      (CamlinternalFormatBasics.String_literal &quot;  &quot; % string
                        (CamlinternalFormatBasics.Alpha
                          (CamlinternalFormatBasics.Formatting_lit
                            CamlinternalFormatBasics.Close_box
                            (CamlinternalFormatBasics.Formatting_lit
                              CamlinternalFormatBasics.Force_newline
                              (CamlinternalFormatBasics.Formatting_lit
                                CamlinternalFormatBasics.Flush_newline
                                CamlinternalFormatBasics.End_of_format))))))))))))
        &quot;@[let %a %a =@
  %a@]@
@.&quot; % string) pp_gname g pp_ldecls params
      pp_array t
  | Gtblnorm g params t =&gt;
    Stdlib.Format.fprintf fmt
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.Formatting_gen
          (CamlinternalFormatBasics.Open_box
            (CamlinternalFormatBasics.Format
              CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
          (CamlinternalFormatBasics.String_literal &quot;let &quot; % string
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
                (CamlinternalFormatBasics.Alpha
                  (CamlinternalFormatBasics.String_literal &quot; =&quot; % string
                    (CamlinternalFormatBasics.Formatting_lit
                      CamlinternalFormatBasics.Force_newline
                      (CamlinternalFormatBasics.String_literal &quot;  &quot; % string
                        (CamlinternalFormatBasics.Alpha
                          (CamlinternalFormatBasics.Formatting_lit
                            CamlinternalFormatBasics.Close_box
                            (CamlinternalFormatBasics.Formatting_lit
                              CamlinternalFormatBasics.Force_newline
                              (CamlinternalFormatBasics.Formatting_lit
                                CamlinternalFormatBasics.Flush_newline
                                CamlinternalFormatBasics.End_of_format))))))))))))
        &quot;@[let %a %a =@
  %a@]@
@.&quot; % string) pp_gname g pp_ldecls params
      pp_array t
  | Gletcase gn params annot a accu bs =&gt;
    Stdlib.Format.fprintf fmt
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.Formatting_gen
          (CamlinternalFormatBasics.Open_box
            (CamlinternalFormatBasics.Format
              CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
          (CamlinternalFormatBasics.String_literal &quot;(* Hash = &quot; % string
            (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
              CamlinternalFormatBasics.No_padding
              CamlinternalFormatBasics.No_precision
              (CamlinternalFormatBasics.String_literal &quot; *)&quot; % string
                (CamlinternalFormatBasics.Formatting_lit
                  CamlinternalFormatBasics.Force_newline
                  (CamlinternalFormatBasics.String_literal &quot;let rec &quot; % string
                    (CamlinternalFormatBasics.Alpha
                      (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
                        (CamlinternalFormatBasics.Alpha
                          (CamlinternalFormatBasics.String_literal &quot; =&quot; % string
                            (CamlinternalFormatBasics.Formatting_lit
                              CamlinternalFormatBasics.Force_newline
                              (CamlinternalFormatBasics.String_literal
                                &quot;  &quot; % string
                                (CamlinternalFormatBasics.Alpha
                                  (CamlinternalFormatBasics.Formatting_lit
                                    CamlinternalFormatBasics.Close_box
                                    (CamlinternalFormatBasics.Formatting_lit
                                      CamlinternalFormatBasics.Force_newline
                                      (CamlinternalFormatBasics.Formatting_lit
                                        CamlinternalFormatBasics.Flush_newline
                                        CamlinternalFormatBasics.End_of_format))))))))))))))))
        &quot;@[(* Hash = %i *)@
let rec %a %a =@
  %a@]@
@.&quot; % string)
      (hash_global g) pp_gname gn pp_ldecls params pp_mllam
      (MLmatch annot a accu bs)
  | Gcomment s =&gt;
    Stdlib.Format.fprintf fmt
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.Formatting_gen
          (CamlinternalFormatBasics.Open_box
            (CamlinternalFormatBasics.Format
              CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
          (CamlinternalFormatBasics.String_literal &quot;(* &quot; % string
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.String_literal &quot; *)&quot; % string
                (CamlinternalFormatBasics.Formatting_lit
                  CamlinternalFormatBasics.Close_box
                  (CamlinternalFormatBasics.Formatting_lit
                    CamlinternalFormatBasics.Flush_newline
                    CamlinternalFormatBasics.End_of_format))))))
        &quot;@[(* %s *)@]@.&quot; % string) s
  end.

Fixpoint compile_with_fv
  (env : Environ.env) (sigma : Nativelambda.evars) (univ : option lname)
  (auxdefs : list global) (l : option Names.Label.t) (t : Nativelambda.lambda)
  : (list global) * mllambda :=
  match mllambda_of_lambda univ auxdefs l t with
  | (auxdefs, (fv_named, fv_rel), ml) =&gt;
    if
      andb (Util.List.(CList.ExtS.is_empty) fv_named)
        (Util.List.(CList.ExtS.is_empty) fv_rel) then
      (auxdefs, ml)
    else
      apply_fv env sigma univ (fv_named, fv_rel) auxdefs ml
  end

with apply_fv
  (env : Environ.env) (sigma : Nativelambda.evars) (univ : option lname)
  (function_parameter :
    (list (Names.variable * mllambda)) * (list (Z * mllambda)))
  : (list global) -&gt; mllambda -&gt; (list global) * mllambda :=
  match function_parameter with
  | (fv_named, fv_rel) =&gt;
    fun auxdefs =&gt;
      fun ml =&gt;
        let get_rel_val {A : Type} (function_parameter : Z * A)
          : (list global) -&gt; list global :=
          match function_parameter with
          | (n, _) =&gt; fun auxdefs =&gt; compile_rel env sigma univ auxdefs n
          end in
        let get_named_val {A : Type} (function_parameter : Names.variable * A)
          : (list global) -&gt; list global :=
          match function_parameter with
          | (id, _) =&gt; fun auxdefs =&gt; compile_named env sigma univ auxdefs id
          end in
        let auxdefs :=
          Util.List.(CList.ExtS.fold_right) get_rel_val fv_rel auxdefs in
        let auxdefs :=
          Util.List.(CList.ExtS.fold_right) get_named_val fv_named auxdefs in
        let lvl := Context.Rel.length (Environ.rel_context env) in
        let fv_rel :=
          Util.List.(CList.ExtS.map)
            (fun function_parameter =&gt;
              match function_parameter with
              | (n, _) =&gt; MLglobal (Grel (Util.op_minus lvl n))
              end) fv_rel in
        let fv_named :=
          Util.List.(CList.ExtS.map)
            (fun function_parameter =&gt;
              match function_parameter with
              | (id, _) =&gt; MLglobal (Gnamed id)
              end) fv_named in
        let aux_name := fresh_lname Anonymous in
        (auxdefs,
          (MLlet aux_name ml
            (mkMLapp (MLlocal aux_name)
              (Util.Array.(CArray.ExtS.of_list) (Util.op_at fv_rel fv_named)))))
  end

with compile_rel
  (env : Environ.env) (sigma : Nativelambda.evars) (univ : option lname)
  (auxdefs : list global) (n : Z) : list global :=
  let decl := Environ.lookup_rel n env in
  let n :=
    Util.op_minus (Util.List.(CList.ExtS.length) (Environ.rel_context env)) n in
  match decl with
  | LocalDef _ t _ =&gt;
    let code := Nativelambda.lambda_of_constr env sigma t in
    match compile_with_fv env sigma univ auxdefs None code with
    | (auxdefs, code) =&gt; cons (Glet (Grel n) code) auxdefs
    end
  | LocalAssum _ _ =&gt; cons (Glet (Grel n) (MLprimitive (Mk_rel n))) auxdefs
  end

with compile_named
  (env : Environ.env) (sigma : Nativelambda.evars) (univ : option lname)
  (auxdefs : list global) (id : Names.variable) : list global :=
  match Environ.lookup_named id env with
  | LocalDef _ t _ =&gt;
    let code := Nativelambda.lambda_of_constr env sigma t in
    match compile_with_fv env sigma univ auxdefs None code with
    | (auxdefs, code) =&gt; cons (Glet (Gnamed id) code) auxdefs
    end
  | LocalAssum _ _ =&gt; cons (Glet (Gnamed id) (MLprimitive (Mk_var id))) auxdefs
  end.

Definition compile_constant {A : Type}
  (env : Environ.env) (sigma : Nativelambda.evars) (prefix : string)
  (interactive : bool) (con : Names.Constant.t)
  (cb : Declarations.constant_body A) : (list global) * Environ.link_info :=
  let no_univs :=
    equiv_decb 0
      (Univ.AUContext.size (Declareops.constant_polymorphic_context cb)) in
  match const_body cb with
  | Def t =&gt;
    let t := Mod_subst.force_constr t in
    let code := Nativelambda.lambda_of_constr env sigma t in
    if Util.op_exclamation Flags.debug then
      Feedback.msg_debug None (Pp.str &quot;Generated lambda code&quot; % string)
    else
      tt;
    let is_lazy := Nativelambda.is_lazy t in
    let code :=
      if is_lazy then
        Nativelambda.mk_lazy code
      else
        code in
    let name :=
      if interactive then
        LinkedInteractive prefix
      else
        Linked prefix in
    let l := Names.Constant.label con in
    match
      if no_univs then
        compile_with_fv env sigma None [] (Some l) code
      else
        let univ := fresh_univ tt in
        match compile_with_fv env sigma (Some univ) [] (Some l) code with
        | (auxdefs, code) =&gt; (auxdefs, (mkMLlam (univ) code))
        end with
    | (auxdefs, code) =&gt;
      if Util.op_exclamation Flags.debug then
        Feedback.msg_debug None (Pp.str &quot;Generated mllambda code&quot; % string)
      else
        tt;
      let code :=
        optimize_stk (cons (Glet (Gconstant &quot;&quot; % string con) code) auxdefs) in
      if Util.op_exclamation Flags.debug then
        Feedback.msg_debug None (Pp.str &quot;Optimized mllambda code&quot; % string)
      else
        tt;
      (code, name)
    end
  | _ =&gt;
    let i := push_symbol (SymbConst con) in
    let args :=
      if no_univs then
        ((get_const_code i), (MLarray tt))
      else
        ((get_const_code i)) in
    ((cons
      (Glet (Gconstant &quot;&quot; % string con) (mkMLapp (MLprimitive Mk_const) args))
      []),
      (if interactive then
        LinkedInteractive prefix
      else
        Linked prefix))
  end.

Module StringOrd.
  Definition t := string.
  
  Definition compare
    : Util.String.(CString.ExtS.t) -&gt; Util.String.(CString.ExtS.t) -&gt; Z :=
    Util.String.(CString.ExtS.compare).
End StringOrd.

Definition loaded_native_files : Stdlib.ref StringSet.t :=
  Stdlib.ref StringSet.empty.

Definition is_loaded_native_file (s : StringSet.elt) : bool :=
  StringSet.mem s (Util.op_exclamation loaded_native_files).

Definition register_native_file (s : StringSet.elt) : unit :=
  Stdlib.op_colon_eq loaded_native_files
    (StringSet.add s (Util.op_exclamation loaded_native_files)).

Definition is_code_loaded
  (interactive : bool) (name : Stdlib.ref Environ.link_info) : bool :=
  match Util.op_exclamation name with
  | NotLinked =&gt; false
  | LinkedInteractive s =&gt;
    if andb interactive (is_loaded_native_file s) then
      true
    else
      Stdlib.op_colon_eq name NotLinked;
      false
  | Linked s =&gt;
    if is_loaded_native_file s then
      true
    else
      Stdlib.op_colon_eq name NotLinked;
      false
  end.

Definition param_name : Names.name :=
  Name (Names.Id.of_string &quot;params&quot; % string).

Definition arg_name : Names.name := Name (Names.Id.of_string &quot;arg&quot; % string).

Definition compile_mind
  (mb : Declarations.mutual_inductive_body) (mind : Names.MutInd.t)
  (stack : list global) : list global :=
  let u := Declareops.inductive_polymorphic_context mb in
  let f (i : Z) (stack : list global) (ob : Declarations.one_inductive_body)
    : list global :=
    let ind := (mind, i) in
    let gtype := Gtype ind (mind_reloc_tbl ob) in
    let j := push_symbol (SymbInd ind) in
    let name := Gind &quot;&quot; % string ind in
    let accu :=
      let args :=
        if Int.equal (Univ.AUContext.size u) 0 then
          ((get_ind_code j), (MLarray tt))
        else
          ((get_ind_code j)) in
      Glet name (MLapp (MLprimitive Mk_ind) args) in
    let nparams := mind_nparams mb in
    let add_proj {A : Type} (proj_arg : Int.t) (acc : list global) (_pb : A)
      : list global :=
      let tbl := mind_reloc_tbl ob in
      let ci :=
        {| ci_ind := ind; ci_npar := nparams; ci_cstr_ndecls := tt;
          ci_cstr_nargs := (0); ci_relevance := mind_relevance ob;
          ci_pp_info :=
            {| ind_tags := []; cstr_tags := tt; style := RegularStyle |} |} in
      let asw :=
        {| asw_ind := ind; asw_ci := ci; asw_reloc := tbl; asw_finite := true;
          asw_prefix := &quot;&quot; % string |} in
      let c_uid := fresh_lname Anonymous in
      let cf_uid := fresh_lname Anonymous in
      match Util.Array.(CArray.ExtS.get) tbl 0 with
      | (tag, arity) =&gt;
        OCaml.Stdlib.gt arity 0;
        let ci_uid := fresh_lname Anonymous in
        let cargs :=
          Util.Array.(CArray.ExtS.init) arity
            (fun i =&gt;
              if Int.equal i proj_arg then
                Some ci_uid
              else
                None) in
        let i := push_symbol (SymbProj (ind, proj_arg)) in
        let accu := MLapp (MLprimitive Cast_accu) ((MLlocal cf_uid)) in
        let accu_br := MLapp (MLprimitive Mk_proj) ((get_proj_code i), accu) in
        let code :=
          MLmatch asw (MLlocal cf_uid) accu_br
            (((cons (NonConstPattern tag cargs) []), (MLlocal ci_uid))) in
        let code :=
          MLlet cf_uid (mkForceCofix &quot;&quot; % string ind (MLlocal c_uid)) code in
        let gn := Gproj &quot;&quot; % string ind proj_arg in
        cons (Glet gn (mkMLlam (c_uid) code)) acc
      end in
    let projs :=
      match mind_record mb with
      | NotRecord | FakeRecord =&gt; []
      | PrimRecord info =&gt;
        match Util.Array.(CArray.ExtS.get) info i with
        | (_, _, _, pbs) =&gt; Util.Array.(CArray.ExtS.fold_left_i) add_proj [] pbs
        end
      end in
    Util.op_at projs (cons gtype (cons accu stack)) in
  Util.Array.(CArray.ExtS.fold_left_i) f stack (mind_packets mb).

Definition code_location_update :=
  (Stdlib.ref Environ.link_info) * Environ.link_info.

Definition code_location_updates :=
  (Names.Mindmap_env.t code_location_update) *
    (Names.Cmap_env.t code_location_update).

Definition linkable_code := (list global) * code_location_updates.

Definition empty_updates {A B : Type}
  : (Names.Mindmap_env.t A) * (Names.Cmap_env.t B) :=
  (Names.Mindmap_env.empty, Names.Cmap_env.empty).

Definition compile_mind_deps {A : Type}
  (env : Environ.env) (prefix : string) (interactive : bool)
  (function_parameter :
    (list global) *
      ((Names.Mindmap_env.t ((Stdlib.ref Environ.link_info) * Environ.link_info))
        * A))
  : Names.Mindmap_env.key -&gt;
    (list global) *
      ((Names.Mindmap_env.t ((Stdlib.ref Environ.link_info) * Environ.link_info))
        * A) :=
  match function_parameter with
  | (comp_stack, (mind_updates, const_updates)) as init =&gt;
    fun mind =&gt;
      match Environ.lookup_mind_key mind env with
      | (mib, nameref) =&gt;
        if
          orb (is_code_loaded interactive nameref)
            (Names.Mindmap_env.mem mind mind_updates) then
          init
        else
          let comp_stack := compile_mind mib mind comp_stack in
          let name :=
            if interactive then
              LinkedInteractive prefix
            else
              Linked prefix in
          let upd := (nameref, name) in
          let mind_updates := Names.Mindmap_env.add mind upd mind_updates in
          (comp_stack, (mind_updates, const_updates))
      end
  end.

Definition compile_deps
  (env : Environ.env) (sigma : Nativelambda.evars) (prefix : string)
  (interactive : bool)
  (init :
    (list global) *
      ((Names.Mindmap_env.t ((Stdlib.ref Environ.link_info) * Environ.link_info))
        *
        (Names.Cmap_env.t ((Stdlib.ref Environ.link_info) * Environ.link_info))))
  (t : Constr.constr)
  : (list global) *
    ((Names.Mindmap_env.t ((Stdlib.ref Environ.link_info) * Environ.link_info))
      * (Names.Cmap_env.t ((Stdlib.ref Environ.link_info) * Environ.link_info))) :=
  let fix aux
    (env : Environ.env) (lvl : Z) (init :
    (list global) *
      ((Names.Mindmap_env.t ((Stdlib.ref Environ.link_info) * Environ.link_info))
        *
        (Names.Cmap_env.t ((Stdlib.ref Environ.link_info) * Environ.link_info))))
    (t : Constr.constr)
    : (list global) *
      ((Names.Mindmap_env.t ((Stdlib.ref Environ.link_info) * Environ.link_info))
        *
        (Names.Cmap_env.t ((Stdlib.ref Environ.link_info) * Environ.link_info))) :=
    match Constr.kind t with
    | Ind ((mind, _), _u) =&gt; compile_mind_deps env prefix interactive init mind
    | Const c =&gt;
      match Nativelambda.get_alias env c with
      | (c, _u) =&gt;
        match Environ.lookup_constant_key c env with
        | (cb, (nameref, _)) =&gt;
          match init with
          | (_, (_, const_updates)) =&gt;
            if
              orb (is_code_loaded interactive nameref)
                (Names.Cmap_env.mem c const_updates) then
              init
            else
              match
                match const_body cb with
                | Def t =&gt; aux env lvl init (Mod_subst.force_constr t)
                | _ =&gt; init
                end with
              | (comp_stack, (mind_updates, const_updates)) =&gt;
                match compile_constant env sigma prefix interactive c cb with
                | (code, name) =&gt;
                  let comp_stack := Util.op_at code comp_stack in
                  let const_updates :=
                    Names.Cmap_env.add c (nameref, name) const_updates in
                  (comp_stack, (mind_updates, const_updates))
                end
              end
          end
        end
      end
    | Construct (((mind, _), _), _u) =&gt;
      compile_mind_deps env prefix interactive init mind
    | Proj p c =&gt;
      let init :=
        compile_mind_deps env prefix interactive init (Names.Projection.mind p)
        in
      aux env lvl init c
    | Case ci _p _c _ac =&gt;
      let mind := fst (ci_ind ci) in
      let init := compile_mind_deps env prefix interactive init mind in
      Constr.fold_constr_with_binders Z.succ (aux env) lvl init t
    | Var id =&gt;
      match Environ.lookup_named id env with
      | LocalDef _ t _ =&gt; aux env lvl init t
      | _ =&gt; init
      end
    | _ =&gt; Constr.fold_constr_with_binders Z.succ (aux env) lvl init t
    end in
  aux env 0 init t.

Definition compile_constant_field {A : Type}
  (env : Environ.env) (prefix : string) (con : Names.Constant.t)
  (acc : list global) (cb : Declarations.constant_body A) : list global :=
  match compile_constant env Nativelambda.empty_evars prefix false con cb with
  | (gl, _) =&gt; Util.op_at gl acc
  end.

Definition compile_mind_field
  (mp : Names.ModPath.t) (l : Names.Label.t) (acc : list global)
  (mb : Declarations.mutual_inductive_body) : list global :=
  let mind := Names.MutInd.make2 mp l in
  compile_mind mb mind acc.

Definition mk_open (s : string) : global := Gopen s.

Definition mk_internal_let (s : string) (code : mllambda) : global :=
  Glet (Ginternal s) code.

Definition mk_conv_code
  (env : Environ.env) (sigma : Nativelambda.evars) (prefix : string)
  (t1 : Constr.constr) (t2 : Constr.constr)
  : (list global) *
    ((Names.Mindmap_env.t ((Stdlib.ref Environ.link_info) * Environ.link_info))
      * (Names.Cmap_env.t ((Stdlib.ref Environ.link_info) * Environ.link_info))) :=
  clear_symbols tt;
  clear_global_tbl tt;
  match
    let init := ([], empty_updates) in
    compile_deps env sigma prefix true init t1 with
  | (gl, (mind_updates, const_updates)) =&gt;
    match
      let init := (gl, (mind_updates, const_updates)) in
      compile_deps env sigma prefix true init t2 with
    | (gl, (mind_updates, const_updates)) =&gt;
      let code1 := Nativelambda.lambda_of_constr env sigma t1 in
      let code2 := Nativelambda.lambda_of_constr env sigma t2 in
      match compile_with_fv env sigma None gl None code1 with
      | (gl, code1) =&gt;
        match compile_with_fv env sigma None gl None code2 with
        | (gl, code2) =&gt;
          let t1 := mk_internal_let &quot;t1&quot; % string code1 in
          let t2 := mk_internal_let &quot;t2&quot; % string code2 in
          let g1 := MLglobal (Ginternal &quot;t1&quot; % string) in
          let g2 := MLglobal (Ginternal &quot;t2&quot; % string) in
          let setref1 :=
            Glet (Ginternal &quot;_&quot; % string) (MLsetref &quot;rt1&quot; % string g1) in
          let setref2 :=
            Glet (Ginternal &quot;_&quot; % string) (MLsetref &quot;rt2&quot; % string g2) in
          let gl :=
            Util.List.(CList.ExtS.rev)
              (cons setref2 (cons setref1 (cons t2 (cons t1 gl)))) in
          let header :=
            Glet (Ginternal &quot;symbols_tbl&quot; % string)
              (MLapp (MLglobal (Ginternal &quot;get_symbols&quot; % string))
                ((MLglobal (Ginternal &quot;()&quot; % string)))) in
          ((cons header gl), (mind_updates, const_updates))
        end
      end
    end
  end.

Definition mk_norm_code
  (env : Environ.env) (sigma : Nativelambda.evars) (prefix : string)
  (t : Constr.constr)
  : (list global) *
    ((Names.Mindmap_env.t ((Stdlib.ref Environ.link_info) * Environ.link_info))
      * (Names.Cmap_env.t ((Stdlib.ref Environ.link_info) * Environ.link_info))) :=
  clear_symbols tt;
  clear_global_tbl tt;
  match
    let init := ([], empty_updates) in
    compile_deps env sigma prefix true init t with
  | (gl, (mind_updates, const_updates)) =&gt;
    let code := Nativelambda.lambda_of_constr env sigma t in
    match compile_with_fv env sigma None gl None code with
    | (gl, code) =&gt;
      let t1 := mk_internal_let &quot;t1&quot; % string code in
      let g1 := MLglobal (Ginternal &quot;t1&quot; % string) in
      let setref := Glet (Ginternal &quot;_&quot; % string) (MLsetref &quot;rt1&quot; % string g1)
        in
      let gl := Util.List.(CList.ExtS.rev) (cons setref (cons t1 gl)) in
      let header :=
        Glet (Ginternal &quot;symbols_tbl&quot; % string)
          (MLapp (MLglobal (Ginternal &quot;get_symbols&quot; % string))
            ((MLglobal (Ginternal &quot;()&quot; % string)))) in
      ((cons header gl), (mind_updates, const_updates))
    end
  end.

Definition mk_library_header {A : Type} (dir : A) : list global :=
  let libname :=
    Stdlib.Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;(str_decode &quot;&quot;&quot; % string
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal &quot;&quot;&quot;)&quot; % string
              CamlinternalFormatBasics.End_of_format)))
        &quot;(str_decode &quot;&quot;%s&quot;&quot;)&quot; % string) (Nativevalues.str_encode dir) in
  cons
    (Glet (Ginternal &quot;symbols_tbl&quot; % string)
      (MLapp (MLglobal (Ginternal &quot;get_library_native_symbols&quot; % string))
        ((MLglobal (Ginternal libname))))) [].

Definition update_location {A : Type} (function_parameter : (Stdlib.ref A) * A)
  : unit :=
  match function_parameter with
  | (r, v) =&gt; Stdlib.op_colon_eq r v
  end.

Definition update_locations {A B : Type}
  (function_parameter :
    (Names.Mindmap_env.t ((Stdlib.ref A) * A)) *
      (Names.Cmap_env.t ((Stdlib.ref B) * B))) : unit :=
  match function_parameter with
  | (ind_updates, const_updates) =&gt;
    Names.Mindmap_env.iter
      (fun function_parameter =&gt;
        match function_parameter with
        | _ =&gt; update_location
        end) ind_updates;
    Names.Cmap_env.iter
      (fun function_parameter =&gt;
        match function_parameter with
        | _ =&gt; update_location
        end) const_updates
  end.

Definition add_header_comment (mlcode : list global) (s : string)
  : list global := cons (Gcomment s) mlcode.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="nativeconv" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>nativeconv.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Nativelib
open Reduction
open Util
open Nativevalues
open Nativecode
open Environ

(** This module implements the conversion test by compiling to OCaml code *)

let rec conv_val env pb lvl v1 v2 cu =
  if v1 == v2 then cu
  else
    match kind_of_value v1, kind_of_value v2 with
    | Vfun f1, Vfun f2 -&gt;
	let v = mk_rel_accu lvl in
	conv_val env CONV (lvl+1) (f1 v) (f2 v) cu
    | Vfun _f1, _ -&gt;
	conv_val env CONV lvl v1 (fun x -&gt; v2 x) cu
    | _, Vfun _f2 -&gt;
	conv_val env CONV lvl (fun x -&gt; v1 x) v2 cu
    | Vaccu k1, Vaccu k2 -&gt;
	conv_accu env pb lvl k1 k2 cu
    | Vconst i1, Vconst i2 -&gt; 
	if Int.equal i1 i2 then cu else raise NotConvertible
    | Vint64 i1, Vint64 i2 -&gt;
      if Int64.equal i1 i2 then cu else raise NotConvertible
    | Vblock b1, Vblock b2 -&gt;
	let n1 = block_size b1 in
        let n2 = block_size b2 in
	if not (Int.equal (block_tag b1) (block_tag b2)) || not (Int.equal n1 n2) then
	  raise NotConvertible;
	let rec aux lvl max b1 b2 i cu =
	  if Int.equal i max then 
	    conv_val env CONV lvl (block_field b1 i) (block_field b2 i) cu
	  else
	    let cu = conv_val env CONV lvl (block_field b1 i) (block_field b2 i) cu in
	    aux lvl max b1 b2 (i+1) cu
	in
	aux lvl (n1-1) b1 b2 0 cu
    | Vaccu _, _ | Vconst _, _ | Vint64 _, _ | Vblock _, _ -&gt; raise NotConvertible

and conv_accu env pb lvl k1 k2 cu =
  let n1 = accu_nargs k1 in
  let n2 = accu_nargs k2 in
  if not (Int.equal n1 n2) then raise NotConvertible;
  if Int.equal n1 0 then 
    conv_atom env pb lvl (atom_of_accu k1) (atom_of_accu k2) cu
  else
    let cu = conv_atom env pb lvl (atom_of_accu k1) (atom_of_accu k2) cu in
    Array.fold_right2 (conv_val env CONV lvl) (args_of_accu k1) (args_of_accu k2) cu

and conv_atom env pb lvl a1 a2 cu =
  if a1 == a2 then cu
  else
    match a1, a2 with
    | Ameta (m1,_), Ameta (m2,_) -&gt;
      if Int.equal m1 m2 then cu else raise NotConvertible
    | Aevar (ev1, args1), Aevar (ev2, args2) -&gt;
      if Evar.equal ev1 ev2 then
        Array.fold_right2 (conv_val env CONV lvl) args1 args2 cu
      else raise NotConvertible
    | Arel i1, Arel i2 -&gt; 
	if Int.equal i1 i2 then cu else raise NotConvertible
    | Aind (ind1,u1), Aind (ind2,u2) -&gt;
       if eq_ind ind1 ind2 then convert_instances ~flex:false u1 u2 cu
       else raise NotConvertible
    | Aconstant (c1,u1), Aconstant (c2,u2) -&gt;
       if Constant.equal c1 c2 then convert_instances ~flex:true u1 u2 cu
       else raise NotConvertible
    | Asort s1, Asort s2 -&gt; 
        sort_cmp_universes env pb s1 s2 cu
    | Avar id1, Avar id2 -&gt;
	if Id.equal id1 id2 then cu else raise NotConvertible
    | Acase(a1,ac1,p1,bs1), Acase(a2,ac2,p2,bs2) -&gt;
	if not (eq_ind a1.asw_ind a2.asw_ind) then raise NotConvertible;
	let cu = conv_accu env CONV lvl ac1 ac2 cu in
	let tbl = a1.asw_reloc in
	let len = Array.length tbl in
	if Int.equal len 0 then conv_val env CONV lvl p1 p2 cu
	else begin
	    let cu = conv_val env CONV lvl p1 p2 cu in
	    let max = len - 1 in
	    let rec aux i cu =
	      let tag,arity = tbl.(i) in
	      let ci =
		if Int.equal arity 0 then mk_const tag
		else mk_block tag (mk_rels_accu lvl arity) in
	      let bi1 = bs1 ci and bi2 = bs2 ci in
	      if Int.equal i max then conv_val env CONV (lvl + arity) bi1 bi2 cu
	      else aux (i+1) (conv_val env CONV (lvl + arity) bi1 bi2 cu) in
	    aux 0 cu
	  end
    | Afix(t1,f1,rp1,s1), Afix(t2,f2,rp2,s2) -&gt;
	if not (Int.equal s1 s2) || not (Array.equal Int.equal rp1 rp2) then raise NotConvertible;
	if f1 == f2 then cu
	else conv_fix env lvl t1 f1 t2 f2 cu
    | (Acofix(t1,f1,s1,_) | Acofixe(t1,f1,s1,_)),
      (Acofix(t2,f2,s2,_) | Acofixe(t2,f2,s2,_)) -&gt;
	if not (Int.equal s1 s2) then raise NotConvertible;
	if f1 == f2 then cu
	else
	  if not (Int.equal (Array.length f1) (Array.length f2)) then raise NotConvertible
	  else conv_fix env lvl t1 f1 t2 f2 cu 
    | Aprod(_,d1,_c1), Aprod(_,d2,_c2) -&gt;
       let cu = conv_val env CONV lvl d1 d2 cu in
       let v = mk_rel_accu lvl in
       conv_val env pb (lvl + 1) (d1 v) (d2 v) cu
    | Aproj((ind1, i1), ac1), Aproj((ind2, i2), ac2) -&gt;
       if not (eq_ind ind1 ind2 &amp;&amp; Int.equal i1 i2) then raise NotConvertible
       else conv_accu env CONV lvl ac1 ac2 cu
    | Arel _, _ | Aind _, _ | Aconstant _, _ | Asort _, _ | Avar _, _
    | Acase _, _ | Afix _, _ | Acofix _, _ | Acofixe _, _ | Aprod _, _
    | Aproj _, _ | Ameta _, _ | Aevar _, _ -&gt; raise NotConvertible

(* Precondition length t1 = length f1 = length f2 = length t2 *)
and conv_fix env lvl t1 f1 t2 f2 cu =
  let len = Array.length f1 in
  let max = len - 1 in
  let fargs = mk_rels_accu lvl len in
  let flvl = lvl + len in
  let rec aux i cu =
    let cu = conv_val env CONV lvl t1.(i) t2.(i) cu in
    let fi1 = napply f1.(i) fargs in
    let fi2 = napply f2.(i) fargs in
    if Int.equal i max then conv_val env CONV flvl fi1 fi2 cu
    else aux (i+1) (conv_val env CONV flvl fi1 fi2 cu) in
  aux 0 cu

let warn_no_native_compiler =
  let open Pp in
  CWarnings.create ~name:&quot;native-compiler-disabled&quot; ~category:&quot;native-compiler&quot;
         (fun () -&gt; strbrk &quot;Native compiler is disabled,&quot; ++
                      strbrk &quot; falling back to VM conversion test.&quot;)

let native_conv_gen pb sigma env univs t1 t2 =
  if not (typing_flags env).Declarations.enable_native_compiler then begin
    warn_no_native_compiler ();
    Vconv.vm_conv_gen pb env univs t1 t2
  end
  else
  let ml_filename, prefix = get_ml_filename () in
  let code, upds = mk_conv_code env sigma prefix t1 t2 in
  let fn = compile ml_filename code ~profile:false in
  if !Flags.debug then Feedback.msg_debug (Pp.str &quot;Running test...&quot;);
  let t0 = Sys.time () in
  call_linker env ~fatal:true ~prefix fn (Some upds);
  let t1 = Sys.time () in
  let time_info = Format.sprintf &quot;Evaluation done in %.5f@.&quot; (t1 -. t0) in
  if !Flags.debug then Feedback.msg_debug (Pp.str time_info);
  (* TODO change 0 when we can have de Bruijn *)
  fst (conv_val env pb 0 !rt1 !rt2 univs)

(* Wrapper for [native_conv] above *)
let native_conv cv_pb sigma env t1 t2 =
  let univs = Environ.universes env in
  let b =
    if cv_pb = CUMUL then Constr.leq_constr_univs univs t1 t2
    else Constr.eq_constr_univs univs t1 t2
  in
  if not b then
    let univs = (univs, checked_universes) in
    let t1 = Term.it_mkLambda_or_LetIn t1 (Environ.rel_context env) in
    let t2 = Term.it_mkLambda_or_LetIn t2 (Environ.rel_context env) in
    let _ = native_conv_gen cv_pb sigma env univs t1 t2 in ()
</pre>
          </div>
          <div class="col-md-6">
            <code>nativeconv.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Names.

Import Nativelib.

Import Reduction.

Import Util.

Import Nativevalues.

Import Nativecode.

Import Environ.

Fixpoint conv_val {A : Type}
  (env : Environ.env) (pb : Reduction.conv_pb) (lvl : Z) (v1 : Nativevalues.t)
  (v2 : Nativevalues.t) (cu : A * (Reduction.universe_compare A))
  : A * (Reduction.universe_compare A) :=
  if Stdlib.op_eq_eq v1 v2 then
    cu
  else
    match ((Nativevalues.kind_of_value v1), (Nativevalues.kind_of_value v2))
      with
    | (Vfun f1, Vfun f2) =&gt;
      let v := Nativevalues.mk_rel_accu lvl in
      conv_val env CONV (Util.op_plus lvl 1) (f1 v) (f2 v) cu
    | (Vfun _f1, _) =&gt; conv_val env CONV lvl v1 (fun x =&gt; v2 x) cu
    | (_, Vfun _f2) =&gt; conv_val env CONV lvl (fun x =&gt; v1 x) v2 cu
    | (Vaccu k1, Vaccu k2) =&gt; conv_accu env pb lvl k1 k2 cu
    | (Vconst i1, Vconst i2) =&gt;
      if Int.equal i1 i2 then
        cu
      else
        Stdlib.raise NotConvertible
    | (Vint64 i1, Vint64 i2) =&gt;
      if Stdlib.Int64.equal i1 i2 then
        cu
      else
        Stdlib.raise NotConvertible
    | (Vblock b1, Vblock b2) =&gt;
      let n1 := Nativevalues.block_size b1 in
      let n2 := Nativevalues.block_size b2 in
      if
        orb
          (negb
            (Int.equal (Nativevalues.block_tag b1) (Nativevalues.block_tag b2)))
          (negb (Int.equal n1 n2)) then
        Stdlib.raise NotConvertible
      else
        tt;
      let fix aux
        (lvl : Z) (max : Int.t) (b1 : Nativevalues.block) (b2 :
        Nativevalues.block) (i : Int.t) (cu :
        A * (Reduction.universe_compare A))
        : A * (Reduction.universe_compare A) :=
        if Int.equal i max then
          conv_val env CONV lvl (Nativevalues.block_field b1 i)
            (Nativevalues.block_field b2 i) cu
        else
          let cu :=
            conv_val env CONV lvl (Nativevalues.block_field b1 i)
              (Nativevalues.block_field b2 i) cu in
          aux lvl max b1 b2 (Util.op_plus i 1) cu in
      aux lvl (Util.op_minus n1 1) b1 b2 0 cu
    | (Vaccu _, _) | (Vconst _, _) | (Vint64 _, _) | (Vblock _, _) =&gt;
      Stdlib.raise NotConvertible
    end

with conv_accu {A : Type}
  (env : Environ.env) (pb : Reduction.conv_pb) (lvl : Z)
  (k1 : Nativevalues.accumulator) (k2 : Nativevalues.accumulator)
  (cu : A * (Reduction.universe_compare A))
  : A * (Reduction.universe_compare A) :=
  let n1 := Nativevalues.accu_nargs k1 in
  let n2 := Nativevalues.accu_nargs k2 in
  if negb (Int.equal n1 n2) then
    Stdlib.raise NotConvertible
  else
    tt;
  if Int.equal n1 0 then
    conv_atom env pb lvl (Nativevalues.atom_of_accu k1)
      (Nativevalues.atom_of_accu k2) cu
  else
    let cu :=
      conv_atom env pb lvl (Nativevalues.atom_of_accu k1)
        (Nativevalues.atom_of_accu k2) cu in
    Util.Array.(CArray.ExtS.fold_right2) (conv_val env CONV lvl)
      (Nativevalues.args_of_accu k1) (Nativevalues.args_of_accu k2) cu

with conv_atom {A : Type}
  (env : Environ.env) (pb : Reduction.conv_pb) (lvl : Z)
  (a1 : Nativevalues.atom) (a2 : Nativevalues.atom)
  (cu : A * (Reduction.universe_compare A))
  : A * (Reduction.universe_compare A) :=
  if Stdlib.op_eq_eq a1 a2 then
    cu
  else
    match (a1, a2) with
    | (Ameta m1 _, Ameta m2 _) =&gt;
      if Int.equal m1 m2 then
        cu
      else
        Stdlib.raise NotConvertible
    | (Aevar ev1 args1, Aevar ev2 args2) =&gt;
      if Evar.equal ev1 ev2 then
        Util.Array.(CArray.ExtS.fold_right2) (conv_val env CONV lvl) args1 args2
          cu
      else
        Stdlib.raise NotConvertible
    | (Arel i1, Arel i2) =&gt;
      if Int.equal i1 i2 then
        cu
      else
        Stdlib.raise NotConvertible
    | (Aind (ind1, u1), Aind (ind2, u2)) =&gt;
      if Names.eq_ind ind1 ind2 then
        Reduction.convert_instances false u1 u2 cu
      else
        Stdlib.raise NotConvertible
    | (Aconstant (c1, u1), Aconstant (c2, u2)) =&gt;
      if Names.Constant.equal c1 c2 then
        Reduction.convert_instances true u1 u2 cu
      else
        Stdlib.raise NotConvertible
    | (Asort s1, Asort s2) =&gt; Reduction.sort_cmp_universes env pb s1 s2 cu
    | (Avar id1, Avar id2) =&gt;
      if Names.Id.equal id1 id2 then
        cu
      else
        Stdlib.raise NotConvertible
    | (Acase a1 ac1 p1 bs1, Acase a2 ac2 p2 bs2) =&gt;
      if negb (Names.eq_ind (asw_ind a1) (asw_ind a2)) then
        Stdlib.raise NotConvertible
      else
        tt;
      let cu := conv_accu env CONV lvl ac1 ac2 cu in
      let tbl := asw_reloc a1 in
      let len := Util.Array.(CArray.ExtS.length) tbl in
      if Int.equal len 0 then
        conv_val env CONV lvl p1 p2 cu
      else
        let cu := conv_val env CONV lvl p1 p2 cu in
        let max := Util.op_minus len 1 in
        let fix aux (i : Int.t) (cu : A * (Reduction.universe_compare A))
          : A * (Reduction.universe_compare A) :=
          match Util.Array.(CArray.ExtS.get) tbl i with
          | (tag, arity) =&gt;
            let ci :=
              if Int.equal arity 0 then
                Nativevalues.mk_const tag
              else
                Nativevalues.mk_block tag (Nativevalues.mk_rels_accu lvl arity)
              in
            let bi1 : Nativevalues.t :=
              bs1 ci
            with bi2 : Nativevalues.t :=
              bs2 ci in
            if Int.equal i max then
              conv_val env CONV (Util.op_plus lvl arity) bi1 bi2 cu
            else
              aux (Util.op_plus i 1)
                (conv_val env CONV (Util.op_plus lvl arity) bi1 bi2 cu)
          end in
        aux 0 cu
    | (Afix t1 f1 rp1 s1, Afix t2 f2 rp2 s2) =&gt;
      if
        orb (negb (Int.equal s1 s2))
          (negb (Util.Array.(CArray.ExtS.equal) Int.equal rp1 rp2)) then
        Stdlib.raise NotConvertible
      else
        tt;
      if Stdlib.op_eq_eq f1 f2 then
        cu
      else
        conv_fix env lvl t1 f1 t2 f2 cu
    |
      (Acofix t1 f1 s1 _ | Acofixe t1 f1 s1 _,
        Acofix t2 f2 s2 _ | Acofixe t2 f2 s2 _) =&gt;
      if negb (Int.equal s1 s2) then
        Stdlib.raise NotConvertible
      else
        tt;
      if Stdlib.op_eq_eq f1 f2 then
        cu
      else
        if
          negb
            (Int.equal (Util.Array.(CArray.ExtS.length) f1)
              (Util.Array.(CArray.ExtS.length) f2)) then
          Stdlib.raise NotConvertible
        else
          conv_fix env lvl t1 f1 t2 f2 cu
    | (Aprod _ d1 _c1, Aprod _ d2 _c2) =&gt;
      let cu := conv_val env CONV lvl d1 d2 cu in
      let v := Nativevalues.mk_rel_accu lvl in
      conv_val env pb (Util.op_plus lvl 1) (d1 v) (d2 v) cu
    | (Aproj (ind1, i1) ac1, Aproj (ind2, i2) ac2) =&gt;
      if negb (andb (Names.eq_ind ind1 ind2) (Int.equal i1 i2)) then
        Stdlib.raise NotConvertible
      else
        conv_accu env CONV lvl ac1 ac2 cu
    |
      (Arel _, _) | (Aind _, _) | (Aconstant _, _) | (Asort _, _) | (Avar _, _)
        | (Acase _ _ _ _, _) | (Afix _ _ _ _, _) | (Acofix _ _ _ _, _) |
        (Acofixe _ _ _ _, _) | (Aprod _ _ _, _) | (Aproj _ _, _) |
        (Ameta _ _, _) | (Aevar _ _, _) =&gt; Stdlib.raise NotConvertible
    end

with conv_fix {A : Type}
  (env : Environ.env) (lvl : Z) (t1 : array Nativevalues.t)
  (f1 : array Nativevalues.t) (t2 : array Nativevalues.t)
  (f2 : array Nativevalues.t) (cu : A * (Reduction.universe_compare A))
  : A * (Reduction.universe_compare A) :=
  let len := Util.Array.(CArray.ExtS.length) f1 in
  let max := Util.op_minus len 1 in
  let fargs := Nativevalues.mk_rels_accu lvl len in
  let flvl := Util.op_plus lvl len in
  let fix aux (i : Int.t) (cu : A * (Reduction.universe_compare A))
    : A * (Reduction.universe_compare A) :=
    let cu :=
      conv_val env CONV lvl (Util.Array.(CArray.ExtS.get) t1 i)
        (Util.Array.(CArray.ExtS.get) t2 i) cu in
    let fi1 := Nativevalues.napply (Util.Array.(CArray.ExtS.get) f1 i) fargs in
    let fi2 := Nativevalues.napply (Util.Array.(CArray.ExtS.get) f2 i) fargs in
    if Int.equal i max then
      conv_val env CONV flvl fi1 fi2 cu
    else
      aux (Util.op_plus i 1) (conv_val env CONV flvl fi1 fi2 cu) in
  aux 0 cu.

Definition warn_no_native_compiler : (option Loc.t) -&gt; unit -&gt; unit :=
  CWarnings.create &quot;native-compiler-disabled&quot; % string
    &quot;native-compiler&quot; % string None
    (fun function_parameter =&gt;
      match function_parameter with
      | tt =&gt;
        Pp.op_plus_plus (Pp.strbrk &quot;Native compiler is disabled,&quot; % string)
          (Pp.strbrk &quot; falling back to VM conversion test.&quot; % string)
      end).

Definition native_conv_gen {A : Type}
  (pb : Reduction.conv_pb) (sigma : Nativelambda.evars) (env : Environ.env)
  (univs : Reduction.universe_state A) (t1 : Constr.types) (t2 : Constr.types)
  : A :=
  if negb (Declarations.enable_native_compiler (Environ.typing_flags env)) then
    warn_no_native_compiler None tt;
    Vconv.vm_conv_gen pb env univs t1 t2
  else
    match Nativelib.get_ml_filename tt with
    | (ml_filename, prefix) =&gt;
      match Nativecode.mk_conv_code env sigma prefix t1 t2 with
      | (code, upds) =&gt;
        let fn := Nativelib.compile ml_filename code false in
        if Util.op_exclamation Flags.debug then
          Feedback.msg_debug None (Pp.str &quot;Running test...&quot; % string)
        else
          tt;
        let t0 := Stdlib.Sys.time tt in
        Nativelib.call_linker (Some true) env prefix fn (Some upds);
        let t1 := Stdlib.Sys.time tt in
        let time_info :=
          Stdlib.Format.sprintf
            (CamlinternalFormatBasics.Format
              (CamlinternalFormatBasics.String_literal
                &quot;Evaluation done in &quot; % string
                (CamlinternalFormatBasics.Float CamlinternalFormatBasics.Float_f
                  CamlinternalFormatBasics.No_padding
                  (CamlinternalFormatBasics.Lit_precision 5)
                  (CamlinternalFormatBasics.Formatting_lit
                    CamlinternalFormatBasics.Flush_newline
                    CamlinternalFormatBasics.End_of_format)))
              &quot;Evaluation done in %.5f@.&quot; % string)
            (Stdlib.op_minus_point t1 t0) in
        if Util.op_exclamation Flags.debug then
          Feedback.msg_debug None (Pp.str time_info)
        else
          tt;
        fst
          (conv_val env pb 0 (Util.op_exclamation Nativelib.rt1)
            (Util.op_exclamation Nativelib.rt2) univs)
      end
    end.

Definition native_conv
  (cv_pb : Reduction.conv_pb) (sigma : Nativelambda.evars) (env : Environ.env)
  (t1 : Constr.constr) (t2 : Constr.constr) : unit :=
  let univs := Environ.universes env in
  let b :=
    if equiv_decb cv_pb CUMUL then
      Constr.leq_constr_univs univs t1 t2
    else
      Constr.eq_constr_univs univs t1 t2 in
  if negb b then
    let univs := (univs, Reduction.checked_universes) in
    let t1 := Term.it_mkLambda_or_LetIn t1 (Environ.rel_context env) in
    let t2 := Term.it_mkLambda_or_LetIn t2 (Environ.rel_context env) in
    match native_conv_gen cv_pb sigma env univs t1 t2 with
    | _ =&gt; tt
    end
  else
    tt.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="nativelambda" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>nativelambda.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)
open Util
open Names
open Esubst
open Constr
open Declarations
open Environ
open Nativevalues

module RelDecl = Context.Rel.Declaration

(** This file defines the lambda code generation phase of the native compiler *)
type prefix = string

type lambda =
  | Lrel          of Name.t * int
  | Lvar          of Id.t
  | Lmeta         of metavariable * lambda (* type *)
  | Levar         of Evar.t * lambda array (* arguments *)
  | Lprod         of lambda * lambda
  | Llam          of Name.t Context.binder_annot array * lambda
  | Lrec          of Name.t Context.binder_annot * lambda
  | Llet          of Name.t Context.binder_annot * lambda * lambda
  | Lapp          of lambda * lambda array
  | Lconst        of prefix * pconstant
  | Lproj         of prefix * inductive * int (* prefix, inductive, index starting from 0 *)
  | Lprim         of prefix * pconstant * CPrimitives.t * lambda array
        (* No check if None *)
  | Lcase         of annot_sw * lambda * lambda * lam_branches
                  (* annotations, term being matched, accu, branches *)
  | Lif           of lambda * lambda * lambda
  | Lfix          of (int array * (string * inductive) array * int) * fix_decl
  | Lcofix        of int * fix_decl
  | Lint          of int (* a constant constructor *)
  | Lmakeblock    of prefix * inductive * int * lambda array
                  (* prefix, inductive name, constructor tag, arguments *)
        (* A fully applied non-constant constructor *)
  | Luint         of Uint63.t
  | Lval          of Nativevalues.t
  | Lsort         of Sorts.t
  | Lind          of prefix * pinductive
  | Llazy
  | Lforce

and lam_branches =
  { constant_branches : lambda array;
    nonconstant_branches : (Name.t Context.binder_annot array * lambda) array;
  }

and fix_decl =  Name.t Context.binder_annot array * lambda array * lambda array

type evars =
    { evars_val : existential -&gt; constr option;
      evars_metas : metavariable -&gt; types }

(*s Constructors *)

let mkLapp f args =
  if Array.is_empty args then f
  else
    match f with
    | Lapp(f', args') -&gt; Lapp (f', Array.append args' args)
    | _ -&gt; Lapp(f, args)

let mkLlam ids body =
  if Array.is_empty ids then body
  else 
    match body with
    | Llam(ids', body) -&gt; Llam(Array.append ids ids', body)
    | _ -&gt; Llam(ids, body)

let decompose_Llam lam =
  match lam with
  | Llam(ids,body) -&gt; ids, body
  | _ -&gt; [||], lam

let rec decompose_Llam_Llet lam =
  match lam with
  | Llam(ids,body) -&gt;
      let vars, body = decompose_Llam_Llet body in
      Array.fold_right (fun x l -&gt; (x, None) :: l) ids vars, body
  | Llet(id,def,body) -&gt;
      let vars, body = decompose_Llam_Llet body in
      (id,Some def) :: vars, body
  | _ -&gt; [], lam

let decompose_Llam_Llet lam =
  let vars, body = decompose_Llam_Llet lam in
  Array.of_list vars, body

(*s Operators on substitution *)
let subst_id = subs_id 0
let lift = subs_lift 
let liftn = subs_liftn
let cons v subst = subs_cons([|v|], subst)
let shift subst = subs_shft (1, subst)

(* Linked code location utilities *)
let get_mind_prefix env mind =
   let _,name = lookup_mind_key mind env in
   match !name with
   | NotLinked -&gt; &quot;&quot;
   | Linked s -&gt; s
   | LinkedInteractive s -&gt; s

let get_const_prefix env c =
   let _,(nameref,_) = lookup_constant_key c env in
   match !nameref with
   | NotLinked -&gt; &quot;&quot;
   | Linked s -&gt; s
   | LinkedInteractive s -&gt; s

(* A generic map function *)

let map_lam_with_binders g f n lam =
  match lam with
  | Lrel _ | Lvar _  | Lconst _ | Lproj _ | Lval _ | Lsort _ | Lind _ | Luint _
  | Llazy | Lforce | Lmeta _ | Lint _ -&gt; lam
  | Lprod(dom,codom) -&gt; 
      let dom' = f n dom in
      let codom' = f n codom in
      if dom == dom' &amp;&amp; codom == codom' then lam else Lprod(dom',codom')
  | Llam(ids,body) -&gt;
      let body' = f (g (Array.length ids) n) body in
      if body == body' then lam else mkLlam ids body'
  | Lrec(id,body) -&gt;
      let body' = f (g 1 n) body in
      if body == body' then lam else Lrec(id,body')
  | Llet(id,def,body) -&gt;
      let def' = f n def in
      let body' = f (g 1 n) body in
      if body == body' &amp;&amp; def == def' then lam else Llet(id,def',body')
  | Lapp(fct,args) -&gt;
      let fct' = f n fct in
      let args' = Array.Smart.map (f n) args in
      if fct == fct' &amp;&amp; args == args' then lam else mkLapp fct' args'
  | Lprim(prefix,kn,op,args) -&gt;
      let args' = Array.Smart.map (f n) args in
      if args == args' then lam else Lprim(prefix,kn,op,args')
  | Lcase(annot,t,a,branches) -&gt;
    let const = branches.constant_branches in
    let nonconst = branches.nonconstant_branches in
    let t' = f n t in
    let a' = f n a in
    let const' = Array.Smart.map (f n) const in
    let on_b b =
      let (ids,body) = b in
      let body' = f (g (Array.length ids) n) body in
      if body == body' then b else (ids,body') in
    let nonconst' = Array.Smart.map on_b nonconst in
    let branches' =
      if const == const' &amp;&amp; nonconst == nonconst' then
        branches
      else
        { constant_branches = const';
          nonconstant_branches = nonconst' }
    in
    if t == t' &amp;&amp; a == a' &amp;&amp; branches == branches' then lam else
      Lcase(annot,t',a',branches')
  | Lif(t,bt,bf) -&gt;
      let t' = f n t in
      let bt' = f n bt in
      let bf' = f n bf in
      if t == t' &amp;&amp; bt == bt' &amp;&amp; bf == bf' then lam else Lif(t',bt',bf')
  | Lfix(init,(ids,ltypes,lbodies)) -&gt;
      let ltypes' = Array.Smart.map (f n) ltypes in
      let lbodies' = Array.Smart.map (f (g (Array.length ids) n)) lbodies in
      if ltypes == ltypes' &amp;&amp; lbodies == lbodies' then lam
      else Lfix(init,(ids,ltypes',lbodies'))
  | Lcofix(init,(ids,ltypes,lbodies)) -&gt;
      let ltypes' = Array.Smart.map (f n) ltypes in
      let lbodies' = Array.Smart.map (f (g (Array.length ids) n)) lbodies in
      if ltypes == ltypes' &amp;&amp; lbodies == lbodies' then lam
      else Lcofix(init,(ids,ltypes',lbodies'))
  | Lmakeblock(prefix,cn,tag,args) -&gt;
      let args' = Array.Smart.map (f n) args in
      if args == args' then lam else Lmakeblock(prefix,cn,tag,args')
  | Levar (evk, args) -&gt;
    let args' = Array.Smart.map (f n) args in
    if args == args' then lam else Levar (evk, args')

(*s Lift and substitution *)
 
let rec lam_exlift el lam =
  match lam with
  | Lrel(id,i) -&gt; 
      let i' = reloc_rel i el in
      if i == i' then lam else Lrel(id,i')
  | _ -&gt; map_lam_with_binders el_liftn lam_exlift el lam

let lam_lift k lam =
  if Int.equal k 0 then lam
  else lam_exlift (el_shft k el_id) lam

let lam_subst_rel lam id n subst =
  match expand_rel n subst with
  | Inl(k,v) -&gt; lam_lift k v
  | Inr(n',_) -&gt; 
      if n == n' then lam
      else Lrel(id, n') 

let rec lam_exsubst subst lam =
  match lam with
  | Lrel(id,i) -&gt; lam_subst_rel lam id i subst
  | _ -&gt; map_lam_with_binders liftn lam_exsubst subst lam

let lam_subst_args subst args =
  if is_subs_id subst then args 
  else Array.Smart.map (lam_exsubst subst) args
  
(** Simplification of lambda expression *)
      
(* [simplify subst lam] simplify the expression [lam_subst subst lam] *)
(* that is :                                                          *)
(* - Reduce [let] is the definition can be substituted i.e:           *)
(*    - a variable (rel or Id.t)                                *)
 (*    - a constant                                                    *)
(*    - a structured constant                                         *)
(*    - a function                                                    *)
(* - Transform beta redex into [let] expression                       *)
(* - Move arguments under [let]                                       *) 
(* Invariant : Terms in [subst] are already simplified and can be     *)
(*             substituted                                            *)
  
let can_subst lam = 
  match lam with
  | Lrel _ | Lvar _ | Lconst _ | Lproj _ | Lval _ | Lsort _ | Lind _ | Llam _
  | Lmeta _ | Levar _ -&gt; true
  | _ -&gt; false

let can_merge_if bt bf =
  match bt, bf with
  | Llam(_idst,_), Llam(_idsf,_) -&gt; true
  | _ -&gt; false

let merge_if t bt bf =
  let (idst,bodyt) = decompose_Llam bt in
  let (idsf,bodyf) = decompose_Llam bf in
  let nt = Array.length idst in
  let nf = Array.length idsf in
  let common,idst,idsf = 
    if Int.equal nt nf then idst, [||], [||] 
    else
      if nt &lt; nf then idst,[||], Array.sub idsf nt (nf - nt)
      else idsf, Array.sub idst nf (nt - nf), [||] in
  Llam(common,
       Lif(lam_lift (Array.length common) t, 
	   mkLlam idst bodyt,
	   mkLlam idsf bodyf))

let rec simplify subst lam =
  match lam with
  | Lrel(id,i) -&gt; lam_subst_rel lam id i subst 

  | Llet(id,def,body) -&gt;
      let def' = simplify subst def in
      if can_subst def' then simplify (cons def' subst) body
      else 
	let body' = simplify (lift subst) body in
	if def == def' &amp;&amp; body == body' then lam
	else Llet(id,def',body')

  | Lapp(f,args) -&gt;
      begin match simplify_app subst f subst args with
      | Lapp(f',args') when f == f' &amp;&amp; args == args' -&gt; lam
      | lam' -&gt; lam'
      end

  | Lif(t,bt,bf) -&gt;
      let t' = simplify subst t in
      let bt' = simplify subst bt in
      let bf' = simplify subst bf in
      if can_merge_if bt' bf' then merge_if t' bt' bf'
      else 
	if t == t' &amp;&amp; bt == bt' &amp;&amp; bf == bf' then lam
	else Lif(t',bt',bf')
  | _ -&gt; map_lam_with_binders liftn simplify subst lam

and simplify_app substf f substa args =
  match f with
  | Lrel(id, i) -&gt;
      begin match lam_subst_rel f id i substf with
      | Llam(ids, body) -&gt;
	  reduce_lapp 
	    subst_id (Array.to_list ids) body  
	    substa (Array.to_list args)
      | f' -&gt; mkLapp f' (simplify_args substa args)
      end
  | Llam(ids, body) -&gt;
      reduce_lapp substf (Array.to_list ids) body substa (Array.to_list args)
  | Llet(id, def, body) -&gt;
      let def' = simplify substf def in
      if can_subst def' then
	simplify_app (cons def' substf) body substa args
      else 
	Llet(id, def', simplify_app (lift substf) body (shift substa) args)
  | Lapp(f, args') -&gt;
      let args = Array.append 
	  (lam_subst_args substf args') (lam_subst_args substa args) in
      simplify_app substf f subst_id args
  (* TODO | Lproj -&gt; simplify if the argument is known or a known global *)
  | _ -&gt; mkLapp (simplify substf f) (simplify_args substa args)
  
and simplify_args subst args = Array.Smart.map (simplify subst) args

and reduce_lapp substf lids body substa largs =
  match lids, largs with
  | id::lids, a::largs -&gt;
      let a = simplify substa a in
      if can_subst a then
	reduce_lapp (cons a substf) lids body substa largs
      else
	let body = reduce_lapp (lift substf) lids body (shift substa) largs in
	Llet(id, a, body)
  | [], [] -&gt; simplify substf body
  | _::_, _ -&gt; 
      Llam(Array.of_list lids,  simplify (liftn (List.length lids) substf) body)
  | [], _::_ -&gt; simplify_app substf body substa (Array.of_list largs)

(*s Translation from [constr] to [lambda] *)

(* Translation of constructor *)

let is_value lc =
  match lc with
  | Lval _ | Lint _ | Luint _ -&gt; true
  | _ -&gt; false

let get_value lc =
  match lc with
  | Lval v -&gt; v
  | Lint tag -&gt; Nativevalues.mk_int tag
  | Luint i -&gt; Nativevalues.mk_uint i
  | _ -&gt; raise Not_found

let make_args start _end =
  Array.init (start - _end + 1) (fun i -&gt; Lrel (Anonymous, start - i))
    
(* Translation of constructors *)	
let expand_constructor prefix ind tag nparams arity =
  let anon = Context.make_annot Anonymous Sorts.Relevant in (* TODO relevance *)
  let ids = Array.make (nparams + arity) anon in
  if Int.equal arity 0 then mkLlam ids (Lint tag)
  else
  let args = make_args arity 1 in
  Llam(ids, Lmakeblock (prefix, ind, tag, args))

(* [nparams] is the number of parameters still expected *)
let makeblock env ind tag nparams arity args =
  let nargs = Array.length args in
  if nparams &gt; 0 || nargs &lt; arity then
    let prefix = get_mind_prefix env (fst ind) in
    mkLapp (expand_constructor prefix ind tag nparams arity) args
  else
  (* The constructor is fully applied *)
  if Int.equal arity 0 then Lint tag
  else
  if Array.for_all is_value args then
    let args = Array.map get_value args in
    Lval (Nativevalues.mk_block tag args)
  else
    let prefix = get_mind_prefix env (fst ind) in
    Lmakeblock(prefix, ind, tag, args)

(* Translation of constants *)

let rec get_alias env (kn, u as p) =
  let tps = (lookup_constant kn env).const_body_code in
    match tps with
    | None -&gt; p
    | Some tps -&gt;
       match Cemitcodes.force tps with
       | Cemitcodes.BCalias kn' -&gt; get_alias env (kn', u)
       | _ -&gt; p

let prim env kn p args =
  let prefix = get_const_prefix env (fst kn) in
  Lprim(prefix, kn, p, args)

let expand_prim env kn op arity =
  (* primitives are always Relevant *)
  let ids = Array.make arity Context.anonR in
  let args = make_args arity 1 in
  Llam(ids, prim env kn op args)

let lambda_of_prim env kn op args =
  let arity = CPrimitives.arity op in
  if Array.length args &gt;= arity then prim env kn op args
  else mkLapp (expand_prim env kn op arity) args

(*i Global environment *)

let get_names decl = 
  let decl = Array.of_list decl in
  Array.map fst decl

let empty_args = [||]

module Cache =
  struct

    module ConstrHash =
    struct
      type t = constructor
      let equal = eq_constructor
      let hash = constructor_hash
    end

    module ConstrTable = Hashtbl.Make(ConstrHash)

    type constructor_info = tag * int * int (* nparam nrealargs *)

    let get_construct_info cache env c : constructor_info =
      try ConstrTable.find cache c
      with Not_found -&gt;
	let ((mind,j), i) = c in
        let oib = lookup_mind mind env in
	let oip = oib.mind_packets.(j) in
	let tag,arity = oip.mind_reloc_tbl.(i-1) in
	let nparams = oib.mind_nparams in
	let r = (tag, nparams, arity) in
        ConstrTable.add cache c r;
	r
  end

let is_lazy t =
  match Constr.kind t with
  | App _ | LetIn _ | Case _ | Proj _ -&gt; true
  | _ -&gt; false

let evar_value sigma ev = sigma.evars_val ev

let meta_type sigma mv = sigma.evars_metas mv

let empty_evars =
  { evars_val = (fun _ -&gt; None);
    evars_metas = (fun _ -&gt; assert false) }

(** Extract the inductive type over which a fixpoint is decreasing *)
let rec get_fix_struct env i t = match kind (Reduction.whd_all env t) with
| Prod (na, dom, t) -&gt;
  if Int.equal i 0 then
    let dom = Reduction.whd_all env dom in
    let (dom, _) = decompose_appvect dom in
    match kind dom with
    | Ind (ind, _) -&gt; ind
    | _ -&gt; assert false
  else
    let env = Environ.push_rel (RelDecl.LocalAssum (na, dom)) env in
    get_fix_struct env (i - 1) t
| _ -&gt; assert false

let rec lambda_of_constr cache env sigma c =
  match kind c with
  | Meta mv -&gt;
     let ty = meta_type sigma mv in
     Lmeta (mv, lambda_of_constr cache env sigma ty)

  | Evar (evk,args as ev) -&gt;
     (match evar_value sigma ev with
     | None -&gt;
        let args = Array.map (lambda_of_constr cache env sigma) args in
        Levar(evk, args)
     | Some t -&gt; lambda_of_constr cache env sigma t)

  | Cast (c, _, _) -&gt; lambda_of_constr cache env sigma c

  | Rel i -&gt; Lrel (RelDecl.get_name (Environ.lookup_rel i env), i)

  | Var id -&gt; Lvar id

  | Sort s -&gt; Lsort s

  | Ind (ind,_u as pind) -&gt;
      let prefix = get_mind_prefix env (fst ind) in
      Lind (prefix, pind)

  | Prod(id, dom, codom) -&gt;
      let ld = lambda_of_constr cache env sigma dom in
      let env = Environ.push_rel (RelDecl.LocalAssum (id, dom)) env in
      let lc = lambda_of_constr cache env sigma codom in
      Lprod(ld,  Llam([|id|], lc))

  | Lambda _ -&gt;
      let params, body = Term.decompose_lam c in
      let fold (na, t) env = Environ.push_rel (RelDecl.LocalAssum (na, t)) env in
      let env = List.fold_right fold params env in
      let lb = lambda_of_constr cache env sigma body in
      let ids = get_names (List.rev params) in
      mkLlam ids lb

  | LetIn(id, def, t, body) -&gt;
      let ld = lambda_of_constr cache env sigma def in
      let env = Environ.push_rel (RelDecl.LocalDef (id, def, t)) env in
      let lb = lambda_of_constr cache env sigma body in
      Llet(id, ld, lb)

  | App(f, args) -&gt; lambda_of_app cache env sigma f args

  | Const _ -&gt; lambda_of_app cache env sigma c empty_args

  | Construct _ -&gt;  lambda_of_app cache env sigma c empty_args

  | Proj (p, c) -&gt;
    let ind = Projection.inductive p in
    let prefix = get_mind_prefix env (fst ind) in
    mkLapp (Lproj (prefix, ind, Projection.arg p)) [|lambda_of_constr cache env sigma c|]

  | Case(ci,t,a,branches) -&gt;
    let (mind,i as ind) = ci.ci_ind in
    let mib = lookup_mind mind env in
    let oib = mib.mind_packets.(i) in
    let tbl = oib.mind_reloc_tbl in
    (* Building info *)
    let prefix = get_mind_prefix env mind in
    let annot_sw =
      { asw_ind = ind;
        asw_ci = ci;
        asw_reloc = tbl;
        asw_finite = mib.mind_finite &lt;&gt; CoFinite;
        asw_prefix = prefix}
    in
    (* translation of the argument *)
    let la = lambda_of_constr cache env sigma a in
    (* translation of the type *)
    let lt = lambda_of_constr cache env sigma t in
    (* translation of branches *)
    let dummy = Lrel(Anonymous,0) in
    let consts = Array.make oib.mind_nb_constant dummy in
    let blocks = Array.make oib.mind_nb_args ([||],dummy) in
    let rtbl = oib.mind_reloc_tbl in
    for i = 0 to Array.length rtbl - 1 do
      let tag, arity = rtbl.(i) in
      let b = lambda_of_constr cache env sigma branches.(i) in
      if arity = 0 then consts.(tag) &lt;- b
      else
        let b =
          match b with
          | Llam(ids, body) when Array.length ids = arity -&gt; (ids, body)
          | _ -&gt;
            let anon = Context.make_annot Anonymous Sorts.Relevant in (* TODO relevance *)
            let ids = Array.make arity anon in
            let args = make_args arity 1 in
            let ll = lam_lift arity b in
            (ids, mkLapp  ll args)
        in blocks.(tag-1) &lt;- b
    done;
    let branches =
      { constant_branches = consts;
        nonconstant_branches = blocks }
    in
    Lcase(annot_sw, lt, la, branches)

  | Fix((pos, i), (names,type_bodies,rec_bodies)) -&gt;
      let ltypes = lambda_of_args cache env sigma 0 type_bodies in
      let map i t =
        let ind = get_fix_struct env i t in
        let prefix = get_mind_prefix env (fst ind) in
        (prefix, ind)
      in
      let inds = Array.map2 map pos type_bodies in
      let env = Environ.push_rec_types (names, type_bodies, rec_bodies) env in
      let lbodies = lambda_of_args cache env sigma 0 rec_bodies in
      Lfix((pos, inds, i), (names, ltypes, lbodies))

  | CoFix(init,(names,type_bodies,rec_bodies)) -&gt;
      let rec_bodies = Array.map2 (Reduction.eta_expand env) rec_bodies type_bodies in
      let ltypes = lambda_of_args cache env sigma 0 type_bodies in
      let env = Environ.push_rec_types (names, type_bodies, rec_bodies) env in
      let lbodies = lambda_of_args cache env sigma 0 rec_bodies in
      Lcofix(init, (names, ltypes, lbodies))

  | Int i -&gt; Luint i

and lambda_of_app cache env sigma f args =
  match kind f with
  | Const (_kn,_u as c) -&gt;
      let kn,u = get_alias env c in
      let cb = lookup_constant kn env in
      begin match cb.const_body with
      | Primitive op -&gt; lambda_of_prim env c op (lambda_of_args cache env sigma 0 args)
      | Def csubst -&gt; (* TODO optimize if f is a proj and argument is known *)
          if cb.const_inline_code then
            lambda_of_app cache env sigma (Mod_subst.force_constr csubst) args
          else
          let prefix = get_const_prefix env kn in
          let t =
            if is_lazy (Mod_subst.force_constr csubst) then
              mkLapp Lforce [|Lconst (prefix, (kn,u))|]
            else Lconst (prefix, (kn,u))
          in
        mkLapp t (lambda_of_args cache env sigma 0 args)
      | OpaqueDef _ | Undef _ -&gt;
          let prefix = get_const_prefix env kn in
          mkLapp (Lconst (prefix, (kn,u))) (lambda_of_args cache env sigma 0 args)
      end
  | Construct ((ind,_ as c),_) -&gt;
    let tag, nparams, arity = Cache.get_construct_info cache env c in
    let nargs = Array.length args in
    if nparams &lt; nargs then (* got all parameters *)
      let args = lambda_of_args cache env sigma nparams args in
      makeblock env ind tag 0 arity args
    else makeblock env ind tag (nparams - nargs) arity empty_args
  | _ -&gt; 
      let f = lambda_of_constr cache env sigma f in
      let args = lambda_of_args cache env sigma 0 args in
      mkLapp f args
	
and lambda_of_args cache env sigma start args =
  let nargs = Array.length args in
  if start &lt; nargs then
    Array.init (nargs - start) 
      (fun i -&gt; lambda_of_constr cache env sigma args.(start + i))
  else empty_args

let optimize lam =
  let lam = simplify subst_id lam in
(*  if Flags.vm_draw_opt () then 
    (msgerrnl (str &quot;Simplify = \n&quot; ++ pp_lam lam);flush_all()); 
  let lam = remove_let subst_id lam in
  if Flags.vm_draw_opt () then 
    (msgerrnl (str &quot;Remove let = \n&quot; ++ pp_lam lam);flush_all()); *)
  lam

let lambda_of_constr env sigma c =
  let cache = Cache.ConstrTable.create 91 in
  let lam = lambda_of_constr cache env sigma c in
(*  if Flags.vm_draw_opt () then begin
    (msgerrnl (str &quot;Constr = \n&quot; ++ pr_constr c);flush_all()); 
    (msgerrnl (str &quot;Lambda = \n&quot; ++ pp_lam lam);flush_all()); 
  end; *)
  optimize lam

let mk_lazy c =
  mkLapp Llazy [|c|]
</pre>
          </div>
          <div class="col-md-6">
            <code>nativelambda.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Util.

Import Names.

Import Esubst.

Import Constr.

Import Declarations.

Import Environ.

Import Nativevalues.

Definition prefix := string.

Reserved Notation &quot;'fix_decl&quot;.

Inductive lambda : Type :=
| Lrel : Names.Name.t -&gt; Z -&gt; lambda
| Lvar : Names.Id.t -&gt; lambda
| Lmeta : Constr.metavariable -&gt; lambda -&gt; lambda
| Levar : Evar.t -&gt; (array lambda) -&gt; lambda
| Lprod : lambda -&gt; lambda -&gt; lambda
| Llam : (array (Context.binder_annot Names.Name.t)) -&gt; lambda -&gt; lambda
| Lrec : (Context.binder_annot Names.Name.t) -&gt; lambda -&gt; lambda
| Llet : (Context.binder_annot Names.Name.t) -&gt; lambda -&gt; lambda -&gt; lambda
| Lapp : lambda -&gt; (array lambda) -&gt; lambda
| Lconst : prefix -&gt; Constr.pconstant -&gt; lambda
| Lproj : prefix -&gt; Names.inductive -&gt; Z -&gt; lambda
| Lprim : prefix -&gt; Constr.pconstant -&gt; CPrimitives.t -&gt; (array lambda) -&gt;
  lambda
| Lcase : Nativevalues.annot_sw -&gt; lambda -&gt; lambda -&gt; lam_branches -&gt; lambda
| Lif : lambda -&gt; lambda -&gt; lambda -&gt; lambda
| Lfix : ((array Z) * (array (string * Names.inductive)) * Z) -&gt; 'fix_decl -&gt;
  lambda
| Lcofix : Z -&gt; 'fix_decl -&gt; lambda
| Lint : Z -&gt; lambda
| Lmakeblock : prefix -&gt; Names.inductive -&gt; Z -&gt; (array lambda) -&gt; lambda
| Luint : Uint63.t -&gt; lambda
| Lval : Nativevalues.t -&gt; lambda
| Lsort : Sorts.t -&gt; lambda
| Lind : prefix -&gt; Constr.pinductive -&gt; lambda
| Llazy : lambda
| Lforce : lambda

where &quot;'fix_decl&quot; := (
  (array (Context.binder_annot Names.Name.t)) * (array lambda) * (array lambda)).

Definition fix_decl := 'fix_decl.

Record evars := {
  evars_val : Constr.existential -&gt; option Constr.constr;
  evars_metas : Constr.metavariable -&gt; Constr.types }.

Definition mkLapp (f : lambda) (args : array lambda) : lambda :=
  if Util.Array.(CArray.ExtS.is_empty) args then
    f
  else
    match f with
    | Lapp f' args' =&gt; Lapp f' (Util.Array.(CArray.ExtS.append) args' args)
    | _ =&gt; Lapp f args
    end.

Definition mkLlam
  (ids : array (Context.binder_annot Names.Name.t)) (body : lambda) : lambda :=
  if Util.Array.(CArray.ExtS.is_empty) ids then
    body
  else
    match body with
    | Llam ids' body =&gt; Llam (Util.Array.(CArray.ExtS.append) ids ids') body
    | _ =&gt; Llam ids body
    end.

Definition decompose_Llam (lam : lambda)
  : (array (Context.binder_annot Names.Name.t)) * lambda :=
  match lam with
  | Llam ids body =&gt; (ids, body)
  | _ =&gt; (tt, lam)
  end.

Fixpoint decompose_Llam_Llet (lam : lambda)
  : (list ((Context.binder_annot Names.Name.t) * (option lambda))) * lambda :=
  match lam with
  | Llam ids body =&gt;
    match decompose_Llam_Llet body with
    | (vars, body) =&gt;
      ((Util.Array.(CArray.ExtS.fold_right) (fun x =&gt; fun l =&gt; cons (x, None) l)
        ids vars), body)
    end
  | Llet id def body =&gt;
    match decompose_Llam_Llet body with
    | (vars, body) =&gt; ((cons (id, (Some def)) vars), body)
    end
  | _ =&gt; ([], lam)
  end.

Definition decompose_Llam_Llet (lam : lambda)
  : (array ((Context.binder_annot Names.Name.t) * (option lambda))) * lambda :=
  match decompose_Llam_Llet lam with
  | (vars, body) =&gt; ((Util.Array.(CArray.ExtS.of_list) vars), body)
  end.

Definition subst_id : Esubst.subs lambda := Esubst.subs_id 0.

Definition lift {A : Type} : (Esubst.subs A) -&gt; Esubst.subs A :=
  Esubst.subs_lift.

Definition liftn {A : Type} : Z -&gt; (Esubst.subs A) -&gt; Esubst.subs A :=
  Esubst.subs_liftn.

Definition cons {A : Type} (v : A) (subst : Esubst.subs A) : Esubst.subs A :=
  Esubst.subs_cons ((v), subst).

Definition shift {A : Type} (subst : Esubst.subs A) : Esubst.subs A :=
  Esubst.subs_shft (1, subst).

Definition get_mind_prefix (env : Environ.env) (mind : Names.MutInd.t)
  : string :=
  match Environ.lookup_mind_key mind env with
  | (_, name) =&gt;
    match Util.op_exclamation name with
    | NotLinked =&gt; &quot;&quot; % string
    | Linked s =&gt; s
    | LinkedInteractive s =&gt; s
    end
  end.

Definition get_const_prefix (env : Environ.env) (c : Names.Constant.t)
  : string :=
  match Environ.lookup_constant_key c env with
  | (_, (nameref, _)) =&gt;
    match Util.op_exclamation nameref with
    | NotLinked =&gt; &quot;&quot; % string
    | Linked s =&gt; s
    | LinkedInteractive s =&gt; s
    end
  end.

Definition map_lam_with_binders {A : Type}
  (g : Z -&gt; A -&gt; A) (f : A -&gt; lambda -&gt; lambda) (n : A) (lam : lambda)
  : lambda :=
  match lam with
  |
    Lrel _ _ | Lvar _ | Lconst _ _ | Lproj _ _ _ | Lval _ | Lsort _ | Lind _ _ |
      Luint _ | Llazy | Lforce | Lmeta _ _ | Lint _ =&gt; lam
  | Lprod dom codom =&gt;
    let dom' := f n dom in
    let codom' := f n codom in
    if andb (Stdlib.op_eq_eq dom dom') (Stdlib.op_eq_eq codom codom') then
      lam
    else
      Lprod dom' codom'
  | Llam ids body =&gt;
    let body' := f (g (Util.Array.(CArray.ExtS.length) ids) n) body in
    if Stdlib.op_eq_eq body body' then
      lam
    else
      mkLlam ids body'
  | Lrec id body =&gt;
    let body' := f (g 1 n) body in
    if Stdlib.op_eq_eq body body' then
      lam
    else
      Lrec id body'
  | Llet id def body =&gt;
    let def' := f n def in
    let body' := f (g 1 n) body in
    if andb (Stdlib.op_eq_eq body body') (Stdlib.op_eq_eq def def') then
      lam
    else
      Llet id def' body'
  | Lapp fct args =&gt;
    let fct' := f n fct in
    let args' := Util.Array.Smart.map (f n) args in
    if andb (Stdlib.op_eq_eq fct fct') (Stdlib.op_eq_eq args args') then
      lam
    else
      mkLapp fct' args'
  | Lprim prefix kn op args =&gt;
    let args' := Util.Array.Smart.map (f n) args in
    if Stdlib.op_eq_eq args args' then
      lam
    else
      Lprim prefix kn op args'
  | Lcase annot t a branches =&gt;
    let const := constant_branches branches in
    let nonconst := nonconstant_branches branches in
    let t' := f n t in
    let a' := f n a in
    let const' := Util.Array.Smart.map (f n) const in
    let on_b {B : Type} (b : (array B) * lambda) : (array B) * lambda :=
      match b with
      | (ids, body) =&gt;
        let body' := f (g (Util.Array.(CArray.ExtS.length) ids) n) body in
        if Stdlib.op_eq_eq body body' then
          b
        else
          (ids, body')
      end in
    let nonconst' := Util.Array.Smart.map on_b nonconst in
    let branches' :=
      if
        andb (Stdlib.op_eq_eq const const') (Stdlib.op_eq_eq nonconst nonconst')
        then
        branches
      else
        {| constant_branches := const'; nonconstant_branches := nonconst' |} in
    if
      andb (Stdlib.op_eq_eq t t')
        (andb (Stdlib.op_eq_eq a a') (Stdlib.op_eq_eq branches branches')) then
      lam
    else
      Lcase annot t' a' branches'
  | Lif t bt bf =&gt;
    let t' := f n t in
    let bt' := f n bt in
    let bf' := f n bf in
    if
      andb (Stdlib.op_eq_eq t t')
        (andb (Stdlib.op_eq_eq bt bt') (Stdlib.op_eq_eq bf bf')) then
      lam
    else
      Lif t' bt' bf'
  | Lfix init (ids, ltypes, lbodies) =&gt;
    let ltypes' := Util.Array.Smart.map (f n) ltypes in
    let lbodies' :=
      Util.Array.Smart.map (f (g (Util.Array.(CArray.ExtS.length) ids) n))
        lbodies in
    if andb (Stdlib.op_eq_eq ltypes ltypes') (Stdlib.op_eq_eq lbodies lbodies')
      then
      lam
    else
      Lfix init (ids, ltypes', lbodies')
  | Lcofix init (ids, ltypes, lbodies) =&gt;
    let ltypes' := Util.Array.Smart.map (f n) ltypes in
    let lbodies' :=
      Util.Array.Smart.map (f (g (Util.Array.(CArray.ExtS.length) ids) n))
        lbodies in
    if andb (Stdlib.op_eq_eq ltypes ltypes') (Stdlib.op_eq_eq lbodies lbodies')
      then
      lam
    else
      Lcofix init (ids, ltypes', lbodies')
  | Lmakeblock prefix cn tag args =&gt;
    let args' := Util.Array.Smart.map (f n) args in
    if Stdlib.op_eq_eq args args' then
      lam
    else
      Lmakeblock prefix cn tag args'
  | Levar evk args =&gt;
    let args' := Util.Array.Smart.map (f n) args in
    if Stdlib.op_eq_eq args args' then
      lam
    else
      Levar evk args'
  end.

Fixpoint lam_exlift (el : Esubst.lift) (lam : lambda) : lambda :=
  match lam with
  | Lrel id i =&gt;
    let i' := Esubst.reloc_rel i el in
    if Stdlib.op_eq_eq i i' then
      lam
    else
      Lrel id i'
  | _ =&gt; map_lam_with_binders Esubst.el_liftn lam_exlift el lam
  end.

Definition lam_lift (k : Int.t) (lam : lambda) : lambda :=
  if Int.equal k 0 then
    lam
  else
    lam_exlift (Esubst.el_shft k Esubst.el_id) lam.

Definition lam_subst_rel
  (lam : lambda) (id : Names.Name.t) (n : Z) (subst : Esubst.subs lambda)
  : lambda :=
  match Esubst.expand_rel n subst with
  | Inl (k, v) =&gt; lam_lift k v
  | Inr (n', _) =&gt;
    if Stdlib.op_eq_eq n n' then
      lam
    else
      Lrel id n'
  end.

Fixpoint lam_exsubst (subst : Esubst.subs lambda) (lam : lambda) : lambda :=
  match lam with
  | Lrel id i =&gt; lam_subst_rel lam id i subst
  | _ =&gt; map_lam_with_binders liftn lam_exsubst subst lam
  end.

Definition lam_subst_args (subst : Esubst.subs lambda) (args : array lambda)
  : array lambda :=
  if Esubst.is_subs_id subst then
    args
  else
    Util.Array.Smart.map (lam_exsubst subst) args.

Definition can_subst (lam : lambda) : bool :=
  match lam with
  |
    Lrel _ _ | Lvar _ | Lconst _ _ | Lproj _ _ _ | Lval _ | Lsort _ | Lind _ _ |
      Llam _ _ | Lmeta _ _ | Levar _ _ =&gt; true
  | _ =&gt; false
  end.

Definition can_merge_if (bt : lambda) (bf : lambda) : bool :=
  match (bt, bf) with
  | (Llam _idst _, Llam _idsf _) =&gt; true
  | _ =&gt; false
  end.

Definition merge_if (t : lambda) (bt : lambda) (bf : lambda) : lambda :=
  match decompose_Llam bt with
  | (idst, bodyt) =&gt;
    match decompose_Llam bf with
    | (idsf, bodyf) =&gt;
      let nt := Util.Array.(CArray.ExtS.length) idst in
      let nf := Util.Array.(CArray.ExtS.length) idsf in
      match
        if Int.equal nt nf then
          (idst, tt, tt)
        else
          if OCaml.Stdlib.lt nt nf then
            (idst, tt,
              (Util.Array.(CArray.ExtS.sub) idsf nt (Util.op_minus nf nt)))
          else
            (idsf, (Util.Array.(CArray.ExtS.sub) idst nf (Util.op_minus nt nf)),
              tt) with
      | (common, idst, idsf) =&gt;
        Llam common
          (Lif (lam_lift (Util.Array.(CArray.ExtS.length) common) t)
            (mkLlam idst bodyt) (mkLlam idsf bodyf))
      end
    end
  end.

Fixpoint simplify (subst : Esubst.subs lambda) (lam : lambda) : lambda :=
  match lam with
  | Lrel id i =&gt; lam_subst_rel lam id i subst
  | Llet id def body =&gt;
    let def' := simplify subst def in
    if can_subst def' then
      simplify (cons def' subst) body
    else
      let body' := simplify (lift subst) body in
      if andb (Stdlib.op_eq_eq def def') (Stdlib.op_eq_eq body body') then
        lam
      else
        Llet id def' body'
  | Lapp f args =&gt;
    match simplify_app subst f subst args with
    | lam' =&gt; lam'
    end
  | Lif t bt bf =&gt;
    let t' := simplify subst t in
    let bt' := simplify subst bt in
    let bf' := simplify subst bf in
    if can_merge_if bt' bf' then
      merge_if t' bt' bf'
    else
      if
        andb (Stdlib.op_eq_eq t t')
          (andb (Stdlib.op_eq_eq bt bt') (Stdlib.op_eq_eq bf bf')) then
        lam
      else
        Lif t' bt' bf'
  | _ =&gt; map_lam_with_binders liftn simplify subst lam
  end

with simplify_app
  (substf : Esubst.subs lambda) (f : lambda) (substa : Esubst.subs lambda)
  (args : array lambda) : lambda :=
  match f with
  | Lrel id i =&gt;
    match lam_subst_rel f id i substf with
    | Llam ids body =&gt;
      reduce_lapp subst_id (Util.Array.(CArray.ExtS.to_list) ids) body substa
        (Util.Array.(CArray.ExtS.to_list) args)
    | f' =&gt; mkLapp f' (simplify_args substa args)
    end
  | Llam ids body =&gt;
    reduce_lapp substf (Util.Array.(CArray.ExtS.to_list) ids) body substa
      (Util.Array.(CArray.ExtS.to_list) args)
  | Llet id def body =&gt;
    let def' := simplify substf def in
    if can_subst def' then
      simplify_app (cons def' substf) body substa args
    else
      Llet id def' (simplify_app (lift substf) body (shift substa) args)
  | Lapp f args' =&gt;
    let args :=
      Util.Array.(CArray.ExtS.append) (lam_subst_args substf args')
        (lam_subst_args substa args) in
    simplify_app substf f subst_id args
  | _ =&gt; mkLapp (simplify substf f) (simplify_args substa args)
  end

with simplify_args (subst : Esubst.subs lambda) (args : array lambda)
  : array lambda := Util.Array.Smart.map (simplify subst) args

with reduce_lapp
  (substf : Esubst.subs lambda)
  (lids : list (Context.binder_annot Names.Name.t)) (body : lambda)
  (substa : Esubst.subs lambda) (largs : list lambda) : lambda :=
  match (lids, largs) with
  | (cons id lids, cons a largs) =&gt;
    let a := simplify substa a in
    if can_subst a then
      reduce_lapp (cons a substf) lids body substa largs
    else
      let body := reduce_lapp (lift substf) lids body (shift substa) largs in
      Llet id a body
  | ([], []) =&gt; simplify substf body
  | (cons _ _, _) =&gt;
    Llam (Util.Array.(CArray.ExtS.of_list) lids)
      (simplify (liftn (Util.List.(CList.ExtS.length) lids) substf) body)
  | ([], cons _ _) =&gt;
    simplify_app substf body substa (Util.Array.(CArray.ExtS.of_list) largs)
  end.

Definition is_value (lc : lambda) : bool :=
  match lc with
  | Lval _ | Lint _ | Luint _ =&gt; true
  | _ =&gt; false
  end.

Definition get_value (lc : lambda) : Nativevalues.t :=
  match lc with
  | Lval v =&gt; v
  | Lint tag =&gt; Nativevalues.mk_int tag
  | Luint i =&gt; Nativevalues.mk_uint i
  | _ =&gt; Stdlib.raise OCaml.Not_found
  end.

Definition make_args (start : Z) (_end : Z) : array lambda :=
  Util.Array.(CArray.ExtS.init) (Util.op_plus (Util.op_minus start _end) 1)
    (fun i =&gt; Lrel Anonymous (Util.op_minus start i)).

Definition expand_constructor
  (prefix : prefix) (ind : Names.inductive) (tag : Z) (nparams : Z)
  (arity : Int.t) : lambda :=
  let anon := Context.make_annot Anonymous Sorts.Relevant in
  let ids := Util.Array.(CArray.ExtS.make) (Util.op_plus nparams arity) anon in
  if Int.equal arity 0 then
    mkLlam ids (Lint tag)
  else
    let args := make_args arity 1 in
    Llam ids (Lmakeblock prefix ind tag args).

Definition makeblock
  (env : Environ.env) (ind : Names.inductive) (tag : Nativevalues.tag)
  (nparams : Z) (arity : Int.t) (args : array lambda) : lambda :=
  let nargs := Util.Array.(CArray.ExtS.length) args in
  if orb (OCaml.Stdlib.gt nparams 0) (OCaml.Stdlib.lt nargs arity) then
    let prefix := get_mind_prefix env (fst ind) in
    mkLapp (expand_constructor prefix ind tag nparams arity) args
  else
    if Int.equal arity 0 then
      Lint tag
    else
      if Util.Array.(CArray.ExtS.for_all) is_value args then
        let args := Util.Array.(CArray.ExtS.map) get_value args in
        Lval (Nativevalues.mk_block tag args)
      else
        let prefix := get_mind_prefix env (fst ind) in
        Lmakeblock prefix ind tag args.

Fixpoint get_alias {A : Type}
  (env : Environ.env) (function_parameter : Names.Constant.t * A)
  : Names.Constant.t * A :=
  match function_parameter with
  | (kn, u) as p =&gt;
    let tps := const_body_code (Environ.lookup_constant kn env) in
    match tps with
    | None =&gt; p
    | Some tps =&gt;
      match Cemitcodes.force tps with
      | Cemitcodes.BCalias kn' =&gt; get_alias env (kn', u)
      | _ =&gt; p
      end
    end
  end.

Definition prim
  (env : Environ.env) (kn : Constr.pconstant) (p : CPrimitives.t)
  (args : array lambda) : lambda :=
  let prefix := get_const_prefix env (fst kn) in
  Lprim prefix kn p args.

Definition expand_prim
  (env : Environ.env) (kn : Constr.pconstant) (op : CPrimitives.t) (arity : Z)
  : lambda :=
  let ids := Util.Array.(CArray.ExtS.make) arity Context.anonR in
  let args := make_args arity 1 in
  Llam ids (prim env kn op args).

Definition lambda_of_prim
  (env : Environ.env) (kn : Constr.pconstant) (op : CPrimitives.t)
  (args : array lambda) : lambda :=
  let arity := CPrimitives.arity op in
  if OCaml.Stdlib.ge (Util.Array.(CArray.ExtS.length) args) arity then
    prim env kn op args
  else
    mkLapp (expand_prim env kn op arity) args.

Definition get_names {A B : Type} (decl : list (A * B)) : array A :=
  let decl := Util.Array.(CArray.ExtS.of_list) decl in
  Util.Array.(CArray.ExtS.map) fst decl.

Definition empty_args {A : Type} : array A := tt.

Module Cache.
  Module ConstrHash.
    Definition t := Names.constructor.
    
    Definition equal : Names.constructor -&gt; Names.constructor -&gt; bool :=
      Names.eq_constructor.
    
    Definition hash : Names.constructor -&gt; Z := Names.constructor_hash.
  End ConstrHash.
  
  Definition constructor_info := Nativevalues.tag * Z * Z.
  
  Definition get_construct_info
    (cache : ConstrTable.t constructor_info) (env : Environ.env)
    (c : ConstrTable.key) : constructor_info := try.
End Cache.

Definition is_lazy (t : Constr.constr) : bool :=
  match Constr.kind t with
  | App _ _ | LetIn _ _ _ _ | Case _ _ _ _ | Proj _ _ =&gt; true
  | _ =&gt; false
  end.

Definition evar_value (sigma : evars) (ev : Constr.existential)
  : option Constr.constr := (evars_val sigma) ev.

Definition meta_type (sigma : evars) (mv : Constr.metavariable)
  : Constr.types := (evars_metas sigma) mv.

Definition empty_evars : evars :=
  {|
    evars_val :=
      fun function_parameter =&gt;
        match function_parameter with
        | _ =&gt; None
        end;
    evars_metas :=
      fun function_parameter =&gt;
        match function_parameter with
        | _ =&gt; false
        end |}.

Fixpoint get_fix_struct (env : Environ.env) (i : Int.t) (t : Constr.constr)
  : Names.inductive :=
  match Constr.kind (Reduction.whd_all env t) with
  | Prod na dom t =&gt;
    if Int.equal i 0 then
      let dom := Reduction.whd_all env dom in
      match Constr.decompose_appvect dom with
      | (dom, _) =&gt;
        match Constr.kind dom with
        | Ind (ind, _) =&gt; ind
        | _ =&gt; false
        end
      end
    else
      let env := Environ.push_rel (RelDecl.LocalAssum na dom) env in
      get_fix_struct env (Util.op_minus i 1) t
  | _ =&gt; false
  end.

Fixpoint lambda_of_constr
  (cache : Cache.ConstrTable.t Cache.constructor_info) (env : Environ.env)
  (sigma : evars) (c : Constr.constr) : lambda :=
  match Constr.kind c with
  | Meta mv =&gt;
    let ty := meta_type sigma mv in
    Lmeta mv (lambda_of_constr cache env sigma ty)
  | Evar ((evk, args) as ev) =&gt;
    match evar_value sigma ev with
    | None =&gt;
      let args :=
        Util.Array.(CArray.ExtS.map) (lambda_of_constr cache env sigma) args in
      Levar evk args
    | Some t =&gt; lambda_of_constr cache env sigma t
    end
  | Cast c _ _ =&gt; lambda_of_constr cache env sigma c
  | Rel i =&gt; Lrel (RelDecl.get_name (Environ.lookup_rel i env)) i
  | Var id =&gt; Lvar id
  | Sort s =&gt; Lsort s
  | Ind ((ind, _u) as pind) =&gt;
    let prefix := get_mind_prefix env (fst ind) in
    Lind prefix pind
  | Prod id dom codom =&gt;
    let ld := lambda_of_constr cache env sigma dom in
    let env := Environ.push_rel (RelDecl.LocalAssum id dom) env in
    let lc := lambda_of_constr cache env sigma codom in
    Lprod ld (Llam (id) lc)
  | Lambda _ _ _ =&gt;
    match Term.decompose_lam c with
    | (params, body) =&gt;
      let fold
        (function_parameter :
        (Context.binder_annot Names.Name.t) * Constr.types)
        : Environ.env -&gt; Environ.env :=
        match function_parameter with
        | (na, t) =&gt; fun env =&gt; Environ.push_rel (RelDecl.LocalAssum na t) env
        end in
      let env := Util.List.(CList.ExtS.fold_right) fold params env in
      let lb := lambda_of_constr cache env sigma body in
      let ids := get_names (Util.List.(CList.ExtS.rev) params) in
      mkLlam ids lb
    end
  | LetIn id def t body =&gt;
    let ld := lambda_of_constr cache env sigma def in
    let env := Environ.push_rel (RelDecl.LocalDef id def t) env in
    let lb := lambda_of_constr cache env sigma body in
    Llet id ld lb
  | App f args =&gt; lambda_of_app cache env sigma f args
  | Const _ =&gt; lambda_of_app cache env sigma c empty_args
  | Construct _ =&gt; lambda_of_app cache env sigma c empty_args
  | Proj p c =&gt;
    let ind := Names.Projection.inductive p in
    let prefix := get_mind_prefix env (fst ind) in
    mkLapp (Lproj prefix ind (Names.Projection.arg p))
      ((lambda_of_constr cache env sigma c))
  | Case ci t a branches =&gt;
    match ci_ind ci with
    | (mind, i) as ind =&gt;
      let mib := Environ.lookup_mind mind env in
      let oib := Util.Array.(CArray.ExtS.get) (mind_packets mib) i in
      let tbl := mind_reloc_tbl oib in
      let prefix := get_mind_prefix env mind in
      let annot_sw :=
        {| asw_ind := ind; asw_ci := ci; asw_reloc := tbl;
          asw_finite := nequiv_decb (mind_finite mib) CoFinite;
          asw_prefix := prefix |} in
      let la := lambda_of_constr cache env sigma a in
      let lt := lambda_of_constr cache env sigma t in
      let dummy := Lrel Anonymous 0 in
      let consts := Util.Array.(CArray.ExtS.make) (mind_nb_constant oib) dummy
        in
      let blocks := Util.Array.(CArray.ExtS.make) (mind_nb_args oib) (tt, dummy)
        in
      let rtbl := mind_reloc_tbl oib in
      for;
      let branches :=
        {| constant_branches := consts; nonconstant_branches := blocks |} in
      Lcase annot_sw lt la branches
    end
  | Fix ((pos, i), (names, type_bodies, rec_bodies)) =&gt;
    let ltypes := lambda_of_args cache env sigma 0 type_bodies in
    let map (i : Int.t) (t : Constr.constr) : string * Names.inductive :=
      let ind := get_fix_struct env i t in
      let prefix := get_mind_prefix env (fst ind) in
      (prefix, ind) in
    let inds := Util.Array.(CArray.ExtS.map2) map pos type_bodies in
    let env := Environ.push_rec_types (names, type_bodies, rec_bodies) env in
    let lbodies := lambda_of_args cache env sigma 0 rec_bodies in
    Lfix (pos, inds, i) (names, ltypes, lbodies)
  | CoFix (init, (names, type_bodies, rec_bodies)) =&gt;
    let rec_bodies :=
      Util.Array.(CArray.ExtS.map2) (Reduction.eta_expand env) rec_bodies
        type_bodies in
    let ltypes := lambda_of_args cache env sigma 0 type_bodies in
    let env := Environ.push_rec_types (names, type_bodies, rec_bodies) env in
    let lbodies := lambda_of_args cache env sigma 0 rec_bodies in
    Lcofix init (names, ltypes, lbodies)
  | Int i =&gt; Luint i
  end

with lambda_of_app
  (cache : Cache.ConstrTable.t Cache.constructor_info) (env : Environ.env)
  (sigma : evars) (f : Constr.constr) (args : array Constr.constr) : lambda :=
  match Constr.kind f with
  | Const ((_kn, _u) as c) =&gt;
    match get_alias env c with
    | (kn, u) =&gt;
      let cb := Environ.lookup_constant kn env in
      match const_body cb with
      | Primitive op =&gt;
        lambda_of_prim env c op (lambda_of_args cache env sigma 0 args)
      | Def csubst =&gt;
        if const_inline_code cb then
          lambda_of_app cache env sigma (Mod_subst.force_constr csubst) args
        else
          let prefix := get_const_prefix env kn in
          let t :=
            if is_lazy (Mod_subst.force_constr csubst) then
              mkLapp Lforce ((Lconst prefix (kn, u)))
            else
              Lconst prefix (kn, u) in
          mkLapp t (lambda_of_args cache env sigma 0 args)
      | OpaqueDef _ | Undef _ =&gt;
        let prefix := get_const_prefix env kn in
        mkLapp (Lconst prefix (kn, u)) (lambda_of_args cache env sigma 0 args)
      end
    end
  | Construct ((ind, _) as c, _) =&gt;
    match Cache.get_construct_info cache env c with
    | (tag, nparams, arity) =&gt;
      let nargs := Util.Array.(CArray.ExtS.length) args in
      if OCaml.Stdlib.lt nparams nargs then
        let args := lambda_of_args cache env sigma nparams args in
        makeblock env ind tag 0 arity args
      else
        makeblock env ind tag (Util.op_minus nparams nargs) arity empty_args
    end
  | _ =&gt;
    let f := lambda_of_constr cache env sigma f in
    let args := lambda_of_args cache env sigma 0 args in
    mkLapp f args
  end

with lambda_of_args
  (cache : Cache.ConstrTable.t Cache.constructor_info) (env : Environ.env)
  (sigma : evars) (start : Z) (args : array Constr.types) : array lambda :=
  let nargs := Util.Array.(CArray.ExtS.length) args in
  if OCaml.Stdlib.lt start nargs then
    Util.Array.(CArray.ExtS.init) (Util.op_minus nargs start)
      (fun i =&gt;
        lambda_of_constr cache env sigma
          (Util.Array.(CArray.ExtS.get) args (Util.op_plus start i)))
  else
    empty_args.

Definition optimize (lam : lambda) : lambda :=
  let lam := simplify subst_id lam in
  lam.

Definition lambda_of_constr
  (env : Environ.env) (sigma : evars) (c : Constr.constr) : lambda :=
  let cache := Cache.ConstrTable.create 91 in
  let lam := lambda_of_constr cache env sigma c in
  optimize lam.

Definition mk_lazy (c : lambda) : lambda := mkLapp Llazy (c).</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="nativelib" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>nativelib.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)
open Util
open Nativevalues
open Nativecode
open CErrors

(** This file provides facilities to access OCaml compiler and dynamic linker,
used by the native compiler. *)

let get_load_paths =
  ref (fun _ -&gt; anomaly (Pp.str &quot;get_load_paths not initialized.&quot;) : unit -&gt; string list)

let open_header = [&quot;Nativevalues&quot;;
                   &quot;Nativecode&quot;;
                   &quot;Nativelib&quot;;
                   &quot;Nativeconv&quot;]
let open_header = List.map mk_open open_header

(* Directory where compiled files are stored *)
let output_dir = &quot;.coq-native&quot;

(* Extension of genereted ml files, stored for debugging purposes *)
let source_ext = &quot;.native&quot;

let ( / ) = Filename.concat

(* We have to delay evaluation of include_dirs because coqlib cannot be guessed
until flags have been properly initialized *)
let include_dirs () =
  [Filename.get_temp_dir_name (); Envars.coqlib () / &quot;kernel&quot;; Envars.coqlib () / &quot;library&quot;]

(* Pointer to the function linking an ML object into coq's toplevel *)
let load_obj = ref (fun _x -&gt; () : string -&gt; unit)

let rt1 = ref (dummy_value ())
let rt2 = ref (dummy_value ())

let get_ml_filename () =
  let filename = Filename.temp_file &quot;Coq_native&quot; source_ext in
  let prefix = Filename.chop_extension (Filename.basename filename) ^ &quot;.&quot; in
  filename, prefix

let write_ml_code fn ?(header=[]) code =
  let header = open_header@header in
  let ch_out = open_out fn in
  let fmt = Format.formatter_of_out_channel ch_out in
  List.iter (pp_global fmt) (header@code);
  close_out ch_out

let error_native_compiler_failed e =
  let msg = match e with
  | Inl (Unix.WEXITED 127) -&gt; Pp.(strbrk &quot;The OCaml compiler was not found. Make sure it is installed, together with findlib.&quot;)
  | Inl (Unix.WEXITED n) -&gt; Pp.(strbrk &quot;Native compiler exited with status&quot; ++ str&quot; &quot; ++ int n)
  | Inl (Unix.WSIGNALED n) -&gt; Pp.(strbrk &quot;Native compiler killed by signal&quot; ++ str&quot; &quot; ++ int n)
  | Inl (Unix.WSTOPPED n) -&gt; Pp.(strbrk &quot;Native compiler stopped by signal&quot; ++ str&quot; &quot; ++ int n)
  | Inr e -&gt; Pp.(strbrk &quot;Native compiler failed with error: &quot; ++ strbrk (Unix.error_message e))
  in
  CErrors.user_err msg

let call_compiler ?profile:(profile=false) ml_filename =
  let load_path = !get_load_paths () in
  let load_path = List.map (fun dn -&gt; dn / output_dir) load_path in
  let include_dirs = List.flatten (List.map (fun x -&gt; [&quot;-I&quot;; x]) (include_dirs () @ load_path)) in
  let f = Filename.chop_extension ml_filename in
  let link_filename = f ^ &quot;.cmo&quot; in
  let link_filename = Dynlink.adapt_filename link_filename in
  let remove f = if Sys.file_exists f then Sys.remove f in
  remove link_filename;
  remove (f ^ &quot;.cmi&quot;);
  let initial_args =
    if Dynlink.is_native then
      [&quot;opt&quot;; &quot;-shared&quot;]
     else
      [&quot;ocamlc&quot;; &quot;-c&quot;]
  in
  let profile_args =
    if profile then
      [&quot;-g&quot;]
    else
      []
  in
  let flambda_args = if Sys.(backend_type = Native) then [&quot;-Oclassic&quot;] else [] in
  let args =
    initial_args @
      profile_args @
        flambda_args @
      (&quot;-o&quot;::link_filename
       ::&quot;-rectypes&quot;
       ::&quot;-w&quot;::&quot;a&quot;
       ::include_dirs) @
      [&quot;-impl&quot;; ml_filename] in
  if !Flags.debug then Feedback.msg_debug (Pp.str (Envars.ocamlfind () ^ &quot; &quot; ^ (String.concat &quot; &quot; args)));
  try
    let res = CUnix.sys_command (Envars.ocamlfind ()) args in
    match res with
    | Unix.WEXITED 0 -&gt; link_filename
    | Unix.WEXITED _n | Unix.WSIGNALED _n | Unix.WSTOPPED _n -&gt;
      error_native_compiler_failed (Inl res)
  with Unix.Unix_error (e,_,_) -&gt;
    error_native_compiler_failed (Inr e)

let compile fn code ~profile:profile =
  write_ml_code fn code;
  let r = call_compiler ~profile fn in
  if (not !Flags.debug) &amp;&amp; Sys.file_exists fn then Sys.remove fn;
  r

let compile_library dir code fn =
  let header = mk_library_header dir in
  let fn = fn ^ source_ext in
  let basename = Filename.basename fn in
  let dirname = Filename.dirname fn in
  let dirname = dirname / output_dir in
  let () =
    try Unix.mkdir dirname 0o755
    with Unix.Unix_error (Unix.EEXIST, _, _) -&gt; ()
  in
  let fn = dirname / basename in
  write_ml_code fn ~header code;
  let _ = call_compiler fn in
  if (not !Flags.debug) &amp;&amp; Sys.file_exists fn then Sys.remove fn

let native_symbols = ref Names.DPmap.empty

let get_library_native_symbols dir =
  try Names.DPmap.find dir !native_symbols
  with Not_found -&gt;
    CErrors.user_err ~hdr:&quot;get_library_native_symbols&quot;
      Pp.((str &quot;Linker error in the native compiler. Are you using Require inside a nested Module declaration?&quot;) ++ fnl () ++
          (str &quot;This use case is not supported, but disabling the native compiler may help.&quot;))

(* call_linker links dynamically the code for constants in environment or a  *)
(* conversion test. *)
let call_linker ?(fatal=true) env ~prefix f upds =
  native_symbols := env.Environ.native_symbols;
  rt1 := dummy_value ();
  rt2 := dummy_value ();
  if not (Sys.file_exists f) then
    begin
      let msg = &quot;Cannot find native compiler file &quot; ^ f in
      if fatal then CErrors.user_err Pp.(str msg)
      else if !Flags.debug then Feedback.msg_debug (Pp.str msg)
    end
  else
  (try
    if Dynlink.is_native then Dynlink.loadfile f else !load_obj f;
    register_native_file prefix
   with Dynlink.Error _ as exn -&gt;
     let exn = CErrors.push exn in
     if fatal then iraise exn
     else if !Flags.debug then Feedback.msg_debug CErrors.(iprint exn));
  match upds with Some upds -&gt; update_locations upds | _ -&gt; ()

let link_library env ~prefix ~dirname ~basename =
  let f = dirname / output_dir / basename in
  call_linker env ~fatal:false ~prefix f None
</pre>
          </div>
          <div class="col-md-6">
            <code>nativelib.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Util.

Import Nativevalues.

Import Nativecode.

Import CErrors.

Definition get_load_paths : Stdlib.ref (unit -&gt; list string) :=
  Stdlib.ref
    (fun function_parameter =&gt;
      match function_parameter with
      | _ =&gt;
        CErrors.anomaly None None
          (Pp.str &quot;get_load_paths not initialized.&quot; % string)
      end).

Definition open_header : list string :=
  cons &quot;Nativevalues&quot; % string
    (cons &quot;Nativecode&quot; % string
      (cons &quot;Nativelib&quot; % string (cons &quot;Nativeconv&quot; % string []))).

Definition open_header : list Nativecode.global :=
  Util.List.(CList.ExtS.map) Nativecode.mk_open open_header.

Definition output_dir : string := &quot;.coq-native&quot; % string.

Definition source_ext : string := &quot;.native&quot; % string.

Definition op_div : string -&gt; string -&gt; string := Stdlib.Filename.concat.

Definition include_dirs (function_parameter : unit) : list string :=
  match function_parameter with
  | tt =&gt;
    cons (Stdlib.Filename.get_temp_dir_name tt)
      (cons (op_div (Envars.coqlib tt) &quot;kernel&quot; % string)
        (cons (op_div (Envars.coqlib tt) &quot;library&quot; % string) []))
  end.

Definition load_obj : Stdlib.ref (string -&gt; unit) := Stdlib.ref (fun _x =&gt; tt).

Definition rt1 : Stdlib.ref Nativevalues.t :=
  Stdlib.ref (Nativevalues.dummy_value tt).

Definition rt2 : Stdlib.ref Nativevalues.t :=
  Stdlib.ref (Nativevalues.dummy_value tt).

Definition get_ml_filename (function_parameter : unit) : string * string :=
  match function_parameter with
  | tt =&gt;
    let filename :=
      Stdlib.Filename.temp_file None &quot;Coq_native&quot; % string source_ext in
    let prefix :=
      String.append
        (Stdlib.Filename.chop_extension (Stdlib.Filename.basename filename))
        &quot;.&quot; % string in
    (filename, prefix)
  end.

Definition write_ml_code
  (fn : string) (op_star_o_p_t_star : option (list Nativecode.global))
  : (list Nativecode.global) -&gt; unit :=
  let header :=
    match op_star_o_p_t_star with
    | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
    | None =&gt; []
    end in
  fun code =&gt;
    let header := Util.op_at open_header header in
    let ch_out := Stdlib.open_out fn in
    let fmt := Stdlib.Format.formatter_of_out_channel ch_out in
    Util.List.(CList.ExtS.iter) (Nativecode.pp_global fmt)
      (Util.op_at header code);
    Stdlib.close_out ch_out.

Definition error_native_compiler_failed {A : Type}
  (e : Util.union Unix.process_status Unix.error) : A :=
  let msg :=
    match e with
    | Inl (Unix.WEXITED 127) =&gt;
      Pp.strbrk
        &quot;The OCaml compiler was not found. Make sure it is installed, together with findlib.&quot;
          % string
    | Inl (Unix.WEXITED n) =&gt;
      Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.strbrk &quot;Native compiler exited with status&quot; % string)
          (Pp.str &quot; &quot; % string)) (Pp.int n)
    | Inl (Unix.WSIGNALED n) =&gt;
      Pp.op_plus_plus
        (Pp.op_plus_plus (Pp.strbrk &quot;Native compiler killed by signal&quot; % string)
          (Pp.str &quot; &quot; % string)) (Pp.int n)
    | Inl (Unix.WSTOPPED n) =&gt;
      Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.strbrk &quot;Native compiler stopped by signal&quot; % string)
          (Pp.str &quot; &quot; % string)) (Pp.int n)
    | Inr e =&gt;
      Pp.op_plus_plus (Pp.strbrk &quot;Native compiler failed with error: &quot; % string)
        (Pp.strbrk (Unix.error_message e))
    end in
  CErrors.user_err None None msg.

Definition call_compiler (op_star_o_p_t_star : option bool)
  : string -&gt; string :=
  let profile :=
    match op_star_o_p_t_star with
    | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
    | None =&gt; false
    end in
  fun ml_filename =&gt;
    let load_path := (Util.op_exclamation get_load_paths) tt in
    let load_path :=
      Util.List.(CList.ExtS.map) (fun dn =&gt; op_div dn output_dir) load_path in
    let include_dirs :=
      Util.List.(CList.ExtS.flatten)
        (Util.List.(CList.ExtS.map) (fun x =&gt; cons &quot;-I&quot; % string (cons x []))
          (Util.op_at (include_dirs tt) load_path)) in
    let f := Stdlib.Filename.chop_extension ml_filename in
    let link_filename := String.append f &quot;.cmo&quot; % string in
    let link_filename := Dynlink.adapt_filename link_filename in
    let remove (f : string) : unit :=
      if Stdlib.Sys.file_exists f then
        Stdlib.Sys.remove f
      else
        tt in
    remove link_filename;
    remove (String.append f &quot;.cmi&quot; % string);
    let initial_args :=
      if Dynlink.is_native then
        cons &quot;opt&quot; % string (cons &quot;-shared&quot; % string [])
      else
        cons &quot;ocamlc&quot; % string (cons &quot;-c&quot; % string []) in
    let profile_args :=
      if profile then
        cons &quot;-g&quot; % string []
      else
        [] in
    let flambda_args :=
      if equiv_decb Stdlib.Sys.backend_type Native then
        cons &quot;-Oclassic&quot; % string []
      else
        [] in
    let args :=
      Util.op_at initial_args
        (Util.op_at profile_args
          (Util.op_at flambda_args
            (Util.op_at
              (cons &quot;-o&quot; % string
                (cons link_filename
                  (cons &quot;-rectypes&quot; % string
                    (cons &quot;-w&quot; % string (cons &quot;a&quot; % string include_dirs)))))
              (cons &quot;-impl&quot; % string (cons ml_filename []))))) in
    if Util.op_exclamation Flags.debug then
      Feedback.msg_debug None
        (Pp.str
          (String.append (Envars.ocamlfind tt)
            (String.append &quot; &quot; % string
              (Util.String.(CString.ExtS.concat) &quot; &quot; % string args))))
    else
      tt;
    try.

Definition compile
  (fn : string) (code : list Nativecode.global) (profile : bool) : string :=
  write_ml_code fn None code;
  let r := call_compiler (Some profile) fn in
  if andb (negb (Util.op_exclamation Flags.debug)) (Stdlib.Sys.file_exists fn)
    then
    Stdlib.Sys.remove fn
  else
    tt;
  r.

Definition compile_library
  (dir : Names.DirPath.t) (code : list Nativecode.global) (fn : string)
  : unit :=
  let header := Nativecode.mk_library_header dir in
  let fn := String.append fn source_ext in
  let basename := Stdlib.Filename.basename fn in
  let dirname := Stdlib.Filename.dirname fn in
  let dirname := op_div dirname output_dir in
  match try with
  | tt =&gt;
    let fn := op_div dirname basename in
    write_ml_code fn (Some header) code;
    match call_compiler None fn with
    | _ =&gt;
      if
        andb (negb (Util.op_exclamation Flags.debug))
          (Stdlib.Sys.file_exists fn) then
        Stdlib.Sys.remove fn
      else
        tt
    end
  end.

Definition native_symbols : Stdlib.ref (Names.DPmap.t Nativevalues.symbols) :=
  Stdlib.ref Names.DPmap.empty.

Definition get_library_native_symbols (dir : Names.DPmap.key)
  : Nativevalues.symbols := try.

Definition call_linker (op_star_o_p_t_star : option bool)
  : Environ.env -&gt;
    string -&gt; string -&gt; (option Nativecode.code_location_updates) -&gt; unit :=
  let fatal :=
    match op_star_o_p_t_star with
    | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
    | None =&gt; true
    end in
  fun env =&gt;
    fun prefix =&gt;
      fun f =&gt;
        fun upds =&gt;
          Stdlib.op_colon_eq native_symbols (Environ.native_symbols env);
          Stdlib.op_colon_eq rt1 (Nativevalues.dummy_value tt);
          Stdlib.op_colon_eq rt2 (Nativevalues.dummy_value tt);
          if negb (Stdlib.Sys.file_exists f) then
            let msg :=
              String.append &quot;Cannot find native compiler file &quot; % string f in
            if fatal then
              CErrors.user_err None None (Pp.str msg)
            else
              if Util.op_exclamation Flags.debug then
                Feedback.msg_debug None (Pp.str msg)
              else
                tt
          else
            try;
          match upds with
          | Some upds =&gt; Nativecode.update_locations upds
          | _ =&gt; tt
          end.

Definition link_library
  (env : Environ.env) (prefix : string) (dirname : string) (basename : string)
  : unit :=
  let f := op_div (op_div dirname output_dir) basename in
  call_linker (Some false) env prefix f None.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="nativelibrary" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>nativelibrary.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Declarations
open Mod_subst
open Modops
open Nativecode

(** This file implements separate compilation for libraries in the native
compiler *)

let rec translate_mod prefix mp env mod_expr acc =
  match mod_expr with
  | NoFunctor struc -&gt;
      let env' = add_structure mp struc empty_delta_resolver env in
      List.fold_left (translate_field prefix mp env') acc struc
  | MoreFunctor _ -&gt; acc

and translate_field prefix mp env acc (l,x) =
  match x with
  | SFBconst cb -&gt;
     let con = Constant.make2 mp l in
     (if !Flags.debug then
        let msg = Printf.sprintf &quot;Compiling constant %s...&quot; (Constant.to_string con) in
	Feedback.msg_debug (Pp.str msg));
     compile_constant_field env prefix con acc cb
  | SFBmind mb -&gt;
     (if !Flags.debug then
	let id = mb.mind_packets.(0).mind_typename in
	let msg = Printf.sprintf &quot;Compiling inductive %s...&quot; (Id.to_string id) in
	Feedback.msg_debug (Pp.str msg));
     compile_mind_field mp l acc mb
  | SFBmodule md -&gt;
     let mp = md.mod_mp in
     (if !Flags.debug then
	let msg =
	  Printf.sprintf &quot;Compiling module %s...&quot; (ModPath.to_string mp)
	in
	Feedback.msg_debug (Pp.str msg));
     translate_mod prefix mp env md.mod_type acc
  | SFBmodtype mdtyp -&gt;
     let mp = mdtyp.mod_mp in
     (if !Flags.debug then
	let msg =
	  Printf.sprintf &quot;Compiling module type %s...&quot; (ModPath.to_string mp)
	in
	Feedback.msg_debug (Pp.str msg));
     translate_mod prefix mp env mdtyp.mod_type acc

let dump_library mp dp env mod_expr =
  if !Flags.debug then Feedback.msg_debug (Pp.str &quot;Compiling library...&quot;);
  match mod_expr with
  | NoFunctor struc -&gt;
      let env = add_structure mp struc empty_delta_resolver env in
      let prefix = mod_uid_of_dirpath dp ^ &quot;.&quot; in
      let t0 = Sys.time () in
      clear_global_tbl ();
      clear_symbols ();
      let mlcode =
        List.fold_left (translate_field prefix mp env) [] struc
      in
      let t1 = Sys.time () in
      let time_info = Format.sprintf &quot;Time spent generating this code: %.5fs&quot; (t1-.t0) in
      let mlcode = add_header_comment (List.rev mlcode) time_info in
      mlcode, get_symbols ()
  | _ -&gt; assert false
</pre>
          </div>
          <div class="col-md-6">
            <code>nativelibrary.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Names.

Import Declarations.

Import Mod_subst.

Import Modops.

Import Nativecode.

Fixpoint translate_mod
  (prefix : string) (mp : Names.ModPath.t) (env : Environ.env)
  (mod_expr :
    Declarations.functorize Declarations.module_type_body
      Declarations.structure_body) (acc : list Nativecode.global)
  : list Nativecode.global :=
  match mod_expr with
  | NoFunctor struc =&gt;
    let env' := Modops.add_structure mp struc Mod_subst.empty_delta_resolver env
      in
    Stdlib.List.fold_left (translate_field prefix mp env') acc struc
  | MoreFunctor _ _ _ =&gt; acc
  end

with translate_field
  (prefix : string) (mp : Names.ModPath.t) (env : Environ.env)
  (acc : list Nativecode.global)
  (function_parameter : Names.Label.t * Declarations.structure_field_body)
  : list Nativecode.global :=
  match function_parameter with
  | (l, x) =&gt;
    match x with
    | SFBconst cb =&gt;
      let con := Names.Constant.make2 mp l in
      if Stdlib.op_exclamation Flags.debug then
        let msg :=
          Stdlib.Printf.sprintf
            (CamlinternalFormatBasics.Format
              (CamlinternalFormatBasics.String_literal
                &quot;Compiling constant &quot; % string
                (CamlinternalFormatBasics.String
                  CamlinternalFormatBasics.No_padding
                  (CamlinternalFormatBasics.String_literal &quot;...&quot; % string
                    CamlinternalFormatBasics.End_of_format)))
              &quot;Compiling constant %s...&quot; % string)
            (Names.Constant.to_string con) in
        Feedback.msg_debug None (Pp.str msg)
      else
        tt;
      Nativecode.compile_constant_field env prefix con acc cb
    | SFBmind mb =&gt;
      if Stdlib.op_exclamation Flags.debug then
        let id := mind_typename (Stdlib.Array.get (mind_packets mb) 0) in
        let msg :=
          Stdlib.Printf.sprintf
            (CamlinternalFormatBasics.Format
              (CamlinternalFormatBasics.String_literal
                &quot;Compiling inductive &quot; % string
                (CamlinternalFormatBasics.String
                  CamlinternalFormatBasics.No_padding
                  (CamlinternalFormatBasics.String_literal &quot;...&quot; % string
                    CamlinternalFormatBasics.End_of_format)))
              &quot;Compiling inductive %s...&quot; % string) (Names.Id.to_string id) in
        Feedback.msg_debug None (Pp.str msg)
      else
        tt;
      Nativecode.compile_mind_field mp l acc mb
    | SFBmodule md =&gt;
      let mp := mod_mp md in
      if Stdlib.op_exclamation Flags.debug then
        let msg :=
          Stdlib.Printf.sprintf
            (CamlinternalFormatBasics.Format
              (CamlinternalFormatBasics.String_literal
                &quot;Compiling module &quot; % string
                (CamlinternalFormatBasics.String
                  CamlinternalFormatBasics.No_padding
                  (CamlinternalFormatBasics.String_literal &quot;...&quot; % string
                    CamlinternalFormatBasics.End_of_format)))
              &quot;Compiling module %s...&quot; % string) (Names.ModPath.to_string mp) in
        Feedback.msg_debug None (Pp.str msg)
      else
        tt;
      translate_mod prefix mp env (mod_type md) acc
    | SFBmodtype mdtyp =&gt;
      let mp := mod_mp mdtyp in
      if Stdlib.op_exclamation Flags.debug then
        let msg :=
          Stdlib.Printf.sprintf
            (CamlinternalFormatBasics.Format
              (CamlinternalFormatBasics.String_literal
                &quot;Compiling module type &quot; % string
                (CamlinternalFormatBasics.String
                  CamlinternalFormatBasics.No_padding
                  (CamlinternalFormatBasics.String_literal &quot;...&quot; % string
                    CamlinternalFormatBasics.End_of_format)))
              &quot;Compiling module type %s...&quot; % string)
            (Names.ModPath.to_string mp) in
        Feedback.msg_debug None (Pp.str msg)
      else
        tt;
      translate_mod prefix mp env (mod_type mdtyp) acc
    end
  end.

Definition dump_library {A : Type}
  (mp : Names.ModPath.t) (dp : Names.DirPath.t) (env : Environ.env)
  (mod_expr : Declarations.functorize A Declarations.structure_body)
  : (list Nativecode.global) * Nativevalues.symbols :=
  if Stdlib.op_exclamation Flags.debug then
    Feedback.msg_debug None (Pp.str &quot;Compiling library...&quot; % string)
  else
    tt;
  match mod_expr with
  | NoFunctor struc =&gt;
    let env := Modops.add_structure mp struc Mod_subst.empty_delta_resolver env
      in
    let prefix := String.append (Nativecode.mod_uid_of_dirpath dp) &quot;.&quot; % string
      in
    let t0 := Stdlib.Sys.time tt in
    Nativecode.clear_global_tbl tt;
    Nativecode.clear_symbols tt;
    let mlcode := Stdlib.List.fold_left (translate_field prefix mp env) [] struc
      in
    let t1 := Stdlib.Sys.time tt in
    let time_info :=
      Stdlib.Format.sprintf
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal
            &quot;Time spent generating this code: &quot; % string
            (CamlinternalFormatBasics.Float CamlinternalFormatBasics.Float_f
              CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.Lit_precision 5)
              (CamlinternalFormatBasics.Char_literal &quot;s&quot; % char
                CamlinternalFormatBasics.End_of_format)))
          &quot;Time spent generating this code: %.5fs&quot; % string)
        (Stdlib.op_minus_point t1 t0) in
    let mlcode := Nativecode.add_header_comment (List.rev mlcode) time_info in
    (mlcode, (Nativecode.get_symbols tt))
  | _ =&gt; false
  end.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="nativevalues" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>nativevalues.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Util
open CErrors
open Names
open Constr

(** This module defines the representation of values internally used by
the native compiler *)

type t = t -&gt; t
    
type accumulator (* = t (* a block [0:code;atom;arguments] *) *)

type tag = int
 
type arity = int

type reloc_table = (tag * arity) array

type annot_sw = {
    asw_ind : inductive;
    asw_ci : case_info;
    asw_reloc : reloc_table;
    asw_finite : bool;
    asw_prefix : string
  }

(* We compare only what is relevant for generation of ml code *)
let eq_annot_sw asw1 asw2 =
  eq_ind asw1.asw_ind asw2.asw_ind &amp;&amp;
  String.equal asw1.asw_prefix asw2.asw_prefix

open Hashset.Combine

let hash_annot_sw asw =
  combine (ind_hash asw.asw_ind) (String.hash asw.asw_prefix)

type sort_annot = string * int

type rec_pos = int array

let eq_rec_pos = Array.equal Int.equal

type atom = 
  | Arel of int
  | Aconstant of pconstant
  | Aind of pinductive
  | Asort of Sorts.t
  | Avar of Id.t
  | Acase of annot_sw * accumulator * t * (t -&gt; t)
  | Afix of t array * t array * rec_pos * int
            (* types, bodies, rec_pos, pos *)
  | Acofix of t array * t array * int * t
  | Acofixe of t array * t array * int * t
  | Aprod of Name.t * t * (t -&gt; t)
  | Ameta of metavariable * t
  | Aevar of Evar.t * t array
  | Aproj of (inductive * int) * accumulator

type symbol =
  | SymbValue of t
  | SymbSort of Sorts.t
  | SymbName of Name.t
  | SymbConst of Constant.t
  | SymbMatch of annot_sw
  | SymbInd of inductive
  | SymbMeta of metavariable
  | SymbEvar of Evar.t
  | SymbLevel of Univ.Level.t
  | SymbProj of (inductive * int)

type symbols = symbol array

let empty_symbols = [| |]


let accumulate_tag = 0

(** Unique pointer used to drive the accumulator function *)
let ret_accu = Obj.repr (ref ())

type accu_val = { mutable acc_atm : atom; acc_arg : Obj.t list }

let mk_accu (a : atom) : t =
  let rec accumulate data x =
    if x == ret_accu then Obj.repr data
    else
      let data = { data with acc_arg = x :: data.acc_arg } in
      let ans = Obj.repr (accumulate data) in
      let () = Obj.set_tag ans accumulate_tag [@ocaml.alert &quot;--deprecated&quot;] in
      ans
  in
  let acc = { acc_atm = a; acc_arg = [] } in
  let ans = Obj.repr (accumulate acc) in
  (** FIXME: use another representation for accumulators, this causes naked
      pointers. *)
  let () = Obj.set_tag ans accumulate_tag [@ocaml.alert &quot;--deprecated&quot;] in
  (Obj.obj ans : t)

let get_accu (k : accumulator) =
  (Obj.magic k : Obj.t -&gt; accu_val) ret_accu

let mk_rel_accu i = 
  mk_accu (Arel i)

let rel_tbl_size = 100 
let rel_tbl = Array.init rel_tbl_size mk_rel_accu

let mk_rel_accu i = 
  if i &lt; rel_tbl_size then rel_tbl.(i)
  else mk_rel_accu i

let mk_rels_accu lvl len =
  Array.init len (fun i -&gt; mk_rel_accu (lvl + i))

let napply (f:t) (args: t array) =
  Array.fold_left (fun f a -&gt; f a) f args

let mk_constant_accu kn u = 
  mk_accu (Aconstant (kn,Univ.Instance.of_array u))

let mk_ind_accu ind u = 
  mk_accu (Aind (ind,Univ.Instance.of_array u))

let mk_sort_accu s u =
  let open Sorts in
  match s with
  | SProp | Prop | Set -&gt; mk_accu (Asort s)
  | Type s -&gt;
     let u = Univ.Instance.of_array u in
     let s = Sorts.sort_of_univ (Univ.subst_instance_universe u s) in
     mk_accu (Asort s)

let mk_var_accu id = 
  mk_accu (Avar id)

let mk_sw_accu annot c p ac = 
  mk_accu (Acase(annot,c,p,ac))

let mk_prod_accu s dom codom =
  mk_accu (Aprod (s,dom,codom))

let mk_meta_accu mv ty =
  mk_accu (Ameta (mv,ty))

let mk_evar_accu ev args =
  mk_accu (Aevar (ev, args))

let mk_proj_accu kn c = 
  mk_accu (Aproj (kn,c))

let atom_of_accu (k:accumulator) =
  (get_accu k).acc_atm

let set_atom_of_accu (k:accumulator) (a:atom) =
  (get_accu k).acc_atm &lt;- a

let accu_nargs (k:accumulator) =
  List.length (get_accu k).acc_arg

let args_of_accu (k:accumulator) =
  let acc = (get_accu k).acc_arg in
  (Obj.magic (Array.of_list acc) : t array)

let mk_fix_accu rec_pos pos types bodies =
  mk_accu (Afix(types,bodies,rec_pos, pos))

let mk_cofix_accu pos types norm =
  mk_accu (Acofix(types,norm,pos,(Obj.magic 0 : t)))

let upd_cofix (cofix :t) (cofix_fun : t) =
  let atom = atom_of_accu (Obj.magic cofix) in
  match atom with
  | Acofix (typ,norm,pos,_) -&gt;
      set_atom_of_accu (Obj.magic cofix) (Acofix(typ,norm,pos,cofix_fun))
  | _ -&gt; assert false
  
let force_cofix (cofix : t) = 
  let accu = (Obj.magic cofix : accumulator) in
  let atom = atom_of_accu accu in
  match atom with
  | Acofix(typ,norm,pos,f) -&gt;
    let args = args_of_accu accu in
    let f = Array.fold_right (fun arg f -&gt; f arg) args f in
    let v = f (Obj.magic ()) in
    set_atom_of_accu accu (Acofixe(typ,norm,pos,v));
      v
  | Acofixe(_,_,_,v) -&gt; v
  | _ -&gt; cofix

let mk_const tag = Obj.magic tag

let mk_block tag args =
  let nargs = Array.length args in
  let r = Obj.new_block tag nargs in
  for i = 0 to nargs - 1 do
    Obj.set_field r i (Obj.magic args.(i))
  done;
  (Obj.magic r : t)

(* Two instances of dummy_value should not be pointer equal, otherwise
 comparing them as terms would succeed *)
let dummy_value : unit -&gt; t =
  fun () _ -&gt; anomaly ~label:&quot;native&quot; (Pp.str &quot;Evaluation failed.&quot;)

let cast_accu v = (Obj.magic v:accumulator)
[@@ocaml.inline always]

let mk_int (x : int) = (Obj.magic x : t)
[@@ocaml.inline always]

(* Coq's booleans are reversed... *)
let mk_bool (b : bool) = (Obj.magic (not b) : t)
[@@ocaml.inline always]

let mk_uint (x : Uint63.t) = (Obj.magic x : t)
[@@ocaml.inline always]

type block

let block_size (b:block) =
  Obj.size (Obj.magic b)

let block_field (b:block) i = (Obj.magic (Obj.field (Obj.magic b) i) : t)

let block_tag (b:block) = 
  Obj.tag (Obj.magic b)

type kind_of_value =
  | Vaccu of accumulator
  | Vfun of (t -&gt; t)
  | Vconst of int
  | Vint64 of int64
  | Vblock of block

let kind_of_value (v:t) =
  let o = Obj.repr v in
  if Obj.is_int o then Vconst (Obj.magic v)
  else
    let tag = Obj.tag o in
    if Int.equal tag accumulate_tag then
      Vaccu (Obj.magic v)
    else if Int.equal tag Obj.custom_tag then Vint64 (Obj.magic v)
    else if (tag &lt; Obj.lazy_tag) then Vblock (Obj.magic v)
      else
        (* assert (tag = Obj.closure_tag || tag = Obj.infix_tag); 
           or ??? what is 1002*)
        Vfun v

(** Support for machine integers *)

let is_int (x:t) =
  let o = Obj.repr x in
  Obj.is_int o || Int.equal (Obj.tag o) Obj.custom_tag

let val_to_int (x:t) = (Obj.magic x : int)
[@@ocaml.inline always]

let to_uint (x:t) = (Obj.magic x : Uint63.t)
[@@ocaml.inline always]

let no_check_head0 x =
 mk_uint (Uint63.head0 (to_uint x))
[@@ocaml.inline always]

let head0 accu x =
 if is_int x then  no_check_head0 x
 else accu x

let no_check_tail0 x =
  mk_uint (Uint63.tail0 (to_uint x))
[@@ocaml.inline always]

let tail0 accu x =
 if is_int x then no_check_tail0 x
 else accu x

let no_check_add  x y =
  mk_uint (Uint63.add (to_uint x) (to_uint y))
[@@ocaml.inline always]

let add accu x y =
  if is_int x &amp;&amp; is_int y then no_check_add x y 
  else accu x y

let no_check_sub x y =
  mk_uint (Uint63.sub (to_uint x) (to_uint y))
[@@ocaml.inline always]

let sub accu x y =
  if is_int x &amp;&amp; is_int y then no_check_sub x y
  else accu x y

let no_check_mul x y =
  mk_uint (Uint63.mul (to_uint x) (to_uint y))
[@@ocaml.inline always]

let mul accu x y =
  if is_int x &amp;&amp; is_int y then no_check_mul x y
  else accu x y

let no_check_div x y =
  mk_uint (Uint63.div (to_uint x) (to_uint y))
[@@ocaml.inline always]

let div accu x y =
  if is_int x &amp;&amp; is_int y then no_check_div x y 
  else accu x y

let no_check_rem x y =
  mk_uint (Uint63.rem (to_uint x) (to_uint y))
[@@ocaml.inline always]

let rem accu x y =
  if is_int x &amp;&amp; is_int y then no_check_rem x y
  else accu x y

let no_check_l_sr x y =
  mk_uint (Uint63.l_sr (to_uint x) (to_uint y))
[@@ocaml.inline always]

let l_sr accu x y =
  if is_int x &amp;&amp; is_int y then no_check_l_sr x y
  else accu x y

let no_check_l_sl x y =
  mk_uint (Uint63.l_sl (to_uint x) (to_uint y))
[@@ocaml.inline always]

let l_sl accu x y =
  if is_int x &amp;&amp; is_int y then no_check_l_sl x y
  else accu x y

let no_check_l_and x y =
  mk_uint (Uint63.l_and (to_uint x) (to_uint y))
[@@ocaml.inline always]

let l_and accu x y =
  if is_int x &amp;&amp; is_int y then no_check_l_and x y
  else accu x y

let no_check_l_xor x y =
  mk_uint (Uint63.l_xor (to_uint x) (to_uint y))
[@@ocaml.inline always]

let l_xor accu x y =
  if is_int x &amp;&amp; is_int y then no_check_l_xor x y
  else accu x y

let no_check_l_or x y =
  mk_uint (Uint63.l_or (to_uint x) (to_uint y))
[@@ocaml.inline always]

let l_or accu x y =
  if is_int x &amp;&amp; is_int y then no_check_l_or x y
  else accu x y

[@@@ocaml.warning &quot;-37&quot;]
type coq_carry = 
  | Caccu of t
  | C0 of t
  | C1 of t

type coq_pair = 
  | Paccu of t
  | PPair of t * t

let mkCarry b i =
  if b then (Obj.magic (C1(mk_uint i)):t)
  else (Obj.magic (C0(mk_uint i)):t)

let no_check_addc x y =
  let s = Uint63.add (to_uint x) (to_uint y) in
  mkCarry (Uint63.lt s (to_uint x)) s
[@@ocaml.inline always]

let addc accu x y =
  if is_int x &amp;&amp; is_int y then no_check_addc x y
  else accu x y

let no_check_subc x y =
  let s = Uint63.sub (to_uint x) (to_uint y) in
  mkCarry (Uint63.lt (to_uint x) (to_uint y)) s
[@@ocaml.inline always]

let subc accu x y =
  if is_int x &amp;&amp; is_int y then no_check_subc x y
  else accu x y

let no_check_addCarryC x y =
  let s = 
    Uint63.add (Uint63.add (to_uint x) (to_uint y))
      (Uint63.of_int 1) in
  mkCarry (Uint63.le s (to_uint x)) s
[@@ocaml.inline always]

let addCarryC accu x y =
  if is_int x &amp;&amp; is_int y then no_check_addCarryC x y
  else accu x y 

let no_check_subCarryC x y =
  let s = 
    Uint63.sub (Uint63.sub (to_uint x) (to_uint y))
      (Uint63.of_int 1) in
  mkCarry (Uint63.le (to_uint x) (to_uint y)) s
[@@ocaml.inline always]

let subCarryC accu x y =
  if is_int x &amp;&amp; is_int y then no_check_subCarryC x y
  else accu x y 

let of_pair (x, y) =
  (Obj.magic (PPair(mk_uint x, mk_uint y)):t)
[@@ocaml.inline always]

let no_check_mulc x y =
  of_pair (Uint63.mulc (to_uint x) (to_uint y))
[@@ocaml.inline always]

let mulc accu x y =
  if is_int x &amp;&amp; is_int y then no_check_mulc x y
  else accu x y

let no_check_diveucl x y =
  let i1, i2 = to_uint x, to_uint y in
  of_pair(Uint63.div i1 i2, Uint63.rem i1 i2)
[@@ocaml.inline always]

let diveucl accu x y =
  if is_int x &amp;&amp; is_int y then no_check_diveucl x y
  else accu x y

let no_check_div21 x y z =
  let i1, i2, i3 = to_uint x, to_uint y, to_uint z in
  of_pair (Uint63.div21 i1 i2 i3)
[@@ocaml.inline always]

let div21 accu x y z =
  if is_int x &amp;&amp; is_int y &amp;&amp; is_int z then no_check_div21 x y z
  else accu x y z

let no_check_addMulDiv x y z =
  let p, i, j = to_uint x, to_uint y, to_uint z in
  mk_uint (Uint63.addmuldiv p i j)
[@@ocaml.inline always]

let addMulDiv accu x y z =
  if is_int x &amp;&amp; is_int y &amp;&amp; is_int z then no_check_addMulDiv x y z
  else accu x y z

[@@@ocaml.warning &quot;-34&quot;]
type coq_bool =
  | Baccu of t
  | Btrue
  | Bfalse

type coq_cmp =
  | CmpAccu of t
  | CmpEq 
  | CmpLt
  | CmpGt

let no_check_eq x y =
  mk_bool (Uint63.equal (to_uint x) (to_uint y))
[@@ocaml.inline always]

let eq accu x y =
  if is_int x &amp;&amp; is_int y then no_check_eq x y
  else accu x y

let no_check_lt x y =
  mk_bool (Uint63.lt (to_uint x) (to_uint y))
[@@ocaml.inline always]

let lt accu x y =
  if is_int x &amp;&amp; is_int y then no_check_lt x y
  else accu x y

let no_check_le x y =
  mk_bool (Uint63.le (to_uint x) (to_uint y))
[@@ocaml.inline always]

let le accu x y =
  if is_int x &amp;&amp; is_int y then no_check_le x y
  else accu x y

let no_check_compare x y =
  match Uint63.compare (to_uint x) (to_uint y) with
  | x when x &lt; 0 -&gt; (Obj.magic CmpLt:t)
  | 0 -&gt; (Obj.magic CmpEq:t)
  | _ -&gt; (Obj.magic CmpGt:t)

let compare accu x y =
  if is_int x &amp;&amp; is_int y then no_check_compare x y
  else accu x y

let print x =
  Printf.fprintf stderr &quot;%s&quot; (Uint63.to_string (to_uint x));
  flush stderr;
  x

let hobcnv = Array.init 256 (fun i -&gt; Printf.sprintf &quot;%02x&quot; i)
let bohcnv = Array.init 256 (fun i -&gt; i -
                                      (if 0x30 &lt;= i then 0x30 else 0) -
                                      (if 0x41 &lt;= i then 0x7 else 0) -
                                      (if 0x61 &lt;= i then 0x20 else 0))

let hex_of_bin ch = hobcnv.(int_of_char ch)
let bin_of_hex s = char_of_int (bohcnv.(int_of_char s.[0]) * 16 + bohcnv.(int_of_char s.[1]))

let str_encode expr =
  let mshl_expr = Marshal.to_string expr [] in
  let payload = Buffer.create (String.length mshl_expr * 2) in
  String.iter (fun c -&gt; Buffer.add_string payload (hex_of_bin c)) mshl_expr;
  Buffer.contents payload

let str_decode s =
  let mshl_expr_len = String.length s / 2 in
  let mshl_expr = Buffer.create mshl_expr_len in
  let buf = Bytes.create 2 in
  for i = 0 to mshl_expr_len - 1 do
    Bytes.blit_string s (2*i) buf 0 2;
    Buffer.add_char mshl_expr (bin_of_hex (Bytes.to_string buf))
  done;
  Marshal.from_bytes (Buffer.to_bytes mshl_expr) 0
</pre>
          </div>
          <div class="col-md-6">
            <code>nativevalues.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Util.

Import CErrors.

Import Names.

Import Constr.

Definition t := t -&gt; t.

Parameter accumulator : Type.

Definition tag := Z.

Definition arity := Z.

Definition reloc_table := array (tag * arity).

Record annot_sw := {
  asw_ind : Names.inductive;
  asw_ci : Constr.case_info;
  asw_reloc : reloc_table;
  asw_finite : bool;
  asw_prefix : string }.

Definition eq_annot_sw (asw1 : annot_sw) (asw2 : annot_sw) : bool :=
  andb (Names.eq_ind (asw_ind asw1) (asw_ind asw2))
    (Util.String.(CString.ExtS.equal) (asw_prefix asw1) (asw_prefix asw2)).

Import Hashset.Combine.

Definition hash_annot_sw (asw : annot_sw) : Z :=
  Hashset.Combine.combine (Names.ind_hash (asw_ind asw))
    (Util.String.(CString.ExtS.hash) (asw_prefix asw)).

Definition sort_annot := string * Z.

Definition rec_pos := array Z.

Definition eq_rec_pos : (array Int.t) -&gt; (array Int.t) -&gt; bool :=
  Util.Array.(CArray.ExtS.equal) Int.equal.

Inductive atom : Type :=
| Arel : Z -&gt; atom
| Aconstant : Constr.pconstant -&gt; atom
| Aind : Constr.pinductive -&gt; atom
| Asort : Sorts.t -&gt; atom
| Avar : Names.Id.t -&gt; atom
| Acase : annot_sw -&gt; accumulator -&gt; t -&gt; (t -&gt; t) -&gt; atom
| Afix : (array t) -&gt; (array t) -&gt; rec_pos -&gt; Z -&gt; atom
| Acofix : (array t) -&gt; (array t) -&gt; Z -&gt; t -&gt; atom
| Acofixe : (array t) -&gt; (array t) -&gt; Z -&gt; t -&gt; atom
| Aprod : Names.Name.t -&gt; t -&gt; (t -&gt; t) -&gt; atom
| Ameta : Constr.metavariable -&gt; t -&gt; atom
| Aevar : Evar.t -&gt; (array t) -&gt; atom
| Aproj : (Names.inductive * Z) -&gt; accumulator -&gt; atom.

Inductive symbol : Type :=
| SymbValue : t -&gt; symbol
| SymbSort : Sorts.t -&gt; symbol
| SymbName : Names.Name.t -&gt; symbol
| SymbConst : Names.Constant.t -&gt; symbol
| SymbMatch : annot_sw -&gt; symbol
| SymbInd : Names.inductive -&gt; symbol
| SymbMeta : Constr.metavariable -&gt; symbol
| SymbEvar : Evar.t -&gt; symbol
| SymbLevel : Univ.Level.t -&gt; symbol
| SymbProj : (Names.inductive * Z) -&gt; symbol.

Definition symbols := array symbol.

Definition empty_symbols {A : Type} : array A := tt.

Definition accumulate_tag : Z := 0.

Definition ret_accu : Stdlib.Obj.t := Stdlib.Obj.repr (Stdlib.ref tt).

Record accu_val := {
  acc_atm : atom;
  acc_arg : list Stdlib.Obj.t }.

Definition mk_accu (a : atom) : t :=
  let fix accumulate (data : accu_val) (x : Stdlib.Obj.t) : Stdlib.Obj.t :=
    if Stdlib.op_eq_eq x ret_accu then
      Stdlib.Obj.repr data
    else
      let data := record in
      let ans := Stdlib.Obj.repr (accumulate data) in
      match Stdlib.Obj.set_tag ans accumulate_tag with
      | tt =&gt; ans
      end in
  let acc := {| acc_atm := a; acc_arg := [] |} in
  let ans := Stdlib.Obj.repr (accumulate acc) in
  match Stdlib.Obj.set_tag ans accumulate_tag with
  | tt =&gt; Stdlib.Obj.obj ans
  end.

Definition get_accu (k : accumulator) : accu_val :=
  (Stdlib.Obj.magic k) ret_accu.

Definition mk_rel_accu (i : Z) : t := mk_accu (Arel i).

Definition rel_tbl_size : Z := 100.

Definition rel_tbl : array t :=
  Util.Array.(CArray.ExtS.init) rel_tbl_size mk_rel_accu.

Definition mk_rel_accu (i : Z) : t :=
  if OCaml.Stdlib.lt i rel_tbl_size then
    Util.Array.(CArray.ExtS.get) rel_tbl i
  else
    mk_rel_accu i.

Definition mk_rels_accu (lvl : Z) (len : Z) : array t :=
  Util.Array.(CArray.ExtS.init) len (fun i =&gt; mk_rel_accu (Util.op_plus lvl i)).

Definition napply (f : t) (args : array t) : t :=
  Util.Array.(CArray.ExtS.fold_left) (fun f =&gt; fun a =&gt; f a) f args.

Definition mk_constant_accu (kn : Names.Constant.t) (u : array Univ.Level.t)
  : t := mk_accu (Aconstant (kn, (Univ.Instance.of_array u))).

Definition mk_ind_accu (ind : Names.inductive) (u : array Univ.Level.t) : t :=
  mk_accu (Aind (ind, (Univ.Instance.of_array u))).

Definition mk_sort_accu (s : Sorts.t) (u : array Univ.Level.t) : t :=
  match s with
  | SProp | Prop | Set =&gt; mk_accu (Asort s)
  | Type s =&gt;
    let u := Univ.Instance.of_array u in
    let s := Sorts.sort_of_univ (Univ.subst_instance_universe u s) in
    mk_accu (Asort s)
  end.

Definition mk_var_accu (id : Names.Id.t) : t := mk_accu (Avar id).

Definition mk_sw_accu (annot : annot_sw) (c : accumulator) (p : t) (ac : t -&gt; t)
  : t := mk_accu (Acase annot c p ac).

Definition mk_prod_accu (s : Names.Name.t) (dom : t) (codom : t -&gt; t) : t :=
  mk_accu (Aprod s dom codom).

Definition mk_meta_accu (mv : Constr.metavariable) (ty : t) : t :=
  mk_accu (Ameta mv ty).

Definition mk_evar_accu (ev : Evar.t) (args : array t) : t :=
  mk_accu (Aevar ev args).

Definition mk_proj_accu (kn : Names.inductive * Z) (c : accumulator) : t :=
  mk_accu (Aproj kn c).

Definition atom_of_accu (k : accumulator) : atom := acc_atm (get_accu k).

Definition set_atom_of_accu (k : accumulator) (a : atom) : unit := set_field.

Definition accu_nargs (k : accumulator) : Z :=
  Util.List.(CList.ExtS.length) (acc_arg (get_accu k)).

Definition args_of_accu (k : accumulator) : array t :=
  let acc := acc_arg (get_accu k) in
  Stdlib.Obj.magic (Util.Array.(CArray.ExtS.of_list) acc).

Definition mk_fix_accu
  (rec_pos : rec_pos) (pos : Z) (types : array t) (bodies : array t) : t :=
  mk_accu (Afix types bodies rec_pos pos).

Definition mk_cofix_accu (pos : Z) (types : array t) (norm : array t) : t :=
  mk_accu (Acofix types norm pos (Stdlib.Obj.magic 0)).

Definition upd_cofix (cofix : t) (cofix_fun : t) : unit :=
  let atom := atom_of_accu (Stdlib.Obj.magic cofix) in
  match atom with
  | Acofix typ norm pos _ =&gt;
    set_atom_of_accu (Stdlib.Obj.magic cofix) (Acofix typ norm pos cofix_fun)
  | _ =&gt; false
  end.

Definition force_cofix (cofix : t) : t :=
  let accu := Stdlib.Obj.magic cofix in
  let atom := atom_of_accu accu in
  match atom with
  | Acofix typ norm pos f =&gt;
    let args := args_of_accu accu in
    let f :=
      Util.Array.(CArray.ExtS.fold_right) (fun arg =&gt; fun f =&gt; f arg) args f in
    let v := f (Stdlib.Obj.magic tt) in
    set_atom_of_accu accu (Acofixe typ norm pos v);
    v
  | Acofixe _ _ _ v =&gt; v
  | _ =&gt; cofix
  end.

Definition mk_const {A B : Type} (tag : A) : B := Stdlib.Obj.magic tag.

Definition mk_block {A : Type} (tag : Z) (args : array A) : t :=
  let nargs := Util.Array.(CArray.ExtS.length) args in
  let r := Stdlib.Obj.new_block tag nargs in
  for;
  Stdlib.Obj.magic r.

Definition dummy_value (function_parameter : unit) : t :=
  match function_parameter with
  | tt =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | _ =&gt;
        CErrors.anomaly None (Some &quot;native&quot; % string)
          (Pp.str &quot;Evaluation failed.&quot; % string)
      end
  end.

Definition cast_accu {A : Type} (v : A) : accumulator := Stdlib.Obj.magic v.

Definition mk_int (x : Z) : t := Stdlib.Obj.magic x.

Definition mk_bool (b : bool) : t := Stdlib.Obj.magic (negb b).

Definition mk_uint (x : Uint63.t) : t := Stdlib.Obj.magic x.

Parameter block : Type.

Definition block_size (b : block) : Z := Stdlib.Obj.size (Stdlib.Obj.magic b).

Definition block_field (b : block) (i : Z) : t :=
  Stdlib.Obj.magic (Stdlib.Obj.field (Stdlib.Obj.magic b) i).

Definition block_tag (b : block) : Z := Stdlib.Obj.tag (Stdlib.Obj.magic b).

Inductive kind_of_value : Type :=
| Vaccu : accumulator -&gt; kind_of_value
| Vfun : (t -&gt; t) -&gt; kind_of_value
| Vconst : Z -&gt; kind_of_value
| Vint64 : int64 -&gt; kind_of_value
| Vblock : block -&gt; kind_of_value.

Definition kind_of_value (v : t) : kind_of_value :=
  let o := Stdlib.Obj.repr v in
  if Stdlib.Obj.is_int o then
    Vconst (Stdlib.Obj.magic v)
  else
    let tag := Stdlib.Obj.tag o in
    if Int.equal tag accumulate_tag then
      Vaccu (Stdlib.Obj.magic v)
    else
      if Int.equal tag Stdlib.Obj.custom_tag then
        Vint64 (Stdlib.Obj.magic v)
      else
        if OCaml.Stdlib.lt tag Stdlib.Obj.lazy_tag then
          Vblock (Stdlib.Obj.magic v)
        else
          Vfun v.

Definition is_int (x : t) : bool :=
  let o := Stdlib.Obj.repr x in
  orb (Stdlib.Obj.is_int o) (Int.equal (Stdlib.Obj.tag o) Stdlib.Obj.custom_tag).

Definition val_to_int (x : t) : Z := Stdlib.Obj.magic x.

Definition to_uint (x : t) : Uint63.t := Stdlib.Obj.magic x.

Definition no_check_head0 (x : t) : t := mk_uint (Uint63.head0 (to_uint x)).

Definition head0 (accu : t -&gt; t) (x : t) : t :=
  if is_int x then
    no_check_head0 x
  else
    accu x.

Definition no_check_tail0 (x : t) : t := mk_uint (Uint63.tail0 (to_uint x)).

Definition tail0 (accu : t -&gt; t) (x : t) : t :=
  if is_int x then
    no_check_tail0 x
  else
    accu x.

Definition no_check_add (x : t) (y : t) : t :=
  mk_uint (Uint63.add (to_uint x) (to_uint y)).

Definition add (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_add x y
  else
    accu x y.

Definition no_check_sub (x : t) (y : t) : t :=
  mk_uint (Uint63.sub (to_uint x) (to_uint y)).

Definition sub (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_sub x y
  else
    accu x y.

Definition no_check_mul (x : t) (y : t) : t :=
  mk_uint (Uint63.mul (to_uint x) (to_uint y)).

Definition mul (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_mul x y
  else
    accu x y.

Definition no_check_div (x : t) (y : t) : t :=
  mk_uint (Uint63.div (to_uint x) (to_uint y)).

Definition div (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_div x y
  else
    accu x y.

Definition no_check_rem (x : t) (y : t) : t :=
  mk_uint (Uint63.rem (to_uint x) (to_uint y)).

Definition rem (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_rem x y
  else
    accu x y.

Definition no_check_l_sr (x : t) (y : t) : t :=
  mk_uint (Uint63.l_sr (to_uint x) (to_uint y)).

Definition l_sr (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_l_sr x y
  else
    accu x y.

Definition no_check_l_sl (x : t) (y : t) : t :=
  mk_uint (Uint63.l_sl (to_uint x) (to_uint y)).

Definition l_sl (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_l_sl x y
  else
    accu x y.

Definition no_check_l_and (x : t) (y : t) : t :=
  mk_uint (Uint63.l_and (to_uint x) (to_uint y)).

Definition l_and (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_l_and x y
  else
    accu x y.

Definition no_check_l_xor (x : t) (y : t) : t :=
  mk_uint (Uint63.l_xor (to_uint x) (to_uint y)).

Definition l_xor (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_l_xor x y
  else
    accu x y.

Definition no_check_l_or (x : t) (y : t) : t :=
  mk_uint (Uint63.l_or (to_uint x) (to_uint y)).

Definition l_or (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_l_or x y
  else
    accu x y.

Inductive coq_carry : Type :=
| Caccu : t -&gt; coq_carry
| C0 : t -&gt; coq_carry
| C1 : t -&gt; coq_carry.

Inductive coq_pair : Type :=
| Paccu : t -&gt; coq_pair
| PPair : t -&gt; t -&gt; coq_pair.

Definition mkCarry (b : bool) (i : Uint63.t) : t :=
  if b then
    Stdlib.Obj.magic (C1 (mk_uint i))
  else
    Stdlib.Obj.magic (C0 (mk_uint i)).

Definition no_check_addc (x : t) (y : t) : t :=
  let s := Uint63.add (to_uint x) (to_uint y) in
  mkCarry (Uint63.lt s (to_uint x)) s.

Definition addc (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_addc x y
  else
    accu x y.

Definition no_check_subc (x : t) (y : t) : t :=
  let s := Uint63.sub (to_uint x) (to_uint y) in
  mkCarry (Uint63.lt (to_uint x) (to_uint y)) s.

Definition subc (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_subc x y
  else
    accu x y.

Definition no_check_addCarryC (x : t) (y : t) : t :=
  let s := Uint63.add (Uint63.add (to_uint x) (to_uint y)) (Uint63.of_int 1) in
  mkCarry (Uint63.le s (to_uint x)) s.

Definition addCarryC (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_addCarryC x y
  else
    accu x y.

Definition no_check_subCarryC (x : t) (y : t) : t :=
  let s := Uint63.sub (Uint63.sub (to_uint x) (to_uint y)) (Uint63.of_int 1) in
  mkCarry (Uint63.le (to_uint x) (to_uint y)) s.

Definition subCarryC (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_subCarryC x y
  else
    accu x y.

Definition of_pair (function_parameter : Uint63.t * Uint63.t) : t :=
  match function_parameter with
  | (x, y) =&gt; Stdlib.Obj.magic (PPair (mk_uint x) (mk_uint y))
  end.

Definition no_check_mulc (x : t) (y : t) : t :=
  of_pair (Uint63.mulc (to_uint x) (to_uint y)).

Definition mulc (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_mulc x y
  else
    accu x y.

Definition no_check_diveucl (x : t) (y : t) : t :=
  match ((to_uint x), (to_uint y)) with
  | (i1, i2) =&gt; of_pair ((Uint63.div i1 i2), (Uint63.rem i1 i2))
  end.

Definition diveucl (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_diveucl x y
  else
    accu x y.

Definition no_check_div21 (x : t) (y : t) (z : t) : t :=
  match ((to_uint x), (to_uint y), (to_uint z)) with
  | (i1, i2, i3) =&gt; of_pair (Uint63.div21 i1 i2 i3)
  end.

Definition div21 (accu : t -&gt; t -&gt; t -&gt; t) (x : t) (y : t) (z : t) : t :=
  if andb (is_int x) (andb (is_int y) (is_int z)) then
    no_check_div21 x y z
  else
    accu x y z.

Definition no_check_addMulDiv (x : t) (y : t) (z : t) : t :=
  match ((to_uint x), (to_uint y), (to_uint z)) with
  | (p, i, j) =&gt; mk_uint (Uint63.addmuldiv p i j)
  end.

Definition addMulDiv (accu : t -&gt; t -&gt; t -&gt; t) (x : t) (y : t) (z : t) : t :=
  if andb (is_int x) (andb (is_int y) (is_int z)) then
    no_check_addMulDiv x y z
  else
    accu x y z.

Inductive coq_bool : Type :=
| Baccu : t -&gt; coq_bool
| Btrue : coq_bool
| Bfalse : coq_bool.

Inductive coq_cmp : Type :=
| CmpAccu : t -&gt; coq_cmp
| CmpEq : coq_cmp
| CmpLt : coq_cmp
| CmpGt : coq_cmp.

Definition no_check_eq (x : t) (y : t) : t :=
  mk_bool (Uint63.equal (to_uint x) (to_uint y)).

Definition eq (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_eq x y
  else
    accu x y.

Definition no_check_lt (x : t) (y : t) : t :=
  mk_bool (Uint63.lt (to_uint x) (to_uint y)).

Definition lt (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_lt x y
  else
    accu x y.

Definition no_check_le (x : t) (y : t) : t :=
  mk_bool (Uint63.le (to_uint x) (to_uint y)).

Definition le (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_le x y
  else
    accu x y.

Definition no_check_compare (x : t) (y : t) : t :=
  match Uint63.compare (to_uint x) (to_uint y) with
  | 0 =&gt; Stdlib.Obj.magic CmpEq
  | _ =&gt; Stdlib.Obj.magic CmpGt
  end.

Definition compare (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_compare x y
  else
    accu x y.

Definition print (x : t) : t :=
  Stdlib.Printf.fprintf Stdlib.stderr
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
        CamlinternalFormatBasics.End_of_format) &quot;%s&quot; % string)
    (Uint63.to_string (to_uint x));
  Stdlib.flush Stdlib.stderr;
  x.

Definition hobcnv : array string :=
  Util.Array.(CArray.ExtS.init) 256
    (fun i =&gt;
      Stdlib.Printf.sprintf
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_x
            (CamlinternalFormatBasics.Lit_padding CamlinternalFormatBasics.Zeros
              2) CamlinternalFormatBasics.No_precision
            CamlinternalFormatBasics.End_of_format) &quot;%02x&quot; % string) i).

Definition bohcnv : array Z :=
  Util.Array.(CArray.ExtS.init) 256
    (fun i =&gt;
      Util.op_minus
        (Util.op_minus
          (Util.op_minus i
            (if OCaml.Stdlib.le 48 i then
              48
            else
              0))
          (if OCaml.Stdlib.le 65 i then
            7
          else
            0))
        (if OCaml.Stdlib.le 97 i then
          32
        else
          0)).

Definition hex_of_bin (ch : ascii) : string :=
  Util.Array.(CArray.ExtS.get) hobcnv (OCaml.Stdlib.int_of_char ch).

Definition bin_of_hex (s : string) : ascii :=
  OCaml.Stdlib.char_of_int
    (Util.op_plus
      (Z.mul
        (Util.Array.(CArray.ExtS.get) bohcnv
          (OCaml.Stdlib.int_of_char (Util.String.(CString.ExtS.get) s 0))) 16)
      (Util.Array.(CArray.ExtS.get) bohcnv
        (OCaml.Stdlib.int_of_char (Util.String.(CString.ExtS.get) s 1)))).

Definition str_encode {A : Type} (expr : A) : string :=
  let mshl_expr := Stdlib.Marshal.to_string expr [] in
  let payload :=
    Stdlib.Buffer.create (Z.mul (Util.String.(CString.ExtS.length) mshl_expr) 2)
    in
  Util.String.(CString.ExtS.iter)
    (fun c =&gt; Stdlib.Buffer.add_string payload (hex_of_bin c)) mshl_expr;
  Stdlib.Buffer.contents payload.

Definition str_decode {A : Type} (s : string) : A :=
  let mshl_expr_len := Z.div (Util.String.(CString.ExtS.length) s) 2 in
  let mshl_expr := Stdlib.Buffer.create mshl_expr_len in
  let buf := Stdlib.Bytes.create 2 in
  for;
  Stdlib.Marshal.from_bytes (Stdlib.Buffer.to_bytes mshl_expr) 0.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="opaqueproof" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>opaqueproof.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Univ
open Constr
open Mod_subst

type work_list = (Instance.t * Id.t array) Cmap.t * 
  (Instance.t * Id.t array) Mindmap.t

type cooking_info = {
  modlist : work_list;
  abstract : Constr.named_context * Univ.Instance.t * Univ.AUContext.t }

type 'a delayed_universes =
| PrivateMonomorphic of 'a
| PrivatePolymorphic of int * Univ.ContextSet.t

type opaque_proofterm = (Constr.t * unit delayed_universes) option

type indirect_accessor = {
  access_proof : DirPath.t -&gt; int -&gt; opaque_proofterm;
  access_discharge : cooking_info list -&gt; (Constr.t * unit delayed_universes) -&gt; (Constr.t * unit delayed_universes);
}

let drop_mono = function
| PrivateMonomorphic _ -&gt; PrivateMonomorphic ()
| PrivatePolymorphic _ as ctx -&gt; ctx

type proofterm = (constr * Univ.ContextSet.t delayed_universes) Future.computation

type opaque =
| Indirect of substitution list * cooking_info list * DirPath.t * int (* subst, discharge, lib, index *)

type opaquetab = {
  opaque_val : proofterm Int.Map.t;
  (** Actual proof terms *)
  opaque_len : int;
  (** Size of the above map *)
  opaque_dir : DirPath.t;
}
let empty_opaquetab = {
  opaque_val = Int.Map.empty;
  opaque_len = 0;
  opaque_dir = DirPath.initial;
}

let not_here () =
  CErrors.user_err Pp.(str &quot;Cannot access opaque delayed proof&quot;)

let create dp cu tab =
  let hcons (c, u) =
    let c = Constr.hcons c in
    let u = match u with
    | PrivateMonomorphic u -&gt; PrivateMonomorphic (Univ.hcons_universe_context_set u)
    | PrivatePolymorphic (n, u) -&gt; PrivatePolymorphic (n, Univ.hcons_universe_context_set u)
    in
    (c, u)
  in
  let cu = Future.chain cu hcons in
  let id = tab.opaque_len in
  let opaque_val = Int.Map.add id cu tab.opaque_val in
  let opaque_dir =
    if DirPath.equal dp tab.opaque_dir then tab.opaque_dir
    else if DirPath.equal tab.opaque_dir DirPath.initial then dp
    else CErrors.anomaly
      (Pp.str &quot;Using the same opaque table for multiple dirpaths.&quot;) in
  let ntab = { opaque_val; opaque_dir; opaque_len = id + 1 } in
  Indirect ([], [], dp, id), ntab

let subst_opaque sub = function
| Indirect (s, ci, dp, i) -&gt; Indirect (sub :: s, ci, dp, i)

let discharge_opaque info = function
| Indirect (s, ci, dp, i) -&gt;
  assert (CList.is_empty s);
  Indirect ([], info :: ci, dp, i)

let join except cu = match except with
| None -&gt; ignore (Future.join cu)
| Some except -&gt;
  if Future.UUIDSet.mem (Future.uuid cu) except then ()
  else ignore (Future.join cu)

let join_opaque ?except { opaque_val = prfs; opaque_dir = odp; _ } = function
| Indirect (_,_,dp,i) -&gt;
    if DirPath.equal dp odp then
      let fp = Int.Map.find i prfs in
      join except fp

let force_proof access { opaque_val = prfs; opaque_dir = odp; _ } = function
  | Indirect (l,d,dp,i) -&gt;
      let c, u =
        if DirPath.equal dp odp
        then
          let cu = Int.Map.find i prfs in
          let (c, u) = Future.force cu in
          access.access_discharge d (c, drop_mono u)
        else
          let cu = access.access_proof dp i in
          match cu with
          | None -&gt; not_here ()
          | Some (c, u) -&gt; access.access_discharge d (c, u)
      in
      let c = force_constr (List.fold_right subst_substituted l (from_val c)) in
      (c, u)

let get_mono (_, u) = match u with
| PrivateMonomorphic ctx -&gt; ctx
| PrivatePolymorphic _ -&gt; Univ.ContextSet.empty

let force_constraints _access { opaque_val = prfs; opaque_dir = odp; _ } = function
| Indirect (_,_,dp,i) -&gt;
      if DirPath.equal dp odp
      then
        let cu = Int.Map.find i prfs in
        get_mono (Future.force cu)
      else Univ.ContextSet.empty

module FMap = Future.UUIDMap

let dump ?(except = Future.UUIDSet.empty) { opaque_val = otab; opaque_len = n; _ } =
  let opaque_table = Array.make n None in
  let f2t_map = ref FMap.empty in
  let iter n cu =
    let uid = Future.uuid cu in
    let () = f2t_map := FMap.add (Future.uuid cu) n !f2t_map in
    let c =
      if Future.is_val cu then
        let (c, priv) = Future.force cu in
        let priv = drop_mono priv in
        Some (c, priv)
      else if Future.UUIDSet.mem uid except then None
      else
        CErrors.anomaly
          Pp.(str&quot;Proof object &quot;++int n++str&quot; is not checked nor to be checked&quot;)
    in
    opaque_table.(n) &lt;- c
  in
  let () = Int.Map.iter iter otab in
  opaque_table, !f2t_map
</pre>
          </div>
          <div class="col-md-6">
            <code>opaqueproof.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Names.

Import Univ.

Import Constr.

Import Mod_subst.

Definition work_list :=
  (Names.Cmap.t (Univ.Instance.t * (array Names.Id.t))) *
    (Names.Mindmap.t (Univ.Instance.t * (array Names.Id.t))).

Record cooking_info := {
  modlist : work_list;
  abstract : Constr.named_context * Univ.Instance.t * Univ.AUContext.t }.

Inductive delayed_universes (a : Type) : Type :=
| PrivateMonomorphic : a -&gt; delayed_universes a
| PrivatePolymorphic : Z -&gt; Univ.ContextSet.t -&gt; delayed_universes a.

Arguments PrivateMonomorphic {_}.
Arguments PrivatePolymorphic {_}.

Definition opaque_proofterm := option (Constr.t * (delayed_universes unit)).

Record indirect_accessor := {
  access_proof : Names.DirPath.t -&gt; Z -&gt; opaque_proofterm;
  access_discharge :
    (list cooking_info) -&gt;
      (Constr.t * (delayed_universes unit)) -&gt;
        Constr.t * (delayed_universes unit) }.

Definition drop_mono {A : Type} (function_parameter : delayed_universes A)
  : delayed_universes unit :=
  match function_parameter with
  | PrivateMonomorphic _ =&gt; PrivateMonomorphic tt
  | (PrivatePolymorphic _ _) as ctx =&gt; ctx
  end.

Definition proofterm :=
  Future.computation (Constr.constr * (delayed_universes Univ.ContextSet.t)).

Inductive opaque : Type :=
| Indirect : (list Mod_subst.substitution) -&gt; (list cooking_info) -&gt;
  Names.DirPath.t -&gt; Z -&gt; opaque.

Record opaquetab := {
  opaque_val : Int.Map.t proofterm;
  opaque_len : Z;
  opaque_dir : Names.DirPath.t }.

Definition empty_opaquetab : opaquetab :=
  {| opaque_val := Int.Map.empty; opaque_len := 0;
    opaque_dir := Names.DirPath.initial |}.

Definition not_here {A : Type} (function_parameter : unit) : A :=
  match function_parameter with
  | tt =&gt;
    CErrors.user_err None None
      (Pp.str &quot;Cannot access opaque delayed proof&quot; % string)
  end.

Definition create
  (dp : Names.DirPath.t)
  (cu :
    Future.computation (Constr.constr * (delayed_universes Univ.ContextSet.t)))
  (tab : opaquetab) : opaque * opaquetab :=
  let hcons
    (function_parameter : Constr.constr * (delayed_universes Univ.ContextSet.t))
    : Constr.constr * (delayed_universes Univ.ContextSet.t) :=
    match function_parameter with
    | (c, u) =&gt;
      let c := Constr.hcons c in
      let u :=
        match u with
        | PrivateMonomorphic u =&gt;
          PrivateMonomorphic (Univ.hcons_universe_context_set u)
        | PrivatePolymorphic n u =&gt;
          PrivatePolymorphic n (Univ.hcons_universe_context_set u)
        end in
      (c, u)
    end in
  let cu := Future.chain cu hcons in
  let id := opaque_len tab in
  let opaque_val := Int.Map.add id cu (opaque_val tab) in
  let opaque_dir :=
    if Names.DirPath.equal dp (opaque_dir tab) then
      opaque_dir tab
    else
      if Names.DirPath.equal (opaque_dir tab) Names.DirPath.initial then
        dp
      else
        CErrors.anomaly None None
          (Pp.str &quot;Using the same opaque table for multiple dirpaths.&quot; % string)
    in
  let ntab :=
    {| opaque_val := opaque_val; opaque_len := Z.add id 1;
      opaque_dir := opaque_dir |} in
  ((Indirect [] [] dp id), ntab).

Definition subst_opaque
  (sub : Mod_subst.substitution) (function_parameter : opaque) : opaque :=
  match function_parameter with
  | Indirect s ci dp i =&gt; Indirect (cons sub s) ci dp i
  end.

Definition discharge_opaque (info : cooking_info) (function_parameter : opaque)
  : opaque :=
  match function_parameter with
  | Indirect s ci dp i =&gt;
    CList.is_empty s;
    Indirect [] (cons info ci) dp i
  end.

Definition join {A : Type}
  (except : option Future.UUIDSet.t) (cu : Future.computation A) : unit :=
  match except with
  | None =&gt; OCaml.Stdlib.ignore (Future.join cu)
  | Some except =&gt;
    if Future.UUIDSet.mem (Future.uuid cu) except then
      tt
    else
      OCaml.Stdlib.ignore (Future.join cu)
  end.

Definition join_opaque
  (except : option Future.UUIDSet.t) (function_parameter : opaquetab)
  : opaque -&gt; unit :=
  match function_parameter with
  | {| opaque_val := prfs; opaque_dir := odp |} =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | Indirect _ _ dp i =&gt;
        if Names.DirPath.equal dp odp then
          let fp := Int.Map.find i prfs in
          join except fp
        else
          tt
      end
  end.

Definition force_proof
  (access : indirect_accessor) (function_parameter : opaquetab)
  : opaque -&gt; Constr.constr * (delayed_universes unit) :=
  match function_parameter with
  | {| opaque_val := prfs; opaque_dir := odp |} =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | Indirect l d dp i =&gt;
        match
          if Names.DirPath.equal dp odp then
            let cu := Int.Map.find i prfs in
            match Future.force cu with
            | (c, u) =&gt; (access_discharge access) d (c, (drop_mono u))
            end
          else
            let cu := (access_proof access) dp i in
            match cu with
            | None =&gt; not_here tt
            | Some (c, u) =&gt; (access_discharge access) d (c, u)
            end with
        | (c, u) =&gt;
          let c :=
            Mod_subst.force_constr
              (Stdlib.List.fold_right Mod_subst.subst_substituted l
                (Mod_subst.from_val c)) in
          (c, u)
        end
      end
  end.

Definition get_mono {A : Type}
  (function_parameter : A * (delayed_universes Univ.ContextSet.t))
  : Univ.ContextSet.t :=
  match function_parameter with
  | (_, u) =&gt;
    match u with
    | PrivateMonomorphic ctx =&gt; ctx
    | PrivatePolymorphic _ _ =&gt; Univ.ContextSet.empty
    end
  end.

Definition force_constraints {A : Type}
  (_access : A) (function_parameter : opaquetab)
  : opaque -&gt; Univ.ContextSet.t :=
  match function_parameter with
  | {| opaque_val := prfs; opaque_dir := odp |} =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | Indirect _ _ dp i =&gt;
        if Names.DirPath.equal dp odp then
          let cu := Int.Map.find i prfs in
          get_mono (Future.force cu)
        else
          Univ.ContextSet.empty
      end
  end.

Definition dump (op_star_o_p_t_star : option Future.UUIDSet.t)
  : opaquetab -&gt;
    (array (option (Constr.constr * (delayed_universes unit)))) *
      (FMap.t Int.Map.key) :=
  let except :=
    match op_star_o_p_t_star with
    | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
    | None =&gt; Future.UUIDSet.empty
    end in
  fun function_parameter =&gt;
    match function_parameter with
    | {| opaque_val := otab; opaque_len := n |} =&gt;
      let opaque_table := Stdlib.Array.make n None in
      let f2t_map := Stdlib.ref FMap.empty in
      let iter {A : Type}
        (n : Int.Map.key) (cu :
        Future.computation (Constr.constr * (delayed_universes A))) : unit :=
        let uid := Future.uuid cu in
        match
          Stdlib.op_colon_eq f2t_map
            (FMap.add (Future.uuid cu) n (Stdlib.op_exclamation f2t_map)) with
        | tt =&gt;
          let c :=
            if Future.is_val cu then
              match Future.force cu with
              | (c, priv) =&gt;
                let priv := drop_mono priv in
                Some (c, priv)
              end
            else
              if Future.UUIDSet.mem uid except then
                None
              else
                CErrors.anomaly None None
                  (Pp.op_plus_plus
                    (Pp.op_plus_plus (Pp.str &quot;Proof object &quot; % string)
                      (Pp.int n))
                    (Pp.str &quot; is not checked nor to be checked&quot; % string)) in
          Stdlib.Array.set opaque_table n c
        end in
      match Int.Map.iter iter otab with
      | tt =&gt; (opaque_table, (Stdlib.op_exclamation f2t_map))
      end
    end.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="primred" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>primred.ml</code>
            <pre>(* Reduction of native operators *)
open Names
open CPrimitives
open Retroknowledge
open Environ
open CErrors

let add_retroknowledge env action =
  match action with
  | Register_type(PT_int63,c) -&gt;
    let retro = env.retroknowledge in
    let retro =
      match retro.retro_int63 with
      | None -&gt; { retro with retro_int63 = Some c }
      | Some c' -&gt; assert (Constant.equal c c'); retro in
    set_retroknowledge env retro
  | Register_ind(pit,ind) -&gt;
    let retro = env.retroknowledge in
    let retro =
      match pit with
      | PIT_bool -&gt;
        let r =
          match retro.retro_bool with
          | None -&gt; ((ind,1), (ind,2))
          | Some (((ind',_),_) as t) -&gt; assert (eq_ind ind ind'); t in
        { retro with retro_bool = Some r }
      | PIT_carry -&gt;
        let r =
          match retro.retro_carry with
          | None -&gt; ((ind,1), (ind,2))
          | Some (((ind',_),_) as t) -&gt; assert (eq_ind ind ind'); t in
        { retro with retro_carry = Some r }
      | PIT_pair -&gt;
        let r =
          match retro.retro_pair with
          | None -&gt; (ind,1)
          | Some ((ind',_) as t) -&gt; assert (eq_ind ind ind'); t in
        { retro with retro_pair = Some r }
      | PIT_cmp -&gt;
        let r =
          match retro.retro_cmp with
          | None -&gt; ((ind,1), (ind,2), (ind,3))
          | Some (((ind',_),_,_) as t) -&gt; assert (eq_ind ind ind'); t in
        { retro with retro_cmp = Some r }
    in
    set_retroknowledge env retro

let get_int_type env =
  match env.retroknowledge.retro_int63 with
  | Some c -&gt; c
  | None -&gt; anomaly Pp.(str&quot;Reduction of primitive: int63 not registered&quot;)

let get_bool_constructors env =
  match env.retroknowledge.retro_bool with
  | Some r -&gt; r
  | None -&gt; anomaly Pp.(str&quot;Reduction of primitive: bool not registered&quot;)

let get_carry_constructors env =
  match env.retroknowledge.retro_carry with
  | Some r -&gt; r
  | None -&gt; anomaly Pp.(str&quot;Reduction of primitive: carry not registered&quot;)

let get_pair_constructor env =
  match env.retroknowledge.retro_pair with
  | Some c  -&gt; c
  | None -&gt; anomaly Pp.(str&quot;Reduction of primitive: pair not registered&quot;)

let get_cmp_constructors env =
  match env.retroknowledge.retro_cmp with
  | Some r -&gt; r
  | None -&gt; anomaly Pp.(str&quot;Reduction of primitive: cmp not registered&quot;)

exception NativeDestKO

module type RedNativeEntries =
  sig
    type elem
    type args
    type evd (* will be unit in kernel, evar_map outside *)

    val get : args -&gt; int -&gt; elem
    val get_int : evd -&gt; elem -&gt; Uint63.t
    val mkInt : env -&gt; Uint63.t -&gt; elem
    val mkBool : env -&gt; bool -&gt; elem
    val mkCarry : env -&gt; bool -&gt; elem -&gt; elem (* true if carry *)
    val mkIntPair : env -&gt; elem -&gt; elem -&gt; elem
    val mkLt : env -&gt; elem
    val mkEq : env -&gt; elem
    val mkGt : env -&gt; elem

  end

module type RedNative =
 sig
   type elem
   type args
   type evd
   val red_prim : env -&gt; evd -&gt; CPrimitives.t -&gt; args -&gt; elem option
 end

module RedNative (E:RedNativeEntries) :
  RedNative with type elem = E.elem
  with type args = E.args
  with type evd = E.evd =
struct
  type elem = E.elem
  type args = E.args
  type evd = E.evd

  let get_int evd args i = E.get_int evd (E.get args i)

  let get_int1 evd args = get_int evd args 0

  let get_int2 evd args = get_int evd args 0, get_int evd args 1

  let get_int3 evd args =
    get_int evd args 0, get_int evd args 1, get_int evd args 2

  let red_prim_aux env evd op args =
    let open CPrimitives in
    match op with
    | Int63head0 -&gt;
      let i = get_int1 evd args in E.mkInt env (Uint63.head0 i)
    | Int63tail0 -&gt;
      let i = get_int1 evd args in E.mkInt env (Uint63.tail0 i)
    | Int63add -&gt;
      let i1, i2 = get_int2 evd args in E.mkInt env (Uint63.add i1 i2)
    | Int63sub -&gt;
      let i1, i2 = get_int2 evd args in E.mkInt env (Uint63.sub i1 i2)
    | Int63mul -&gt;
      let i1, i2 = get_int2 evd args in E.mkInt env (Uint63.mul i1 i2)
    | Int63div -&gt;
      let i1, i2 = get_int2 evd args in E.mkInt env (Uint63.div i1 i2)
    | Int63mod -&gt;
      let i1, i2 = get_int2 evd args in E.mkInt env (Uint63.rem i1 i2)
    | Int63lsr -&gt;
      let i1, i2 = get_int2 evd args in E.mkInt env (Uint63.l_sr i1 i2)
    | Int63lsl -&gt;
      let i1, i2 = get_int2 evd args in E.mkInt env (Uint63.l_sl i1 i2)
    | Int63land -&gt;
      let i1, i2 = get_int2 evd args in E.mkInt env (Uint63.l_and i1 i2)
    | Int63lor -&gt;
      let i1, i2 = get_int2 evd args in E.mkInt env (Uint63.l_or i1 i2)
    | Int63lxor -&gt;
      let i1, i2 = get_int2 evd args in E.mkInt env (Uint63.l_xor i1 i2)
    | Int63addc -&gt;
      let i1, i2 = get_int2 evd args in
      let s = Uint63.add i1 i2 in
      E.mkCarry env (Uint63.lt s i1) (E.mkInt env s)
    | Int63subc -&gt;
      let i1, i2 = get_int2 evd args in
      let s = Uint63.sub i1 i2 in
      E.mkCarry env (Uint63.lt i1 i2) (E.mkInt env s)
    | Int63addCarryC  -&gt;
      let i1, i2 = get_int2 evd args in
      let s = Uint63.add (Uint63.add i1 i2) (Uint63.of_int 1) in
      E.mkCarry env (Uint63.le s i1) (E.mkInt env s)
    | Int63subCarryC  -&gt;
      let i1, i2 = get_int2 evd args in
      let s = Uint63.sub (Uint63.sub i1 i2) (Uint63.of_int 1) in
      E.mkCarry env (Uint63.le i1 i2) (E.mkInt env s)
    | Int63mulc -&gt;
      let i1, i2 = get_int2 evd args in
      let (h, l) = Uint63.mulc i1 i2 in
      E.mkIntPair env (E.mkInt env h) (E.mkInt env l)
    | Int63diveucl -&gt;
      let i1, i2 = get_int2 evd args in
      let q,r = Uint63.div i1 i2, Uint63.rem i1 i2 in
      E.mkIntPair env (E.mkInt env q) (E.mkInt env r)
    | Int63div21 -&gt;
      let i1, i2, i3 = get_int3 evd args in
      let q,r = Uint63.div21 i1 i2 i3 in
      E.mkIntPair env (E.mkInt env q) (E.mkInt env r)
    | Int63addMulDiv -&gt;
      let p, i, j = get_int3 evd args in
      E.mkInt env
        (Uint63.l_or
           (Uint63.l_sl i p)
           (Uint63.l_sr j (Uint63.sub (Uint63.of_int Uint63.uint_size) p)))
    | Int63eq -&gt;
      let i1, i2 = get_int2 evd args in
      E.mkBool env (Uint63.equal i1 i2)
    | Int63lt -&gt;
      let i1, i2 = get_int2 evd args in
      E.mkBool env (Uint63.lt i1 i2)
    | Int63le -&gt;
      let i1, i2 = get_int2 evd args in
      E.mkBool env (Uint63.le i1 i2)
    | Int63compare -&gt;
      let i1, i2 = get_int2 evd args in
      begin match Uint63.compare i1 i2 with
        | x when x &lt; 0 -&gt;  E.mkLt env
        | 0 -&gt; E.mkEq env
        | _ -&gt; E.mkGt env
      end

  let red_prim env evd p args =
    try
      let r =
        red_prim_aux env evd p args
      in Some r
    with NativeDestKO -&gt; None

end
</pre>
          </div>
          <div class="col-md-6">
            <code>primred.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Names.

Import CPrimitives.

Import Retroknowledge.

Import Environ.

Import CErrors.

Definition add_retroknowledge
  (env : Environ.env) (action : Retroknowledge.action) : Environ.env :=
  match action with
  | Register_type PT_int63 c =&gt;
    let retro := retroknowledge env in
    let retro :=
      match retro_int63 retro with
      | None =&gt; record
      | Some c' =&gt;
        Names.Constant.equal c c';
        retro
      end in
    Environ.set_retroknowledge env retro
  | Register_ind pit ind =&gt;
    let retro := retroknowledge env in
    let retro :=
      match pit with
      | PIT_bool =&gt;
        let r :=
          match retro_bool retro with
          | None =&gt; ((ind, 1), (ind, 2))
          | Some (((ind', _), _) as t) =&gt;
            Names.eq_ind ind ind';
            t
          end in
        record
      | PIT_carry =&gt;
        let r :=
          match retro_carry retro with
          | None =&gt; ((ind, 1), (ind, 2))
          | Some (((ind', _), _) as t) =&gt;
            Names.eq_ind ind ind';
            t
          end in
        record
      | PIT_pair =&gt;
        let r :=
          match retro_pair retro with
          | None =&gt; (ind, 1)
          | Some ((ind', _) as t) =&gt;
            Names.eq_ind ind ind';
            t
          end in
        record
      | PIT_cmp =&gt;
        let r :=
          match retro_cmp retro with
          | None =&gt; ((ind, 1), (ind, 2), (ind, 3))
          | Some (((ind', _), _, _) as t) =&gt;
            Names.eq_ind ind ind';
            t
          end in
        record
      end in
    Environ.set_retroknowledge env retro
  end.

Definition get_int_type (env : Environ.env) : Names.Constant.t :=
  match retro_int63 (retroknowledge env) with
  | Some c =&gt; c
  | None =&gt;
    CErrors.anomaly None None
      (Pp.str &quot;Reduction of primitive: int63 not registered&quot; % string)
  end.

Definition get_bool_constructors (env : Environ.env)
  : Names.constructor * Names.constructor :=
  match retro_bool (retroknowledge env) with
  | Some r =&gt; r
  | None =&gt;
    CErrors.anomaly None None
      (Pp.str &quot;Reduction of primitive: bool not registered&quot; % string)
  end.

Definition get_carry_constructors (env : Environ.env)
  : Names.constructor * Names.constructor :=
  match retro_carry (retroknowledge env) with
  | Some r =&gt; r
  | None =&gt;
    CErrors.anomaly None None
      (Pp.str &quot;Reduction of primitive: carry not registered&quot; % string)
  end.

Definition get_pair_constructor (env : Environ.env) : Names.constructor :=
  match retro_pair (retroknowledge env) with
  | Some c =&gt; c
  | None =&gt;
    CErrors.anomaly None None
      (Pp.str &quot;Reduction of primitive: pair not registered&quot; % string)
  end.

Definition get_cmp_constructors (env : Environ.env)
  : Names.constructor * Names.constructor * Names.constructor :=
  match retro_cmp (retroknowledge env) with
  | Some r =&gt; r
  | None =&gt;
    CErrors.anomaly None None
      (Pp.str &quot;Reduction of primitive: cmp not registered&quot; % string)
  end.

Module RedNativeEntries.
  Record signature {elem args evd : Type} := {
    elem := elem;
    args := args;
    evd := evd;
    get : args -&gt; Z -&gt; elem;
    get_int : evd -&gt; elem -&gt; Uint63.t;
    mkInt : Environ.env -&gt; Uint63.t -&gt; elem;
    mkBool : Environ.env -&gt; bool -&gt; elem;
    mkCarry : Environ.env -&gt; bool -&gt; elem -&gt; elem;
    mkIntPair : Environ.env -&gt; elem -&gt; elem -&gt; elem;
    mkLt : Environ.env -&gt; elem;
    mkEq : Environ.env -&gt; elem;
    mkGt : Environ.env -&gt; elem;
  }.
  Arguments signature : clear implicits.
End RedNativeEntries.

Module RedNative.
  Record signature {elem args evd : Type} := {
    elem := elem;
    args := args;
    evd := evd;
    red_prim : Environ.env -&gt; evd -&gt; CPrimitives.t -&gt; args -&gt; option elem;
  }.
  Arguments signature : clear implicits.
End RedNative.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="reduction" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>reduction.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created under Benjamin Werner account by Bruno Barras to implement
   a call-by-value conversion algorithm and a lazy reduction machine
   with sharing, Nov 1996 *)
(* Addition of zeta-reduction (let-in contraction) by Hugo Herbelin, Oct 2000 *)
(* Irreversibility of opacity by Bruno Barras *)
(* Cleaning and lightening of the kernel by Bruno Barras, Nov 2001 *)
(* Equal inductive types by Jacek Chrzaszcz as part of the module
   system, Aug 2002 *)

open CErrors
open Util
open Names
open Constr
open Declarations
open Vars
open Environ
open CClosure
open Esubst
open Context.Rel.Declaration

let rec is_empty_stack = function
  [] -&gt; true
  | Zupdate _::s -&gt; is_empty_stack s
  | Zshift _::s -&gt; is_empty_stack s
  | _ -&gt; false

(* Compute the lift to be performed on a term placed in a given stack *)
let el_stack el stk =
  let n =
    List.fold_left
      (fun i z -&gt;
        match z with
            Zshift n -&gt; i+n
          | _ -&gt; i)
      0
      stk in
  el_shft n el

let compare_stack_shape stk1 stk2 =
  let rec compare_rec bal stk1 stk2 =
  match (stk1,stk2) with
      ([],[]) -&gt; Int.equal bal 0
    | ((Zupdate _|Zshift _)::s1, _) -&gt; compare_rec bal s1 stk2
    | (_, (Zupdate _|Zshift _)::s2) -&gt; compare_rec bal stk1 s2
    | (Zapp l1::s1, _) -&gt; compare_rec (bal+Array.length l1) s1 stk2
    | (_, Zapp l2::s2) -&gt; compare_rec (bal-Array.length l2) stk1 s2
    | (Zproj _p1::s1, Zproj _p2::s2) -&gt;
        Int.equal bal 0 &amp;&amp; compare_rec 0 s1 s2
    | (ZcaseT(_c1,_,_,_)::s1, ZcaseT(_c2,_,_,_)::s2) -&gt;
        Int.equal bal 0 (* &amp;&amp; c1.ci_ind  = c2.ci_ind *) &amp;&amp; compare_rec 0 s1 s2
    | (Zfix(_,a1)::s1, Zfix(_,a2)::s2) -&gt;
        Int.equal bal 0 &amp;&amp; compare_rec 0 a1 a2 &amp;&amp; compare_rec 0 s1 s2
    | Zprimitive(op1,_,rargs1, _kargs1)::s1, Zprimitive(op2,_,rargs2, _kargs2)::s2 -&gt;
        bal=0 &amp;&amp; op1=op2 &amp;&amp; List.length rargs1=List.length rargs2 &amp;&amp;
        compare_rec 0 s1 s2
    | [], _ :: _
    | (Zproj _ | ZcaseT _ | Zfix _ | Zprimitive _) :: _, _ -&gt; false
  in
  compare_rec 0 stk1 stk2

type lft_fconstr = lift * fconstr

type lft_constr_stack_elt =
    Zlapp of (lift * fconstr) array
  | Zlproj of Projection.Repr.t * lift
  | Zlfix of (lift * fconstr) * lft_constr_stack
  | Zlcase of case_info * lift * constr * constr array * fconstr subs
  | Zlprimitive of
     CPrimitives.t * pconstant * lft_fconstr list * lft_fconstr next_native_args
and lft_constr_stack = lft_constr_stack_elt list

let rec zlapp v = function
    Zlapp v2 :: s -&gt; zlapp (Array.append v v2) s
  | s -&gt; Zlapp v :: s

(** Hand-unrolling of the map function to bypass the call to the generic array
    allocation. Type annotation is required to tell OCaml that the array does
    not contain floats. *)
let map_lift (l : lift) (v : fconstr array) = match v with
| [||] -&gt; assert false
| [|c0|] -&gt; [|(l, c0)|]
| [|c0; c1|] -&gt; [|(l, c0); (l, c1)|]
| [|c0; c1; c2|] -&gt; [|(l, c0); (l, c1); (l, c2)|]
| [|c0; c1; c2; c3|] -&gt; [|(l, c0); (l, c1); (l, c2); (l, c3)|]
| v -&gt; Array.Fun1.map (fun l t -&gt; (l, t)) l v

let pure_stack lfts stk =
  let rec pure_rec lfts stk =
    match stk with
        [] -&gt; (lfts,[])
      | zi::s -&gt;
          (match (zi,pure_rec lfts s) with
              (Zupdate _,lpstk)  -&gt; lpstk
            | (Zshift n,(l,pstk)) -&gt; (el_shft n l, pstk)
            | (Zapp a, (l,pstk)) -&gt;
                (l,zlapp (map_lift l a) pstk)
            | (Zproj p, (l,pstk)) -&gt;
                (l, Zlproj (p,l)::pstk)
            | (Zfix(fx,a),(l,pstk)) -&gt;
                let (lfx,pa) = pure_rec l a in
                (l, Zlfix((lfx,fx),pa)::pstk)
            | (ZcaseT(ci,p,br,e),(l,pstk)) -&gt;
                (l,Zlcase(ci,l,p,br,e)::pstk)
            | (Zprimitive(op,c,rargs,kargs),(l,pstk)) -&gt;
                (l,Zlprimitive(op,c,List.map (fun t -&gt; (l,t)) rargs,
                            List.map (fun (k,t) -&gt; (k,(l,t))) kargs)::pstk))
  in
  snd (pure_rec lfts stk)

(****************************************************************************)
(*                   Reduction Functions                                    *)
(****************************************************************************)

let whd_betaiota env t =
  match kind t with
    | (Sort _|Var _|Meta _|Evar _|Const _|Ind _|Construct _|
       Prod _|Lambda _|Fix _|CoFix _) -&gt; t
    | App (c, _) -&gt;
      begin match kind c with
      | Ind _ | Construct _ | Evar _ | Meta _ | Const _ | LetIn _ -&gt; t
      | _ -&gt; whd_val (create_clos_infos betaiota env) (create_tab ()) (inject t)
      end
    | _ -&gt; whd_val (create_clos_infos betaiota env) (create_tab ()) (inject t)

let nf_betaiota env t =
  norm_val (create_clos_infos betaiota env) (create_tab ()) (inject t)

let whd_betaiotazeta env x =
  match kind x with
  | (Sort _|Var _|Meta _|Evar _|Const _|Ind _|Construct _|
       Prod _|Lambda _|Fix _|CoFix _|Int _) -&gt; x
    | App (c, _) -&gt;
      begin match kind c with
      | Ind _ | Construct _ | Evar _ | Meta _ | Const _ | Int _ -&gt; x
      | Sort _ | Rel _ | Var _ | Cast _ | Prod _ | Lambda _ | LetIn _ | App _
        | Case _ | Fix _ | CoFix _ | Proj _ -&gt;
         whd_val (create_clos_infos betaiotazeta env) (create_tab ()) (inject x)
      end
    | Rel _ | Cast _ | LetIn _ | Case _ | Proj _ -&gt;
        whd_val (create_clos_infos betaiotazeta env) (create_tab ()) (inject x)

let whd_all env t =
  match kind t with
    | (Sort _|Meta _|Evar _|Ind _|Construct _|
       Prod _|Lambda _|Fix _|CoFix _|Int _) -&gt; t
    | App (c, _) -&gt;
      begin match kind c with
      | Ind _ | Construct _ | Evar _ | Meta _ | Int _ -&gt; t
      | Sort _ | Rel _ | Var _ | Cast _ | Prod _ | Lambda _ | LetIn _ | App _
        | Const _ |Case _ | Fix _ | CoFix _ | Proj _ -&gt;
         whd_val (create_clos_infos all env) (create_tab ()) (inject t)
      end
    | Rel _ | Cast _ | LetIn _ | Case _ | Proj _ | Const _ | Var _ -&gt;
        whd_val (create_clos_infos all env) (create_tab ()) (inject t)

let whd_allnolet env t =
  match kind t with
    | (Sort _|Meta _|Evar _|Ind _|Construct _|
       Prod _|Lambda _|Fix _|CoFix _|LetIn _|Int _) -&gt; t
    | App (c, _) -&gt;
      begin match kind c with
      | Ind _ | Construct _ | Evar _ | Meta _ | LetIn _ | Int _ -&gt; t
      | Sort _ | Rel _ | Var _ | Cast _ | Prod _ | Lambda _ | App _
        | Const _ | Case _ | Fix _ | CoFix _ | Proj _ -&gt;
         whd_val (create_clos_infos allnolet env) (create_tab ()) (inject t)
      end
    | Rel _ | Cast _ | Case _ | Proj _ | Const _ | Var _ -&gt;
        whd_val (create_clos_infos allnolet env) (create_tab ()) (inject t)

(********************************************************************)
(*                         Conversion                               *)
(********************************************************************)

(* Conversion utility functions *)

(* functions of this type are called from the kernel *)
type 'a kernel_conversion_function = env -&gt; 'a -&gt; 'a -&gt; unit

(* functions of this type can be called from outside the kernel *)
type 'a extended_conversion_function =
  ?l2r:bool -&gt; ?reds:TransparentState.t -&gt; env -&gt;
  ?evars:((existential-&gt;constr option) * UGraph.t) -&gt;
  'a -&gt; 'a -&gt; unit

exception NotConvertible

(* Convertibility of sorts *)

(* The sort cumulativity is

    Prop &lt;= Set &lt;= Type 1 &lt;= ... &lt;= Type i &lt;= ...

    and this holds whatever Set is predicative or impredicative
*)

type conv_pb =
  | CONV
  | CUMUL

let is_cumul = function CUMUL -&gt; true | CONV -&gt; false

type 'a universe_compare = 
  { (* Might raise NotConvertible *)
    compare_sorts : env -&gt; conv_pb -&gt; Sorts.t -&gt; Sorts.t -&gt; 'a -&gt; 'a;
    compare_instances: flex:bool -&gt; Univ.Instance.t -&gt; Univ.Instance.t -&gt; 'a -&gt; 'a;
    compare_cumul_instances : conv_pb -&gt; Univ.Variance.t array -&gt;
      Univ.Instance.t -&gt; Univ.Instance.t -&gt; 'a -&gt; 'a }

type 'a universe_state = 'a * 'a universe_compare

type ('a,'b) generic_conversion_function = env -&gt; 'b universe_state -&gt; 'a -&gt; 'a -&gt; 'b

type 'a infer_conversion_function = env -&gt; UGraph.t -&gt; 'a -&gt; 'a -&gt; Univ.Constraint.t

let sort_cmp_universes env pb s0 s1 (u, check) =
  (check.compare_sorts env pb s0 s1 u, check)

(* [flex] should be true for constants, false for inductive types and
   constructors. *)
let convert_instances ~flex u u' (s, check) =
  (check.compare_instances ~flex u u' s, check)

let get_cumulativity_constraints cv_pb variance u u' =
  match cv_pb with
  | CONV -&gt;
    Univ.enforce_eq_variance_instances variance u u' Univ.Constraint.empty
  | CUMUL -&gt;
    Univ.enforce_leq_variance_instances variance u u' Univ.Constraint.empty

let inductive_cumulativity_arguments (mind,ind) =
  mind.Declarations.mind_nparams +
  mind.Declarations.mind_packets.(ind).Declarations.mind_nrealargs

let convert_inductives_gen cmp_instances cmp_cumul cv_pb (mind,ind) nargs u1 u2 s =
  match mind.Declarations.mind_variance with
  | None -&gt; cmp_instances u1 u2 s
  | Some variances -&gt;
    let num_param_arity = inductive_cumulativity_arguments (mind,ind) in
    if not (Int.equal num_param_arity nargs) then
      cmp_instances u1 u2 s
    else
      cmp_cumul cv_pb variances u1 u2 s

let convert_inductives cv_pb ind nargs u1 u2 (s, check) =
  convert_inductives_gen (check.compare_instances ~flex:false) check.compare_cumul_instances
    cv_pb ind nargs u1 u2 s, check

let constructor_cumulativity_arguments (mind, ind, ctor) =
  mind.Declarations.mind_nparams +
  mind.Declarations.mind_packets.(ind).Declarations.mind_consnrealargs.(ctor - 1)

let convert_constructors_gen cmp_instances cmp_cumul (mind, ind, cns) nargs u1 u2 s =
  match mind.Declarations.mind_variance with
  | None -&gt; cmp_instances u1 u2 s
  | Some _ -&gt;
    let num_cnstr_args = constructor_cumulativity_arguments (mind,ind,cns) in
    if not (Int.equal num_cnstr_args nargs) then
      cmp_instances u1 u2 s
    else
      (** By invariant, both constructors have a common supertype,
          so they are convertible _at that type_. *)
      let variance = Array.make (Univ.Instance.length u1) Univ.Variance.Irrelevant in
      cmp_cumul CONV variance u1 u2 s

let convert_constructors ctor nargs u1 u2 (s, check) =
  convert_constructors_gen (check.compare_instances ~flex:false) check.compare_cumul_instances
    ctor nargs u1 u2 s, check

let conv_table_key infos k1 k2 cuniv =
  if k1 == k2 then cuniv else
  match k1, k2 with
  | ConstKey (cst, u), ConstKey (cst', u') when Constant.equal cst cst' -&gt;
    if Univ.Instance.equal u u' then cuniv
    else 
      let flex = evaluable_constant cst (info_env infos) 
	&amp;&amp; RedFlags.red_set (info_flags infos) (RedFlags.fCONST cst)
      in convert_instances ~flex u u' cuniv
  | VarKey id, VarKey id' when Id.equal id id' -&gt; cuniv
  | RelKey n, RelKey n' when Int.equal n n' -&gt; cuniv
  | _ -&gt; raise NotConvertible

exception IrregularPatternShape

let unfold_ref_with_args infos tab fl v =
  match unfold_reference infos tab fl with
  | Def def -&gt; Some (def, v)
  | Primitive op when check_native_args op v -&gt;
    let c = match fl with ConstKey c -&gt; c | _ -&gt; assert false in
    let rargs, a, nargs, v = get_native_args1 op c v in
    Some (whd_stack infos tab a (Zupdate a::(Zprimitive(op,c,rargs,nargs)::v)))
  | Undef _ | OpaqueDef _ | Primitive _ -&gt; None

type conv_tab = {
  cnv_inf : clos_infos;
  relevances : Sorts.relevance list;
  lft_tab : clos_tab;
  rgt_tab : clos_tab;
}
(** Invariant: for any tl ‚àà lft_tab and tr ‚àà rgt_tab, there is no mutable memory
    location contained both in tl and in tr. *)

(** The same heap separation invariant must hold for the fconstr arguments
    passed to each respective side of the conversion function below. *)

let push_relevance infos r =
  { infos with relevances = r.Context.binder_relevance :: infos.relevances }

let push_relevances infos nas =
  { infos with relevances = Array.fold_left (fun l x -&gt; x.Context.binder_relevance :: l) infos.relevances nas }

let rec skip_pattern infos relevances n c1 c2 =
  if Int.equal n 0 then {infos with relevances}, c1, c2
  else match kind c1, kind c2 with
    | Lambda (x, _, c1), Lambda (_, _, c2) -&gt;
      skip_pattern infos (x.Context.binder_relevance :: relevances) (pred n) c1 c2
    | _ -&gt; raise IrregularPatternShape

let skip_pattern infos n c1 c2 =
  if Int.equal n 0 then infos, c1, c2
  else skip_pattern infos infos.relevances n c1 c2

let is_irrelevant infos lft c =
  let env = info_env infos.cnv_inf in
  try Retypeops.relevance_of_fterm env infos.relevances lft c == Sorts.Irrelevant with _ -&gt; false

(* Conversion between  [lft1]term1 and [lft2]term2 *)
let rec ccnv cv_pb l2r infos lft1 lft2 term1 term2 cuniv =
  try eqappr cv_pb l2r infos (lft1, (term1,[])) (lft2, (term2,[])) cuniv
  with NotConvertible when is_irrelevant infos lft1 term1 &amp;&amp; is_irrelevant infos lft2 term2 -&gt; cuniv

(* Conversion between [lft1](hd1 v1) and [lft2](hd2 v2) *)
and eqappr cv_pb l2r infos (lft1,st1) (lft2,st2) cuniv =
  Control.check_for_interrupt ();
  (* First head reduce both terms *)
  let ninfos = infos_with_reds infos.cnv_inf betaiotazeta in
  let (hd1, v1 as appr1) = whd_stack ninfos infos.lft_tab (fst st1) (snd st1) in
  let (hd2, v2 as appr2) = whd_stack ninfos infos.rgt_tab (fst st2) (snd st2) in
  let appr1 = (lft1, appr1) and appr2 = (lft2, appr2) in
  (** We delay the computation of the lifts that apply to the head of the term
      with [el_stack] inside the branches where they are actually used. *)
  match (fterm_of hd1, fterm_of hd2) with
    (* case of leaves *)
    | (FAtom a1, FAtom a2) -&gt;
	(match kind a1, kind a2 with
	   | (Sort s1, Sort s2) -&gt;
	       if not (is_empty_stack v1 &amp;&amp; is_empty_stack v2) then
		 anomaly (Pp.str &quot;conversion was given ill-typed terms (Sort).&quot;);
              sort_cmp_universes (info_env infos.cnv_inf) cv_pb s1 s2 cuniv
	   | (Meta n, Meta m) -&gt;
               if Int.equal n m
               then convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
               else raise NotConvertible
	   | _ -&gt; raise NotConvertible)
    | (FEvar ((ev1,args1),env1), FEvar ((ev2,args2),env2)) -&gt;
        if Evar.equal ev1 ev2 then
          let el1 = el_stack lft1 v1 in
          let el2 = el_stack lft2 v2 in
          let cuniv = convert_stacks l2r infos lft1 lft2 v1 v2 cuniv in
          convert_vect l2r infos el1 el2
            (Array.map (mk_clos env1) args1)
            (Array.map (mk_clos env2) args2) cuniv
        else raise NotConvertible

    (* 2 index known to be bound to no constant *)
    | (FRel n, FRel m) -&gt;
        let el1 = el_stack lft1 v1 in
        let el2 = el_stack lft2 v2 in
        if Int.equal (reloc_rel n el1) (reloc_rel m el2)
        then convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
        else raise NotConvertible

    (* 2 constants, 2 local defined vars or 2 defined rels *)
    | (FFlex fl1, FFlex fl2) -&gt;
      (try
         let cuniv = conv_table_key infos.cnv_inf fl1 fl2 cuniv in
         convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
       with NotConvertible | Univ.UniverseInconsistency _ -&gt;
         (* else the oracle tells which constant is to be expanded *)
         let oracle = CClosure.oracle_of_infos infos.cnv_inf in
         let (app1,app2) =
           let aux appr1 lft1 fl1 tab1 v1 appr2 lft2 fl2 tab2 v2 =
             match unfold_ref_with_args infos.cnv_inf tab1 fl1 v1 with
             | Some t1 -&gt; ((lft1, t1), appr2)
             | None -&gt; match unfold_ref_with_args infos.cnv_inf tab2 fl2 v2 with
               | Some t2 -&gt; (appr1, (lft2, t2))
               | None -&gt; raise NotConvertible
           in
           if Conv_oracle.oracle_order Univ.out_punivs oracle l2r fl1 fl2 then
             aux appr1 lft1 fl1 infos.lft_tab v1 appr2 lft2 fl2 infos.rgt_tab v2
           else
             let (app2,app1) = aux appr2 lft2 fl2 infos.rgt_tab v2 appr1 lft1 fl1 infos.lft_tab v1 in
             (app1,app2)
         in
         eqappr cv_pb l2r infos app1 app2 cuniv)

    | (FProj (p1,c1), FProj (p2, c2)) -&gt;
      (* Projections: prefer unfolding to first-order unification,
	 which will happen naturally if the terms c1, c2 are not in constructor
	 form *)
      (match unfold_projection infos.cnv_inf p1 with
      | Some s1 -&gt;
        eqappr cv_pb l2r infos (lft1, (c1, (s1 :: v1))) appr2 cuniv
      | None -&gt;
        match unfold_projection infos.cnv_inf p2 with
        | Some s2 -&gt;
          eqappr cv_pb l2r infos appr1 (lft2, (c2, (s2 :: v2))) cuniv
        | None -&gt;
          if Projection.Repr.equal (Projection.repr p1) (Projection.repr p2)
             &amp;&amp; compare_stack_shape v1 v2 then
            let el1 = el_stack lft1 v1 in
            let el2 = el_stack lft2 v2 in
            let u1 = ccnv CONV l2r infos el1 el2 c1 c2 cuniv in
              convert_stacks l2r infos lft1 lft2 v1 v2 u1
          else (* Two projections in WHNF: unfold *)
	    raise NotConvertible)

    | (FProj (p1,c1), t2) -&gt;
      begin match unfold_projection infos.cnv_inf p1 with
       | Some s1 -&gt;
         eqappr cv_pb l2r infos (lft1, (c1, (s1 :: v1))) appr2 cuniv
       | None -&gt;
         begin match t2 with
          | FFlex fl2 -&gt;
            begin match unfold_ref_with_args infos.cnv_inf infos.rgt_tab fl2 v2 with
             | Some t2 -&gt;
               eqappr cv_pb l2r infos appr1 (lft2, t2) cuniv
             | None -&gt; raise NotConvertible
            end
          | _ -&gt; raise NotConvertible
         end
      end

    | (t1, FProj (p2,c2)) -&gt;
      begin match unfold_projection infos.cnv_inf p2 with
       | Some s2 -&gt;
         eqappr cv_pb l2r infos appr1 (lft2, (c2, (s2 :: v2))) cuniv
       | None -&gt;
         begin match t1 with
          | FFlex fl1 -&gt;
            begin match unfold_ref_with_args infos.cnv_inf infos.lft_tab fl1 v1 with
             | Some t1 -&gt;
               eqappr cv_pb l2r infos (lft1, t1) appr2 cuniv
             | None -&gt; raise NotConvertible
            end
          | _ -&gt; raise NotConvertible
         end
      end

    (* other constructors *)
    | (FLambda _, FLambda _) -&gt;
        (* Inconsistency: we tolerate that v1, v2 contain shift and update but
           we throw them away *)
        if not (is_empty_stack v1 &amp;&amp; is_empty_stack v2) then
          anomaly (Pp.str &quot;conversion was given ill-typed terms (FLambda).&quot;);
        let (x1,ty1,bd1) = destFLambda mk_clos hd1 in
        let (_,ty2,bd2) = destFLambda mk_clos hd2 in
        let el1 = el_stack lft1 v1 in
        let el2 = el_stack lft2 v2 in
        let cuniv = ccnv CONV l2r infos el1 el2 ty1 ty2 cuniv in
        ccnv CONV l2r (push_relevance infos x1) (el_lift el1) (el_lift el2) bd1 bd2 cuniv

    | (FProd (x1, c1, c2, e), FProd (_, c'1, c'2, e')) -&gt;
        if not (is_empty_stack v1 &amp;&amp; is_empty_stack v2) then
	  anomaly (Pp.str &quot;conversion was given ill-typed terms (FProd).&quot;);
	(* Luo's system *)
        let el1 = el_stack lft1 v1 in
        let el2 = el_stack lft2 v2 in
        let cuniv = ccnv CONV l2r infos el1 el2 c1 c'1 cuniv in
        ccnv cv_pb l2r (push_relevance infos x1) (el_lift el1) (el_lift el2) (mk_clos (subs_lift e) c2) (mk_clos (subs_lift e') c'2) cuniv

    (* Eta-expansion on the fly *)
    | (FLambda _, _) -&gt;
        let () = match v1 with
        | [] -&gt; ()
        | _ -&gt;
          anomaly (Pp.str &quot;conversion was given unreduced term (FLambda).&quot;)
        in
        let (x1,_ty1,bd1) = destFLambda mk_clos hd1 in
        let infos = push_relevance infos x1 in
        eqappr CONV l2r infos
          (el_lift lft1, (bd1, [])) (el_lift lft2, (hd2, eta_expand_stack v2)) cuniv
    | (_, FLambda _) -&gt;
        let () = match v2 with
        | [] -&gt; ()
        | _ -&gt;
	  anomaly (Pp.str &quot;conversion was given unreduced term (FLambda).&quot;)
	in
        let (x2,_ty2,bd2) = destFLambda mk_clos hd2 in
        let infos = push_relevance infos x2 in
        eqappr CONV l2r infos
          (el_lift lft1, (hd1, eta_expand_stack v1)) (el_lift lft2, (bd2, [])) cuniv

    (* only one constant, defined var or defined rel *)
    | (FFlex fl1, c2)      -&gt;
      begin match unfold_ref_with_args infos.cnv_inf infos.lft_tab fl1 v1 with
        | Some (def1,v1) -&gt;
          (** By virtue of the previous case analyses, we know [c2] is rigid.
              Conversion check to rigid terms eventually implies full weak-head
              reduction, so instead of repeatedly performing small-step
              unfoldings, we perform reduction with all flags on. *)
            let all = RedFlags.red_add_transparent all (RedFlags.red_transparent (info_flags infos.cnv_inf)) in
            let r1 = whd_stack (infos_with_reds infos.cnv_inf all) infos.lft_tab def1 v1 in
            eqappr cv_pb l2r infos (lft1, r1) appr2 cuniv
        | None -&gt;
          (match c2 with
           | FConstruct ((ind2,_j2),_u2) -&gt;
             (try
                let v2, v1 =
                  eta_expand_ind_stack (info_env infos.cnv_inf) ind2 hd2 v2 (snd appr1)
                in convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
              with Not_found -&gt; raise NotConvertible)
           | _ -&gt; raise NotConvertible)
      end

    | (c1, FFlex fl2)      -&gt;
       begin match unfold_ref_with_args infos.cnv_inf infos.rgt_tab fl2 v2 with
        | Some (def2, v2) -&gt;
          (** Symmetrical case of above. *)
          let all = RedFlags.red_add_transparent all (RedFlags.red_transparent (info_flags infos.cnv_inf)) in
          let r2 = whd_stack (infos_with_reds infos.cnv_inf all) infos.rgt_tab def2 v2 in
          eqappr cv_pb l2r infos appr1 (lft2, r2) cuniv
        | None -&gt;
          match c1 with
          | FConstruct ((ind1,_j1),_u1) -&gt;
            (try let v1, v2 =
                   eta_expand_ind_stack (info_env infos.cnv_inf) ind1 hd1 v1 (snd appr2)
               in convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
             with Not_found -&gt; raise NotConvertible)
          | _ -&gt; raise NotConvertible
       end

    (* Inductive types:  MutInd MutConstruct Fix Cofix *)
    | (FInd (ind1,u1), FInd (ind2,u2)) -&gt;
      if eq_ind ind1 ind2 then
        if Univ.Instance.length u1 = 0 || Univ.Instance.length u2 = 0 then
          let cuniv = convert_instances ~flex:false u1 u2 cuniv in
          convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
        else
          let mind = Environ.lookup_mind (fst ind1) (info_env infos.cnv_inf) in
          let nargs = CClosure.stack_args_size v1 in
          if not (Int.equal nargs (CClosure.stack_args_size v2))
          then raise NotConvertible
          else
            let cuniv = convert_inductives cv_pb (mind, snd ind1) nargs u1 u2 cuniv in
            convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
      else raise NotConvertible

    | (FConstruct ((ind1,j1),u1), FConstruct ((ind2,j2),u2)) -&gt;
      if Int.equal j1 j2 &amp;&amp; eq_ind ind1 ind2 then
        if Univ.Instance.length u1 = 0 || Univ.Instance.length u2 = 0 then
          let cuniv = convert_instances ~flex:false u1 u2 cuniv in
          convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
        else
          let mind = Environ.lookup_mind (fst ind1) (info_env infos.cnv_inf) in
          let nargs = CClosure.stack_args_size v1 in
          if not (Int.equal nargs (CClosure.stack_args_size v2))
          then raise NotConvertible
          else
            let cuniv = convert_constructors (mind, snd ind1, j1) nargs u1 u2 cuniv in
            convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
      else raise NotConvertible
	  
    (* Eta expansion of records *)
    | (FConstruct ((ind1,_j1),_u1), _) -&gt;
      (try
    	 let v1, v2 =
            eta_expand_ind_stack (info_env infos.cnv_inf) ind1 hd1 v1 (snd appr2)
         in convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
       with Not_found -&gt; raise NotConvertible)

    | (_, FConstruct ((ind2,_j2),_u2)) -&gt;
      (try
    	 let v2, v1 =
            eta_expand_ind_stack (info_env infos.cnv_inf) ind2 hd2 v2 (snd appr1)
         in convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
       with Not_found -&gt; raise NotConvertible)

    | (FFix (((op1, i1),(na1,tys1,cl1)),e1), FFix(((op2, i2),(_,tys2,cl2)),e2)) -&gt;
        if Int.equal i1 i2 &amp;&amp; Array.equal Int.equal op1 op2
	then
	  let n = Array.length cl1 in
          let fty1 = Array.map (mk_clos e1) tys1 in
          let fty2 = Array.map (mk_clos e2) tys2 in
          let fcl1 = Array.map (mk_clos (subs_liftn n e1)) cl1 in
          let fcl2 = Array.map (mk_clos (subs_liftn n e2)) cl2 in
          let el1 = el_stack lft1 v1 in
          let el2 = el_stack lft2 v2 in
          let cuniv = convert_vect l2r infos el1 el2 fty1 fty2 cuniv in
          let cuniv =
            let infos = push_relevances infos na1 in
            convert_vect l2r infos
                         (el_liftn n el1) (el_liftn n el2) fcl1 fcl2 cuniv
          in
          convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
        else raise NotConvertible

    | (FCoFix ((op1,(na1,tys1,cl1)),e1), FCoFix((op2,(_,tys2,cl2)),e2)) -&gt;
        if Int.equal op1 op2
        then
	  let n = Array.length cl1 in
          let fty1 = Array.map (mk_clos e1) tys1 in
          let fty2 = Array.map (mk_clos e2) tys2 in
          let fcl1 = Array.map (mk_clos (subs_liftn n e1)) cl1 in
          let fcl2 = Array.map (mk_clos (subs_liftn n e2)) cl2 in
          let el1 = el_stack lft1 v1 in
          let el2 = el_stack lft2 v2 in
          let cuniv = convert_vect l2r infos el1 el2 fty1 fty2 cuniv in
          let cuniv =
            let infos = push_relevances infos na1 in
            convert_vect l2r infos
                         (el_liftn n el1) (el_liftn n el2) fcl1 fcl2 cuniv
          in
          convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
        else raise NotConvertible

    | FInt i1, FInt i2 -&gt;
       if Uint63.equal i1 i2 then convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
       else raise NotConvertible

     (* Should not happen because both (hd1,v1) and (hd2,v2) are in whnf *)
     | ( (FLetIn _, _) | (FCaseT _,_) | (FApp _,_) | (FCLOS _,_) | (FLIFT _,_)
       | (_, FLetIn _) | (_,FCaseT _) | (_,FApp _) | (_,FCLOS _) | (_,FLIFT _)
       | (FLOCKED,_) | (_,FLOCKED) ) -&gt; assert false

     | (FRel _ | FAtom _ | FInd _ | FFix _ | FCoFix _
        | FProd _ | FEvar _ | FInt _), _ -&gt; raise NotConvertible

and convert_stacks l2r infos lft1 lft2 stk1 stk2 cuniv =
  let f (l1, t1) (l2, t2) cuniv = ccnv CONV l2r infos l1 l2 t1 t2 cuniv in
  let rec cmp_rec pstk1 pstk2 cuniv =
    match (pstk1,pstk2) with
      | (z1::s1, z2::s2) -&gt;
          let cu1 = cmp_rec s1 s2 cuniv in
          (match (z1,z2) with
            | (Zlapp a1,Zlapp a2) -&gt;
               Array.fold_right2 f a1 a2 cu1
            | (Zlproj (c1,_l1),Zlproj (c2,_l2)) -&gt;
              if not (Projection.Repr.equal c1 c2) then
                raise NotConvertible
              else cu1
            | (Zlfix(fx1,a1),Zlfix(fx2,a2)) -&gt;
                let cu2 = f fx1 fx2 cu1 in
                cmp_rec a1 a2 cu2
            | (Zlcase(ci1,l1,p1,br1,e1),Zlcase(ci2,l2,p2,br2,e2)) -&gt;
                if not (eq_ind ci1.ci_ind ci2.ci_ind) then
                  raise NotConvertible;
                let cu2 = f (l1, mk_clos e1 p1) (l2, mk_clos e2 p2) cu1 in
                convert_branches l2r infos ci1 e1 e2 l1 l2 br1 br2 cu2
            | (Zlprimitive(op1,_,rargs1,kargs1),Zlprimitive(op2,_,rargs2,kargs2)) -&gt;
              if not (CPrimitives.equal op1 op2) then raise NotConvertible else
                let cu2 = List.fold_right2 f rargs1 rargs2 cu1 in
                let fk (_,a1) (_,a2) cu = f a1 a2 cu in
                List.fold_right2 fk kargs1 kargs2 cu2
            | ((Zlapp _ | Zlproj _ | Zlfix _| Zlcase _| Zlprimitive _), _) -&gt; assert false)
      | _ -&gt; cuniv in
  if compare_stack_shape stk1 stk2 then
    cmp_rec (pure_stack lft1 stk1) (pure_stack lft2 stk2) cuniv
  else raise NotConvertible

and convert_vect l2r infos lft1 lft2 v1 v2 cuniv =
  let lv1 = Array.length v1 in
  let lv2 = Array.length v2 in
  if Int.equal lv1 lv2
  then
    let rec fold n cuniv =
      if n &gt;= lv1 then cuniv
      else
        let cuniv = ccnv CONV l2r infos lft1 lft2 v1.(n) v2.(n) cuniv in
        fold (n+1) cuniv in
    fold 0 cuniv
  else raise NotConvertible

and convert_branches l2r infos ci e1 e2 lft1 lft2 br1 br2 cuniv =
  (** Skip comparison of the pattern types. We know that the two terms are
      living in a common type, thus this check is useless. *)
  let fold n c1 c2 cuniv = match skip_pattern infos n c1 c2 with
  | (infos, c1, c2) -&gt;
    let lft1 = el_liftn n lft1 in
    let lft2 = el_liftn n lft2 in
    let e1 = subs_liftn n e1 in
    let e2 = subs_liftn n e2 in
    ccnv CONV l2r infos lft1 lft2 (mk_clos e1 c1) (mk_clos e2 c2) cuniv
  | exception IrregularPatternShape -&gt;
    (** Might happen due to a shape invariant that is not enforced *)
    ccnv CONV l2r infos lft1 lft2 (mk_clos e1 c1) (mk_clos e2 c2) cuniv
  in
  Array.fold_right3 fold ci.ci_cstr_nargs br1 br2 cuniv

let clos_gen_conv trans cv_pb l2r evars env univs t1 t2 =
  let reds = CClosure.RedFlags.red_add_transparent betaiotazeta trans in
  let infos = create_clos_infos ~evars reds env in
  let infos = {
    cnv_inf = infos;
    relevances = List.map Context.Rel.Declaration.get_relevance (rel_context env);
    lft_tab = create_tab ();
    rgt_tab = create_tab ();
  } in
  ccnv cv_pb l2r infos el_id el_id (inject t1) (inject t2) univs


let check_eq univs u u' = 
  if not (UGraph.check_eq univs u u') then raise NotConvertible

let check_leq univs u u' = 
  if not (UGraph.check_leq univs u u') then raise NotConvertible

let check_sort_cmp_universes env pb s0 s1 univs =
  let open Sorts in
  if not (type_in_type env) then
    let check_pb u0 u1 =
      match pb with
      | CUMUL -&gt; check_leq univs u0 u1
      | CONV -&gt; check_eq univs u0 u1
    in
    match (s0,s1) with
    | SProp, SProp | Prop, Prop | Set, Set -&gt; ()
    | SProp, _ | _, SProp -&gt; raise NotConvertible
    | Prop, (Set | Type _) -&gt; if not (is_cumul pb) then raise NotConvertible
    | Set, Prop -&gt; raise NotConvertible
    | Set, Type u -&gt; check_pb Univ.type0_univ u
    | Type _u, Prop -&gt; raise NotConvertible
    | Type u, Set -&gt; check_pb u Univ.type0_univ
    | Type u0, Type u1 -&gt; check_pb u0 u1

let checked_sort_cmp_universes env pb s0 s1 univs =
  check_sort_cmp_universes env pb s0 s1 univs; univs

let check_convert_instances ~flex:_ u u' univs =
  if UGraph.check_eq_instances univs u u' then univs
  else raise NotConvertible

(* general conversion and inference functions *)
let check_inductive_instances cv_pb variance u1 u2 univs =
  let csts = get_cumulativity_constraints cv_pb variance u1 u2 in
  if (UGraph.check_constraints csts univs) then univs
  else raise NotConvertible

let checked_universes =
  { compare_sorts = checked_sort_cmp_universes;
    compare_instances = check_convert_instances;
    compare_cumul_instances = check_inductive_instances; }

let infer_eq (univs, cstrs as cuniv) u u' =
  if UGraph.check_eq univs u u' then cuniv
  else
    univs, (Univ.enforce_eq u u' cstrs)

let infer_leq (univs, cstrs as cuniv) u u' =
  if UGraph.check_leq univs u u' then cuniv
  else
    let cstrs', _ = UGraph.enforce_leq_alg u u' univs in
      univs, Univ.Constraint.union cstrs cstrs'

let infer_cmp_universes env pb s0 s1 univs =
  if type_in_type env
  then univs
  else
    let open Sorts in
    let infer_pb u0 u1 =
      match pb with
      | CUMUL -&gt; infer_leq univs u0 u1
      | CONV -&gt; infer_eq univs u0 u1
    in
    match (s0,s1) with
    | SProp, SProp | Prop, Prop | Set, Set -&gt; univs
    | SProp, _ | _, SProp -&gt; raise NotConvertible
    | Prop, (Set | Type _) -&gt; if not (is_cumul pb) then raise NotConvertible else univs
    | Set, Prop -&gt; raise NotConvertible
    | Set, Type u -&gt; infer_pb Univ.type0_univ u
    | Type u, Prop -&gt; infer_pb u Univ.type0m_univ
    | Type u, Set -&gt; infer_pb u Univ.type0_univ
    | Type u0, Type u1 -&gt; infer_pb u0 u1

let infer_convert_instances ~flex u u' (univs,cstrs) =
  let cstrs' =
    if flex then 
      if UGraph.check_eq_instances univs u u' then cstrs
      else raise NotConvertible
    else Univ.enforce_eq_instances u u' cstrs
  in (univs, cstrs')

let infer_inductive_instances cv_pb variance u1 u2 (univs,csts') =
  let csts = get_cumulativity_constraints cv_pb variance u1 u2 in
  (univs, Univ.Constraint.union csts csts')

let inferred_universes : (UGraph.t * Univ.Constraint.t) universe_compare =
  { compare_sorts = infer_cmp_universes;
    compare_instances = infer_convert_instances;
    compare_cumul_instances = infer_inductive_instances; }

let gen_conv cv_pb l2r reds env evars univs t1 t2 =
  let b = 
    if cv_pb = CUMUL then leq_constr_univs univs t1 t2 
    else eq_constr_univs univs t1 t2
  in
    if b then ()
    else 
      let _ = clos_gen_conv reds cv_pb l2r evars env (univs, checked_universes) t1 t2 in
	()

(* Profiling *)
let gen_conv cv_pb ?(l2r=false) ?(reds=TransparentState.full) env ?(evars=(fun _-&gt;None), universes env) =
  let evars, univs = evars in
  if Flags.profile then
    let fconv_universes_key = CProfile.declare_profile &quot;trans_fconv_universes&quot; in
      CProfile.profile8 fconv_universes_key gen_conv cv_pb l2r reds env evars univs
  else gen_conv cv_pb l2r reds env evars univs

let conv = gen_conv CONV

let conv_leq = gen_conv CUMUL

let generic_conv cv_pb ~l2r evars reds env univs t1 t2 =
  let (s, _) = 
    clos_gen_conv reds cv_pb l2r evars env univs t1 t2 
  in s

let infer_conv_universes cv_pb l2r evars reds env univs t1 t2 =
  let b, cstrs =
    if cv_pb == CUMUL then Constr.leq_constr_univs_infer univs t1 t2
    else Constr.eq_constr_univs_infer univs t1 t2
  in
    if b then cstrs
    else
      let univs = ((univs, Univ.Constraint.empty), inferred_universes) in
      let ((_,cstrs), _) = clos_gen_conv reds cv_pb l2r evars env univs t1 t2 in
	cstrs

(* Profiling *)
let infer_conv_universes = 
  if Flags.profile then 
    let infer_conv_universes_key = CProfile.declare_profile &quot;infer_conv_universes&quot; in
      CProfile.profile8 infer_conv_universes_key infer_conv_universes
  else infer_conv_universes

let infer_conv ?(l2r=false) ?(evars=fun _ -&gt; None) ?(ts=TransparentState.full)
    env univs t1 t2 = 
  infer_conv_universes CONV l2r evars ts env univs t1 t2

let infer_conv_leq ?(l2r=false) ?(evars=fun _ -&gt; None) ?(ts=TransparentState.full)
    env univs t1 t2 = 
  infer_conv_universes CUMUL l2r evars ts env univs t1 t2

let default_conv cv_pb ?l2r:_ env t1 t2 =
    gen_conv cv_pb env t1 t2

let default_conv_leq = default_conv CUMUL
(*
let convleqkey = CProfile.declare_profile &quot;Kernel_reduction.conv_leq&quot;;;
let conv_leq env t1 t2 =
  CProfile.profile4 convleqkey conv_leq env t1 t2;;

let convkey = CProfile.declare_profile &quot;Kernel_reduction.conv&quot;;;
let conv env t1 t2 =
  CProfile.profile4 convleqkey conv env t1 t2;;
*)

(* Application with on-the-fly reduction *)

let beta_applist c l =
  let rec app subst c l =
    match kind c, l with
    | Lambda(_,_,c), arg::l -&gt; app (arg::subst) c l
    | _ -&gt; Term.applist (substl subst c, l) in
  app [] c l

let beta_appvect c v = beta_applist c (Array.to_list v)

let beta_app c a = beta_applist c [a]

(* Compatibility *)
let betazeta_appvect = Term.lambda_appvect_assum

(********************************************************************)
(*             Special-Purpose Reduction                            *)
(********************************************************************)

(* pseudo-reduction rule:
 * [hnf_prod_app env (Prod(_,B)) N --&gt; B[N]
 * with an HNF on the first argument to produce a product.
 * if this does not work, then we use the string S as part of our
 * error message. *)

let hnf_prod_app env t n =
  match kind (whd_all env t) with
    | Prod (_,_,b) -&gt; subst1 n b
    | _ -&gt; anomaly ~label:&quot;hnf_prod_app&quot; (Pp.str &quot;Need a product.&quot;)

let hnf_prod_applist env t nl =
  List.fold_left (hnf_prod_app env) t nl

let hnf_prod_applist_assum env n c l =
  let rec app n subst t l =
    if Int.equal n 0 then
      if l == [] then substl subst t
      else anomaly (Pp.str &quot;Too many arguments.&quot;)
    else match kind (whd_allnolet env t), l with
    | Prod(_,_,c), arg::l -&gt; app (n-1) (arg::subst) c l
    | LetIn(_,b,_,c), _ -&gt; app (n-1) (substl subst b::subst) c l
    | _, [] -&gt; anomaly (Pp.str &quot;Not enough arguments.&quot;)
    | _ -&gt; anomaly (Pp.str &quot;Not enough prod/let's.&quot;) in
  app n [] c l

(* Dealing with arities *)

let dest_prod env =
  let rec decrec env m c =
    let t = whd_all env c in
    match kind t with
      | Prod (n,a,c0) -&gt;
          let d = LocalAssum (n,a) in
	  decrec (push_rel d env) (Context.Rel.add d m) c0
      | _ -&gt; m,t
  in
  decrec env Context.Rel.empty

let dest_lam env =
  let rec decrec env m c =
    let t = whd_all env c in
    match kind t with
      | Lambda (n,a,c0) -&gt;
          let d = LocalAssum (n,a) in
          decrec (push_rel d env) (Context.Rel.add d m) c0
      | _ -&gt; m,t
  in
  decrec env Context.Rel.empty

(* The same but preserving lets in the context, not internal ones. *)
let dest_prod_assum env =
  let rec prodec_rec env l ty =
    let rty = whd_allnolet env ty in
    match kind rty with
    | Prod (x,t,c)  -&gt;
        let d = LocalAssum (x,t) in
	prodec_rec (push_rel d env) (Context.Rel.add d l) c
    | LetIn (x,b,t,c) -&gt;
        let d = LocalDef (x,b,t) in
	prodec_rec (push_rel d env) (Context.Rel.add d l) c
    | _               -&gt;
      let rty' = whd_all env rty in
	if Constr.equal rty' rty then l, rty
	else prodec_rec env l rty'
  in
  prodec_rec env Context.Rel.empty

let dest_lam_assum env =
  let rec lamec_rec env l ty =
    let rty = whd_allnolet env ty in
    match kind rty with
    | Lambda (x,t,c)  -&gt;
        let d = LocalAssum (x,t) in
	lamec_rec (push_rel d env) (Context.Rel.add d l) c
    | LetIn (x,b,t,c) -&gt;
        let d = LocalDef (x,b,t) in
	lamec_rec (push_rel d env) (Context.Rel.add d l) c
    | _               -&gt; l,rty
  in
  lamec_rec env Context.Rel.empty

exception NotArity

let dest_arity env c =
  let l, c = dest_prod_assum env c in
  match kind c with
    | Sort s -&gt; l,s
    | _ -&gt; raise NotArity

let is_arity env c =
  try
    let _ = dest_arity env c in
    true
  with NotArity -&gt; false

let eta_expand env t ty =
  let ctxt, _codom = dest_prod env ty in
  let ctxt',t = dest_lam env t in
  let d = Context.Rel.nhyps ctxt - Context.Rel.nhyps ctxt' in
  let eta_args = List.rev_map mkRel (List.interval 1 d) in
  let t = Term.applistc (Vars.lift d t) eta_args in
  let t = Term.it_mkLambda_or_LetIn t (List.firstn d ctxt) in
  Term.it_mkLambda_or_LetIn t ctxt'
</pre>
          </div>
          <div class="col-md-6">
            <code>reduction.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import CErrors.

Import Util.

Import Names.

Import Constr.

Import Declarations.

Import Vars.

Import Environ.

Import CClosure.

Import Esubst.

Import Context.Rel.Declaration.

Fixpoint is_empty_stack (function_parameter : list CClosure.stack_member)
  : bool :=
  match function_parameter with
  | [] =&gt; true
  | cons (Zupdate _) s =&gt; is_empty_stack s
  | cons (Zshift _) s =&gt; is_empty_stack s
  | _ =&gt; false
  end.

Definition el_stack (el : Esubst.lift) (stk : list CClosure.stack_member)
  : Esubst.lift :=
  let n :=
    Util.List.(CList.ExtS.fold_left)
      (fun i =&gt;
        fun z =&gt;
          match z with
          | Zshift n =&gt; Util.op_plus i n
          | _ =&gt; i
          end) 0 stk in
  Esubst.el_shft n el.

Definition compare_stack_shape (stk1 : CClosure.stack) (stk2 : CClosure.stack)
  : bool :=
  let fix compare_rec
    (bal : Int.t) (stk1 : CClosure.stack) (stk2 : CClosure.stack) : bool :=
    match (stk1, stk2) with
    | ([], []) =&gt; Int.equal bal 0
    | (cons (Zupdate _ | Zshift _) s1, _) =&gt; compare_rec bal s1 stk2
    | (_, cons (Zupdate _ | Zshift _) s2) =&gt; compare_rec bal stk1 s2
    | (cons (Zapp l1) s1, _) =&gt;
      compare_rec (Util.op_plus bal (Util.Array.(CArray.ExtS.length) l1)) s1
        stk2
    | (_, cons (Zapp l2) s2) =&gt;
      compare_rec (Util.op_minus bal (Util.Array.(CArray.ExtS.length) l2)) stk1
        s2
    | (cons (Zproj _p1) s1, cons (Zproj _p2) s2) =&gt;
      andb (Int.equal bal 0) (compare_rec 0 s1 s2)
    | (cons (ZcaseT _c1 _ _ _) s1, cons (ZcaseT _c2 _ _ _) s2) =&gt;
      andb (Int.equal bal 0) (compare_rec 0 s1 s2)
    | (cons (Zfix _ a1) s1, cons (Zfix _ a2) s2) =&gt;
      andb (Int.equal bal 0) (andb (compare_rec 0 a1 a2) (compare_rec 0 s1 s2))
    |
      (cons (Zprimitive op1 _ rargs1 _kargs1) s1,
        cons (Zprimitive op2 _ rargs2 _kargs2) s2) =&gt;
      andb (equiv_decb bal 0)
        (andb (equiv_decb op1 op2)
          (andb
            (equiv_decb (Util.List.(CList.ExtS.length) rargs1)
              (Util.List.(CList.ExtS.length) rargs2)) (compare_rec 0 s1 s2)))
    |
      ([], cons _ _) |
        (cons (Zproj _ | ZcaseT _ _ _ _ | Zfix _ _ | Zprimitive _ _ _ _) _, _)
      =&gt; false
    end in
  compare_rec 0 stk1 stk2.

Definition lft_fconstr := Esubst.lift * CClosure.fconstr.

Reserved Notation &quot;'lft_constr_stack&quot;.

Inductive lft_constr_stack_elt : Type :=
| Zlapp : (array (Esubst.lift * CClosure.fconstr)) -&gt; lft_constr_stack_elt
| Zlproj : Names.Projection.Repr.t -&gt; Esubst.lift -&gt; lft_constr_stack_elt
| Zlfix : (Esubst.lift * CClosure.fconstr) -&gt; 'lft_constr_stack -&gt;
  lft_constr_stack_elt
| Zlcase : Constr.case_info -&gt; Esubst.lift -&gt; Constr.constr -&gt;
  (array Constr.constr) -&gt; (Esubst.subs CClosure.fconstr) -&gt;
  lft_constr_stack_elt
| Zlprimitive : CPrimitives.t -&gt; Constr.pconstant -&gt; (list lft_fconstr) -&gt;
  (CClosure.next_native_args lft_fconstr) -&gt; lft_constr_stack_elt

where &quot;'lft_constr_stack&quot; := ( list lft_constr_stack_elt).

Definition lft_constr_stack := 'lft_constr_stack.

Fixpoint zlapp
  (v : array (Esubst.lift * CClosure.fconstr))
  (function_parameter : list lft_constr_stack_elt)
  : list lft_constr_stack_elt :=
  match function_parameter with
  | cons (Zlapp v2) s =&gt; zlapp (Util.Array.(CArray.ExtS.append) v v2) s
  | s =&gt; cons (Zlapp v) s
  end.

Definition map_lift (l : Esubst.lift) (v : array CClosure.fconstr)
  : array (Esubst.lift * CClosure.fconstr) :=
  match v with
  | tt =&gt; false
  | (c0) =&gt; ((l, c0))
  | (c0, c1) =&gt; ((l, c0), (l, c1))
  | (c0, c1, c2) =&gt; ((l, c0), (l, c1), (l, c2))
  | (c0, c1, c2, c3) =&gt; ((l, c0), (l, c1), (l, c2), (l, c3))
  | v =&gt; Util.Array.Fun1.map (fun l =&gt; fun t =&gt; (l, t)) l v
  end.

Definition pure_stack (lfts : Esubst.lift) (stk : list CClosure.stack_member)
  : list lft_constr_stack_elt :=
  let fix pure_rec (lfts : Esubst.lift) (stk : list CClosure.stack_member)
    : Esubst.lift * (list lft_constr_stack_elt) :=
    match stk with
    | [] =&gt; (lfts, [])
    | cons zi s =&gt;
      match (zi, (pure_rec lfts s)) with
      | (Zupdate _, lpstk) =&gt; lpstk
      | (Zshift n, (l, pstk)) =&gt; ((Esubst.el_shft n l), pstk)
      | (Zapp a, (l, pstk)) =&gt; (l, (zlapp (map_lift l a) pstk))
      | (Zproj p, (l, pstk)) =&gt; (l, (cons (Zlproj p l) pstk))
      | (Zfix fx a, (l, pstk)) =&gt;
        match pure_rec l a with
        | (lfx, pa) =&gt; (l, (cons (Zlfix (lfx, fx) pa) pstk))
        end
      | (ZcaseT ci p br e, (l, pstk)) =&gt; (l, (cons (Zlcase ci l p br e) pstk))
      | (Zprimitive op c rargs kargs, (l, pstk)) =&gt;
        (l,
          (cons
            (Zlprimitive op c
              (Util.List.(CList.ExtS.map) (fun t =&gt; (l, t)) rargs)
              (Util.List.(CList.ExtS.map)
                (fun function_parameter =&gt;
                  match function_parameter with
                  | (k, t) =&gt; (k, (l, t))
                  end) kargs)) pstk))
      end
    end in
  snd (pure_rec lfts stk).

Definition whd_betaiota (env : Environ.env) (t : Constr.constr)
  : Constr.constr :=
  match Constr.kind t with
  |
    Sort _ | Var _ | Meta _ | Evar _ | Const _ | Ind _ | Construct _ |
      Prod _ _ _ | Lambda _ _ _ | Fix _ | CoFix _ =&gt; t
  | App c _ =&gt;
    match Constr.kind c with
    | Ind _ | Construct _ | Evar _ | Meta _ | Const _ | LetIn _ _ _ _ =&gt; t
    | _ =&gt;
      CClosure.whd_val (CClosure.create_clos_infos None CClosure.betaiota env)
        (CClosure.create_tab tt) (CClosure.inject t)
    end
  | _ =&gt;
    CClosure.whd_val (CClosure.create_clos_infos None CClosure.betaiota env)
      (CClosure.create_tab tt) (CClosure.inject t)
  end.

Definition nf_betaiota (env : Environ.env) (t : Constr.constr)
  : Constr.constr :=
  CClosure.norm_val (CClosure.create_clos_infos None CClosure.betaiota env)
    (CClosure.create_tab tt) (CClosure.inject t).

Definition whd_betaiotazeta (env : Environ.env) (x : Constr.constr)
  : Constr.constr :=
  match Constr.kind x with
  |
    Sort _ | Var _ | Meta _ | Evar _ | Const _ | Ind _ | Construct _ |
      Prod _ _ _ | Lambda _ _ _ | Fix _ | CoFix _ | Int _ =&gt; x
  | App c _ =&gt;
    match Constr.kind c with
    | Ind _ | Construct _ | Evar _ | Meta _ | Const _ | Int _ =&gt; x
    |
      Sort _ | Rel _ | Var _ | Cast _ _ _ | Prod _ _ _ | Lambda _ _ _ |
        LetIn _ _ _ _ | App _ _ | Case _ _ _ _ | Fix _ | CoFix _ | Proj _ _ =&gt;
      CClosure.whd_val
        (CClosure.create_clos_infos None CClosure.betaiotazeta env)
        (CClosure.create_tab tt) (CClosure.inject x)
    end
  | Rel _ | Cast _ _ _ | LetIn _ _ _ _ | Case _ _ _ _ | Proj _ _ =&gt;
    CClosure.whd_val (CClosure.create_clos_infos None CClosure.betaiotazeta env)
      (CClosure.create_tab tt) (CClosure.inject x)
  end.

Definition whd_all (env : Environ.env) (t : Constr.constr) : Constr.constr :=
  match Constr.kind t with
  |
    Sort _ | Meta _ | Evar _ | Ind _ | Construct _ | Prod _ _ _ | Lambda _ _ _ |
      Fix _ | CoFix _ | Int _ =&gt; t
  | App c _ =&gt;
    match Constr.kind c with
    | Ind _ | Construct _ | Evar _ | Meta _ | Int _ =&gt; t
    |
      Sort _ | Rel _ | Var _ | Cast _ _ _ | Prod _ _ _ | Lambda _ _ _ |
        LetIn _ _ _ _ | App _ _ | Const _ | Case _ _ _ _ | Fix _ | CoFix _ |
        Proj _ _ =&gt;
      CClosure.whd_val (CClosure.create_clos_infos None CClosure.all env)
        (CClosure.create_tab tt) (CClosure.inject t)
    end
  |
    Rel _ | Cast _ _ _ | LetIn _ _ _ _ | Case _ _ _ _ | Proj _ _ | Const _ |
      Var _ =&gt;
    CClosure.whd_val (CClosure.create_clos_infos None CClosure.all env)
      (CClosure.create_tab tt) (CClosure.inject t)
  end.

Definition whd_allnolet (env : Environ.env) (t : Constr.constr)
  : Constr.constr :=
  match Constr.kind t with
  |
    Sort _ | Meta _ | Evar _ | Ind _ | Construct _ | Prod _ _ _ | Lambda _ _ _ |
      Fix _ | CoFix _ | LetIn _ _ _ _ | Int _ =&gt; t
  | App c _ =&gt;
    match Constr.kind c with
    | Ind _ | Construct _ | Evar _ | Meta _ | LetIn _ _ _ _ | Int _ =&gt; t
    |
      Sort _ | Rel _ | Var _ | Cast _ _ _ | Prod _ _ _ | Lambda _ _ _ | App _ _
        | Const _ | Case _ _ _ _ | Fix _ | CoFix _ | Proj _ _ =&gt;
      CClosure.whd_val (CClosure.create_clos_infos None CClosure.allnolet env)
        (CClosure.create_tab tt) (CClosure.inject t)
    end
  | Rel _ | Cast _ _ _ | Case _ _ _ _ | Proj _ _ | Const _ | Var _ =&gt;
    CClosure.whd_val (CClosure.create_clos_infos None CClosure.allnolet env)
      (CClosure.create_tab tt) (CClosure.inject t)
  end.

Definition kernel_conversion_function (a : Type) :=
  Environ.env -&gt; a -&gt; a -&gt; unit.

Definition extended_conversion_function (a : Type) :=
  (option bool) -&gt;
    (option TransparentState.t) -&gt;
      Environ.env -&gt;
        (option ((Constr.existential -&gt; option Constr.constr) * UGraph.t)) -&gt;
          a -&gt; a -&gt; unit.

Inductive conv_pb : Type :=
| CONV : conv_pb
| CUMUL : conv_pb.

Definition is_cumul (function_parameter : conv_pb) : bool :=
  match function_parameter with
  | CUMUL =&gt; true
  | CONV =&gt; false
  end.

Record universe_compare {a : Type} := {
  compare_sorts : Environ.env -&gt; conv_pb -&gt; Sorts.t -&gt; Sorts.t -&gt; a -&gt; a;
  compare_instances : bool -&gt; Univ.Instance.t -&gt; Univ.Instance.t -&gt; a -&gt; a;
  compare_cumul_instances :
    conv_pb -&gt;
      (array Univ.Variance.t) -&gt; Univ.Instance.t -&gt; Univ.Instance.t -&gt; a -&gt; a }.
Arguments universe_compare : clear implicits.

Definition universe_state (a : Type) := a * (universe_compare a).

Definition generic_conversion_function (a b : Type) :=
  Environ.env -&gt; (universe_state b) -&gt; a -&gt; a -&gt; b.

Definition infer_conversion_function (a : Type) :=
  Environ.env -&gt; UGraph.t -&gt; a -&gt; a -&gt; Univ.Constraint.t.

Definition sort_cmp_universes {A : Type}
  (env : Environ.env) (pb : conv_pb) (s0 : Sorts.t) (s1 : Sorts.t)
  (function_parameter : A * (universe_compare A)) : A * (universe_compare A) :=
  match function_parameter with
  | (u, check) =&gt; (((compare_sorts check) env pb s0 s1 u), check)
  end.

Definition convert_instances {A : Type}
  (flex : bool) (u : Univ.Instance.t) (u' : Univ.Instance.t)
  (function_parameter : A * (universe_compare A)) : A * (universe_compare A) :=
  match function_parameter with
  | (s, check) =&gt; (((compare_instances check) flex u u' s), check)
  end.

Definition get_cumulativity_constraints
  (cv_pb : conv_pb) (variance : array Univ.Variance.t) (u : Univ.Instance.t)
  (u' : Univ.Instance.t) : Univ.Constraint.t :=
  match cv_pb with
  | CONV =&gt;
    Univ.enforce_eq_variance_instances variance u u' Univ.Constraint.empty
  | CUMUL =&gt;
    Univ.enforce_leq_variance_instances variance u u' Univ.Constraint.empty
  end.

Definition inductive_cumulativity_arguments
  (function_parameter : Declarations.mutual_inductive_body * Z) : Z :=
  match function_parameter with
  | (mind, ind) =&gt;
    Util.op_plus (Declarations.mind_nparams mind)
      (Declarations.mind_nrealargs
        (Util.Array.(CArray.ExtS.get) (Declarations.mind_packets mind) ind))
  end.

Definition convert_inductives_gen {A B C D E : Type}
  (cmp_instances : A -&gt; B -&gt; C -&gt; D)
  (cmp_cumul : E -&gt; (array Univ.Variance.t) -&gt; A -&gt; B -&gt; C -&gt; D) (cv_pb : E)
  (function_parameter : Declarations.mutual_inductive_body * Z)
  : Int.t -&gt; A -&gt; B -&gt; C -&gt; D :=
  match function_parameter with
  | (mind, ind) =&gt;
    fun nargs =&gt;
      fun u1 =&gt;
        fun u2 =&gt;
          fun s =&gt;
            match Declarations.mind_variance mind with
            | None =&gt; cmp_instances u1 u2 s
            | Some variances =&gt;
              let num_param_arity :=
                inductive_cumulativity_arguments (mind, ind) in
              if negb (Int.equal num_param_arity nargs) then
                cmp_instances u1 u2 s
              else
                cmp_cumul cv_pb variances u1 u2 s
            end
  end.

Definition convert_inductives {A : Type}
  (cv_pb : conv_pb) (ind : Declarations.mutual_inductive_body * Z)
  (nargs : Int.t) (u1 : Univ.Instance.t) (u2 : Univ.Instance.t)
  (function_parameter : A * (universe_compare A)) : A * (universe_compare A) :=
  match function_parameter with
  | (s, check) =&gt;
    ((convert_inductives_gen ((compare_instances check) false)
      (compare_cumul_instances check) cv_pb ind nargs u1 u2 s), check)
  end.

Definition constructor_cumulativity_arguments
  (function_parameter : Declarations.mutual_inductive_body * Z * Z) : Z :=
  match function_parameter with
  | (mind, ind, ctor) =&gt;
    Util.op_plus (Declarations.mind_nparams mind)
      (Util.Array.(CArray.ExtS.get)
        (Declarations.mind_consnrealargs
          (Util.Array.(CArray.ExtS.get) (Declarations.mind_packets mind) ind))
        (Util.op_minus ctor 1))
  end.

Definition convert_constructors_gen {A B C : Type}
  (cmp_instances : Univ.Instance.t -&gt; A -&gt; B -&gt; C)
  (cmp_cumul :
    conv_pb -&gt; (array Univ.Variance.t) -&gt; Univ.Instance.t -&gt; A -&gt; B -&gt; C)
  (function_parameter : Declarations.mutual_inductive_body * Z * Z)
  : Int.t -&gt; Univ.Instance.t -&gt; A -&gt; B -&gt; C :=
  match function_parameter with
  | (mind, ind, cns) =&gt;
    fun nargs =&gt;
      fun u1 =&gt;
        fun u2 =&gt;
          fun s =&gt;
            match Declarations.mind_variance mind with
            | None =&gt; cmp_instances u1 u2 s
            | Some _ =&gt;
              let num_cnstr_args :=
                constructor_cumulativity_arguments (mind, ind, cns) in
              if negb (Int.equal num_cnstr_args nargs) then
                cmp_instances u1 u2 s
              else
                let variance :=
                  Util.Array.(CArray.ExtS.make) (Univ.Instance.length u1)
                    Univ.Variance.Irrelevant in
                cmp_cumul CONV variance u1 u2 s
            end
  end.

Definition convert_constructors {A : Type}
  (ctor : Declarations.mutual_inductive_body * Z * Z) (nargs : Int.t)
  (u1 : Univ.Instance.t) (u2 : Univ.Instance.t)
  (function_parameter : A * (universe_compare A)) : A * (universe_compare A) :=
  match function_parameter with
  | (s, check) =&gt;
    ((convert_constructors_gen ((compare_instances check) false)
      (compare_cumul_instances check) ctor nargs u1 u2 s), check)
  end.

Definition conv_table_key {A : Type}
  (infos : CClosure.clos_infos)
  (k1 : Names.tableKey (Names.Constant.t * Univ.Instance.t))
  (k2 : Names.tableKey (Names.Constant.t * Univ.Instance.t))
  (cuniv : A * (universe_compare A)) : A * (universe_compare A) :=
  if Stdlib.op_eq_eq k1 k2 then
    cuniv
  else
    match (k1, k2) with
    | _ =&gt; Stdlib.raise NotConvertible
    end.

Definition unfold_ref_with_args
  (infos : CClosure.clos_infos) (tab : CClosure.clos_tab)
  (fl : CClosure.table_key) (v : CClosure.stack)
  : option (CClosure.fconstr * CClosure.stack) :=
  match CClosure.unfold_reference infos tab fl with
  | Def def =&gt; Some (def, v)
  | Undef _ | OpaqueDef _ | Primitive _ =&gt; None
  end.

Record conv_tab := {
  cnv_inf : CClosure.clos_infos;
  relevances : list Sorts.relevance;
  lft_tab : CClosure.clos_tab;
  rgt_tab : CClosure.clos_tab }.

Definition push_relevance {A : Type}
  (infos : conv_tab) (r : Context.binder_annot A) : conv_tab := record.

Definition push_relevances {A : Type}
  (infos : conv_tab) (nas : array (Context.binder_annot A)) : conv_tab := record.

Fixpoint skip_pattern
  (infos : conv_tab) (relevances : list Sorts.relevance) (n : Int.t)
  (c1 : Constr.constr) (c2 : Constr.constr)
  : conv_tab * Constr.constr * Constr.constr :=
  if Int.equal n 0 then
    (record, c1, c2)
  else
    match ((Constr.kind c1), (Constr.kind c2)) with
    | (Lambda x _ c1, Lambda _ _ c2) =&gt;
      skip_pattern infos (cons (Context.binder_relevance x) relevances)
        (Z.pred n) c1 c2
    | _ =&gt; Stdlib.raise IrregularPatternShape
    end.

Definition skip_pattern
  (infos : conv_tab) (n : Int.t) (c1 : Constr.constr) (c2 : Constr.constr)
  : conv_tab * Constr.constr * Constr.constr :=
  if Int.equal n 0 then
    (infos, c1, c2)
  else
    skip_pattern infos (relevances infos) n c1 c2.

Definition is_irrelevant
  (infos : conv_tab) (lft : Esubst.lift) (c : CClosure.fconstr) : bool :=
  let env := CClosure.info_env (cnv_inf infos) in
  try.

Fixpoint ccnv {A : Type}
  (cv_pb : conv_pb) (l2r : bool) (infos : conv_tab) (lft1 : Esubst.lift)
  (lft2 : Esubst.lift) (term1 : CClosure.fconstr) (term2 : CClosure.fconstr)
  (cuniv : A * (universe_compare A)) : A * (universe_compare A) := try

with eqappr {A : Type}
  (cv_pb : conv_pb) (l2r : bool) (infos : conv_tab)
  (function_parameter : Esubst.lift * (CClosure.fconstr * CClosure.stack))
  : (Esubst.lift * (CClosure.fconstr * CClosure.stack)) -&gt;
    (A * (universe_compare A)) -&gt; A * (universe_compare A) :=
  match function_parameter with
  | (lft1, st1) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (lft2, st2) =&gt;
        fun cuniv =&gt;
          Control.check_for_interrupt tt;
          let ninfos :=
            CClosure.infos_with_reds (cnv_inf infos) CClosure.betaiotazeta in
          match CClosure.whd_stack ninfos (lft_tab infos) (fst st1) (snd st1)
            with
          | (hd1, v1) as appr1 =&gt;
            match CClosure.whd_stack ninfos (rgt_tab infos) (fst st2) (snd st2)
              with
            | (hd2, v2) as appr2 =&gt;
              let appr1 : Esubst.lift * (CClosure.fconstr * CClosure.stack) :=
                (lft1, appr1)
              with appr2 : Esubst.lift * (CClosure.fconstr * CClosure.stack) :=
                (lft2, appr2) in
              match ((CClosure.fterm_of hd1), (CClosure.fterm_of hd2)) with
              | (FAtom a1, FAtom a2) =&gt;
                match ((Constr.kind a1), (Constr.kind a2)) with
                | (Sort s1, Sort s2) =&gt;
                  if negb (andb (is_empty_stack v1) (is_empty_stack v2)) then
                    CErrors.anomaly None None
                      (Pp.str
                        &quot;conversion was given ill-typed terms (Sort).&quot; % string)
                  else
                    tt;
                  sort_cmp_universes (CClosure.info_env (cnv_inf infos)) cv_pb
                    s1 s2 cuniv
                | (Meta n, Meta m) =&gt;
                  if Int.equal n m then
                    convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
                  else
                    Stdlib.raise NotConvertible
                | _ =&gt; Stdlib.raise NotConvertible
                end
              | (FEvar (ev1, args1) env1, FEvar (ev2, args2) env2) =&gt;
                if Evar.equal ev1 ev2 then
                  let el1 := el_stack lft1 v1 in
                  let el2 := el_stack lft2 v2 in
                  let cuniv := convert_stacks l2r infos lft1 lft2 v1 v2 cuniv in
                  convert_vect l2r infos el1 el2
                    (Util.Array.(CArray.ExtS.map) (CClosure.mk_clos env1) args1)
                    (Util.Array.(CArray.ExtS.map) (CClosure.mk_clos env2) args2)
                    cuniv
                else
                  Stdlib.raise NotConvertible
              | (FRel n, FRel m) =&gt;
                let el1 := el_stack lft1 v1 in
                let el2 := el_stack lft2 v2 in
                if Int.equal (Esubst.reloc_rel n el1) (Esubst.reloc_rel m el2)
                  then
                  convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
                else
                  Stdlib.raise NotConvertible
              | (FFlex fl1, FFlex fl2) =&gt; try
              | (FProj p1 c1, FProj p2 c2) =&gt;
                match CClosure.unfold_projection (cnv_inf infos) p1 with
                | Some s1 =&gt;
                  eqappr cv_pb l2r infos (lft1, (c1, (cons s1 v1))) appr2 cuniv
                | None =&gt;
                  match CClosure.unfold_projection (cnv_inf infos) p2 with
                  | Some s2 =&gt;
                    eqappr cv_pb l2r infos appr1 (lft2, (c2, (cons s2 v2)))
                      cuniv
                  | None =&gt;
                    if
                      andb
                        (Names.Projection.Repr.equal (Names.Projection.repr p1)
                          (Names.Projection.repr p2))
                        (compare_stack_shape v1 v2) then
                      let el1 := el_stack lft1 v1 in
                      let el2 := el_stack lft2 v2 in
                      let u1 := ccnv CONV l2r infos el1 el2 c1 c2 cuniv in
                      convert_stacks l2r infos lft1 lft2 v1 v2 u1
                    else
                      Stdlib.raise NotConvertible
                  end
                end
              | (FProj p1 c1, t2) =&gt;
                match CClosure.unfold_projection (cnv_inf infos) p1 with
                | Some s1 =&gt;
                  eqappr cv_pb l2r infos (lft1, (c1, (cons s1 v1))) appr2 cuniv
                | None =&gt;
                  match t2 with
                  | FFlex fl2 =&gt;
                    match
                      unfold_ref_with_args (cnv_inf infos) (rgt_tab infos) fl2
                        v2 with
                    | Some t2 =&gt; eqappr cv_pb l2r infos appr1 (lft2, t2) cuniv
                    | None =&gt; Stdlib.raise NotConvertible
                    end
                  | _ =&gt; Stdlib.raise NotConvertible
                  end
                end
              | (t1, FProj p2 c2) =&gt;
                match CClosure.unfold_projection (cnv_inf infos) p2 with
                | Some s2 =&gt;
                  eqappr cv_pb l2r infos appr1 (lft2, (c2, (cons s2 v2))) cuniv
                | None =&gt;
                  match t1 with
                  | FFlex fl1 =&gt;
                    match
                      unfold_ref_with_args (cnv_inf infos) (lft_tab infos) fl1
                        v1 with
                    | Some t1 =&gt; eqappr cv_pb l2r infos (lft1, t1) appr2 cuniv
                    | None =&gt; Stdlib.raise NotConvertible
                    end
                  | _ =&gt; Stdlib.raise NotConvertible
                  end
                end
              | (FLambda _ _ _ _, FLambda _ _ _ _) =&gt;
                if negb (andb (is_empty_stack v1) (is_empty_stack v2)) then
                  CErrors.anomaly None None
                    (Pp.str
                      &quot;conversion was given ill-typed terms (FLambda).&quot; % string)
                else
                  tt;
                match CClosure.destFLambda CClosure.mk_clos hd1 with
                | (x1, ty1, bd1) =&gt;
                  match CClosure.destFLambda CClosure.mk_clos hd2 with
                  | (_, ty2, bd2) =&gt;
                    let el1 := el_stack lft1 v1 in
                    let el2 := el_stack lft2 v2 in
                    let cuniv := ccnv CONV l2r infos el1 el2 ty1 ty2 cuniv in
                    ccnv CONV l2r (push_relevance infos x1) (Esubst.el_lift el1)
                      (Esubst.el_lift el2) bd1 bd2 cuniv
                  end
                end
              | (FProd x1 c1 c2 e, FProd _ c'1 c'2 e') =&gt;
                if negb (andb (is_empty_stack v1) (is_empty_stack v2)) then
                  CErrors.anomaly None None
                    (Pp.str
                      &quot;conversion was given ill-typed terms (FProd).&quot; % string)
                else
                  tt;
                let el1 := el_stack lft1 v1 in
                let el2 := el_stack lft2 v2 in
                let cuniv := ccnv CONV l2r infos el1 el2 c1 c'1 cuniv in
                ccnv cv_pb l2r (push_relevance infos x1) (Esubst.el_lift el1)
                  (Esubst.el_lift el2)
                  (CClosure.mk_clos (Esubst.subs_lift e) c2)
                  (CClosure.mk_clos (Esubst.subs_lift e') c'2) cuniv
              | (FLambda _ _ _ _, _) =&gt;
                match
                  match v1 with
                  | [] =&gt; tt
                  | _ =&gt;
                    CErrors.anomaly None None
                      (Pp.str
                        &quot;conversion was given unreduced term (FLambda).&quot; %
                          string)
                  end with
                | tt =&gt;
                  match CClosure.destFLambda CClosure.mk_clos hd1 with
                  | (x1, _ty1, bd1) =&gt;
                    let infos := push_relevance infos x1 in
                    eqappr CONV l2r infos ((Esubst.el_lift lft1), (bd1, []))
                      ((Esubst.el_lift lft2),
                        (hd2, (CClosure.eta_expand_stack v2))) cuniv
                  end
                end
              | (_, FLambda _ _ _ _) =&gt;
                match
                  match v2 with
                  | [] =&gt; tt
                  | _ =&gt;
                    CErrors.anomaly None None
                      (Pp.str
                        &quot;conversion was given unreduced term (FLambda).&quot; %
                          string)
                  end with
                | tt =&gt;
                  match CClosure.destFLambda CClosure.mk_clos hd2 with
                  | (x2, _ty2, bd2) =&gt;
                    let infos := push_relevance infos x2 in
                    eqappr CONV l2r infos
                      ((Esubst.el_lift lft1),
                        (hd1, (CClosure.eta_expand_stack v1)))
                      ((Esubst.el_lift lft2), (bd2, [])) cuniv
                  end
                end
              | (FFlex fl1, c2) =&gt;
                match
                  unfold_ref_with_args (cnv_inf infos) (lft_tab infos) fl1 v1
                  with
                | Some (def1, v1) =&gt;
                  let all :=
                    CClosure.RedFlags.(CClosure.RedFlagsSig.red_add_transparent)
                      CClosure.all
                      (CClosure.RedFlags.(CClosure.RedFlagsSig.red_transparent)
                        (CClosure.info_flags (cnv_inf infos))) in
                  let r1 :=
                    CClosure.whd_stack
                      (CClosure.infos_with_reds (cnv_inf infos) all)
                      (lft_tab infos) def1 v1 in
                  eqappr cv_pb l2r infos (lft1, r1) appr2 cuniv
                | None =&gt;
                  match c2 with
                  | FConstruct ((ind2, _j2), _u2) =&gt; try
                  | _ =&gt; Stdlib.raise NotConvertible
                  end
                end
              | (c1, FFlex fl2) =&gt;
                match
                  unfold_ref_with_args (cnv_inf infos) (rgt_tab infos) fl2 v2
                  with
                | Some (def2, v2) =&gt;
                  let all :=
                    CClosure.RedFlags.(CClosure.RedFlagsSig.red_add_transparent)
                      CClosure.all
                      (CClosure.RedFlags.(CClosure.RedFlagsSig.red_transparent)
                        (CClosure.info_flags (cnv_inf infos))) in
                  let r2 :=
                    CClosure.whd_stack
                      (CClosure.infos_with_reds (cnv_inf infos) all)
                      (rgt_tab infos) def2 v2 in
                  eqappr cv_pb l2r infos appr1 (lft2, r2) cuniv
                | None =&gt;
                  match c1 with
                  | FConstruct ((ind1, _j1), _u1) =&gt; try
                  | _ =&gt; Stdlib.raise NotConvertible
                  end
                end
              | (FInd (ind1, u1), FInd (ind2, u2)) =&gt;
                if Names.eq_ind ind1 ind2 then
                  if
                    orb (equiv_decb (Univ.Instance.length u1) 0)
                      (equiv_decb (Univ.Instance.length u2) 0) then
                    let cuniv := convert_instances false u1 u2 cuniv in
                    convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
                  else
                    let mind :=
                      Environ.lookup_mind (fst ind1)
                        (CClosure.info_env (cnv_inf infos)) in
                    let nargs := CClosure.stack_args_size v1 in
                    if negb (Int.equal nargs (CClosure.stack_args_size v2)) then
                      Stdlib.raise NotConvertible
                    else
                      let cuniv :=
                        convert_inductives cv_pb (mind, (snd ind1)) nargs u1 u2
                          cuniv in
                      convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
                else
                  Stdlib.raise NotConvertible
              | (FConstruct ((ind1, j1), u1), FConstruct ((ind2, j2), u2)) =&gt;
                if andb (Int.equal j1 j2) (Names.eq_ind ind1 ind2) then
                  if
                    orb (equiv_decb (Univ.Instance.length u1) 0)
                      (equiv_decb (Univ.Instance.length u2) 0) then
                    let cuniv := convert_instances false u1 u2 cuniv in
                    convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
                  else
                    let mind :=
                      Environ.lookup_mind (fst ind1)
                        (CClosure.info_env (cnv_inf infos)) in
                    let nargs := CClosure.stack_args_size v1 in
                    if negb (Int.equal nargs (CClosure.stack_args_size v2)) then
                      Stdlib.raise NotConvertible
                    else
                      let cuniv :=
                        convert_constructors (mind, (snd ind1), j1) nargs u1 u2
                          cuniv in
                      convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
                else
                  Stdlib.raise NotConvertible
              | (FConstruct ((ind1, _j1), _u1), _) =&gt; try
              | (_, FConstruct ((ind2, _j2), _u2)) =&gt; try
              |
                (FFix ((op1, i1), (na1, tys1, cl1)) e1,
                  FFix ((op2, i2), (_, tys2, cl2)) e2) =&gt;
                if
                  andb (Int.equal i1 i2)
                    (Util.Array.(CArray.ExtS.equal) Int.equal op1 op2) then
                  let n := Util.Array.(CArray.ExtS.length) cl1 in
                  let fty1 :=
                    Util.Array.(CArray.ExtS.map) (CClosure.mk_clos e1) tys1 in
                  let fty2 :=
                    Util.Array.(CArray.ExtS.map) (CClosure.mk_clos e2) tys2 in
                  let fcl1 :=
                    Util.Array.(CArray.ExtS.map)
                      (CClosure.mk_clos (Esubst.subs_liftn n e1)) cl1 in
                  let fcl2 :=
                    Util.Array.(CArray.ExtS.map)
                      (CClosure.mk_clos (Esubst.subs_liftn n e2)) cl2 in
                  let el1 := el_stack lft1 v1 in
                  let el2 := el_stack lft2 v2 in
                  let cuniv := convert_vect l2r infos el1 el2 fty1 fty2 cuniv in
                  let cuniv :=
                    let infos := push_relevances infos na1 in
                    convert_vect l2r infos (Esubst.el_liftn n el1)
                      (Esubst.el_liftn n el2) fcl1 fcl2 cuniv in
                  convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
                else
                  Stdlib.raise NotConvertible
              |
                (FCoFix (op1, (na1, tys1, cl1)) e1,
                  FCoFix (op2, (_, tys2, cl2)) e2) =&gt;
                if Int.equal op1 op2 then
                  let n := Util.Array.(CArray.ExtS.length) cl1 in
                  let fty1 :=
                    Util.Array.(CArray.ExtS.map) (CClosure.mk_clos e1) tys1 in
                  let fty2 :=
                    Util.Array.(CArray.ExtS.map) (CClosure.mk_clos e2) tys2 in
                  let fcl1 :=
                    Util.Array.(CArray.ExtS.map)
                      (CClosure.mk_clos (Esubst.subs_liftn n e1)) cl1 in
                  let fcl2 :=
                    Util.Array.(CArray.ExtS.map)
                      (CClosure.mk_clos (Esubst.subs_liftn n e2)) cl2 in
                  let el1 := el_stack lft1 v1 in
                  let el2 := el_stack lft2 v2 in
                  let cuniv := convert_vect l2r infos el1 el2 fty1 fty2 cuniv in
                  let cuniv :=
                    let infos := push_relevances infos na1 in
                    convert_vect l2r infos (Esubst.el_liftn n el1)
                      (Esubst.el_liftn n el2) fcl1 fcl2 cuniv in
                  convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
                else
                  Stdlib.raise NotConvertible
              | (FInt i1, FInt i2) =&gt;
                if Uint63.equal i1 i2 then
                  convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
                else
                  Stdlib.raise NotConvertible
              |
                (FLetIn _ _ _ _ _, _) | (FCaseT _ _ _ _ _, _) | (FApp _ _, _) |
                  (FCLOS _ _, _) | (FLIFT _ _, _) | (_, FLetIn _ _ _ _ _) |
                  (_, FCaseT _ _ _ _ _) | (_, FApp _ _) | (_, FCLOS _ _) |
                  (_, FLIFT _ _) | (FLOCKED, _) | (_, FLOCKED) =&gt; false
              |
                (FRel _ | FAtom _ | FInd _ | FFix _ _ | FCoFix _ _ |
                  FProd _ _ _ _ | FEvar _ _ | FInt _, _) =&gt;
                Stdlib.raise NotConvertible
              end
            end
          end
      end
  end

with convert_stacks {A : Type}
  (l2r : bool) (infos : conv_tab) (lft1 : Esubst.lift) (lft2 : Esubst.lift)
  (stk1 : CClosure.stack) (stk2 : CClosure.stack)
  (cuniv : A * (universe_compare A)) : A * (universe_compare A) :=
  let f (function_parameter : Esubst.lift * CClosure.fconstr)
    : (Esubst.lift * CClosure.fconstr) -&gt;
      (A * (universe_compare A)) -&gt; A * (universe_compare A) :=
    match function_parameter with
    | (l1, t1) =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | (l2, t2) =&gt; fun cuniv =&gt; ccnv CONV l2r infos l1 l2 t1 t2 cuniv
        end
    end in
  let fix cmp_rec
    (pstk1 : list lft_constr_stack_elt) (pstk2 : list lft_constr_stack_elt)
    (cuniv : A * (universe_compare A)) : A * (universe_compare A) :=
    match (pstk1, pstk2) with
    | (cons z1 s1, cons z2 s2) =&gt;
      let cu1 := cmp_rec s1 s2 cuniv in
      match (z1, z2) with
      | (Zlapp a1, Zlapp a2) =&gt; Util.Array.(CArray.ExtS.fold_right2) f a1 a2 cu1
      | (Zlproj c1 _l1, Zlproj c2 _l2) =&gt;
        if negb (Names.Projection.Repr.equal c1 c2) then
          Stdlib.raise NotConvertible
        else
          cu1
      | (Zlfix fx1 a1, Zlfix fx2 a2) =&gt;
        let cu2 := f fx1 fx2 cu1 in
        cmp_rec a1 a2 cu2
      | (Zlcase ci1 l1 p1 br1 e1, Zlcase ci2 l2 p2 br2 e2) =&gt;
        if negb (Names.eq_ind (ci_ind ci1) (ci_ind ci2)) then
          Stdlib.raise NotConvertible
        else
          tt;
        let cu2 :=
          f (l1, (CClosure.mk_clos e1 p1)) (l2, (CClosure.mk_clos e2 p2)) cu1 in
        convert_branches l2r infos ci1 e1 e2 l1 l2 br1 br2 cu2
      | (Zlprimitive op1 _ rargs1 kargs1, Zlprimitive op2 _ rargs2 kargs2) =&gt;
        if negb (CPrimitives.equal op1 op2) then
          Stdlib.raise NotConvertible
        else
          let cu2 := Util.List.(CList.ExtS.fold_right2) f rargs1 rargs2 cu1 in
          let fk {B C : Type}
            (function_parameter : B * (Esubst.lift * CClosure.fconstr))
            : (C * (Esubst.lift * CClosure.fconstr)) -&gt;
              (A * (universe_compare A)) -&gt; A * (universe_compare A) :=
            match function_parameter with
            | (_, a1) =&gt;
              fun function_parameter =&gt;
                match function_parameter with
                | (_, a2) =&gt; fun cu =&gt; f a1 a2 cu
                end
            end in
          Util.List.(CList.ExtS.fold_right2) fk kargs1 kargs2 cu2
      |
        (Zlapp _ | Zlproj _ _ | Zlfix _ _ | Zlcase _ _ _ _ _ |
          Zlprimitive _ _ _ _, _) =&gt; false
      end
    | _ =&gt; cuniv
    end in
  if compare_stack_shape stk1 stk2 then
    cmp_rec (pure_stack lft1 stk1) (pure_stack lft2 stk2) cuniv
  else
    Stdlib.raise NotConvertible

with convert_vect {A : Type}
  (l2r : bool) (infos : conv_tab) (lft1 : Esubst.lift) (lft2 : Esubst.lift)
  (v1 : array CClosure.fconstr) (v2 : array CClosure.fconstr)
  (cuniv : A * (universe_compare A)) : A * (universe_compare A) :=
  let lv1 := Util.Array.(CArray.ExtS.length) v1 in
  let lv2 := Util.Array.(CArray.ExtS.length) v2 in
  if Int.equal lv1 lv2 then
    let fix fold (n : Z) (cuniv : A * (universe_compare A))
      : A * (universe_compare A) :=
      if OCaml.Stdlib.ge n lv1 then
        cuniv
      else
        let cuniv :=
          ccnv CONV l2r infos lft1 lft2 (Util.Array.(CArray.ExtS.get) v1 n)
            (Util.Array.(CArray.ExtS.get) v2 n) cuniv in
        fold (Util.op_plus n 1) cuniv in
    fold 0 cuniv
  else
    Stdlib.raise NotConvertible

with convert_branches {A : Type}
  (l2r : bool) (infos : conv_tab) (ci : Constr.case_info)
  (e1 : Esubst.subs CClosure.fconstr) (e2 : Esubst.subs CClosure.fconstr)
  (lft1 : Esubst.lift) (lft2 : Esubst.lift) (br1 : array Constr.constr)
  (br2 : array Constr.constr) (cuniv : A * (universe_compare A))
  : A * (universe_compare A) :=
  let fold
    (n : Int.t) (c1 : Constr.constr) (c2 : Constr.constr) (cuniv :
    A * (universe_compare A)) : A * (universe_compare A) :=
    match skip_pattern infos n c1 c2 with
    | (infos, c1, c2) =&gt;
      let lft1 := Esubst.el_liftn n lft1 in
      let lft2 := Esubst.el_liftn n lft2 in
      let e1 := Esubst.subs_liftn n e1 in
      let e2 := Esubst.subs_liftn n e2 in
      ccnv CONV l2r infos lft1 lft2 (CClosure.mk_clos e1 c1)
        (CClosure.mk_clos e2 c2) cuniv
    end in
  Util.Array.(CArray.ExtS.fold_right3) fold (ci_cstr_nargs ci) br1 br2 cuniv.

Definition clos_gen_conv {A : Type}
  (trans : TransparentState.t) (cv_pb : conv_pb) (l2r : bool)
  (evars : Constr.existential -&gt; option Constr.constr) (env : Environ.env)
  (univs : A * (universe_compare A)) (t1 : Constr.constr) (t2 : Constr.constr)
  : A * (universe_compare A) :=
  let reds :=
    CClosure.RedFlags.(CClosure.RedFlagsSig.red_add_transparent)
      CClosure.betaiotazeta trans in
  let infos := CClosure.create_clos_infos (Some evars) reds env in
  let infos :=
    {| cnv_inf := infos;
      relevances :=
        Util.List.(CList.ExtS.map) Context.Rel.Declaration.get_relevance
          (Environ.rel_context env); lft_tab := CClosure.create_tab tt;
      rgt_tab := CClosure.create_tab tt |} in
  ccnv cv_pb l2r infos Esubst.el_id Esubst.el_id (CClosure.inject t1)
    (CClosure.inject t2) univs.

Definition check_eq
  (univs : UGraph.t) (u : Univ.Universe.t) (u' : Univ.Universe.t) : unit :=
  if negb (UGraph.check_eq univs u u') then
    Stdlib.raise NotConvertible
  else
    tt.

Definition check_leq
  (univs : UGraph.t) (u : Univ.Universe.t) (u' : Univ.Universe.t) : unit :=
  if negb (UGraph.check_leq univs u u') then
    Stdlib.raise NotConvertible
  else
    tt.

Definition check_sort_cmp_universes
  (env : Environ.env) (pb : conv_pb) (s0 : Sorts.t) (s1 : Sorts.t)
  (univs : UGraph.t) : unit :=
  if negb (Environ.type_in_type env) then
    let check_pb (u0 : Univ.Universe.t) (u1 : Univ.Universe.t) : unit :=
      match pb with
      | CUMUL =&gt; check_leq univs u0 u1
      | CONV =&gt; check_eq univs u0 u1
      end in
    match (s0, s1) with
    | (SProp, SProp) | (Prop, Prop) | (Set, Set) =&gt; tt
    | (SProp, _) | (_, SProp) =&gt; Stdlib.raise NotConvertible
    | (Prop, Set | Type _) =&gt;
      if negb (is_cumul pb) then
        Stdlib.raise NotConvertible
      else
        tt
    | (Set, Prop) =&gt; Stdlib.raise NotConvertible
    | (Set, Type u) =&gt; check_pb Univ.type0_univ u
    | (Type _u, Prop) =&gt; Stdlib.raise NotConvertible
    | (Type u, Set) =&gt; check_pb u Univ.type0_univ
    | (Type u0, Type u1) =&gt; check_pb u0 u1
    end
  else
    tt.

Definition checked_sort_cmp_universes
  (env : Environ.env) (pb : conv_pb) (s0 : Sorts.t) (s1 : Sorts.t)
  (univs : UGraph.t) : UGraph.t :=
  check_sort_cmp_universes env pb s0 s1 univs;
  univs.

Definition check_convert_instances {A : Type} (function_parameter : A)
  : Univ.Instance.t -&gt; Univ.Instance.t -&gt; UGraph.t -&gt; UGraph.t :=
  match function_parameter with
  | _ =&gt;
    fun u =&gt;
      fun u' =&gt;
        fun univs =&gt;
          if UGraph.check_eq_instances univs u u' then
            univs
          else
            Stdlib.raise NotConvertible
  end.

Definition check_inductive_instances
  (cv_pb : conv_pb) (variance : array Univ.Variance.t) (u1 : Univ.Instance.t)
  (u2 : Univ.Instance.t) (univs : UGraph.t) : UGraph.t :=
  let csts := get_cumulativity_constraints cv_pb variance u1 u2 in
  if UGraph.check_constraints csts univs then
    univs
  else
    Stdlib.raise NotConvertible.

Definition checked_universes : universe_compare UGraph.t :=
  {| compare_sorts := checked_sort_cmp_universes;
    compare_instances := check_convert_instances;
    compare_cumul_instances := check_inductive_instances |}.

Definition infer_eq (function_parameter : UGraph.t * Univ.Constraint.t)
  : Univ.Universe.t -&gt; Univ.Universe.t -&gt; UGraph.t * Univ.Constraint.t :=
  match function_parameter with
  | (univs, cstrs) as cuniv =&gt;
    fun u =&gt;
      fun u' =&gt;
        if UGraph.check_eq univs u u' then
          cuniv
        else
          (univs, (Univ.enforce_eq u u' cstrs))
  end.

Definition infer_leq (function_parameter : UGraph.t * Univ.Constraint.t)
  : Univ.Universe.t -&gt; Univ.Universe.t -&gt; UGraph.t * Univ.Constraint.t :=
  match function_parameter with
  | (univs, cstrs) as cuniv =&gt;
    fun u =&gt;
      fun u' =&gt;
        if UGraph.check_leq univs u u' then
          cuniv
        else
          match UGraph.enforce_leq_alg u u' univs with
          | (cstrs', _) =&gt; (univs, (Univ.Constraint.union cstrs cstrs'))
          end
  end.

Definition infer_cmp_universes
  (env : Environ.env) (pb : conv_pb) (s0 : Sorts.t) (s1 : Sorts.t)
  (univs : UGraph.t * Univ.Constraint.t) : UGraph.t * Univ.Constraint.t :=
  if Environ.type_in_type env then
    univs
  else
    let infer_pb (u0 : Univ.Universe.t) (u1 : Univ.Universe.t)
      : UGraph.t * Univ.Constraint.t :=
      match pb with
      | CUMUL =&gt; infer_leq univs u0 u1
      | CONV =&gt; infer_eq univs u0 u1
      end in
    match (s0, s1) with
    | (SProp, SProp) | (Prop, Prop) | (Set, Set) =&gt; univs
    | (SProp, _) | (_, SProp) =&gt; Stdlib.raise NotConvertible
    | (Prop, Set | Type _) =&gt;
      if negb (is_cumul pb) then
        Stdlib.raise NotConvertible
      else
        univs
    | (Set, Prop) =&gt; Stdlib.raise NotConvertible
    | (Set, Type u) =&gt; infer_pb Univ.type0_univ u
    | (Type u, Prop) =&gt; infer_pb u Univ.type0m_univ
    | (Type u, Set) =&gt; infer_pb u Univ.type0_univ
    | (Type u0, Type u1) =&gt; infer_pb u0 u1
    end.

Definition infer_convert_instances
  (flex : bool) (u : Univ.Instance.t) (u' : Univ.Instance.t)
  (function_parameter : UGraph.t * Univ.Constraint.t)
  : UGraph.t * Univ.Constraint.t :=
  match function_parameter with
  | (univs, cstrs) =&gt;
    let cstrs' :=
      if flex then
        if UGraph.check_eq_instances univs u u' then
          cstrs
        else
          Stdlib.raise NotConvertible
      else
        Univ.enforce_eq_instances u u' cstrs in
    (univs, cstrs')
  end.

Definition infer_inductive_instances {A : Type}
  (cv_pb : conv_pb) (variance : array Univ.Variance.t) (u1 : Univ.Instance.t)
  (u2 : Univ.Instance.t) (function_parameter : A * Univ.Constraint.t)
  : A * Univ.Constraint.t :=
  match function_parameter with
  | (univs, csts') =&gt;
    let csts := get_cumulativity_constraints cv_pb variance u1 u2 in
    (univs, (Univ.Constraint.union csts csts'))
  end.

Definition inferred_universes
  : universe_compare (UGraph.t * Univ.Constraint.t) :=
  {| compare_sorts := infer_cmp_universes;
    compare_instances := infer_convert_instances;
    compare_cumul_instances := infer_inductive_instances |}.

Definition gen_conv
  (cv_pb : conv_pb) (l2r : bool) (reds : TransparentState.t) (env : Environ.env)
  (evars : Constr.existential -&gt; option Constr.constr) (univs : UGraph.t)
  (t1 : Constr.constr) (t2 : Constr.constr) : unit :=
  let b :=
    if equiv_decb cv_pb CUMUL then
      Constr.leq_constr_univs univs t1 t2
    else
      Constr.eq_constr_univs univs t1 t2 in
  if b then
    tt
  else
    match
      clos_gen_conv reds cv_pb l2r evars env (univs, checked_universes) t1 t2
      with
    | _ =&gt; tt
    end.

Definition gen_conv (cv_pb : conv_pb) (op_star_o_p_t_star : option bool)
  : (option TransparentState.t) -&gt;
    Environ.env -&gt;
      (option ((Constr.existential -&gt; option Constr.constr) * UGraph.t)) -&gt;
        Constr.constr -&gt; Constr.constr -&gt; unit :=
  let l2r :=
    match op_star_o_p_t_star with
    | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
    | None =&gt; false
    end in
  fun op_star_o_p_t_star =&gt;
    let reds :=
      match op_star_o_p_t_star with
      | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
      | None =&gt; TransparentState.full
      end in
    fun env =&gt;
      fun op_star_o_p_t_star =&gt;
        let evars :=
          match op_star_o_p_t_star with
          | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
          | None =&gt;
            ((fun function_parameter =&gt;
              match function_parameter with
              | _ =&gt; None
              end), (Environ.universes env))
          end in
        match evars with
        | (evars, univs) =&gt;
          if Flags.profile then
            let fconv_universes_key :=
              CProfile.declare_profile &quot;trans_fconv_universes&quot; % string in
            CProfile.profile8 fconv_universes_key gen_conv cv_pb l2r reds env
              evars univs
          else
            gen_conv cv_pb l2r reds env evars univs
        end.

Definition conv
  : (option bool) -&gt;
    (option TransparentState.t) -&gt;
      Environ.env -&gt;
        (option ((Constr.existential -&gt; option Constr.constr) * UGraph.t)) -&gt;
          Constr.constr -&gt; Constr.constr -&gt; unit := gen_conv CONV.

Definition conv_leq
  : (option bool) -&gt;
    (option TransparentState.t) -&gt;
      Environ.env -&gt;
        (option ((Constr.existential -&gt; option Constr.constr) * UGraph.t)) -&gt;
          Constr.constr -&gt; Constr.constr -&gt; unit := gen_conv CUMUL.

Definition generic_conv {A : Type}
  (cv_pb : conv_pb) (l2r : bool)
  (evars : Constr.existential -&gt; option Constr.constr)
  (reds : TransparentState.t) (env : Environ.env)
  (univs : A * (universe_compare A)) (t1 : Constr.constr) (t2 : Constr.constr)
  : A :=
  match clos_gen_conv reds cv_pb l2r evars env univs t1 t2 with
  | (s, _) =&gt; s
  end.

Definition infer_conv_universes
  (cv_pb : conv_pb) (l2r : bool)
  (evars : Constr.existential -&gt; option Constr.constr)
  (reds : TransparentState.t) (env : Environ.env) (univs : UGraph.t)
  (t1 : Constr.constr) (t2 : Constr.constr) : Univ.Constraint.t :=
  match
    if Stdlib.op_eq_eq cv_pb CUMUL then
      Constr.leq_constr_univs_infer univs t1 t2
    else
      Constr.eq_constr_univs_infer univs t1 t2 with
  | (b, cstrs) =&gt;
    if b then
      cstrs
    else
      let univs := ((univs, Univ.Constraint.empty), inferred_universes) in
      match clos_gen_conv reds cv_pb l2r evars env univs t1 t2 with
      | ((_, cstrs), _) =&gt; cstrs
      end
  end.

Definition infer_conv_universes
  : conv_pb -&gt;
    bool -&gt;
      (Constr.existential -&gt; option Constr.constr) -&gt;
        TransparentState.t -&gt;
          Environ.env -&gt;
            UGraph.t -&gt; Constr.constr -&gt; Constr.constr -&gt; Univ.Constraint.t :=
  if Flags.profile then
    let infer_conv_universes_key :=
      CProfile.declare_profile &quot;infer_conv_universes&quot; % string in
    CProfile.profile8 infer_conv_universes_key infer_conv_universes
  else
    infer_conv_universes.

Definition infer_conv (op_star_o_p_t_star : option bool)
  : (option (Constr.existential -&gt; option Constr.constr)) -&gt;
    (option TransparentState.t) -&gt;
      Environ.env -&gt;
        UGraph.t -&gt; Constr.constr -&gt; Constr.constr -&gt; Univ.Constraint.t :=
  let l2r :=
    match op_star_o_p_t_star with
    | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
    | None =&gt; false
    end in
  fun op_star_o_p_t_star =&gt;
    let evars :=
      match op_star_o_p_t_star with
      | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
      | None =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | _ =&gt; None
          end
      end in
    fun op_star_o_p_t_star =&gt;
      let ts :=
        match op_star_o_p_t_star with
        | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
        | None =&gt; TransparentState.full
        end in
      fun env =&gt;
        fun univs =&gt;
          fun t1 =&gt;
            fun t2 =&gt; infer_conv_universes CONV l2r evars ts env univs t1 t2.

Definition infer_conv_leq (op_star_o_p_t_star : option bool)
  : (option (Constr.existential -&gt; option Constr.constr)) -&gt;
    (option TransparentState.t) -&gt;
      Environ.env -&gt;
        UGraph.t -&gt; Constr.constr -&gt; Constr.constr -&gt; Univ.Constraint.t :=
  let l2r :=
    match op_star_o_p_t_star with
    | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
    | None =&gt; false
    end in
  fun op_star_o_p_t_star =&gt;
    let evars :=
      match op_star_o_p_t_star with
      | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
      | None =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | _ =&gt; None
          end
      end in
    fun op_star_o_p_t_star =&gt;
      let ts :=
        match op_star_o_p_t_star with
        | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
        | None =&gt; TransparentState.full
        end in
      fun env =&gt;
        fun univs =&gt;
          fun t1 =&gt;
            fun t2 =&gt; infer_conv_universes CUMUL l2r evars ts env univs t1 t2.

Definition default_conv {A : Type}
  (cv_pb : conv_pb) (function_parameter : option A)
  : Environ.env -&gt; Constr.constr -&gt; Constr.constr -&gt; unit :=
  match function_parameter with
  | _ =&gt; fun env =&gt; fun t1 =&gt; fun t2 =&gt; gen_conv cv_pb None None env None t1 t2
  end.

Definition default_conv_leq {A : Type}
  : (option A) -&gt; Environ.env -&gt; Constr.constr -&gt; Constr.constr -&gt; unit :=
  default_conv CUMUL.

Definition beta_applist (c : Constr.constr) (l : list Constr.constr)
  : Constr.constr :=
  let fix app (subst : Vars.substl) (c : Constr.constr) (l : list Constr.constr)
    : Constr.constr :=
    match ((Constr.kind c), l) with
    | (Lambda _ _ c, cons arg l) =&gt; app (cons arg subst) c l
    | _ =&gt; Term.applist ((Vars.substl subst c), l)
    end in
  app [] c l.

Definition beta_appvect (c : Constr.constr) (v : array Constr.constr)
  : Constr.constr := beta_applist c (Util.Array.(CArray.ExtS.to_list) v).

Definition beta_app (c : Constr.constr) (a : Constr.constr) : Constr.constr :=
  beta_applist c (cons a []).

Definition betazeta_appvect
  : Z -&gt; Constr.constr -&gt; (array Constr.constr) -&gt; Constr.constr :=
  Term.lambda_appvect_assum.

Definition hnf_prod_app
  (env : Environ.env) (t : Constr.constr) (n : Constr.constr) : Constr.constr :=
  match Constr.kind (whd_all env t) with
  | Prod _ _ b =&gt; Vars.subst1 n b
  | _ =&gt;
    CErrors.anomaly None (Some &quot;hnf_prod_app&quot; % string)
      (Pp.str &quot;Need a product.&quot; % string)
  end.

Definition hnf_prod_applist
  (env : Environ.env) (t : Constr.constr) (nl : list Constr.constr)
  : Constr.constr := Util.List.(CList.ExtS.fold_left) (hnf_prod_app env) t nl.

Definition hnf_prod_applist_assum
  (env : Environ.env) (n : Int.t) (c : Constr.constr) (l : list Constr.constr)
  : Constr.constr :=
  let fix app
    (n : Int.t) (subst : Vars.substl) (t : Constr.constr) (l :
    list Constr.constr) : Constr.constr :=
    if Int.equal n 0 then
      if Stdlib.op_eq_eq l [] then
        Vars.substl subst t
      else
        CErrors.anomaly None None (Pp.str &quot;Too many arguments.&quot; % string)
    else
      match ((Constr.kind (whd_allnolet env t)), l) with
      | (Prod _ _ c, cons arg l) =&gt; app (Util.op_minus n 1) (cons arg subst) c l
      | (LetIn _ b _ c, _) =&gt;
        app (Util.op_minus n 1) (cons (Vars.substl subst b) subst) c l
      | (_, []) =&gt;
        CErrors.anomaly None None (Pp.str &quot;Not enough arguments.&quot; % string)
      | _ =&gt;
        CErrors.anomaly None None (Pp.str &quot;Not enough prod/let's.&quot; % string)
      end in
  app n [] c l.

Definition dest_prod {A : Type} (env : Environ.env)
  : Constr.constr -&gt; (Context.Rel.pt A Constr.types) * Constr.constr :=
  let fix decrec {B : Type}
    (env : Environ.env) (m : Context.Rel.pt B Constr.types) (c : Constr.constr)
    : (Context.Rel.pt B Constr.types) * Constr.constr :=
    let t := whd_all env c in
    match Constr.kind t with
    | Prod n a c0 =&gt;
      let d := LocalAssum n a in
      decrec (Environ.push_rel d env) (Context.Rel.add d m) c0
    | _ =&gt; (m, t)
    end in
  decrec env Context.Rel.empty.

Definition dest_lam {A : Type} (env : Environ.env)
  : Constr.constr -&gt; (Context.Rel.pt A Constr.types) * Constr.constr :=
  let fix decrec {B : Type}
    (env : Environ.env) (m : Context.Rel.pt B Constr.types) (c : Constr.constr)
    : (Context.Rel.pt B Constr.types) * Constr.constr :=
    let t := whd_all env c in
    match Constr.kind t with
    | Lambda n a c0 =&gt;
      let d := LocalAssum n a in
      decrec (Environ.push_rel d env) (Context.Rel.add d m) c0
    | _ =&gt; (m, t)
    end in
  decrec env Context.Rel.empty.

Definition dest_prod_assum (env : Environ.env)
  : Constr.constr -&gt; (Context.Rel.pt Constr.constr Constr.types) * Constr.constr :=
  let fix prodec_rec
    (env : Environ.env) (l : Context.Rel.pt Constr.constr Constr.types) (ty :
    Constr.constr)
    : (Context.Rel.pt Constr.constr Constr.types) * Constr.constr :=
    let rty := whd_allnolet env ty in
    match Constr.kind rty with
    | Prod x t c =&gt;
      let d := LocalAssum x t in
      prodec_rec (Environ.push_rel d env) (Context.Rel.add d l) c
    | LetIn x b t c =&gt;
      let d := LocalDef x b t in
      prodec_rec (Environ.push_rel d env) (Context.Rel.add d l) c
    | _ =&gt;
      let rty' := whd_all env rty in
      if Constr.equal rty' rty then
        (l, rty)
      else
        prodec_rec env l rty'
    end in
  prodec_rec env Context.Rel.empty.

Definition dest_lam_assum (env : Environ.env)
  : Constr.constr -&gt; (Context.Rel.pt Constr.constr Constr.types) * Constr.constr :=
  let fix lamec_rec
    (env : Environ.env) (l : Context.Rel.pt Constr.constr Constr.types) (ty :
    Constr.constr)
    : (Context.Rel.pt Constr.constr Constr.types) * Constr.constr :=
    let rty := whd_allnolet env ty in
    match Constr.kind rty with
    | Lambda x t c =&gt;
      let d := LocalAssum x t in
      lamec_rec (Environ.push_rel d env) (Context.Rel.add d l) c
    | LetIn x b t c =&gt;
      let d := LocalDef x b t in
      lamec_rec (Environ.push_rel d env) (Context.Rel.add d l) c
    | _ =&gt; (l, rty)
    end in
  lamec_rec env Context.Rel.empty.

Definition dest_arity (env : Environ.env) (c : Constr.constr)
  : (Context.Rel.pt Constr.constr Constr.types) * Sorts.t :=
  match dest_prod_assum env c with
  | (l, c) =&gt;
    match Constr.kind c with
    | Sort s =&gt; (l, s)
    | _ =&gt; Stdlib.raise NotArity
    end
  end.

Definition is_arity (env : Environ.env) (c : Constr.constr) : bool := try.

Definition eta_expand
  (env : Environ.env) (t : Constr.constr) (ty : Constr.constr)
  : Constr.constr :=
  match dest_prod env ty with
  | (ctxt, _codom) =&gt;
    match dest_lam env t with
    | (ctxt', t) =&gt;
      let d := Util.op_minus (Context.Rel.nhyps ctxt) (Context.Rel.nhyps ctxt')
        in
      let eta_args :=
        Util.List.(CList.ExtS.rev_map) Constr.mkRel
          (Util.List.(CList.ExtS.interval) 1 d) in
      let t := Term.applistc (Vars.lift d t) eta_args in
      let t :=
        Term.it_mkLambda_or_LetIn t (Util.List.(CList.ExtS.firstn) d ctxt) in
      Term.it_mkLambda_or_LetIn t ctxt'
    end
  end.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="retroknowledge" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>retroknowledge.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Arnaud Spiwack, May 2007 *)
(* Addition of native Head (nb of heading 0) and Tail (nb of trailing 0) by
   Benjamin Gr√©goire, Jun 2007 *)

(* This file defines the knowledge that the kernel is able to optimize. *)

open Names

type retroknowledge = {
    retro_int63 : Constant.t option;
    retro_bool : (constructor * constructor) option; (* true, false *)
    retro_carry : (constructor * constructor) option; (* C0, C1 *)
    retro_pair : constructor option;
    retro_cmp : (constructor * constructor * constructor) option;
                    (* Eq, Lt, Gt *)
    retro_refl : constructor option;
}

let empty = {
    retro_int63 = None;
    retro_bool = None;
    retro_carry = None;
    retro_pair = None;
    retro_cmp = None;
    retro_refl = None;
}

type action =
  | Register_ind of CPrimitives.prim_ind * inductive
  | Register_type of CPrimitives.prim_type * Constant.t
</pre>
          </div>
          <div class="col-md-6">
            <code>retroknowledge.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Names.

Record retroknowledge := {
  retro_int63 : option Names.Constant.t;
  retro_bool : option (Names.constructor * Names.constructor);
  retro_carry : option (Names.constructor * Names.constructor);
  retro_pair : option Names.constructor;
  retro_cmp : option (Names.constructor * Names.constructor * Names.constructor);
  retro_refl : option Names.constructor }.

Definition empty : retroknowledge :=
  {| retro_int63 := None; retro_bool := None; retro_carry := None;
    retro_pair := None; retro_cmp := None; retro_refl := None |}.

Inductive action : Type :=
| Register_ind : CPrimitives.prim_ind -&gt; Names.inductive -&gt; action
| Register_type : CPrimitives.prim_type -&gt; Names.Constant.t -&gt; action.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="retypeops" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>retypeops.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Util
open Names
open Constr
open Declarations
open Environ
open Context

module RelDecl = Context.Rel.Declaration

let relevance_of_rel env n =
  let decl = lookup_rel n env in
  RelDecl.get_relevance decl

let relevance_of_var env x =
  let decl = lookup_named x env in
  Context.Named.Declaration.get_relevance decl

let relevance_of_constant env c =
  let decl = lookup_constant c env in
  decl.const_relevance

let relevance_of_constructor env ((mi,i),_) =
  let decl = lookup_mind mi env in
  let packet = decl.mind_packets.(i) in
  packet.mind_relevance

let relevance_of_projection env p =
  let mind = Projection.mind p in
  let mib = lookup_mind mind env in
  Declareops.relevance_of_projection_repr mib (Projection.repr p)

let rec relevance_of_rel_extra env extra n =
  match extra with
  | [] -&gt; relevance_of_rel env n
  | r :: _ when Int.equal n 1 -&gt; r
  | _ :: extra -&gt; relevance_of_rel_extra env extra (n-1)

let relevance_of_flex env extra lft = function
  | ConstKey (c,_) -&gt; relevance_of_constant env c
  | VarKey x -&gt; relevance_of_var env x
  | RelKey p -&gt; relevance_of_rel_extra env extra (Esubst.reloc_rel p lft)

let rec relevance_of_fterm env extra lft f =
  let open CClosure in
  match CClosure.relevance_of f with
  | KnownR -&gt; Sorts.Relevant
  | KnownI -&gt; Sorts.Irrelevant
  | Unknown -&gt;
    let r = match fterm_of f with
      | FRel n -&gt; relevance_of_rel_extra env extra (Esubst.reloc_rel n lft)
      | FAtom c -&gt; relevance_of_term_extra env extra lft (Esubst.subs_id 0) c
      | FFlex key -&gt; relevance_of_flex env extra lft key
      | FInt _ -&gt; Sorts.Relevant
      | FInd _ | FProd _ -&gt; Sorts.Relevant (* types are always relevant *)
      | FConstruct (c,_) -&gt; relevance_of_constructor env c
      | FApp (f, _) -&gt; relevance_of_fterm env extra lft f
      | FProj (p, _) -&gt; relevance_of_projection env p
      | FFix (((_,i),(lna,_,_)), _) -&gt; (lna.(i)).binder_relevance
      | FCoFix ((i,(lna,_,_)), _) -&gt; (lna.(i)).binder_relevance
      | FCaseT (ci, _, _, _, _) -&gt; ci.ci_relevance
      | FLambda (len, tys, bdy, e) -&gt;
        let extra = List.rev_append (List.map (fun (x,_) -&gt; binder_relevance x) tys) extra in
        let lft = Esubst.el_liftn len lft in
        let e = Esubst.subs_liftn len e in
        relevance_of_term_extra env extra lft e bdy
      | FLetIn (x, _, _, bdy, e) -&gt;
        relevance_of_term_extra env (x.binder_relevance :: extra)
          (Esubst.el_lift lft) (Esubst.subs_lift e) bdy
      | FLIFT (k, f) -&gt; relevance_of_fterm env extra (Esubst.el_shft k lft) f
      | FCLOS (c, e) -&gt; relevance_of_term_extra env extra lft e c

      | FEvar (_, _) -&gt; Sorts.Relevant (* let's assume evars are relevant for now *)
      | FLOCKED -&gt; assert false
    in
    CClosure.set_relevance r f;
    r

and relevance_of_term_extra env extra lft subs c =
  match kind c with
  | Rel n -&gt;
    (match Esubst.expand_rel n subs with
     | Inl (k, f) -&gt; relevance_of_fterm env extra (Esubst.el_liftn k lft) f
     | Inr (n, _) -&gt; relevance_of_rel_extra env extra (Esubst.reloc_rel n lft))
  | Var x -&gt; relevance_of_var env x
  | Sort _ | Ind _ | Prod _ -&gt; Sorts.Relevant (* types are always relevant *)
  | Cast (c, _, _) -&gt; relevance_of_term_extra env extra lft subs c
  | Lambda ({binder_relevance=r;_}, _, bdy) -&gt;
    relevance_of_term_extra env (r::extra) (Esubst.el_lift lft) (Esubst.subs_lift subs) bdy
  | LetIn ({binder_relevance=r;_}, _, _, bdy) -&gt;
    relevance_of_term_extra env (r::extra) (Esubst.el_lift lft) (Esubst.subs_lift subs) bdy
  | App (c, _) -&gt; relevance_of_term_extra env extra lft subs c
  | Const (c,_) -&gt; relevance_of_constant env c
  | Construct (c,_) -&gt; relevance_of_constructor env c
  | Case (ci, _, _, _) -&gt; ci.ci_relevance
  | Fix ((_,i),(lna,_,_)) -&gt; (lna.(i)).binder_relevance
  | CoFix (i,(lna,_,_)) -&gt; (lna.(i)).binder_relevance
  | Proj (p, _) -&gt; relevance_of_projection env p
  | Int _ -&gt; Sorts.Relevant

  | Meta _ | Evar _ -&gt; Sorts.Relevant (* let's assume metas and evars are relevant for now *)

let relevance_of_fterm env extra lft c =
  if Environ.sprop_allowed env then relevance_of_fterm env extra lft c
  else Sorts.Relevant

let relevance_of_term env c =
  if Environ.sprop_allowed env
  then relevance_of_term_extra env [] Esubst.el_id (Esubst.subs_id 0) c
  else Sorts.Relevant
</pre>
          </div>
          <div class="col-md-6">
            <code>retypeops.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Util.

Import Names.

Import Constr.

Import Declarations.

Import Environ.

Import Context.

Definition relevance_of_rel (env : Environ.env) (n : Z) : Sorts.relevance :=
  let decl := Environ.lookup_rel n env in
  RelDecl.get_relevance decl.

Definition relevance_of_var (env : Environ.env) (x : Names.variable)
  : Sorts.relevance :=
  let decl := Environ.lookup_named x env in
  Context.Named.Declaration.get_relevance decl.

Definition relevance_of_constant (env : Environ.env) (c : Names.Constant.t)
  : Sorts.relevance :=
  let decl := Environ.lookup_constant c env in
  const_relevance decl.

Definition relevance_of_constructor {A : Type}
  (env : Environ.env) (function_parameter : (Names.MutInd.t * Z) * A)
  : Sorts.relevance :=
  match function_parameter with
  | ((mi, i), _) =&gt;
    let decl := Environ.lookup_mind mi env in
    let packet := Util.Array.(CArray.ExtS.get) (mind_packets decl) i in
    mind_relevance packet
  end.

Definition relevance_of_projection (env : Environ.env) (p : Names.Projection.t)
  : Sorts.relevance :=
  let mind := Names.Projection.mind p in
  let mib := Environ.lookup_mind mind env in
  Declareops.relevance_of_projection_repr mib (Names.Projection.repr p).

Fixpoint relevance_of_rel_extra
  (env : Environ.env) (extra : list Sorts.relevance) (n : Int.t)
  : Sorts.relevance :=
  match extra with
  | [] =&gt; relevance_of_rel env n
  | cons _ extra =&gt; relevance_of_rel_extra env extra (Util.op_minus n 1)
  end.

Definition relevance_of_flex {A : Type}
  (env : Environ.env) (extra : list Sorts.relevance) (lft : Esubst.lift)
  (function_parameter : Names.tableKey (Names.Constant.t * A))
  : Sorts.relevance :=
  match function_parameter with
  | ConstKey (c, _) =&gt; relevance_of_constant env c
  | VarKey x =&gt; relevance_of_var env x
  | RelKey p =&gt; relevance_of_rel_extra env extra (Esubst.reloc_rel p lft)
  end.

Fixpoint relevance_of_fterm
  (env : Environ.env) (extra : list Sorts.relevance) (lft : Esubst.lift)
  (f : CClosure.fconstr) : Sorts.relevance :=
  match CClosure.relevance_of f with
  | KnownR =&gt; Sorts.Relevant
  | KnownI =&gt; Sorts.Irrelevant
  | Unknown =&gt;
    let r :=
      match CClosure.fterm_of f with
      | FRel n =&gt; relevance_of_rel_extra env extra (Esubst.reloc_rel n lft)
      | FAtom c =&gt; relevance_of_term_extra env extra lft (Esubst.subs_id 0) c
      | FFlex key =&gt; relevance_of_flex env extra lft key
      | FInt _ =&gt; Sorts.Relevant
      | FInd _ | FProd _ _ _ _ =&gt; Sorts.Relevant
      | FConstruct (c, _) =&gt; relevance_of_constructor env c
      | FApp f _ =&gt; relevance_of_fterm env extra lft f
      | FProj p _ =&gt; relevance_of_projection env p
      | FFix ((_, i), (lna, _, _)) _ =&gt;
        binder_relevance (Util.Array.(CArray.ExtS.get) lna i)
      | FCoFix (i, (lna, _, _)) _ =&gt;
        binder_relevance (Util.Array.(CArray.ExtS.get) lna i)
      | FCaseT ci _ _ _ _ =&gt; ci_relevance ci
      | FLambda len tys bdy e =&gt;
        let extra :=
          Util.List.(CList.ExtS.rev_append)
            (Util.List.(CList.ExtS.map)
              (fun function_parameter =&gt;
                match function_parameter with
                | (x, _) =&gt; Context.binder_relevance x
                end) tys) extra in
        let lft := Esubst.el_liftn len lft in
        let e := Esubst.subs_liftn len e in
        relevance_of_term_extra env extra lft e bdy
      | FLetIn x _ _ bdy e =&gt;
        relevance_of_term_extra env (cons (binder_relevance x) extra)
          (Esubst.el_lift lft) (Esubst.subs_lift e) bdy
      | FLIFT k f =&gt; relevance_of_fterm env extra (Esubst.el_shft k lft) f
      | FCLOS c e =&gt; relevance_of_term_extra env extra lft e c
      | FEvar _ _ =&gt; Sorts.Relevant
      | FLOCKED =&gt; false
      end in
    CClosure.set_relevance r f;
    r
  end

with relevance_of_term_extra
  (env : Environ.env) (extra : list Sorts.relevance) (lft : Esubst.lift)
  (subs : Esubst.subs CClosure.fconstr) (c : Constr.constr) : Sorts.relevance :=
  match Constr.kind c with
  | Rel n =&gt;
    match Esubst.expand_rel n subs with
    | Inl (k, f) =&gt; relevance_of_fterm env extra (Esubst.el_liftn k lft) f
    | Inr (n, _) =&gt; relevance_of_rel_extra env extra (Esubst.reloc_rel n lft)
    end
  | Var x =&gt; relevance_of_var env x
  | Sort _ | Ind _ | Prod _ _ _ =&gt; Sorts.Relevant
  | Cast c _ _ =&gt; relevance_of_term_extra env extra lft subs c
  | Lambda {| binder_relevance := r |} _ bdy =&gt;
    relevance_of_term_extra env (cons r extra) (Esubst.el_lift lft)
      (Esubst.subs_lift subs) bdy
  | LetIn {| binder_relevance := r |} _ _ bdy =&gt;
    relevance_of_term_extra env (cons r extra) (Esubst.el_lift lft)
      (Esubst.subs_lift subs) bdy
  | App c _ =&gt; relevance_of_term_extra env extra lft subs c
  | Const (c, _) =&gt; relevance_of_constant env c
  | Construct (c, _) =&gt; relevance_of_constructor env c
  | Case ci _ _ _ =&gt; ci_relevance ci
  | Fix ((_, i), (lna, _, _)) =&gt;
    binder_relevance (Util.Array.(CArray.ExtS.get) lna i)
  | CoFix (i, (lna, _, _)) =&gt;
    binder_relevance (Util.Array.(CArray.ExtS.get) lna i)
  | Proj p _ =&gt; relevance_of_projection env p
  | Int _ =&gt; Sorts.Relevant
  | Meta _ | Evar _ =&gt; Sorts.Relevant
  end.

Definition relevance_of_fterm
  (env : Environ.env) (extra : list Sorts.relevance) (lft : Esubst.lift)
  (c : CClosure.fconstr) : Sorts.relevance :=
  if Environ.sprop_allowed env then
    relevance_of_fterm env extra lft c
  else
    Sorts.Relevant.

Definition relevance_of_term (env : Environ.env) (c : Constr.constr)
  : Sorts.relevance :=
  if Environ.sprop_allowed env then
    relevance_of_term_extra env [] Esubst.el_id (Esubst.subs_id 0) c
  else
    Sorts.Relevant.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="safe_typing" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>safe_typing.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Jean-Christophe Filli√¢tre as part of the rebuilding of
   Coq around a purely functional abstract type-checker, Dec 1999 *)

(* This file provides the entry points to the kernel type-checker. It
   defines the abstract type of well-formed environments and
   implements the rules that build well-formed environments.

   An environment is made of constants and inductive types (E), of
   section declarations (Delta), of local bound-by-index declarations
   (Gamma) and of universe constraints (C). Below E[Delta,Gamma] |-_C
   means that the tuple E, Delta, Gamma, C is a well-formed
   environment. Main rules are:

   empty_environment:

     ------
     [,] |-

   push_named_assum(a,T):

     E[Delta,Gamma] |-_G
     ------------------------
     E[Delta,Gamma,a:T] |-_G'

   push_named_def(a,t,T):

     E[Delta,Gamma] |-_G
     ---------------------------
     E[Delta,Gamma,a:=t:T] |-_G'

   add_constant(ConstantEntry(DefinitionEntry(c,t,T))):

     E[Delta,Gamma] |-_G
     ---------------------------
     E,c:=t:T[Delta,Gamma] |-_G'

   add_constant(ConstantEntry(ParameterEntry(c,T))):

     E[Delta,Gamma] |-_G
     ------------------------
     E,c:T[Delta,Gamma] |-_G'

   add_mind(Ind(Ind[Gamma_p](Gamma_I:=Gamma_C))):

     E[Delta,Gamma] |-_G
     ------------------------
     E,Ind[Gamma_p](Gamma_I:=Gamma_C)[Delta,Gamma] |-_G'

   etc.
*)

open Util
open Names
open Declarations
open Constr
open Context.Named.Declaration

module NamedDecl = Context.Named.Declaration

(** {6 Safe environments }

  Fields of [safe_environment] :

  - [env] : the underlying environment (cf Environ)
  - [modpath] : the current module name
  - [modvariant] :
    * NONE before coqtop initialization
    * LIBRARY at toplevel of a compilation or a regular coqtop session
    * STRUCT (params,oldsenv) : inside a local module, with
      module parameters [params] and earlier environment [oldsenv]
    * SIG (params,oldsenv) : same for a local module type
  - [modresolver] : delta_resolver concerning the module content
  - [paramresolver] : delta_resolver concerning the module parameters
  - [revstruct] : current module content, most recent declarations first
  - [modlabels] and [objlabels] : names defined in the current module,
      either for modules/modtypes or for constants/inductives.
      These fields could be deduced from [revstruct], but they allow faster
      name freshness checks.
 - [univ] and [future_cst] : current and future universe constraints
 - [engagement] : are we Set-impredicative? does the universe hierarchy collapse?
 - [required] : names and digests of Require'd libraries since big-bang.
      This field will only grow
 - [loads] : list of libraries Require'd inside the current module.
      They will be propagated to the upper module level when
      the current module ends.
 - [local_retroknowledge]

*)

type vodigest =
  | Dvo_or_vi of Digest.t        (* The digest of the seg_lib part *)
  | Dvivo of Digest.t * Digest.t (* The digest of the seg_lib + seg_univ part *)

let digest_match ~actual ~required =
  match actual, required with
  | Dvo_or_vi d1, Dvo_or_vi d2
  | Dvivo (d1,_), Dvo_or_vi d2 -&gt; String.equal d1 d2
  | Dvivo (d1,e1), Dvivo (d2,e2) -&gt; String.equal d1 d2 &amp;&amp; String.equal e1 e2
  | Dvo_or_vi _, Dvivo _ -&gt; false

type library_info = DirPath.t * vodigest

(** Functor and funsig parameters, most recent first *)
type module_parameters = (MBId.t * module_type_body) list

(** Part of the safe_env at a section opening time to be backtracked *)
type section_data = {
  rev_env : Environ.env;
  rev_univ : Univ.ContextSet.t;
  rev_objlabels : Label.Set.t;
}

type safe_environment =
  { env : Environ.env;
    sections : section_data Section.t;
    modpath : ModPath.t;
    modvariant : modvariant;
    modresolver : Mod_subst.delta_resolver;
    paramresolver : Mod_subst.delta_resolver;
    revstruct : structure_body;
    modlabels : Label.Set.t;
    objlabels : Label.Set.t;
    univ : Univ.ContextSet.t;
    future_cst : Univ.ContextSet.t Future.computation list;
    engagement : engagement option;
    required : vodigest DPmap.t;
    loads : (ModPath.t * module_body) list;
    local_retroknowledge : Retroknowledge.action list;
}

and modvariant =
  | NONE
  | LIBRARY
  | SIG of module_parameters * safe_environment (** saved env *)
  | STRUCT of module_parameters * safe_environment (** saved env *)

let rec library_dp_of_senv senv =
  match senv.modvariant with
  | NONE | LIBRARY -&gt; ModPath.dp senv.modpath
  | SIG(_,senv) -&gt; library_dp_of_senv senv
  | STRUCT(_,senv) -&gt; library_dp_of_senv senv

let empty_environment =
  { env = Environ.empty_env;
    modpath = ModPath.initial;
    modvariant = NONE;
    modresolver = Mod_subst.empty_delta_resolver;
    paramresolver = Mod_subst.empty_delta_resolver;
    revstruct = [];
    modlabels = Label.Set.empty;
    objlabels = Label.Set.empty;
    sections = Section.empty;
    future_cst = [];
    univ = Univ.ContextSet.empty;
    engagement = None;
    required = DPmap.empty;
    loads = [];
    local_retroknowledge = [];
}

let is_initial senv =
  match senv.revstruct, senv.modvariant with
  | [], NONE -&gt; ModPath.equal senv.modpath ModPath.initial
  | _ -&gt; false

let sections_are_opened senv = not (Section.is_empty senv.sections)

let delta_of_senv senv = senv.modresolver,senv.paramresolver

let constant_of_delta_kn_senv senv kn =
  Mod_subst.constant_of_deltas_kn senv.paramresolver senv.modresolver kn

let mind_of_delta_kn_senv senv kn =
  Mod_subst.mind_of_deltas_kn senv.paramresolver senv.modresolver kn

(** The safe_environment state monad *)

type safe_transformer0 = safe_environment -&gt; safe_environment
type 'a safe_transformer = safe_environment -&gt; 'a * safe_environment


(** {6 Engagement } *)

let set_engagement_opt env = function
  | Some c -&gt; Environ.set_engagement c env
  | None -&gt; env

let set_engagement c senv =
  { senv with
    env = Environ.set_engagement c senv.env;
    engagement = Some c }

let set_typing_flags c senv =
  let env = Environ.set_typing_flags c senv.env in
  if env == senv.env then senv
  else { senv with env }

let set_check_guarded b senv =
  let flags = Environ.typing_flags senv.env in
  set_typing_flags { flags with check_guarded = b } senv

let set_check_positive b senv =
  let flags = Environ.typing_flags senv.env in
  set_typing_flags { flags with check_positive = b } senv

let set_check_universes b senv =
  let flags = Environ.typing_flags senv.env in
  set_typing_flags { flags with check_universes = b } senv

let set_indices_matter indices_matter senv =
  set_typing_flags { (Environ.typing_flags senv.env) with indices_matter } senv

let set_share_reduction b senv =
  let flags = Environ.typing_flags senv.env in
  set_typing_flags { flags with share_reduction = b } senv

let set_VM b senv =
  let flags = Environ.typing_flags senv.env in
  set_typing_flags { flags with enable_VM = b } senv

let set_native_compiler b senv =
  let flags = Environ.typing_flags senv.env in
  set_typing_flags { flags with enable_native_compiler = b } senv

let make_sprop_cumulative senv = { senv with env = Environ.make_sprop_cumulative senv.env }

let set_allow_sprop b senv = { senv with env = Environ.set_allow_sprop b senv.env }

(** Check that the engagement [c] expected by a library matches
    the current (initial) one *)
let check_engagement env expected_impredicative_set =
  let impredicative_set = Environ.engagement env in
  begin
    match impredicative_set, expected_impredicative_set with
    | PredicativeSet, ImpredicativeSet -&gt;
        CErrors.user_err Pp.(str &quot;Needs option -impredicative-set.&quot;)
    | _ -&gt; ()
  end

(** {6 Stm machinery } *)

type side_effect = {
  from_env : Declarations.structure_body CEphemeron.key;
  seff_constant : Constant.t;
  seff_body : Constr.t Declarations.constant_body;
}

module SideEffects :
sig
  type t
  val repr : t -&gt; side_effect list
  val empty : t
  val add : side_effect -&gt; t -&gt; t
  val concat : t -&gt; t -&gt; t
end =
struct

module SeffOrd = struct
type t = side_effect
let compare e1 e2 =
  Constant.CanOrd.compare e1.seff_constant e2.seff_constant
end

module SeffSet = Set.Make(SeffOrd)

type t = { seff : side_effect list; elts : SeffSet.t }
(** Invariant: [seff] is a permutation of the elements of [elts] *)

let repr eff = eff.seff
let empty = { seff = []; elts = SeffSet.empty }
let add x es =
  if SeffSet.mem x es.elts then es
  else { seff = x :: es.seff; elts = SeffSet.add x es.elts }
let concat xes yes =
  List.fold_right add xes.seff yes

end

type private_constants = SideEffects.t

let side_effects_of_private_constants l =
  List.rev (SideEffects.repr l)

(* Only used to push in an Environ.env. *)
let lift_constant c =
  let body = match c.const_body with
  | OpaqueDef _ -&gt; Undef None
  | Def _ | Undef _ | Primitive _ as body -&gt; body
  in
  { c with const_body = body }

let push_private_constants env eff =
  let eff = side_effects_of_private_constants eff in
  let add_if_undefined env eff =
    try ignore(Environ.lookup_constant eff.seff_constant env); env
    with Not_found -&gt; Environ.add_constant eff.seff_constant (lift_constant eff.seff_body) env
  in
  List.fold_left add_if_undefined env eff

let empty_private_constants = SideEffects.empty
let concat_private = SideEffects.concat

let universes_of_private eff =
  let fold acc eff =
    match eff.seff_body.const_universes with
    | Monomorphic ctx -&gt; Univ.ContextSet.union ctx acc
    | Polymorphic _ -&gt; acc
  in
  List.fold_left fold Univ.ContextSet.empty (side_effects_of_private_constants eff)

let env_of_safe_env senv = senv.env
let env_of_senv = env_of_safe_env

let sections_of_safe_env senv = senv.sections

type constraints_addition =
  | Now of Univ.ContextSet.t
  | Later of Univ.ContextSet.t Future.computation

let push_context_set poly cst senv =
  if Univ.ContextSet.is_empty cst then senv
  else
    let sections =
      if Section.is_empty senv.sections then senv.sections
      else Section.push_constraints cst senv.sections
    in
    { senv with
      env = Environ.push_context_set ~strict:(not poly) cst senv.env;
      univ = Univ.ContextSet.union cst senv.univ;
      sections }

let add_constraints cst senv =
  match cst with
  | Later fc -&gt; 
    {senv with future_cst = fc :: senv.future_cst}
  | Now cst -&gt;
    push_context_set false cst senv

let add_constraints_list cst senv =
  List.fold_left (fun acc c -&gt; add_constraints c acc) senv cst

let is_curmod_library senv =
  match senv.modvariant with LIBRARY -&gt; true | _ -&gt; false

let join_safe_environment ?(except=Future.UUIDSet.empty) e =
  Modops.join_structure except (Environ.opaque_tables e.env) e.revstruct;
  List.fold_left
    (fun e fc -&gt;
       if Future.UUIDSet.mem (Future.uuid fc) except then e
       else add_constraints (Now (Future.join fc)) e)
    {e with future_cst = []} e.future_cst

let is_joined_environment e = List.is_empty e.future_cst 

(** {6 Various checks } *)

let exists_modlabel l senv = Label.Set.mem l senv.modlabels
let exists_objlabel l senv = Label.Set.mem l senv.objlabels

let check_modlabel l senv =
  if exists_modlabel l senv then Modops.error_existing_label l

let check_objlabel l senv =
  if exists_objlabel l senv then Modops.error_existing_label l

let check_objlabels ls senv =
  Label.Set.iter (fun l -&gt; check_objlabel l senv) ls

(** Are we closing the right module / modtype ?
    No user error here, since the opening/ending coherence
    is now verified in [vernac_end_segment] *)

let check_current_label lab = function
  | MPdot (_,l) -&gt; assert (Label.equal lab l)
  | _ -&gt; assert false

let check_struct = function
  | STRUCT (params,oldsenv) -&gt; params, oldsenv
  | NONE | LIBRARY | SIG _ -&gt; assert false

let check_sig = function
  | SIG (params,oldsenv) -&gt; params, oldsenv
  | NONE | LIBRARY | STRUCT _ -&gt; assert false

let check_current_library dir senv = match senv.modvariant with
  | LIBRARY -&gt; assert (ModPath.equal senv.modpath (MPfile dir))
  | NONE | STRUCT _ | SIG _ -&gt; assert false (* cf Lib.end_compilation *)

(** When operating on modules, we're normally outside sections *)

let check_empty_context senv =
  assert (Environ.empty_context senv.env &amp;&amp; Section.is_empty senv.sections)

(** When adding a parameter to the current module/modtype,
    it must have been freshly started *)

let check_empty_struct senv =
  assert (List.is_empty senv.revstruct
          &amp;&amp; List.is_empty senv.loads)

(** When starting a library, the current environment should be initial
    i.e. only composed of Require's *)

let check_initial senv = assert (is_initial senv)

(** When loading a library, its dependencies should be already there,
    with the correct digests. *)

let check_required current_libs needed =
  let check (id,required) =
    try
      let actual = DPmap.find id current_libs in
      if not(digest_match ~actual ~required) then
        CErrors.user_err Pp.(pr_sequence str
          [&quot;Inconsistent assumptions over module&quot;; DirPath.to_string id; &quot;.&quot;])
    with Not_found -&gt;
      CErrors.user_err Pp.(pr_sequence str [&quot;Reference to unknown module&quot;; DirPath.to_string id; &quot;.&quot;])
  in
  Array.iter check needed


(** {6 Insertion of section variables} *)

(** They are now typed before being added to the environment.
    Same as push_named, but check that the variable is not already
    there. Should *not* be done in Environ because tactics add temporary
    hypothesis many many times, and the check performed here would
    cost too much. *)

let safe_push_named d env =
  let id = NamedDecl.get_id d in
  let _ =
    try
      let _ = Environ.lookup_named id env in
      CErrors.user_err Pp.(pr_sequence str [&quot;Identifier&quot;; Id.to_string id; &quot;already defined.&quot;])
    with Not_found -&gt; () in
  Environ.push_named d env

let push_named_def (id,de) senv =
  let sections = Section.push_local senv.sections in
  let c, r, typ = Term_typing.translate_local_def senv.env id de in
  let x = Context.make_annot id r in
  let env'' = safe_push_named (LocalDef (x, c, typ)) senv.env in
  { senv with sections; env = env'' }

let push_named_assum (x,t) senv =
  let sections = Section.push_local senv.sections in
  let t, r = Term_typing.translate_local_assum senv.env t in
  let x = Context.make_annot x r in
  let env'' = safe_push_named (LocalAssum (x,t)) senv.env in
  { senv with sections; env = env'' }

let push_section_context (nas, ctx) senv =
  let sections = Section.push_context (nas, ctx) senv.sections in
  let senv = { senv with sections } in
  let ctx = Univ.ContextSet.of_context ctx in
  (* We check that the universes are fresh. FIXME: This should be done
     implicitly, but we have to work around the API. *)
  let () = assert (Univ.LSet.for_all (fun u -&gt; not (Univ.LSet.mem u (fst senv.univ))) (fst ctx)) in
  { senv with
    env = Environ.push_context_set ~strict:false ctx senv.env;
    univ = Univ.ContextSet.union ctx senv.univ }

(** {6 Insertion of new declarations to current environment } *)

let labels_of_mib mib =
  let add,get =
    let labels = ref Label.Set.empty in
    (fun id -&gt; labels := Label.Set.add (Label.of_id id) !labels),
    (fun () -&gt; !labels)
  in
  let visit_mip mip =
    add mip.mind_typename;
    Array.iter add mip.mind_consnames
  in
  Array.iter visit_mip mib.mind_packets;
  get ()

let globalize_constant_universes cb =
  match cb.const_universes with
  | Monomorphic cstrs -&gt;
    (* Constraints hidden in the opaque body are added by [add_constant_aux] *)
    [cstrs]
  | Polymorphic _ -&gt;
    []
      
let globalize_mind_universes mb =
  match mb.mind_universes with
  | Monomorphic ctx -&gt;
    [ctx]
  | Polymorphic _ -&gt; []

let constraints_of_sfb sfb =
  match sfb with
  | SFBconst cb -&gt; globalize_constant_universes cb
  | SFBmind mib -&gt; globalize_mind_universes mib
  | SFBmodtype mtb -&gt; [mtb.mod_constraints]
  | SFBmodule mb -&gt; [mb.mod_constraints]

let add_retroknowledge pttc senv =
  { senv with
    env = Primred.add_retroknowledge senv.env pttc;
    local_retroknowledge = pttc::senv.local_retroknowledge }

(** A generic function for adding a new field in a same environment.
    It also performs the corresponding [add_constraints]. *)

type generic_name =
  | C of Constant.t
  | I of MutInd.t
  | M (** name already known, cf the mod_mp field *)
  | MT (** name already known, cf the mod_mp field *)

let add_field ?(is_include=false) ((l,sfb) as field) gn senv =
  let mlabs,olabs = match sfb with
    | SFBmind mib -&gt;
      let l = labels_of_mib mib in
      check_objlabels l senv; (Label.Set.empty,l)
    | SFBconst _ -&gt;
      check_objlabel l senv; (Label.Set.empty, Label.Set.singleton l)
    | SFBmodule _ | SFBmodtype _ -&gt;
      check_modlabel l senv; (Label.Set.singleton l, Label.Set.empty)
  in
  let senv =
    if is_include then
      (* Universes and constraints were added when the included module
         was defined eg in [Include F X.] (one of the trickier
         versions of Include) the constraints on the fields are
         exactly those of the fields of F which was defined
         separately. *)
      senv
    else
      (* Delayed constraints from opaque body are added by [add_constant_aux] *)
      let cst = constraints_of_sfb sfb in
      List.fold_left (fun senv cst -&gt; push_context_set false cst senv) senv cst
  in
  let env' = match sfb, gn with
    | SFBconst cb, C con -&gt; Environ.add_constant con cb senv.env
    | SFBmind mib, I mind -&gt; Environ.add_mind mind mib senv.env
    | SFBmodtype mtb, MT -&gt; Environ.add_modtype mtb senv.env
    | SFBmodule mb, M -&gt; Modops.add_module mb senv.env
    | _ -&gt; assert false
  in
  let sections = match sfb, gn with
  | SFBconst cb, C con -&gt;
    let poly = Declareops.constant_is_polymorphic cb in
    Section.push_constant ~poly con senv.sections
  | SFBmind mib, I mind -&gt;
    let poly = Declareops.inductive_is_polymorphic mib in
    Section.push_inductive ~poly mind senv.sections
  | _, (M | MT) -&gt; senv.sections
  | _ -&gt; assert false
  in
  { senv with
    env = env';
    sections;
    revstruct = field :: senv.revstruct;
    modlabels = Label.Set.union mlabs senv.modlabels;
    objlabels = Label.Set.union olabs senv.objlabels }

(** Applying a certain function to the resolver of a safe environment *)

let update_resolver f senv = { senv with modresolver = f senv.modresolver }

type global_declaration =
| ConstantEntry : Entries.constant_entry -&gt; global_declaration
| OpaqueEntry : private_constants Entries.const_entry_body Entries.opaque_entry -&gt; global_declaration

type exported_private_constant = Constant.t

let add_constant_aux senv (kn, cb) =
  let l = Constant.label kn in
  (* This is the only place where we hashcons the contents of a constant body *)
  let cb = if sections_are_opened senv then cb else Declareops.hcons_const_body cb in
  let senv' = add_field (l,SFBconst cb) (C kn) senv in
  let senv'' = match cb.const_body with
    | Undef (Some lev) -&gt;
      update_resolver
        (Mod_subst.add_inline_delta_resolver (Constant.user kn) (lev,None)) senv'
    | _ -&gt; senv'
  in
  senv''

let mk_pure_proof c = (c, Univ.ContextSet.empty), SideEffects.empty

let inline_side_effects env body side_eff =
  let open Constr in
  (** First step: remove the constants that are still in the environment *)
  let filter e =
    let cb = (e.seff_constant, e.seff_body) in
    try ignore (Environ.lookup_constant e.seff_constant env); None
    with Not_found -&gt; Some (cb, e.from_env)
  in
  (* CAVEAT: we assure that most recent effects come first *)
  let side_eff = List.map_filter filter (SideEffects.repr side_eff) in
  let sigs = List.rev_map (fun (_, mb) -&gt; mb) side_eff in
  let side_eff = List.fold_left (fun accu (cb, _) -&gt; cb :: accu) [] side_eff in
  let side_eff = List.rev side_eff in
  (** Most recent side-effects first in side_eff *)
  if List.is_empty side_eff then (body, Univ.ContextSet.empty, sigs)
  else
    (** Second step: compute the lifts and substitutions to apply *)
    let cname c r = Context.make_annot (Name (Label.to_id (Constant.label c))) r in
    let fold (subst, var, ctx, args) (c, cb) =
      let (b, opaque) = match cb.const_body with
      | Def b -&gt; (Mod_subst.force_constr b, false)
      | OpaqueDef b -&gt; (b, true)
      | _ -&gt; assert false
      in
      match cb.const_universes with
      | Monomorphic univs -&gt;
        (** Abstract over the term at the top of the proof *)
        let ty = cb.const_type in
        let subst = Cmap_env.add c (Inr var) subst in
        let ctx = Univ.ContextSet.union ctx univs in
        (subst, var + 1, ctx, (cname c cb.const_relevance, b, ty, opaque) :: args)
      | Polymorphic _ -&gt;
        (** Inline the term to emulate universe polymorphism *)
        let subst = Cmap_env.add c (Inl b) subst in
        (subst, var, ctx, args)
    in
    let (subst, len, ctx, args) = List.fold_left fold (Cmap_env.empty, 1, Univ.ContextSet.empty, []) side_eff in
    (** Third step: inline the definitions *)
    let rec subst_const i k t = match Constr.kind t with
    | Const (c, u) -&gt;
      let data = try Some (Cmap_env.find c subst) with Not_found -&gt; None in
      begin match data with
      | None -&gt; t
      | Some (Inl b) -&gt;
        (** [b] is closed but may refer to other constants *)
        subst_const i k (Vars.subst_instance_constr u b)
      | Some (Inr n) -&gt;
        mkRel (k + n - i)
      end
    | Rel n -&gt;
      (** Lift free rel variables *)
      if n &lt;= k then t
      else mkRel (n + len - i - 1)
    | _ -&gt; Constr.map_with_binders ((+) 1) (fun k t -&gt; subst_const i k t) k t
    in
    let map_args i (na, b, ty, opaque) =
      (** Both the type and the body may mention other constants *)
      let ty = subst_const (len - i - 1) 0 ty in
      let b = subst_const (len - i - 1) 0 b in
      (na, b, ty, opaque)
    in
    let args = List.mapi map_args args in
    let body = subst_const 0 0 body in
    let fold_arg (na, b, ty, opaque) accu =
      if opaque then mkApp (mkLambda (na, ty, accu), [|b|])
      else mkLetIn (na, b, ty, accu)
    in
    let body = List.fold_right fold_arg args body in
    (body, ctx, sigs)

let inline_private_constants env ((body, ctx), side_eff) =
  let body, ctx',_ = inline_side_effects env body side_eff in
  let ctx' = Univ.ContextSet.union ctx ctx' in
  (body, ctx')

let is_suffix l suf = match l with
| [] -&gt; false
| _ :: l -&gt; l == suf

(* Given the list of signatures of side effects, checks if they match.
 * I.e. if they are ordered descendants of the current revstruct.
   Returns the number of effects that can be trusted. *)
let check_signatures curmb sl =
  let is_direct_ancestor accu mb =
    match accu with
    | None -&gt; None
    | Some (n, curmb) -&gt;
        try
          let mb = CEphemeron.get mb in
          if is_suffix mb curmb
          then Some (n + 1, mb)
          else None
        with CEphemeron.InvalidKey -&gt; None in
  let sl = List.fold_left is_direct_ancestor (Some (0, curmb)) sl in
  match sl with
  | None -&gt; 0
  | Some (n, _) -&gt; n

type side_effect_declaration =
| DefinitionEff : Entries.definition_entry -&gt; side_effect_declaration
| OpaqueEff : Constr.constr Entries.opaque_entry -&gt; side_effect_declaration

let constant_entry_of_side_effect eff =
  let cb = eff.seff_body in
  let open Entries in
  let univs =
    match cb.const_universes with
    | Monomorphic uctx -&gt;
      Monomorphic_entry uctx
    | Polymorphic auctx -&gt;
      Polymorphic_entry (Univ.AUContext.names auctx, Univ.AUContext.repr auctx)
  in
  let p =
    match cb.const_body with
    | OpaqueDef b -&gt; b
    | Def b -&gt; Mod_subst.force_constr b
    | _ -&gt; assert false in
  if Declareops.is_opaque cb then
  OpaqueEff {
    opaque_entry_body = p;
    opaque_entry_secctx = Context.Named.to_vars cb.const_hyps;
    opaque_entry_feedback = None;
    opaque_entry_type = cb.const_type;
    opaque_entry_universes = univs;
  }
  else
  DefinitionEff {
    const_entry_body = p;
    const_entry_secctx = Some (Context.Named.to_vars cb.const_hyps);
    const_entry_feedback = None;
    const_entry_type = Some cb.const_type;
    const_entry_universes = univs;
    const_entry_inline_code = cb.const_inline_code }

let export_eff eff =
  (eff.seff_constant, eff.seff_body)

let is_empty_private = function
| Opaqueproof.PrivateMonomorphic ctx -&gt; Univ.ContextSet.is_empty ctx
| Opaqueproof.PrivatePolymorphic (_, ctx) -&gt; Univ.ContextSet.is_empty ctx

let empty_private univs = match univs with
| Monomorphic _ -&gt; Opaqueproof.PrivateMonomorphic Univ.ContextSet.empty
| Polymorphic auctx -&gt; Opaqueproof.PrivatePolymorphic (Univ.AUContext.size auctx, Univ.ContextSet.empty)

(* Special function to call when the body of an opaque definition is provided.
  It performs the type-checking of the body immediately. *)
let translate_direct_opaque env kn ce =
  let cb, ctx = Term_typing.translate_opaque env kn ce in
  let body = ce.Entries.opaque_entry_body, Univ.ContextSet.empty in
  let handle _env c () = (c, Univ.ContextSet.empty, 0) in
  let (c, u) = Term_typing.check_delayed handle ctx (body, ()) in
  (* No constraints can be generated, we set it empty everywhere *)
  let () = assert (is_empty_private u) in
  { cb with const_body = OpaqueDef c }

let export_side_effects mb env (b_ctx, eff) =
      let not_exists e =
        try ignore(Environ.lookup_constant e.seff_constant env); false
        with Not_found -&gt; true in
      let aux (acc,sl) e =
        if not (not_exists e) then acc, sl
        else e :: acc, e.from_env :: sl in
      let seff, signatures = List.fold_left aux ([],[]) (SideEffects.repr eff) in
      let trusted = check_signatures mb signatures in
      let push_seff env eff =
        let { seff_constant = kn; seff_body = cb ; _ } = eff in
        let env = Environ.add_constant kn (lift_constant cb) env in
        match cb.const_universes with
        | Polymorphic _ -&gt; env
        | Monomorphic ctx -&gt;
          Environ.push_context_set ~strict:true ctx env
      in
      let rec translate_seff sl seff acc env =
        match seff with
        | [] -&gt; List.rev acc, b_ctx
        | eff :: rest -&gt;
          if Int.equal sl 0 then
            let env, cb =
              let kn = eff.seff_constant in
              let ce = constant_entry_of_side_effect eff in
              let open Entries in
              let cb = match ce with
              | DefinitionEff ce -&gt;
                Term_typing.translate_constant env kn (DefinitionEntry ce)
              | OpaqueEff ce -&gt;
                translate_direct_opaque env kn ce
              in
               let eff = { eff with seff_body = cb } in
               (push_seff env eff, export_eff eff)
            in
            translate_seff 0 rest (cb :: acc) env
          else
           let env = push_seff env eff in
           let ecb = export_eff eff in
           translate_seff (sl - 1) rest (ecb :: acc) env
     in
       translate_seff trusted seff [] env

let push_opaque_proof pf senv =
  let o, otab = Opaqueproof.create (library_dp_of_senv senv) pf (Environ.opaque_tables senv.env) in
  let senv = { senv with env = Environ.set_opaque_tables senv.env otab } in
  senv, o

let export_private_constants ce senv =
  let exported, ce = export_side_effects senv.revstruct senv.env ce in
  let map senv (kn, c) = match c.const_body with
  | OpaqueDef p -&gt;
    let local = empty_private c.const_universes in
    let senv, o = push_opaque_proof (Future.from_val (p, local)) senv in
    senv, (kn, { c with const_body = OpaqueDef o })
  | Def _ | Undef _ | Primitive _ as body -&gt;
    senv, (kn, { c with const_body = body })
  in
  let senv, bodies = List.fold_left_map map senv exported in
  let exported = List.map (fun (kn, _) -&gt; kn) exported in
  (* No delayed constants to declare *)
  let senv = List.fold_left add_constant_aux senv bodies in
  (ce, exported), senv

let add_constant l decl senv =
  let kn = Constant.make2 senv.modpath l in
    let cb =
      match decl with
      | OpaqueEntry ce -&gt;
        let handle env body eff =
          let body, uctx, signatures = inline_side_effects env body eff in
          let trusted = check_signatures senv.revstruct signatures in
          body, uctx, trusted
        in
        let cb, ctx = Term_typing.translate_opaque senv.env kn ce in
        let map pf = Term_typing.check_delayed handle ctx pf in
        let pf = Future.chain ce.Entries.opaque_entry_body map in
        { cb with const_body = OpaqueDef pf }
      | ConstantEntry ce -&gt;
        Term_typing.translate_constant senv.env kn ce
    in
  let senv =
    let senv, cb, delayed_cst = match cb.const_body with
    | OpaqueDef fc -&gt;
      let senv, o = push_opaque_proof fc senv in
      let delayed_cst =
        if not (Declareops.constant_is_polymorphic cb) then
          let map (_, u) = match u with
          | Opaqueproof.PrivateMonomorphic ctx -&gt; ctx
          | Opaqueproof.PrivatePolymorphic _ -&gt; assert false
          in
          let fc = Future.chain fc map in
          match Future.peek_val fc with
          | None -&gt; [Later fc]
          | Some c -&gt; [Now c]
        else []
      in
      senv, { cb with const_body = OpaqueDef o }, delayed_cst
    | Undef _ | Def _ | Primitive _ as body -&gt;
      senv, { cb with const_body = body }, []
    in
    let senv = add_constant_aux senv (kn, cb) in
    add_constraints_list delayed_cst senv
  in

  let senv =
    match decl with
    | ConstantEntry (Entries.PrimitiveEntry { Entries.prim_entry_content = CPrimitives.OT_type t; _ }) -&gt;
      if sections_are_opened senv then CErrors.anomaly (Pp.str &quot;Primitive type not allowed in sections&quot;);
      add_retroknowledge (Retroknowledge.Register_type(t,kn)) senv
    | _ -&gt; senv
  in
  kn, senv

let add_private_constant l decl senv : (Constant.t * private_constants) * safe_environment =
  let kn = Constant.make2 senv.modpath l in
    let cb =
      match decl with
      | OpaqueEff ce -&gt;
        translate_direct_opaque senv.env kn ce
      | DefinitionEff ce -&gt;
        Term_typing.translate_constant senv.env kn (Entries.DefinitionEntry ce)
    in
  let senv, dcb = match cb.const_body with
  | Def _ as const_body -&gt; senv, { cb with const_body }
  | OpaqueDef c -&gt;
    let local = empty_private cb.const_universes in
    let senv, o = push_opaque_proof (Future.from_val (c, local)) senv in
    senv, { cb with const_body = OpaqueDef o }
  | Undef _ | Primitive _ -&gt; assert false
  in
  let senv = add_constant_aux senv (kn, dcb) in
  let eff =
    let from_env = CEphemeron.create senv.revstruct in
    let eff = {
      from_env = from_env;
      seff_constant = kn;
      seff_body = cb;
    } in
    SideEffects.add eff empty_private_constants
  in
  (kn, eff), senv

(** Insertion of inductive types *)

let check_mind mie lab =
  let open Entries in
  match mie.mind_entry_inds with
  | [] -&gt; assert false (* empty inductive entry *)
  | oie::_ -&gt;
    (* The label and the first inductive type name should match *)
    assert (Id.equal (Label.to_id lab) oie.mind_entry_typename)

let add_mind l mie senv =
  let () = check_mind mie l in
  let kn = MutInd.make2 senv.modpath l in
  let mib = Indtypes.check_inductive senv.env kn mie in
  let mib =
    match mib.mind_hyps with [] -&gt; Declareops.hcons_mind mib | _ -&gt; mib
  in
  kn, add_field (l,SFBmind mib) (I kn) senv

(** Insertion of module types *)

let add_modtype l params_mte inl senv =
  let mp = MPdot(senv.modpath, l) in
  let mtb = Mod_typing.translate_modtype senv.env mp inl params_mte  in
  let mtb = Declareops.hcons_module_type mtb in
  let senv' = add_field (l,SFBmodtype mtb) MT senv in
  mp, senv'

(** full_add_module adds module with universes and constraints *)

let full_add_module mb senv =
  let senv = add_constraints (Now mb.mod_constraints) senv in
  let dp = ModPath.dp mb.mod_mp in
  let linkinfo = Nativecode.link_info_of_dirpath dp in
  { senv with env = Modops.add_linked_module mb linkinfo senv.env }

let full_add_module_type mp mt senv =
  let senv = add_constraints (Now mt.mod_constraints) senv in
  { senv with env = Modops.add_module_type mp mt senv.env }

(** Insertion of modules *)

let add_module l me inl senv =
  let mp = MPdot(senv.modpath, l) in
  let mb = Mod_typing.translate_module senv.env mp inl me in
  let mb = Declareops.hcons_module_body mb in
  let senv' = add_field (l,SFBmodule mb) M senv in
  let senv'' =
    if Modops.is_functor mb.mod_type then senv'
    else update_resolver (Mod_subst.add_delta_resolver mb.mod_delta) senv'
  in
  (mp,mb.mod_delta),senv''

(** {6 Interactive sections *)

let open_section senv =
  let custom = {
    rev_env = senv.env;
    rev_univ = senv.univ;
    rev_objlabels = senv.objlabels;
  } in
  let sections = Section.open_section ~custom senv.sections in
  { senv with sections }

let close_section senv =
  let open Section in
  let sections0 = senv.sections in
  let env0 = senv.env in
  (* First phase: revert the declarations added in the section *)
  let sections, entries, cstrs, revert = Section.close_section sections0 in
  let rec pop_revstruct accu entries revstruct = match entries, revstruct with
  | [], revstruct -&gt; accu, revstruct
  | _ :: _, [] -&gt;
    CErrors.anomaly (Pp.str &quot;Unmatched section data&quot;)
  | entry :: entries, (lbl, leaf) :: revstruct -&gt;
    let data = match entry, leaf with
    | SecDefinition kn, SFBconst cb -&gt;
      let () = assert (Label.equal lbl (Constant.label kn)) in
      `Definition (kn, cb)
    | SecInductive ind, SFBmind mib -&gt;
      let () = assert (Label.equal lbl (MutInd.label ind)) in
      `Inductive (ind, mib)
    | (SecDefinition _ | SecInductive _), (SFBconst _ | SFBmind _) -&gt;
      CErrors.anomaly (Pp.str &quot;Section content mismatch&quot;)
    | (SecDefinition _ | SecInductive _), (SFBmodule _ | SFBmodtype _) -&gt;
      CErrors.anomaly (Pp.str &quot;Module inside a section&quot;)
    in
    pop_revstruct (data :: accu) entries revstruct
  in
  let redo, revstruct = pop_revstruct [] entries senv.revstruct in
  (* Don't revert the delayed constraints. If some delayed constraints were
     forced inside the section, they have been turned into global monomorphic
     that are going to be replayed. Those that are not forced are not readded
     by {!add_constant_aux}. *)
  let { rev_env = env; rev_univ = univ; rev_objlabels = objlabels } = revert in
  (* Do not revert the opaque table, the discharged opaque constants are
     referring to it. *)
  let env = Environ.set_opaque_tables env (Environ.opaque_tables senv.env) in
  let senv = { senv with env; revstruct; sections; univ; objlabels; } in
  (* Second phase: replay the discharged section contents *)
  let senv = add_constraints (Now cstrs) senv in
  let modlist = Section.replacement_context env0 sections0 in
  let cooking_info seg =
    let { abstr_ctx; abstr_subst; abstr_uctx } = seg in
    let abstract = (abstr_ctx, abstr_subst, abstr_uctx) in
    { Opaqueproof.modlist; abstract }
  in
  let fold senv = function
  | `Definition (kn, cb) -&gt;
    let info = cooking_info (Section.segment_of_constant env0 kn sections0) in
    let r = { Cooking.from = cb; info } in
    let cb = Term_typing.translate_recipe senv.env kn r in
    (* Delayed constants are already in the global environment *)
    add_constant_aux senv (kn, cb)
  | `Inductive (ind, mib) -&gt;
    let info = cooking_info (Section.segment_of_inductive env0 ind sections0) in
    let mie = Cooking.cook_inductive info mib in
    let mie = InferCumulativity.infer_inductive senv.env mie in
    let _, senv = add_mind (MutInd.label ind) mie senv in
    senv
  in
  List.fold_left fold senv redo

(** {6 Starting / ending interactive modules and module types } *)

let start_module l senv =
  let () = check_modlabel l senv in
  let () = check_empty_context senv in
  let mp = MPdot(senv.modpath, l) in
  mp,
  { empty_environment with
    env = senv.env;
    modpath = mp;
    modvariant = STRUCT ([],senv);
    required = senv.required }

let start_modtype l senv =
  let () = check_modlabel l senv in
  let () = check_empty_context senv in
  let mp = MPdot(senv.modpath, l) in
  mp,
  { empty_environment with
    env = senv.env;
    modpath = mp;
    modvariant = SIG ([], senv);
    required = senv.required }

(** Adding parameters to the current module or module type.
    This module should have been freshly started. *)

let add_module_parameter mbid mte inl senv =
  let () = check_empty_struct senv in
  let mp = MPbound mbid in
  let mtb = Mod_typing.translate_modtype senv.env mp inl ([],mte) in
  let senv = full_add_module_type mp mtb senv in
  let new_variant = match senv.modvariant with
    | STRUCT (params,oldenv) -&gt; STRUCT ((mbid,mtb) :: params, oldenv)
    | SIG (params,oldenv) -&gt; SIG ((mbid,mtb) :: params, oldenv)
    | _ -&gt; assert false
  in
  let new_paramresolver =
    if Modops.is_functor mtb.mod_type then senv.paramresolver
    else Mod_subst.add_delta_resolver mtb.mod_delta senv.paramresolver
  in
  mtb.mod_delta,
  { senv with
    modvariant = new_variant;
    paramresolver = new_paramresolver }

let functorize params init =
  List.fold_left (fun e (mbid,mt) -&gt; MoreFunctor(mbid,mt,e)) init params

let propagate_loads senv =
  List.fold_left
    (fun env (_,mb) -&gt; full_add_module mb env)
    senv
    (List.rev senv.loads)

(** Build the module body of the current module, taking in account
    a possible return type (_:T) *)

let functorize_module params mb =
  let f x = functorize params x in
  { mb with
    mod_expr = Modops.implem_smartmap f f mb.mod_expr;
    mod_type = f mb.mod_type;
    mod_type_alg = Option.map f mb.mod_type_alg }

let build_module_body params restype senv =
  let struc = NoFunctor (List.rev senv.revstruct) in
  let restype' = Option.map (fun (ty,inl) -&gt; (([],ty),inl)) restype in
  let mb =
    Mod_typing.finalize_module senv.env senv.modpath
      (struc,None,senv.modresolver,senv.univ) restype'
  in
  let mb' = functorize_module params mb in
  { mb' with mod_retroknowledge = ModBodyRK senv.local_retroknowledge }

(** Returning back to the old pre-interactive-module environment,
    with one extra component and some updated fields
    (constraints, required, etc) *)

let allow_delayed_constants = ref false

let propagate_senv newdef newenv newresolver senv oldsenv =
  let now_cst, later_cst = List.partition Future.is_val senv.future_cst in
  (* This asserts that after Paral-ITP, standard vo compilation is behaving
   * exctly as before: the same universe constraints are added to modules *)
  if not !allow_delayed_constants &amp;&amp; later_cst &lt;&gt; [] then
    CErrors.anomaly ~label:&quot;safe_typing&quot;
      Pp.(str &quot;True Future.t were created for opaque constants even if -async-proofs is off&quot;);
  { oldsenv with
    env = newenv;
    modresolver = newresolver;
    revstruct = newdef::oldsenv.revstruct;
    modlabels = Label.Set.add (fst newdef) oldsenv.modlabels;
    univ =
      List.fold_left (fun acc cst -&gt;
        Univ.ContextSet.union acc (Future.force cst))
      (Univ.ContextSet.union senv.univ oldsenv.univ)
      now_cst;
    future_cst = later_cst @ oldsenv.future_cst;
    (* engagement is propagated to the upper level *)
    engagement = senv.engagement;
    required = senv.required;
    loads = senv.loads@oldsenv.loads;
    local_retroknowledge =
      senv.local_retroknowledge@oldsenv.local_retroknowledge;
  }

let end_module l restype senv =
  let mp = senv.modpath in
  let params, oldsenv = check_struct senv.modvariant in
  let () = check_current_label l mp in
  let () = check_empty_context senv in
  let mbids = List.rev_map fst params in
  let mb = build_module_body params restype senv in
  let newenv = Environ.set_opaque_tables oldsenv.env (Environ.opaque_tables senv.env) in
  let newenv = Environ.set_native_symbols newenv senv.env.Environ.native_symbols in
  let newenv = set_engagement_opt newenv senv.engagement in
  let senv'=
    propagate_loads { senv with
      env = newenv;
      univ = Univ.ContextSet.union senv.univ mb.mod_constraints} in
  let newenv = Environ.push_context_set ~strict:true mb.mod_constraints senv'.env in
  let newenv = Modops.add_module mb newenv in
  let newresolver =
    if Modops.is_functor mb.mod_type then oldsenv.modresolver
    else Mod_subst.add_delta_resolver mb.mod_delta oldsenv.modresolver
  in
  (mp,mbids,mb.mod_delta),
  propagate_senv (l,SFBmodule mb) newenv newresolver senv' oldsenv

let build_mtb mp sign cst delta =
  { mod_mp = mp;
    mod_expr = ();
    mod_type = sign;
    mod_type_alg = None;
    mod_constraints = cst;
    mod_delta = delta;
    mod_retroknowledge = ModTypeRK }

let end_modtype l senv =
  let mp = senv.modpath in
  let params, oldsenv = check_sig senv.modvariant in
  let () = check_current_label l mp in
  let () = check_empty_context senv in
  let mbids = List.rev_map fst params in
  let newenv = Environ.set_opaque_tables oldsenv.env (Environ.opaque_tables senv.env) in
  let newenv = Environ.set_native_symbols newenv senv.env.Environ.native_symbols in
  let newenv = Environ.push_context_set ~strict:true senv.univ newenv in
  let newenv = set_engagement_opt newenv senv.engagement in
  let senv' = propagate_loads {senv with env=newenv} in
  let auto_tb = functorize params (NoFunctor (List.rev senv.revstruct)) in
  let mtb = build_mtb mp auto_tb senv'.univ senv.modresolver in
  let newenv = Environ.add_modtype mtb senv'.env in
  let newresolver = oldsenv.modresolver in
  (mp,mbids),
  propagate_senv (l,SFBmodtype mtb) newenv newresolver senv' oldsenv

(** {6 Inclusion of module or module type } *)

let add_include me is_module inl senv =
  let open Mod_typing in
  let mp_sup = senv.modpath in
  let sign,(),resolver,cst =
    translate_mse_incl is_module senv.env mp_sup inl me
  in
  let senv = add_constraints (Now cst) senv in
  (* Include Self support  *)
  let rec compute_sign sign mb resolver senv =
    match sign with
    | MoreFunctor(mbid,mtb,str) -&gt;
      let cst_sub = Subtyping.check_subtypes senv.env mb mtb in
      let senv =
	add_constraints
          (Now (Univ.ContextSet.add_constraints cst_sub Univ.ContextSet.empty))
	  senv in
      let mpsup_delta =
	Modops.inline_delta_resolver senv.env inl mp_sup mbid mtb mb.mod_delta
      in
      let subst = Mod_subst.map_mbid mbid mp_sup mpsup_delta in
      let resolver = Mod_subst.subst_codom_delta_resolver subst resolver in
      compute_sign (Modops.subst_signature subst str) mb resolver senv
    | NoFunctor str -&gt; resolver,str,senv
  in
  let resolver,str,senv =
    let struc = NoFunctor (List.rev senv.revstruct) in
    let mtb = build_mtb mp_sup struc Univ.ContextSet.empty senv.modresolver in
    compute_sign sign mtb resolver senv
  in
  let senv = update_resolver (Mod_subst.add_delta_resolver resolver) senv
  in
  let add senv ((l,elem) as field) =
    let new_name = match elem with
      | SFBconst _ -&gt;
        C (Mod_subst.constant_of_delta_kn resolver (KerName.make mp_sup l))
      | SFBmind _ -&gt;
        I (Mod_subst.mind_of_delta_kn resolver (KerName.make mp_sup l))
      | SFBmodule _ -&gt; M
      | SFBmodtype _ -&gt; MT
    in
    add_field ~is_include:true field new_name senv
  in
  resolver, List.fold_left add senv str

(** {6 Libraries, i.e. compiled modules } *)

type compiled_library = {
  comp_name : DirPath.t;
  comp_mod : module_body;
  comp_deps : library_info array;
  comp_enga : engagement;
  comp_natsymbs : Nativevalues.symbols
}

let module_of_library lib = lib.comp_mod

type native_library = Nativecode.global list

(** FIXME: MS: remove?*)
let current_modpath senv = senv.modpath
let current_dirpath senv = Names.ModPath.dp (current_modpath senv)

let start_library dir senv =
  check_initial senv;
  assert (not (DirPath.is_empty dir));
  let mp = MPfile dir in
  mp,
  { empty_environment with
    env = senv.env;
    modpath = mp;
    modvariant = LIBRARY;
    required = senv.required }

let export ?except ~output_native_objects senv dir =
  let senv =
    try join_safe_environment ?except senv
    with e -&gt;
      let e = CErrors.push e in
      CErrors.user_err ~hdr:&quot;export&quot; (CErrors.iprint e)
  in
  assert(senv.future_cst = []);
  let () = check_current_library dir senv in
  let mp = senv.modpath in
  let str = NoFunctor (List.rev senv.revstruct) in
  let mb =
    { mod_mp = mp;
      mod_expr = FullStruct;
      mod_type = str;
      mod_type_alg = None;
      mod_constraints = senv.univ;
      mod_delta = senv.modresolver;
      mod_retroknowledge = ModBodyRK senv.local_retroknowledge
    }
  in
  let ast, symbols =
    if output_native_objects then
      Nativelibrary.dump_library mp dir senv.env str
    else [], Nativevalues.empty_symbols
  in
  let lib = {
    comp_name = dir;
    comp_mod = mb;
    comp_deps = Array.of_list (DPmap.bindings senv.required);
    comp_enga = Environ.engagement senv.env;
    comp_natsymbs = symbols }
  in
  mp, lib, ast

(* cst are the constraints that were computed by the vi2vo step and hence are
 * not part of the mb.mod_constraints field (but morally should be) *)
let import lib cst vodigest senv =
  check_required senv.required lib.comp_deps;
  check_engagement senv.env lib.comp_enga;
  if DirPath.equal (ModPath.dp senv.modpath) lib.comp_name then
    CErrors.user_err ~hdr:&quot;Safe_typing.import&quot;
     (Pp.strbrk &quot;Cannot load a library with the same name as the current one.&quot;);
  let mp = MPfile lib.comp_name in
  let mb = lib.comp_mod in
  let env = Environ.push_context_set ~strict:true
				     (Univ.ContextSet.union mb.mod_constraints cst)
				     senv.env
  in
  let env =
    let linkinfo = Nativecode.link_info_of_dirpath lib.comp_name in
    Modops.add_linked_module mb linkinfo env
  in
  let env = Environ.add_native_symbols lib.comp_name lib.comp_natsymbs env in
  mp,
  { senv with
    env;
    modresolver = Mod_subst.add_delta_resolver mb.mod_delta senv.modresolver;
    required = DPmap.add lib.comp_name vodigest senv.required;
    loads = (mp,mb)::senv.loads;
  }

(** {6 Safe typing } *)

type judgment = Environ.unsafe_judgment

let j_val j = j.Environ.uj_val
let j_type j = j.Environ.uj_type

let typing senv = Typeops.infer (env_of_senv senv)

(** {6 Retroknowledge / native compiler } *)

let register_inline kn senv =
  let open Environ in
  if not (evaluable_constant kn senv.env) then
    CErrors.user_err Pp.(str &quot;Register inline: an evaluable constant is expected&quot;);
  let env = senv.env in
  let cb = lookup_constant kn env in
  let cb = {cb with const_inline_code = true} in
  let env = add_constant kn cb env in { senv with env}

let check_register_ind ind r env =
  let (mb,ob as spec) = Inductive.lookup_mind_specif env ind in
  let check_if b msg =
    if not b then
      CErrors.user_err ~hdr:&quot;check_register_ind&quot; msg in
  check_if (Int.equal (Array.length mb.mind_packets) 1) Pp.(str &quot;A non mutual inductive is expected&quot;);
  let is_monomorphic = function Monomorphic _ -&gt; true | Polymorphic _ -&gt; false in
  check_if (is_monomorphic mb.mind_universes) Pp.(str &quot;A universe monomorphic inductive type is expected&quot;);
  check_if (not @@ Inductive.is_private spec) Pp.(str &quot;A non-private inductive type is expected&quot;);
  let check_nparams n =
    check_if (Int.equal mb.mind_nparams n) Pp.(str &quot;An inductive type with &quot; ++ int n ++ str &quot; parameters is expected&quot;)
  in
  let check_nconstr n =
    check_if (Int.equal (Array.length ob.mind_consnames) n)
      Pp.(str &quot;an inductive type with &quot; ++ int n ++ str &quot; constructors is expected&quot;)
  in
  let check_name pos s =
    check_if (Id.equal ob.mind_consnames.(pos) (Id.of_string s))
      Pp.(str&quot;the &quot; ++ int (pos + 1) ++ str
       &quot;th constructor does not have the expected name: &quot; ++ str s) in
  let check_type pos t =
    check_if (Constr.equal t ob.mind_user_lc.(pos))
      Pp.(str&quot;the &quot; ++ int (pos + 1) ++ str
       &quot;th constructor does not have the expected type&quot;) in
  let check_type_cte pos = check_type pos (Constr.mkRel 1) in
  match r with
  | CPrimitives.PIT_bool -&gt;
    check_nparams 0;
    check_nconstr 2;
    check_name 0 &quot;true&quot;;
    check_type_cte 0;
    check_name 1 &quot;false&quot;;
    check_type_cte 1
  | CPrimitives.PIT_carry -&gt;
    check_nparams 1;
    check_nconstr 2;
    let test_type pos =
      let c = ob.mind_user_lc.(pos) in
      let s = Pp.(str&quot;the &quot; ++ int (pos + 1) ++ str
              &quot;th constructor does not have the expected type&quot;) in
      check_if (Constr.isProd c) s;
      let (_,d,cd) = Constr.destProd c in
      check_if (Constr.is_Type d) s;
      check_if
        (Constr.equal
                (mkProd (Context.anonR,mkRel 1, mkApp (mkRel 3,[|mkRel 2|])))
                cd)
        s in
    check_name 0 &quot;C0&quot;;
    test_type 0;
    check_name 1 &quot;C1&quot;;
    test_type 1;
  | CPrimitives.PIT_pair -&gt;
    check_nparams 2;
    check_nconstr 1;
    check_name 0 &quot;pair&quot;;
    let c = ob.mind_user_lc.(0) in
    let s =  Pp.str &quot;the constructor does not have the expected type&quot; in
    begin match Term.decompose_prod c with
      | ([_,b;_,a;_,_B;_,_A], codom) -&gt;
        check_if (is_Type _A) s;
        check_if (is_Type _B) s;
        check_if (Constr.equal a (mkRel 2)) s;
        check_if (Constr.equal b (mkRel 2)) s;
        check_if (Constr.equal codom (mkApp (mkRel 5,[|mkRel 4; mkRel 3|]))) s
      | _ -&gt; check_if false s
    end
  | CPrimitives.PIT_cmp -&gt;
    check_nparams 0;
    check_nconstr 3;
    check_name 0 &quot;Eq&quot;;
    check_type_cte 0;
    check_name 1 &quot;Lt&quot;;
    check_type_cte 1;
    check_name 2 &quot;Gt&quot;;
    check_type_cte 2

let register_inductive ind prim senv =
  check_register_ind ind prim senv.env;
  let action = Retroknowledge.Register_ind(prim,ind) in
  add_retroknowledge action senv

let add_constraints c =
  add_constraints
    (Now (Univ.ContextSet.add_constraints c Univ.ContextSet.empty))


(* NB: The next old comment probably refers to [propagate_loads] above.
   When a Require is done inside a module, we'll redo this require
   at the upper level after the module is ended, and so on.
   This is probably not a big deal anyway, since these Require's
   inside modules should be pretty rare. Maybe someday we could
   brutally forbid this tricky &quot;feature&quot;... *)

(* we have an inefficiency: Since loaded files are added to the
environment every time a module is closed, their components are
calculated many times. This could be avoided in several ways:

1 - for each file create a dummy environment containing only this
file's components, merge this environment with the global
environment, and store for the future (instead of just its type)

2 - create &quot;persistent modules&quot; environment table in Environ add put
loaded by side-effect once and for all (like it is done in OCaml).
Would this be correct with respect to undo's and stuff ?
*)

let set_strategy k l e = { e with env =
   (Environ.set_oracle e.env
      (Conv_oracle.set_strategy (Environ.oracle e.env) k l)) }
</pre>
          </div>
          <div class="col-md-6">
            <code>safe_typing.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Util.

Import Names.

Import Declarations.

Import Constr.

Import Context.Named.Declaration.

Inductive vodigest : Type :=
| Dvo_or_vi : Stdlib.Digest.t -&gt; vodigest
| Dvivo : Stdlib.Digest.t -&gt; Stdlib.Digest.t -&gt; vodigest.

Definition digest_match (actual : vodigest) (required : vodigest) : bool :=
  match (actual, required) with
  | (Dvo_or_vi d1, Dvo_or_vi d2) | (Dvivo d1 _, Dvo_or_vi d2) =&gt;
    Util.String.(CString.ExtS.equal) d1 d2
  | (Dvivo d1 e1, Dvivo d2 e2) =&gt;
    andb (Util.String.(CString.ExtS.equal) d1 d2)
      (Util.String.(CString.ExtS.equal) e1 e2)
  | (Dvo_or_vi _, Dvivo _ _) =&gt; false
  end.

Definition library_info := Names.DirPath.t * vodigest.

Definition module_parameters :=
  list (Names.MBId.t * Declarations.module_type_body).

Record section_data := {
  rev_env : Environ.env;
  rev_univ : Univ.ContextSet.t;
  rev_objlabels : Names.Label.Set.t }.

Inductive modvariant : Type :=
| NONE : modvariant
| LIBRARY : modvariant
| SIG : module_parameters -&gt; safe_environment -&gt; modvariant
| STRUCT : module_parameters -&gt; safe_environment -&gt; modvariant.

Fixpoint library_dp_of_senv (senv : safe_environment) : Names.DirPath.t :=
  match modvariant senv with
  | NONE | LIBRARY =&gt; Names.ModPath.dp (modpath senv)
  | SIG _ senv =&gt; library_dp_of_senv senv
  | STRUCT _ senv =&gt; library_dp_of_senv senv
  end.

Definition empty_environment : safe_environment :=
  {| env := Environ.empty_env; sections := Section.empty;
    modpath := Names.ModPath.initial; modvariant := NONE;
    modresolver := Mod_subst.empty_delta_resolver;
    paramresolver := Mod_subst.empty_delta_resolver; revstruct := [];
    modlabels := Names.Label.Set.empty; objlabels := Names.Label.Set.empty;
    univ := Univ.ContextSet.empty; future_cst := []; engagement := None;
    required := Names.DPmap.empty; loads := []; local_retroknowledge := [] |}.

Definition is_initial (senv : safe_environment) : bool :=
  match ((revstruct senv), (modvariant senv)) with
  | ([], NONE) =&gt; Names.ModPath.equal (modpath senv) Names.ModPath.initial
  | _ =&gt; false
  end.

Definition sections_are_opened (senv : safe_environment) : bool :=
  negb (Section.is_empty (sections senv)).

Definition delta_of_senv (senv : safe_environment)
  : Mod_subst.delta_resolver * Mod_subst.delta_resolver :=
  ((modresolver senv), (paramresolver senv)).

Definition constant_of_delta_kn_senv
  (senv : safe_environment) (kn : Names.KerName.t) : Names.Constant.t :=
  Mod_subst.constant_of_deltas_kn (paramresolver senv) (modresolver senv) kn.

Definition mind_of_delta_kn_senv
  (senv : safe_environment) (kn : Names.KerName.t) : Names.MutInd.t :=
  Mod_subst.mind_of_deltas_kn (paramresolver senv) (modresolver senv) kn.

Definition safe_transformer0 := safe_environment -&gt; safe_environment.

Definition safe_transformer (a : Type) :=
  safe_environment -&gt; a * safe_environment.

Definition set_engagement_opt
  (env : Environ.env) (function_parameter : option Declarations.engagement)
  : Environ.env :=
  match function_parameter with
  | Some c =&gt; Environ.set_engagement c env
  | None =&gt; env
  end.

Definition set_engagement
  (c : Declarations.engagement) (senv : safe_environment) : safe_environment :=
  record.

Definition set_typing_flags
  (c : Declarations.typing_flags) (senv : safe_environment)
  : safe_environment :=
  let env := Environ.set_typing_flags c (env senv) in
  if Stdlib.op_eq_eq env (env senv) then
    senv
  else
    record.

Definition set_check_guarded (b : bool) (senv : safe_environment)
  : safe_environment :=
  let flags := Environ.typing_flags (env senv) in
  set_typing_flags record senv.

Definition set_check_positive (b : bool) (senv : safe_environment)
  : safe_environment :=
  let flags := Environ.typing_flags (env senv) in
  set_typing_flags record senv.

Definition set_check_universes (b : bool) (senv : safe_environment)
  : safe_environment :=
  let flags := Environ.typing_flags (env senv) in
  set_typing_flags record senv.

Definition set_indices_matter (indices_matter : bool) (senv : safe_environment)
  : safe_environment := set_typing_flags record senv.

Definition set_share_reduction (b : bool) (senv : safe_environment)
  : safe_environment :=
  let flags := Environ.typing_flags (env senv) in
  set_typing_flags record senv.

Definition set_VM (b : bool) (senv : safe_environment) : safe_environment :=
  let flags := Environ.typing_flags (env senv) in
  set_typing_flags record senv.

Definition set_native_compiler (b : bool) (senv : safe_environment)
  : safe_environment :=
  let flags := Environ.typing_flags (env senv) in
  set_typing_flags record senv.

Definition make_sprop_cumulative (senv : safe_environment) : safe_environment :=
  record.

Definition set_allow_sprop (b : bool) (senv : safe_environment)
  : safe_environment := record.

Definition check_engagement
  (env : Environ.env)
  (expected_impredicative_set : Declarations.set_predicativity) : unit :=
  let impredicative_set := Environ.engagement env in
  match (impredicative_set, expected_impredicative_set) with
  | (PredicativeSet, ImpredicativeSet) =&gt;
    CErrors.user_err None None
      (Pp.str &quot;Needs option -impredicative-set.&quot; % string)
  | _ =&gt; tt
  end.

Record side_effect := {
  from_env : CEphemeron.key Declarations.structure_body;
  seff_constant : Names.Constant.t;
  seff_body : Declarations.constant_body Constr.t }.

Module SideEffects.
  Module SeffOrd.
    Definition t := side_effect.
    
    Definition compare (e1 : side_effect) (e2 : side_effect) : Z :=
      Names.Constant.CanOrd.compare (seff_constant e1) (seff_constant e2).
  End SeffOrd.
  
  Record t := {
    seff : list side_effect;
    elts : SeffSet.t }.
  
  Definition repr (eff : t) : list side_effect := seff eff.
  
  Definition empty : t := {| seff := []; elts := SeffSet.empty |}.
  
  Definition add (x : SeffSet.elt) (es : t) : t :=
    if SeffSet.mem x (elts es) then
      es
    else
      {| seff := cons x (seff es); elts := SeffSet.add x (elts es) |}.
  
  Definition concat (xes : t) (yes : t) : t :=
    Util.List.(CList.ExtS.fold_right) add (seff xes) yes.
End SideEffects.

Definition private_constants := SideEffects.t.

Definition side_effects_of_private_constants (l : SideEffects.t)
  : list side_effect := Util.List.(CList.ExtS.rev) (SideEffects.repr l).

Definition lift_constant {A B : Type} (c : Declarations.constant_body A)
  : Declarations.constant_body B :=
  let body :=
    match const_body c with
    | OpaqueDef _ =&gt; Undef None
    | (Def _ | Undef _ | Primitive _) as body =&gt; body
    end in
  record.

Definition push_private_constants (env : Environ.env) (eff : SideEffects.t)
  : Environ.env :=
  let eff := side_effects_of_private_constants eff in
  let add_if_undefined (env : Environ.env) (eff : side_effect) : Environ.env :=
    try in
  Util.List.(CList.ExtS.fold_left) add_if_undefined env eff.

Definition empty_private_constants : SideEffects.t := SideEffects.empty.

Definition concat_private : SideEffects.t -&gt; SideEffects.t -&gt; SideEffects.t :=
  SideEffects.concat.

Definition universes_of_private (eff : SideEffects.t) : Univ.ContextSet.t :=
  let fold (acc : Univ.ContextSet.t) (eff : side_effect) : Univ.ContextSet.t :=
    match const_universes (seff_body eff) with
    | Monomorphic ctx =&gt; Univ.ContextSet.union ctx acc
    | Polymorphic _ =&gt; acc
    end in
  Util.List.(CList.ExtS.fold_left) fold Univ.ContextSet.empty
    (side_effects_of_private_constants eff).

Definition env_of_safe_env (senv : safe_environment) : Environ.env := env senv.

Definition env_of_senv : safe_environment -&gt; Environ.env := env_of_safe_env.

Definition sections_of_safe_env (senv : safe_environment)
  : Section.t section_data := sections senv.

Inductive constraints_addition : Type :=
| Now : Univ.ContextSet.t -&gt; constraints_addition
| Later : (Future.computation Univ.ContextSet.t) -&gt; constraints_addition.

Definition push_context_set
  (poly : bool) (cst : Univ.ContextSet.t) (senv : safe_environment)
  : safe_environment :=
  if Univ.ContextSet.is_empty cst then
    senv
  else
    let sections :=
      if Section.is_empty (sections senv) then
        sections senv
      else
        Section.push_constraints cst (sections senv) in
    record.

Definition add_constraints
  (cst : constraints_addition) (senv : safe_environment) : safe_environment :=
  match cst with
  | Later fc =&gt; record
  | Now cst =&gt; push_context_set false cst senv
  end.

Definition add_constraints_list
  (cst : list constraints_addition) (senv : safe_environment)
  : safe_environment :=
  Util.List.(CList.ExtS.fold_left) (fun acc =&gt; fun c =&gt; add_constraints c acc)
    senv cst.

Definition is_curmod_library (senv : safe_environment) : bool :=
  match modvariant senv with
  | LIBRARY =&gt; true
  | _ =&gt; false
  end.

Definition join_safe_environment (op_star_o_p_t_star : option Future.UUIDSet.t)
  : safe_environment -&gt; safe_environment :=
  let except :=
    match op_star_o_p_t_star with
    | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
    | None =&gt; Future.UUIDSet.empty
    end in
  fun e =&gt;
    Modops.join_structure except (Environ.opaque_tables (env e)) (revstruct e);
    Util.List.(CList.ExtS.fold_left)
      (fun e =&gt;
        fun fc =&gt;
          if Future.UUIDSet.mem (Future.uuid fc) except then
            e
          else
            add_constraints (Now (Future.join fc)) e) record (future_cst e).

Definition is_joined_environment (e : safe_environment) : bool :=
  Util.List.(CList.ExtS.is_empty) (future_cst e).

Definition exists_modlabel (l : Names.Label.Set.elt) (senv : safe_environment)
  : bool := Names.Label.Set.mem l (modlabels senv).

Definition exists_objlabel (l : Names.Label.Set.elt) (senv : safe_environment)
  : bool := Names.Label.Set.mem l (objlabels senv).

Definition check_modlabel (l : Names.Label.Set.elt) (senv : safe_environment)
  : unit :=
  if exists_modlabel l senv then
    Modops.error_existing_label l
  else
    tt.

Definition check_objlabel (l : Names.Label.Set.elt) (senv : safe_environment)
  : unit :=
  if exists_objlabel l senv then
    Modops.error_existing_label l
  else
    tt.

Definition check_objlabels (ls : Names.Label.Set.t) (senv : safe_environment)
  : unit := Names.Label.Set.iter (fun l =&gt; check_objlabel l senv) ls.

Definition check_current_label
  (lab : Names.Label.t) (function_parameter : Names.module_path) : unit :=
  match function_parameter with
  | MPdot _ l =&gt; Names.Label.equal lab l
  | _ =&gt; false
  end.

Definition check_struct (function_parameter : modvariant)
  : module_parameters * safe_environment :=
  match function_parameter with
  | STRUCT params oldsenv =&gt; (params, oldsenv)
  | NONE | LIBRARY | SIG _ _ =&gt; false
  end.

Definition check_sig (function_parameter : modvariant)
  : module_parameters * safe_environment :=
  match function_parameter with
  | SIG params oldsenv =&gt; (params, oldsenv)
  | NONE | LIBRARY | STRUCT _ _ =&gt; false
  end.

Definition check_current_library
  (dir : Names.DirPath.t) (senv : safe_environment) : unit :=
  match modvariant senv with
  | LIBRARY =&gt; Names.ModPath.equal (modpath senv) (MPfile dir)
  | NONE | STRUCT _ _ | SIG _ _ =&gt; false
  end.

Definition check_empty_context (senv : safe_environment) : unit :=
  andb (Environ.empty_context (env senv)) (Section.is_empty (sections senv)).

Definition check_empty_struct (senv : safe_environment) : unit :=
  andb (Util.List.(CList.ExtS.is_empty) (revstruct senv))
    (Util.List.(CList.ExtS.is_empty) (loads senv)).

Definition check_initial (senv : safe_environment) : unit := is_initial senv.

Definition check_required
  (current_libs : Names.DPmap.t vodigest)
  (needed : array (Names.DPmap.key * vodigest)) : unit :=
  let check (function_parameter : Names.DPmap.key * vodigest) : unit :=
    match function_parameter with
    | (id, required) =&gt; try
    end in
  Util.Array.(CArray.ExtS.iter) check needed.

Definition safe_push_named
  (d : NamedDecl.pt Constr.constr Constr.types) (env : Environ.env)
  : Environ.env :=
  let id := NamedDecl.get_id d in
  match try with
  | _ =&gt; Environ.push_named d env
  end.

Definition push_named_def
  (function_parameter : Names.Id.t * Entries.section_def_entry)
  : safe_environment -&gt; safe_environment :=
  match function_parameter with
  | (id, de) =&gt;
    fun senv =&gt;
      let sections := Section.push_local (sections senv) in
      match Term_typing.translate_local_def (env senv) id de with
      | (c, r, typ) =&gt;
        let x := Context.make_annot id r in
        let env'' := safe_push_named (LocalDef x c typ) (env senv) in
        record
      end
  end.

Definition push_named_assum (function_parameter : Names.Id.t * Constr.types)
  : safe_environment -&gt; safe_environment :=
  match function_parameter with
  | (x, t) =&gt;
    fun senv =&gt;
      let sections := Section.push_local (sections senv) in
      match Term_typing.translate_local_assum (env senv) t with
      | (t, r) =&gt;
        let x := Context.make_annot x r in
        let env'' := safe_push_named (LocalAssum x t) (env senv) in
        record
      end
  end.

Definition push_section_context
  (function_parameter : (array Names.Name.t) * Univ.UContext.t)
  : safe_environment -&gt; safe_environment :=
  match function_parameter with
  | (nas, ctx) =&gt;
    fun senv =&gt;
      let sections := Section.push_context (nas, ctx) (sections senv) in
      let senv := record in
      let ctx := Univ.ContextSet.of_context ctx in
      match
        Univ.LSet.for_all (fun u =&gt; negb (Univ.LSet.mem u (fst (univ senv))))
          (fst ctx) with
      | tt =&gt; record
      end
  end.

Definition labels_of_mib (mib : Declarations.mutual_inductive_body)
  : Names.Label.Set.t :=
  match
    let labels := Stdlib.ref Names.Label.Set.empty in
    ((fun id =&gt;
      Stdlib.op_colon_eq labels
        (Names.Label.Set.add (Names.Label.of_id id) (Util.op_exclamation labels))),
      (fun function_parameter =&gt;
        match function_parameter with
        | tt =&gt; Util.op_exclamation labels
        end)) with
  | (add, get) =&gt;
    let visit_mip (mip : Declarations.one_inductive_body) : unit :=
      add (mind_typename mip);
      Util.Array.(CArray.ExtS.iter) add (mind_consnames mip) in
    Util.Array.(CArray.ExtS.iter) visit_mip (mind_packets mib);
    get tt
  end.

Definition globalize_constant_universes {A : Type}
  (cb : Declarations.constant_body A) : list Univ.ContextSet.t :=
  match const_universes cb with
  | Monomorphic cstrs =&gt; cons cstrs []
  | Polymorphic _ =&gt; []
  end.

Definition globalize_mind_universes (mb : Declarations.mutual_inductive_body)
  : list Univ.ContextSet.t :=
  match mind_universes mb with
  | Monomorphic ctx =&gt; cons ctx []
  | Polymorphic _ =&gt; []
  end.

Definition constraints_of_sfb (sfb : Declarations.structure_field_body)
  : list Univ.ContextSet.t :=
  match sfb with
  | SFBconst cb =&gt; globalize_constant_universes cb
  | SFBmind mib =&gt; globalize_mind_universes mib
  | SFBmodtype mtb =&gt; cons (mod_constraints mtb) []
  | SFBmodule mb =&gt; cons (mod_constraints mb) []
  end.

Definition add_retroknowledge
  (pttc : Retroknowledge.action) (senv : safe_environment) : safe_environment :=
  record.

Inductive generic_name : Type :=
| C : Names.Constant.t -&gt; generic_name
| I : Names.MutInd.t -&gt; generic_name
| M : generic_name
| MT : generic_name.

Definition add_field (op_star_o_p_t_star : option bool)
  : (Names.Label.Set.elt * Declarations.structure_field_body) -&gt;
    generic_name -&gt; safe_environment -&gt; safe_environment :=
  let is_include :=
    match op_star_o_p_t_star with
    | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
    | None =&gt; false
    end in
  fun function_parameter =&gt;
    match function_parameter with
    | (l, sfb) as field =&gt;
      fun gn =&gt;
        fun senv =&gt;
          match
            match sfb with
            | SFBmind mib =&gt;
              let l := labels_of_mib mib in
              check_objlabels l senv;
              (Names.Label.Set.empty, l)
            | SFBconst _ =&gt;
              check_objlabel l senv;
              (Names.Label.Set.empty, (Names.Label.Set.singleton l))
            | SFBmodule _ | SFBmodtype _ =&gt;
              check_modlabel l senv;
              ((Names.Label.Set.singleton l), Names.Label.Set.empty)
            end with
          | (mlabs, olabs) =&gt;
            let senv :=
              if is_include then
                senv
              else
                let cst := constraints_of_sfb sfb in
                Util.List.(CList.ExtS.fold_left)
                  (fun senv =&gt; fun cst =&gt; push_context_set false cst senv) senv
                  cst in
            let env' :=
              match (sfb, gn) with
              | (SFBconst cb, C con) =&gt; Environ.add_constant con cb (env senv)
              | (SFBmind mib, I mind) =&gt; Environ.add_mind mind mib (env senv)
              | (SFBmodtype mtb, MT) =&gt; Environ.add_modtype mtb (env senv)
              | (SFBmodule mb, M) =&gt; Modops.add_module mb (env senv)
              | _ =&gt; false
              end in
            let sections :=
              match (sfb, gn) with
              | (SFBconst cb, C con) =&gt;
                let poly := Declareops.constant_is_polymorphic cb in
                Section.push_constant poly con (sections senv)
              | (SFBmind mib, I mind) =&gt;
                let poly := Declareops.inductive_is_polymorphic mib in
                Section.push_inductive poly mind (sections senv)
              | (_, M | MT) =&gt; sections senv
              | _ =&gt; false
              end in
            record
          end
    end.

Definition update_resolver
  (f : Mod_subst.delta_resolver -&gt; Mod_subst.delta_resolver)
  (senv : safe_environment) : safe_environment := record.

Inductive global_declaration : Type :=
| ConstantEntry : Entries.constant_entry -&gt; global_declaration
| OpaqueEntry :
  (Entries.opaque_entry (Entries.const_entry_body private_constants)) -&gt;
  global_declaration.

Definition exported_private_constant := Names.Constant.t.

Definition add_constant_aux
  (senv : safe_environment)
  (function_parameter :
    Names.Constant.t * (Declarations.constant_body Opaqueproof.opaque))
  : safe_environment :=
  match function_parameter with
  | (kn, cb) =&gt;
    let l := Names.Constant.label kn in
    let cb :=
      if sections_are_opened senv then
        cb
      else
        Declareops.hcons_const_body cb in
    let senv' := add_field None (l, (SFBconst cb)) (C kn) senv in
    let senv'' :=
      match const_body cb with
      | Undef (Some lev) =&gt;
        update_resolver
          (Mod_subst.add_inline_delta_resolver (Names.Constant.user kn)
            (lev, None)) senv'
      | _ =&gt; senv'
      end in
    senv''
  end.

Definition mk_pure_proof {A : Type} (c : A)
  : (A * Univ.ContextSet.t) * SideEffects.t :=
  ((c, Univ.ContextSet.empty), SideEffects.empty).

Definition inline_side_effects
  (env : Environ.env) (body : Constr.constr) (side_eff : SideEffects.t)
  : Constr.constr * Univ.ContextSet.t *
    (list (CEphemeron.key Declarations.structure_body)) :=
  let filter (e : side_effect)
    : option
      ((Names.Constant.t * (Declarations.constant_body Constr.t)) *
        (CEphemeron.key Declarations.structure_body)) :=
    let cb := ((seff_constant e), (seff_body e)) in
    try in
  let side_eff :=
    Util.List.(CList.ExtS.map_filter) filter (SideEffects.repr side_eff) in
  let sigs :=
    Util.List.(CList.ExtS.rev_map)
      (fun function_parameter =&gt;
        match function_parameter with
        | (_, mb) =&gt; mb
        end) side_eff in
  let side_eff :=
    Util.List.(CList.ExtS.fold_left)
      (fun accu =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | (cb, _) =&gt; cons cb accu
          end) [] side_eff in
  let side_eff := Util.List.(CList.ExtS.rev) side_eff in
  if Util.List.(CList.ExtS.is_empty) side_eff then
    (body, Univ.ContextSet.empty, sigs)
  else
    let cname (c : Names.Constant.t) (r : Sorts.relevance)
      : Context.binder_annot Names.name :=
      Context.make_annot (Name (Names.Label.to_id (Names.Constant.label c))) r
      in
    let fold
      (function_parameter :
      (Names.Cmap_env.t (Util.union Constr.constr Z)) * Z * Univ.ContextSet.t *
        (list
          ((Context.binder_annot Names.name) * Constr.constr * Constr.types *
            bool)))
      : (Names.Cmap_env.key * (Declarations.constant_body Constr.constr)) -&gt;
        (Names.Cmap_env.t (Util.union Constr.constr Z)) * Z * Univ.ContextSet.t
          *
          (list
            ((Context.binder_annot Names.name) * Constr.constr * Constr.types *
              bool)) :=
      match function_parameter with
      | (subst, var, ctx, args) =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | (c, cb) =&gt;
            match
              match const_body cb with
              | Def b =&gt; ((Mod_subst.force_constr b), false)
              | OpaqueDef b =&gt; (b, true)
              | _ =&gt; false
              end with
            | (b, opaque) =&gt;
              match const_universes cb with
              | Monomorphic univs =&gt;
                let ty := const_type cb in
                let subst := Names.Cmap_env.add c (Inr var) subst in
                let ctx := Univ.ContextSet.union ctx univs in
                (subst, (Util.op_plus var 1), ctx,
                  (cons ((cname c (const_relevance cb)), b, ty, opaque) args))
              | Polymorphic _ =&gt;
                let subst := Names.Cmap_env.add c (Inl b) subst in
                (subst, var, ctx, args)
              end
            end
          end
      end in
    match
      Util.List.(CList.ExtS.fold_left) fold
        (Names.Cmap_env.empty, 1, Univ.ContextSet.empty, []) side_eff with
    | (subst, len, ctx, args) =&gt;
      let fix subst_const (i : Z) (k : Z) (t : Constr.constr) : Constr.constr :=
        match Constr.kind t with
        | Const (c, u) =&gt;
          let data := try in
          match data with
          | None =&gt; t
          | Some (Inl b) =&gt; subst_const i k (Vars.subst_instance_constr u b)
          | Some (Inr n) =&gt; Constr.mkRel (Util.op_minus (Util.op_plus k n) i)
          end
        | Rel n =&gt;
          if OCaml.Stdlib.le n k then
            t
          else
            Constr.mkRel
              (Util.op_minus (Util.op_minus (Util.op_plus n len) i) 1)
        | _ =&gt;
          Constr.map_with_binders (Util.op_plus 1)
            (fun k =&gt; fun t =&gt; subst_const i k t) k t
        end in
      let map_args {A B : Type}
        (i : Z) (function_parameter : A * Constr.constr * Constr.constr * B)
        : A * Constr.constr * Constr.constr * B :=
        match function_parameter with
        | (na, b, ty, opaque) =&gt;
          let ty := subst_const (Util.op_minus (Util.op_minus len i) 1) 0 ty in
          let b := subst_const (Util.op_minus (Util.op_minus len i) 1) 0 b in
          (na, b, ty, opaque)
        end in
      let args := Util.List.(CList.ExtS.mapi) map_args args in
      let body := subst_const 0 0 body in
      let fold_arg
        (function_parameter :
        (Context.binder_annot Names.Name.t) * Constr.constr * Constr.types *
          bool) : Constr.constr -&gt; Constr.constr :=
        match function_parameter with
        | (na, b, ty, opaque) =&gt;
          fun accu =&gt;
            if opaque then
              Constr.mkApp ((Constr.mkLambda (na, ty, accu)), (b))
            else
              Constr.mkLetIn (na, b, ty, accu)
        end in
      let body := Util.List.(CList.ExtS.fold_right) fold_arg args body in
      (body, ctx, sigs)
    end.

Definition inline_private_constants
  (env : Environ.env)
  (function_parameter : (Constr.constr * Univ.ContextSet.t) * SideEffects.t)
  : Constr.constr * Univ.ContextSet.t :=
  match function_parameter with
  | ((body, ctx), side_eff) =&gt;
    match inline_side_effects env body side_eff with
    | (body, ctx', _) =&gt;
      let ctx' := Univ.ContextSet.union ctx ctx' in
      (body, ctx')
    end
  end.

Definition is_suffix {A : Type} (l : list A) (suf : list A) : bool :=
  match l with
  | [] =&gt; false
  | cons _ l =&gt; Stdlib.op_eq_eq l suf
  end.

Definition check_signatures {A : Type}
  (curmb : list A) (sl : list (CEphemeron.key (list A))) : Z :=
  let is_direct_ancestor {B : Type}
    (accu : option (Z * (list B))) (mb : CEphemeron.key (list B))
    : option (Z * (list B)) :=
    match accu with
    | None =&gt; None
    | Some (n, curmb) =&gt; try
    end in
  let sl :=
    Util.List.(CList.ExtS.fold_left) is_direct_ancestor (Some (0, curmb)) sl in
  match sl with
  | None =&gt; 0
  | Some (n, _) =&gt; n
  end.

Inductive side_effect_declaration : Type :=
| DefinitionEff : Entries.definition_entry -&gt; side_effect_declaration
| OpaqueEff : (Entries.opaque_entry Constr.constr) -&gt; side_effect_declaration.

Definition constant_entry_of_side_effect (eff : side_effect)
  : side_effect_declaration :=
  let cb := seff_body eff in
  let univs :=
    match const_universes cb with
    | Monomorphic uctx =&gt; Monomorphic_entry uctx
    | Polymorphic auctx =&gt;
      Polymorphic_entry (Univ.AUContext.names auctx) (Univ.AUContext.repr auctx)
    end in
  let p :=
    match const_body cb with
    | OpaqueDef b =&gt; b
    | Def b =&gt; Mod_subst.force_constr b
    | _ =&gt; false
    end in
  if Declareops.is_opaque cb then
    OpaqueEff
      {| opaque_entry_body := p;
        opaque_entry_secctx := Context.Named.to_vars (const_hyps cb);
        opaque_entry_feedback := None; opaque_entry_type := const_type cb;
        opaque_entry_universes := univs |}
  else
    DefinitionEff
      {| const_entry_body := p;
        const_entry_secctx := Some (Context.Named.to_vars (const_hyps cb));
        const_entry_feedback := None; const_entry_type := Some (const_type cb);
        const_entry_universes := univs;
        const_entry_inline_code := const_inline_code cb |}.

Definition export_eff (eff : side_effect)
  : Names.Constant.t * (Declarations.constant_body Constr.t) :=
  ((seff_constant eff), (seff_body eff)).

Definition is_empty_private
  (function_parameter : Opaqueproof.delayed_universes Univ.ContextSet.t)
  : bool :=
  match function_parameter with
  | Opaqueproof.PrivateMonomorphic ctx =&gt; Univ.ContextSet.is_empty ctx
  | Opaqueproof.PrivatePolymorphic _ ctx =&gt; Univ.ContextSet.is_empty ctx
  end.

Definition empty_private (univs : Declarations.universes)
  : Opaqueproof.delayed_universes Univ.ContextSet.t :=
  match univs with
  | Monomorphic _ =&gt; Opaqueproof.PrivateMonomorphic Univ.ContextSet.empty
  | Polymorphic auctx =&gt;
    Opaqueproof.PrivatePolymorphic (Univ.AUContext.size auctx)
      Univ.ContextSet.empty
  end.

Definition translate_direct_opaque
  (env : Environ.env) (kn : Names.Constant.t)
  (ce : Entries.opaque_entry Constr.constr)
  : Declarations.constant_body Constr.t :=
  match Term_typing.translate_opaque env kn ce with
  | (cb, ctx) =&gt;
    let body := ((Entries.opaque_entry_body ce), Univ.ContextSet.empty) in
    let handle {A B : Type} (_env : A) (c : B) (function_parameter : unit)
      : B * Univ.ContextSet.t * Z :=
      match function_parameter with
      | tt =&gt; (c, Univ.ContextSet.empty, 0)
      end in
    match Term_typing.check_delayed handle ctx (body, tt) with
    | (c, u) =&gt;
      match is_empty_private u with
      | tt =&gt; record
      end
    end
  end.

Definition export_side_effects {A : Type}
  (mb : Declarations.structure_body) (env : Environ.env)
  (function_parameter : A * SideEffects.t)
  : (list (Names.Constant.t * (Declarations.constant_body Constr.t))) * A :=
  match function_parameter with
  | (b_ctx, eff) =&gt;
    let not_exists (e : side_effect) : bool :=
      try in
    let aux
      (function_parameter :
      (list side_effect) * (list (CEphemeron.key Declarations.structure_body)))
      : side_effect -&gt;
        (list side_effect) * (list (CEphemeron.key Declarations.structure_body)) :=
      match function_parameter with
      | (acc, sl) =&gt;
        fun e =&gt;
          if negb (not_exists e) then
            (acc, sl)
          else
            ((cons e acc), (cons (from_env e) sl))
      end in
    match Util.List.(CList.ExtS.fold_left) aux ([], []) (SideEffects.repr eff)
      with
    | (seff, signatures) =&gt;
      let trusted := check_signatures mb signatures in
      let push_seff (env : Environ.env) (eff : side_effect) : Environ.env :=
        match eff with
        | {| seff_constant := kn; seff_body := cb |} =&gt;
          let env := Environ.add_constant kn (lift_constant cb) env in
          match const_universes cb with
          | Polymorphic _ =&gt; env
          | Monomorphic ctx =&gt; Environ.push_context_set (Some true) ctx env
          end
        end in
      let fix translate_seff
        (sl : Int.t) (seff : list side_effect) (acc :
        list (Names.Constant.t * (Declarations.constant_body Constr.t))) (env :
        Environ.env)
        : (list (Names.Constant.t * (Declarations.constant_body Constr.t))) * A :=
        match seff with
        | [] =&gt; ((Util.List.(CList.ExtS.rev) acc), b_ctx)
        | cons eff rest =&gt;
          if Int.equal sl 0 then
            match
              let kn := seff_constant eff in
              let ce := constant_entry_of_side_effect eff in
              let cb :=
                match ce with
                | DefinitionEff ce =&gt;
                  Term_typing.translate_constant env kn (DefinitionEntry ce)
                | OpaqueEff ce =&gt; translate_direct_opaque env kn ce
                end in
              let eff := record in
              ((push_seff env eff), (export_eff eff)) with
            | (env, cb) =&gt; translate_seff 0 rest (cons cb acc) env
            end
          else
            let env := push_seff env eff in
            let ecb := export_eff eff in
            translate_seff (Util.op_minus sl 1) rest (cons ecb acc) env
        end in
      translate_seff trusted seff [] env
    end
  end.

Definition push_opaque_proof
  (pf : Opaqueproof.proofterm) (senv : safe_environment)
  : safe_environment * Opaqueproof.opaque :=
  match
    Opaqueproof.create (library_dp_of_senv senv) pf
      (Environ.opaque_tables (env senv)) with
  | (o, otab) =&gt;
    let senv := record in
    (senv, o)
  end.

Definition export_private_constants {A : Type}
  (ce : A * SideEffects.t) (senv : safe_environment)
  : (A * (list Names.Constant.t)) * safe_environment :=
  match export_side_effects (revstruct senv) (env senv) ce with
  | (exported, ce) =&gt;
    let map {B : Type}
      (senv : safe_environment) (function_parameter :
      B * (Declarations.constant_body Constr.constr))
      : safe_environment * (B * (Declarations.constant_body Opaqueproof.opaque)) :=
      match function_parameter with
      | (kn, c) =&gt;
        match const_body c with
        | OpaqueDef p =&gt;
          let local := empty_private (const_universes c) in
          match push_opaque_proof (Future.from_val None (p, local)) senv with
          | (senv, o) =&gt; (senv, (kn, record))
          end
        | (Def _ | Undef _ | Primitive _) as body =&gt; (senv, (kn, record))
        end
      end in
    match Util.List.(CList.ExtS.fold_left_map) map senv exported with
    | (senv, bodies) =&gt;
      let exported :=
        Util.List.(CList.ExtS.map)
          (fun function_parameter =&gt;
            match function_parameter with
            | (kn, _) =&gt; kn
            end) exported in
      let senv := Util.List.(CList.ExtS.fold_left) add_constant_aux senv bodies
        in
      ((ce, exported), senv)
    end
  end.

Definition add_constant
  (l : Names.Label.t) (decl : global_declaration) (senv : safe_environment)
  : Names.Constant.t * safe_environment :=
  let kn := Names.Constant.make2 (modpath senv) l in
  let cb :=
    match decl with
    | OpaqueEntry ce =&gt;
      let handle
        (env : Environ.env) (body : Constr.constr) (eff : SideEffects.t)
        : Constr.constr * Univ.ContextSet.t * Z :=
        match inline_side_effects env body eff with
        | (body, uctx, signatures) =&gt;
          let trusted := check_signatures (revstruct senv) signatures in
          (body, uctx, trusted)
        end in
      match Term_typing.translate_opaque (env senv) kn ce with
      | (cb, ctx) =&gt;
        let map (pf : Entries.proof_output SideEffects.t)
          : Constr.t * (Opaqueproof.delayed_universes Univ.ContextSet.t) :=
          Term_typing.check_delayed handle ctx pf in
        let pf := Future.chain (Entries.opaque_entry_body ce) map in
        record
      end
    | ConstantEntry ce =&gt; Term_typing.translate_constant (env senv) kn ce
    end in
  let senv :=
    match
      match const_body cb with
      | OpaqueDef fc =&gt;
        match push_opaque_proof fc senv with
        | (senv, o) =&gt;
          let delayed_cst :=
            if negb (Declareops.constant_is_polymorphic cb) then
              let map {A B : Type}
                (function_parameter : A * (Opaqueproof.delayed_universes B))
                : B :=
                match function_parameter with
                | (_, u) =&gt;
                  match u with
                  | Opaqueproof.PrivateMonomorphic ctx =&gt; ctx
                  | Opaqueproof.PrivatePolymorphic _ _ =&gt; false
                  end
                end in
              let fc := Future.chain fc map in
              match Future.peek_val fc with
              | None =&gt; cons (Later fc) []
              | Some c =&gt; cons (Now c) []
              end
            else
              [] in
          (senv, record, delayed_cst)
        end
      | (Undef _ | Def _ | Primitive _) as body =&gt; (senv, record, [])
      end with
    | (senv, cb, delayed_cst) =&gt;
      let senv := add_constant_aux senv (kn, cb) in
      add_constraints_list delayed_cst senv
    end in
  let senv :=
    match decl with
    |
      ConstantEntry
        (Entries.PrimitiveEntry {|
          Entries.prim_entry_content := CPrimitives.OT_type t |}) =&gt;
      if sections_are_opened senv then
        CErrors.anomaly None None
          (Pp.str &quot;Primitive type not allowed in sections&quot; % string)
      else
        tt;
      add_retroknowledge (Retroknowledge.Register_type t kn) senv
    | _ =&gt; senv
    end in
  (kn, senv).

Definition add_private_constant
  (l : Names.Label.t) (decl : side_effect_declaration) (senv : safe_environment)
  : (Names.Constant.t * private_constants) * safe_environment :=
  let kn := Names.Constant.make2 (modpath senv) l in
  let cb :=
    match decl with
    | OpaqueEff ce =&gt; translate_direct_opaque (env senv) kn ce
    | DefinitionEff ce =&gt;
      Term_typing.translate_constant (env senv) kn (Entries.DefinitionEntry ce)
    end in
  match
    match const_body cb with
    | (Def _) as const_body =&gt; (senv, record)
    | OpaqueDef c =&gt;
      let local := empty_private (const_universes cb) in
      match push_opaque_proof (Future.from_val None (c, local)) senv with
      | (senv, o) =&gt; (senv, record)
      end
    | Undef _ | Primitive _ =&gt; false
    end with
  | (senv, dcb) =&gt;
    let senv := add_constant_aux senv (kn, dcb) in
    let eff :=
      let from_env := CEphemeron.create (revstruct senv) in
      let eff :=
        {| from_env := from_env; seff_constant := kn; seff_body := cb |} in
      SideEffects.add eff empty_private_constants in
    ((kn, eff), senv)
  end.

Definition check_mind
  (mie : Entries.mutual_inductive_entry) (lab : Names.Label.t) : unit :=
  match mind_entry_inds mie with
  | [] =&gt; false
  | cons oie _ =&gt;
    Names.Id.equal (Names.Label.to_id lab) (mind_entry_typename oie)
  end.

Definition add_mind
  (l : Names.Label.t) (mie : Entries.mutual_inductive_entry)
  (senv : safe_environment) : Names.MutInd.t * safe_environment :=
  match check_mind mie l with
  | tt =&gt;
    let kn := Names.MutInd.make2 (modpath senv) l in
    let mib := Indtypes.check_inductive (env senv) kn mie in
    let mib :=
      match mind_hyps mib with
      | [] =&gt; Declareops.hcons_mind mib
      | _ =&gt; mib
      end in
    (kn, (add_field None (l, (SFBmind mib)) (I kn) senv))
  end.

Definition add_modtype
  (l : Names.Label.Set.elt) (params_mte : Entries.module_type_entry)
  (inl : Entries.inline) (senv : safe_environment)
  : Names.module_path * safe_environment :=
  let mp := MPdot (modpath senv) l in
  let mtb := Mod_typing.translate_modtype (env senv) mp inl params_mte in
  let mtb := Declareops.hcons_module_type mtb in
  let senv' := add_field None (l, (SFBmodtype mtb)) MT senv in
  (mp, senv').

Definition full_add_module
  (mb : Declarations.module_body) (senv : safe_environment)
  : safe_environment :=
  let senv := add_constraints (Now (mod_constraints mb)) senv in
  let dp := Names.ModPath.dp (mod_mp mb) in
  let linkinfo := Nativecode.link_info_of_dirpath dp in
  record.

Definition full_add_module_type
  (mp : Names.ModPath.t) (mt : Declarations.module_type_body)
  (senv : safe_environment) : safe_environment :=
  let senv := add_constraints (Now (mod_constraints mt)) senv in
  record.

Definition add_module
  (l : Names.Label.Set.elt) (me : Entries.module_entry) (inl : Entries.inline)
  (senv : safe_environment)
  : (Names.module_path * Mod_subst.delta_resolver) * safe_environment :=
  let mp := MPdot (modpath senv) l in
  let mb := Mod_typing.translate_module (env senv) mp inl me in
  let mb := Declareops.hcons_module_body mb in
  let senv' := add_field None (l, (SFBmodule mb)) M senv in
  let senv'' :=
    if Modops.is_functor (mod_type mb) then
      senv'
    else
      update_resolver (Mod_subst.add_delta_resolver (mod_delta mb)) senv' in
  ((mp, (mod_delta mb)), senv'').

Definition open_section (senv : safe_environment) : safe_environment :=
  let custom :=
    {| rev_env := env senv; rev_univ := univ senv;
      rev_objlabels := objlabels senv |} in
  let sections := Section.open_section custom (sections senv) in
  record.

Definition close_section (senv : safe_environment) : safe_environment :=
  let sections0 := sections senv in
  let env0 := env senv in
  match Section.close_section sections0 with
  | (sections, entries, cstrs, revert) =&gt;
    let fix pop_revstruct
      (accu : list variant) (entries : list Section.section_entry) (revstruct :
      list (Names.Label.t * Declarations.structure_field_body))
      : (list variant) *
        (list (Names.Label.t * Declarations.structure_field_body)) :=
      match (entries, revstruct) with
      | ([], revstruct) =&gt; (accu, revstruct)
      | (cons _ _, []) =&gt;
        CErrors.anomaly None None (Pp.str &quot;Unmatched section data&quot; % string)
      | (cons entry entries, cons (lbl, leaf) revstruct) =&gt;
        let data :=
          match (entry, leaf) with
          | (SecDefinition kn, SFBconst cb) =&gt;
            match Names.Label.equal lbl (Names.Constant.label kn) with
            | tt =&gt; variant
            end
          | (SecInductive ind, SFBmind mib) =&gt;
            match Names.Label.equal lbl (Names.MutInd.label ind) with
            | tt =&gt; variant
            end
          | (SecDefinition _ | SecInductive _, SFBconst _ | SFBmind _) =&gt;
            CErrors.anomaly None None
              (Pp.str &quot;Section content mismatch&quot; % string)
          | (SecDefinition _ | SecInductive _, SFBmodule _ | SFBmodtype _) =&gt;
            CErrors.anomaly None None
              (Pp.str &quot;Module inside a section&quot; % string)
          end in
        pop_revstruct (cons data accu) entries revstruct
      end in
    match pop_revstruct [] entries (revstruct senv) with
    | (redo, revstruct) =&gt;
      match revert with
      | {| rev_env := env; rev_univ := univ; rev_objlabels := objlabels |} =&gt;
        let env :=
          Environ.set_opaque_tables env (Environ.opaque_tables (env senv)) in
        let senv := record in
        let senv := add_constraints (Now cstrs) senv in
        let modlist := Section.replacement_context env0 sections0 in
        let cooking_info (seg : Section.abstr_info)
          : Opaqueproof.cooking_info :=
          match seg with
          | {|
            abstr_ctx := abstr_ctx;
              abstr_subst := abstr_subst;
              abstr_uctx := abstr_uctx
              |} =&gt;
            let abstract := (abstr_ctx, abstr_subst, abstr_uctx) in
            {| Opaqueproof.modlist := modlist; Opaqueproof.abstract := abstract
              |}
          end in
        let fold (senv : safe_environment) (function_parameter : variant)
          : safe_environment :=
          match function_parameter with
          | Definition (kn, cb) =&gt;
            let info :=
              cooking_info (Section.segment_of_constant env0 kn sections0) in
            let r := {| Cooking.from := cb; Cooking.info := info |} in
            let cb := Term_typing.translate_recipe (env senv) kn r in
            add_constant_aux senv (kn, cb)
          | Inductive (ind, mib) =&gt;
            let info :=
              cooking_info (Section.segment_of_inductive env0 ind sections0) in
            let mie := Cooking.cook_inductive info mib in
            let mie := InferCumulativity.infer_inductive (env senv) mie in
            match add_mind (Names.MutInd.label ind) mie senv with
            | (_, senv) =&gt; senv
            end
          end in
        Util.List.(CList.ExtS.fold_left) fold senv redo
      end
    end
  end.

Definition start_module (l : Names.Label.Set.elt) (senv : safe_environment)
  : Names.module_path * safe_environment :=
  match check_modlabel l senv with
  | tt =&gt;
    match check_empty_context senv with
    | tt =&gt;
      let mp := MPdot (modpath senv) l in
      (mp, record)
    end
  end.

Definition start_modtype (l : Names.Label.Set.elt) (senv : safe_environment)
  : Names.module_path * safe_environment :=
  match check_modlabel l senv with
  | tt =&gt;
    match check_empty_context senv with
    | tt =&gt;
      let mp := MPdot (modpath senv) l in
      (mp, record)
    end
  end.

Definition add_module_parameter
  (mbid : Names.MBId.t) (mte : Entries.module_struct_entry)
  (inl : Entries.inline) (senv : safe_environment)
  : Mod_subst.delta_resolver * safe_environment :=
  match check_empty_struct senv with
  | tt =&gt;
    let mp := MPbound mbid in
    let mtb := Mod_typing.translate_modtype (env senv) mp inl ([], mte) in
    let senv := full_add_module_type mp mtb senv in
    let new_variant :=
      match modvariant senv with
      | STRUCT params oldenv =&gt; STRUCT (cons (mbid, mtb) params) oldenv
      | SIG params oldenv =&gt; SIG (cons (mbid, mtb) params) oldenv
      | _ =&gt; false
      end in
    let new_paramresolver :=
      if Modops.is_functor (mod_type mtb) then
        paramresolver senv
      else
        Mod_subst.add_delta_resolver (mod_delta mtb) (paramresolver senv) in
    ((mod_delta mtb), record)
  end.

Definition functorize {A B : Type}
  (params : list (Names.MBId.t * A)) (init : Declarations.functorize A B)
  : Declarations.functorize A B :=
  Util.List.(CList.ExtS.fold_left)
    (fun e =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | (mbid, mt) =&gt; MoreFunctor mbid mt e
        end) init params.

Definition propagate_loads (senv : safe_environment) : safe_environment :=
  Util.List.(CList.ExtS.fold_left)
    (fun env =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | (_, mb) =&gt; full_add_module mb env
        end) senv (Util.List.(CList.ExtS.rev) (loads senv)).

Definition functorize_module
  (params : list (Names.MBId.t * Declarations.module_type_body))
  (mb : Declarations.generic_module_body Declarations.module_implementation)
  : Declarations.generic_module_body Declarations.module_implementation :=
  let f {A : Type} (x : Declarations.functorize Declarations.module_type_body A)
    : Declarations.functorize Declarations.module_type_body A :=
    functorize params x in
  record.

Definition build_module_body
  (params : list (Names.MBId.t * Declarations.module_type_body))
  (restype : option (Entries.module_struct_entry * Entries.inline))
  (senv : safe_environment)
  : Declarations.generic_module_body Declarations.module_implementation :=
  let struc := NoFunctor (Util.List.(CList.ExtS.rev) (revstruct senv)) in
  let restype' :=
    Option.map
      (fun function_parameter =&gt;
        match function_parameter with
        | (ty, inl) =&gt; (([], ty), inl)
        end) restype in
  let mb :=
    Mod_typing.finalize_module (env senv) (modpath senv)
      (struc, None, (modresolver senv), (univ senv)) restype' in
  let mb' := functorize_module params mb in
  record.

Definition allow_delayed_constants : Stdlib.ref bool := Stdlib.ref false.

Definition propagate_senv
  (newdef : Names.Label.Set.elt * Declarations.structure_field_body)
  (newenv : Environ.env) (newresolver : Mod_subst.delta_resolver)
  (senv : safe_environment) (oldsenv : safe_environment) : safe_environment :=
  match Util.List.(CList.ExtS.partition) Future.is_val (future_cst senv) with
  | (now_cst, later_cst) =&gt;
    if
      andb (negb (Util.op_exclamation allow_delayed_constants))
        (nequiv_decb later_cst []) then
      CErrors.anomaly None (Some &quot;safe_typing&quot; % string)
        (Pp.str
          &quot;True Future.t were created for opaque constants even if -async-proofs is off&quot;
            % string)
    else
      tt;
    record
  end.

Definition end_module
  (l : Names.Label.t)
  (restype : option (Entries.module_struct_entry * Entries.inline))
  (senv : safe_environment)
  : (Names.ModPath.t * (list Names.MBId.t) * Mod_subst.delta_resolver) *
    safe_environment :=
  let mp := modpath senv in
  match check_struct (modvariant senv) with
  | (params, oldsenv) =&gt;
    match check_current_label l mp with
    | tt =&gt;
      match check_empty_context senv with
      | tt =&gt;
        let mbids := Util.List.(CList.ExtS.rev_map) fst params in
        let mb := build_module_body params restype senv in
        let newenv :=
          Environ.set_opaque_tables (env oldsenv)
            (Environ.opaque_tables (env senv)) in
        let newenv :=
          Environ.set_native_symbols newenv (Environ.native_symbols (env senv))
          in
        let newenv := set_engagement_opt newenv (engagement senv) in
        let senv' := propagate_loads record in
        let newenv :=
          Environ.push_context_set (Some true) (mod_constraints mb) (env senv')
          in
        let newenv := Modops.add_module mb newenv in
        let newresolver :=
          if Modops.is_functor (mod_type mb) then
            modresolver oldsenv
          else
            Mod_subst.add_delta_resolver (mod_delta mb) (modresolver oldsenv) in
        ((mp, mbids, (mod_delta mb)),
          (propagate_senv (l, (SFBmodule mb)) newenv newresolver senv' oldsenv))
      end
    end
  end.

Definition build_mtb
  (mp : Names.ModPath.t) (sign : Declarations.module_signature)
  (cst : Univ.ContextSet.t) (delta : Mod_subst.delta_resolver)
  : Declarations.generic_module_body unit :=
  {| mod_mp := mp; mod_expr := tt; mod_type := sign; mod_type_alg := None;
    mod_constraints := cst; mod_delta := delta; mod_retroknowledge := ModTypeRK
    |}.

Definition end_modtype (l : Names.Label.t) (senv : safe_environment)
  : (Names.ModPath.t * (list Names.MBId.t)) * safe_environment :=
  let mp := modpath senv in
  match check_sig (modvariant senv) with
  | (params, oldsenv) =&gt;
    match check_current_label l mp with
    | tt =&gt;
      match check_empty_context senv with
      | tt =&gt;
        let mbids := Util.List.(CList.ExtS.rev_map) fst params in
        let newenv :=
          Environ.set_opaque_tables (env oldsenv)
            (Environ.opaque_tables (env senv)) in
        let newenv :=
          Environ.set_native_symbols newenv (Environ.native_symbols (env senv))
          in
        let newenv := Environ.push_context_set (Some true) (univ senv) newenv in
        let newenv := set_engagement_opt newenv (engagement senv) in
        let senv' := propagate_loads record in
        let auto_tb :=
          functorize params
            (NoFunctor (Util.List.(CList.ExtS.rev) (revstruct senv))) in
        let mtb := build_mtb mp auto_tb (univ senv') (modresolver senv) in
        let newenv := Environ.add_modtype mtb (env senv') in
        let newresolver := modresolver oldsenv in
        ((mp, mbids),
          (propagate_senv (l, (SFBmodtype mtb)) newenv newresolver senv' oldsenv))
      end
    end
  end.

Definition add_include
  (me : Entries.module_struct_entry) (is_module : bool) (inl : Entries.inline)
  (senv : safe_environment) : Mod_subst.delta_resolver * safe_environment :=
  let mp_sup := modpath senv in
  match Mod_typing.translate_mse_incl is_module (env senv) mp_sup inl me with
  | (sign, tt, resolver, cst) =&gt;
    let senv := add_constraints (Now cst) senv in
    let fix compute_sign
      (sign : Declarations.module_signature) (mb :
      Declarations.module_type_body) (resolver : Mod_subst.delta_resolver) (senv
      : safe_environment)
      : Mod_subst.delta_resolver * Declarations.structure_body *
        safe_environment :=
      match sign with
      | MoreFunctor mbid mtb str =&gt;
        let cst_sub := Subtyping.check_subtypes (env senv) mb mtb in
        let senv :=
          add_constraints
            (Now (Univ.ContextSet.add_constraints cst_sub Univ.ContextSet.empty))
            senv in
        let mpsup_delta :=
          Modops.inline_delta_resolver (env senv) inl mp_sup mbid mtb
            (mod_delta mb) in
        let subst := Mod_subst.map_mbid mbid mp_sup mpsup_delta in
        let resolver := Mod_subst.subst_codom_delta_resolver subst resolver in
        compute_sign (Modops.subst_signature subst str) mb resolver senv
      | NoFunctor str =&gt; (resolver, str, senv)
      end in
    match
      let struc := NoFunctor (Util.List.(CList.ExtS.rev) (revstruct senv)) in
      let mtb := build_mtb mp_sup struc Univ.ContextSet.empty (modresolver senv)
        in
      compute_sign sign mtb resolver senv with
    | (resolver, str, senv) =&gt;
      let senv := update_resolver (Mod_subst.add_delta_resolver resolver) senv
        in
      let add
        (senv : safe_environment) (function_parameter :
        Names.Label.Set.elt * Declarations.structure_field_body)
        : safe_environment :=
        match function_parameter with
        | (l, elem) as field =&gt;
          let new_name :=
            match elem with
            | SFBconst _ =&gt;
              C
                (Mod_subst.constant_of_delta_kn resolver
                  (Names.KerName.make mp_sup l))
            | SFBmind _ =&gt;
              I
                (Mod_subst.mind_of_delta_kn resolver
                  (Names.KerName.make mp_sup l))
            | SFBmodule _ =&gt; M
            | SFBmodtype _ =&gt; MT
            end in
          add_field (Some true) field new_name senv
        end in
      (resolver, (Util.List.(CList.ExtS.fold_left) add senv str))
    end
  end.

Record compiled_library := {
  comp_name : Names.DirPath.t;
  comp_mod : Declarations.module_body;
  comp_deps : array library_info;
  comp_enga : Declarations.engagement;
  comp_natsymbs : Nativevalues.symbols }.

Definition module_of_library (lib : compiled_library)
  : Declarations.module_body := comp_mod lib.

Definition native_library := list Nativecode.global.

Definition current_modpath (senv : safe_environment) : Names.ModPath.t :=
  modpath senv.

Definition current_dirpath (senv : safe_environment) : Names.DirPath.t :=
  Names.ModPath.dp (current_modpath senv).

Definition start_library (dir : Names.DirPath.t) (senv : safe_environment)
  : Names.module_path * safe_environment :=
  check_initial senv;
  negb (Names.DirPath.is_empty dir);
  let mp := MPfile dir in
  (mp, record).

Definition export
  (except : option Future.UUIDSet.t) (output_native_objects : bool)
  (senv : safe_environment) (dir : Names.DirPath.t)
  : Names.ModPath.t * compiled_library * (list Nativecode.global) :=
  let senv := try in
  equiv_decb (future_cst senv) [];
  match check_current_library dir senv with
  | tt =&gt;
    let mp := modpath senv in
    let str := NoFunctor (Util.List.(CList.ExtS.rev) (revstruct senv)) in
    let mb :=
      {| mod_mp := mp; mod_expr := FullStruct; mod_type := str;
        mod_type_alg := None; mod_constraints := univ senv;
        mod_delta := modresolver senv;
        mod_retroknowledge := ModBodyRK (local_retroknowledge senv) |} in
    match
      if output_native_objects then
        Nativelibrary.dump_library mp dir (env senv) str
      else
        ([], Nativevalues.empty_symbols) with
    | (ast, symbols) =&gt;
      let lib :=
        {| comp_name := dir; comp_mod := mb;
          comp_deps :=
            Util.Array.(CArray.ExtS.of_list)
              (Names.DPmap.bindings (required senv));
          comp_enga := Environ.engagement (env senv); comp_natsymbs := symbols
          |} in
      (mp, lib, ast)
    end
  end.

Definition import
  (lib : compiled_library) (cst : Univ.ContextSet.t) (vodigest : vodigest)
  (senv : safe_environment) : Names.module_path * safe_environment :=
  check_required (required senv) (comp_deps lib);
  check_engagement (env senv) (comp_enga lib);
  if Names.DirPath.equal (Names.ModPath.dp (modpath senv)) (comp_name lib) then
    CErrors.user_err None (Some &quot;Safe_typing.import&quot; % string)
      (Pp.strbrk
        &quot;Cannot load a library with the same name as the current one.&quot; % string)
  else
    tt;
  let mp := MPfile (comp_name lib) in
  let mb := comp_mod lib in
  let env :=
    Environ.push_context_set (Some true)
      (Univ.ContextSet.union (mod_constraints mb) cst) (env senv) in
  let env :=
    let linkinfo := Nativecode.link_info_of_dirpath (comp_name lib) in
    Modops.add_linked_module mb linkinfo env in
  let env := Environ.add_native_symbols (comp_name lib) (comp_natsymbs lib) env
    in
  (mp, record).

Definition judgment := Environ.unsafe_judgment.

Definition j_val {A B : Type} (j : Environ.punsafe_judgment A B) : A :=
  Environ.uj_val j.

Definition j_type {A B : Type} (j : Environ.punsafe_judgment A B) : B :=
  Environ.uj_type j.

Definition typing (senv : safe_environment)
  : Constr.constr -&gt; Environ.unsafe_judgment := Typeops.infer (env_of_senv senv).

Definition register_inline (kn : Names.Constant.t) (senv : safe_environment)
  : safe_environment :=
  if negb (Environ.evaluable_constant kn (env senv)) then
    CErrors.user_err None None
      (Pp.str &quot;Register inline: an evaluable constant is expected&quot; % string)
  else
    tt;
  let env := env senv in
  let cb := Environ.lookup_constant kn env in
  let cb := record in
  let env := Environ.add_constant kn cb env in
  record.

Definition check_register_ind
  (ind : Names.inductive) (r : CPrimitives.prim_ind) (env : Environ.env)
  : unit :=
  match Inductive.lookup_mind_specif env ind with
  | (mb, ob) as spec =&gt;
    let check_if (b : bool) (msg : Pp.t) : unit :=
      if negb b then
        CErrors.user_err None (Some &quot;check_register_ind&quot; % string) msg
      else
        tt in
    check_if (Int.equal (Util.Array.(CArray.ExtS.length) (mind_packets mb)) 1)
      (Pp.str &quot;A non mutual inductive is expected&quot; % string);
    let is_monomorphic (function_parameter : Declarations.universes) : bool :=
      match function_parameter with
      | Monomorphic _ =&gt; true
      | Polymorphic _ =&gt; false
      end in
    check_if (is_monomorphic (mind_universes mb))
      (Pp.str &quot;A universe monomorphic inductive type is expected&quot; % string);
    check_if (apply negb (Inductive.is_private spec))
      (Pp.str &quot;A non-private inductive type is expected&quot; % string);
    let check_nparams (n : Int.t) : unit :=
      check_if (Int.equal (mind_nparams mb) n)
        (Pp.op_plus_plus
          (Pp.op_plus_plus (Pp.str &quot;An inductive type with &quot; % string)
            (Pp.int n)) (Pp.str &quot; parameters is expected&quot; % string)) in
    let check_nconstr (n : Int.t) : unit :=
      check_if
        (Int.equal (Util.Array.(CArray.ExtS.length) (mind_consnames ob)) n)
        (Pp.op_plus_plus
          (Pp.op_plus_plus (Pp.str &quot;an inductive type with &quot; % string)
            (Pp.int n)) (Pp.str &quot; constructors is expected&quot; % string)) in
    let check_name (pos : Z) (s : string) : unit :=
      check_if
        (Names.Id.equal (Util.Array.(CArray.ExtS.get) (mind_consnames ob) pos)
          (Names.Id.of_string s))
        (Pp.op_plus_plus
          (Pp.op_plus_plus
            (Pp.op_plus_plus (Pp.str &quot;the &quot; % string)
              (Pp.int (Util.op_plus pos 1)))
            (Pp.str &quot;th constructor does not have the expected name: &quot; % string))
          (Pp.str s)) in
    let check_type (pos : Z) (t : Constr.constr) : unit :=
      check_if
        (Constr.equal t (Util.Array.(CArray.ExtS.get) (mind_user_lc ob) pos))
        (Pp.op_plus_plus
          (Pp.op_plus_plus (Pp.str &quot;the &quot; % string)
            (Pp.int (Util.op_plus pos 1)))
          (Pp.str &quot;th constructor does not have the expected type&quot; % string)) in
    let check_type_cte (pos : Z) : unit :=
      check_type pos (Constr.mkRel 1) in
    match r with
    | CPrimitives.PIT_bool =&gt;
      check_nparams 0;
      check_nconstr 2;
      check_name 0 &quot;true&quot; % string;
      check_type_cte 0;
      check_name 1 &quot;false&quot; % string;
      check_type_cte 1
    | CPrimitives.PIT_carry =&gt;
      check_nparams 1;
      check_nconstr 2;
      let test_type (pos : Z) : unit :=
        let c := Util.Array.(CArray.ExtS.get) (mind_user_lc ob) pos in
        let s :=
          Pp.op_plus_plus
            (Pp.op_plus_plus (Pp.str &quot;the &quot; % string)
              (Pp.int (Util.op_plus pos 1)))
            (Pp.str &quot;th constructor does not have the expected type&quot; % string)
          in
        check_if (Constr.isProd c) s;
        match Constr.destProd c with
        | (_, d, cd) =&gt;
          check_if (Constr.is_Type d) s;
          check_if
            (Constr.equal
              (Constr.mkProd
                (Context.anonR, (Constr.mkRel 1),
                  (Constr.mkApp ((Constr.mkRel 3), ((Constr.mkRel 2)))))) cd) s
        end in
      check_name 0 &quot;C0&quot; % string;
      test_type 0;
      check_name 1 &quot;C1&quot; % string;
      test_type 1
    | CPrimitives.PIT_pair =&gt;
      check_nparams 2;
      check_nconstr 1;
      check_name 0 &quot;pair&quot; % string;
      let c := Util.Array.(CArray.ExtS.get) (mind_user_lc ob) 0 in
      let s := Pp.str &quot;the constructor does not have the expected type&quot; % string
        in
      match Term.decompose_prod c with
      | (cons (_, b) (cons (_, a) (cons (_, _B) (cons (_, _A) []))), codom) =&gt;
        check_if (Constr.is_Type _A) s;
        check_if (Constr.is_Type _B) s;
        check_if (Constr.equal a (Constr.mkRel 2)) s;
        check_if (Constr.equal b (Constr.mkRel 2)) s;
        check_if
          (Constr.equal codom
            (Constr.mkApp
              ((Constr.mkRel 5), ((Constr.mkRel 4), (Constr.mkRel 3))))) s
      | _ =&gt; check_if false s
      end
    | CPrimitives.PIT_cmp =&gt;
      check_nparams 0;
      check_nconstr 3;
      check_name 0 &quot;Eq&quot; % string;
      check_type_cte 0;
      check_name 1 &quot;Lt&quot; % string;
      check_type_cte 1;
      check_name 2 &quot;Gt&quot; % string;
      check_type_cte 2
    end
  end.

Definition register_inductive
  (ind : Names.inductive) (prim : CPrimitives.prim_ind)
  (senv : safe_environment) : safe_environment :=
  check_register_ind ind prim (env senv);
  let action := Retroknowledge.Register_ind prim ind in
  add_retroknowledge action senv.

Definition add_constraints (c : Univ.Constraint.t)
  : safe_environment -&gt; safe_environment :=
  add_constraints
    (Now (Univ.ContextSet.add_constraints c Univ.ContextSet.empty)).

Definition set_strategy
  (k : Names.tableKey Names.Constant.t) (l : Conv_oracle.level)
  (e : safe_environment) : safe_environment := record.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="section" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>section.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Util
open Names
open Univ

module NamedDecl = Context.Named.Declaration

type section_entry =
| SecDefinition of Constant.t
| SecInductive of MutInd.t

type 'a entry_map = 'a Cmap.t * 'a Mindmap.t

type 'a section = {
  sec_context : int;
  (** Length of the named context suffix that has been introduced locally *)
  sec_mono_universes : ContextSet.t;
  sec_poly_universes : Name.t array * UContext.t;
  (** Universes local to the section *)
  has_poly_univs : bool;
  (** Are there polymorphic universes or constraints, including in previous sections. *)
  sec_entries : section_entry list;
  (** Definitions introduced in the section *)
  sec_data : (Instance.t * AUContext.t) entry_map;
  (** Additional data synchronized with the section *)
  sec_custom : 'a;
}

(** Sections can be nested with the proviso that no monomorphic section can be
    opened inside a polymorphic one. The reverse is allowed. *)
type 'a t = 'a section list

let empty = []

let is_empty = List.is_empty

let depth = List.length

let has_poly_univs = function
  | [] -&gt; false
  | sec :: _ -&gt; sec.has_poly_univs

let find_emap e (cmap, imap) = match e with
| SecDefinition con -&gt; Cmap.find con cmap
| SecInductive ind -&gt; Mindmap.find ind imap

let add_emap e v (cmap, imap) = match e with
| SecDefinition con -&gt; (Cmap.add con v cmap, imap)
| SecInductive ind -&gt; (cmap, Mindmap.add ind v imap)

let on_last_section f sections = match sections with
| [] -&gt; CErrors.user_err (Pp.str &quot;No opened section&quot;)
| sec :: rem -&gt; f sec :: rem

let with_last_section f sections = match sections with
| [] -&gt; f None
| sec :: _ -&gt; f (Some sec)

let push_local s =
  let on_sec sec = { sec with sec_context = sec.sec_context + 1 } in
  on_last_section on_sec s

let push_context (nas, ctx) s =
    let on_sec sec =
      if UContext.is_empty ctx then sec
      else
        let (snas, sctx) = sec.sec_poly_universes in
        let sec_poly_universes = (Array.append snas nas, UContext.union sctx ctx) in
        { sec with sec_poly_universes; has_poly_univs = true }
    in
    on_last_section on_sec s

let is_polymorphic_univ u s =
  let check sec =
    let (_, uctx) = sec.sec_poly_universes in
    Array.exists (fun u' -&gt; Level.equal u u') (Instance.to_array (UContext.instance uctx))
  in
  List.exists check s

let push_constraints uctx s =
  let on_sec sec =
    if sec.has_poly_univs &amp;&amp; Constraint.exists (fun (l,_,r) -&gt; is_polymorphic_univ l s || is_polymorphic_univ r s) (snd uctx)
    then CErrors.user_err Pp.(str &quot;Cannot add monomorphic constraints which refer to section polymorphic universes.&quot;);
    let uctx' = sec.sec_mono_universes in
    let sec_mono_universes =  (ContextSet.union uctx uctx') in
    { sec with sec_mono_universes }
  in
  on_last_section on_sec s

let open_section ~custom sections =
  let sec = {
    sec_context = 0;
    sec_mono_universes = ContextSet.empty;
    sec_poly_universes = ([||], UContext.empty);
    has_poly_univs = has_poly_univs sections;
    sec_entries = [];
    sec_data = (Cmap.empty, Mindmap.empty);
    sec_custom = custom;
  } in
  sec :: sections

let close_section sections =
  match sections with
  | sec :: sections -&gt;
    sections, sec.sec_entries, sec.sec_mono_universes, sec.sec_custom
  | [] -&gt;
    CErrors.user_err (Pp.str &quot;No opened section.&quot;)

let make_decl_univs (nas,uctx) = abstract_universes nas uctx

let push_global ~poly e s =
  if is_empty s then s
  else if has_poly_univs s &amp;&amp; not poly
  then CErrors.user_err
      Pp.(str &quot;Cannot add a universe monomorphic declaration when \
               section polymorphic universes are present.&quot;)
  else
    let on_sec sec =
      { sec with
        sec_entries = e :: sec.sec_entries;
        sec_data = add_emap e (make_decl_univs sec.sec_poly_universes) sec.sec_data;
      }
    in
    on_last_section on_sec s

let push_constant ~poly con s = push_global ~poly (SecDefinition con) s

let push_inductive ~poly ind s = push_global ~poly (SecInductive ind) s

type abstr_info = {
  abstr_ctx : Constr.named_context;
  abstr_subst : Instance.t;
  abstr_uctx : AUContext.t;
}

let empty_segment = {
  abstr_ctx = [];
  abstr_subst = Instance.empty;
  abstr_uctx = AUContext.empty;
}

let extract_hyps sec vars used =
  (* Keep the section-local segment of variables *)
  let vars = List.firstn sec.sec_context vars in
  (* Only keep the part that is used by the declaration *)
  List.filter (fun d -&gt; Id.Set.mem (NamedDecl.get_id d) used) vars

let section_segment_of_entry vars e hyps sections =
  (* [vars] are the named hypotheses, [hyps] the subset that is declared by the
    global *)
  let with_sec s = match s with
  | None -&gt;
    CErrors.user_err (Pp.str &quot;No opened section.&quot;)
  | Some sec -&gt;
    let hyps = extract_hyps sec vars hyps in
    let inst, auctx = find_emap e sec.sec_data in
    {
      abstr_ctx = hyps;
      abstr_subst = inst;
      abstr_uctx = auctx;
    }
  in
  with_last_section with_sec sections

let segment_of_constant env con s =
  let body = Environ.lookup_constant con env in
  let vars = Environ.named_context env in
  let used = Context.Named.to_vars body.Declarations.const_hyps in
  section_segment_of_entry vars (SecDefinition con) used s

let segment_of_inductive env mind s =
  let mib = Environ.lookup_mind mind env in
  let vars = Environ.named_context env in
  let used = Context.Named.to_vars mib.Declarations.mind_hyps in
  section_segment_of_entry vars (SecInductive mind) used s

let instance_from_variable_context =
  List.rev %&gt; List.filter NamedDecl.is_local_assum %&gt; List.map NamedDecl.get_id %&gt; Array.of_list

let extract_worklist info =
  let args = instance_from_variable_context info.abstr_ctx in
  info.abstr_subst, args

let replacement_context env s =
  let with_sec sec = match sec with
  | None -&gt; CErrors.user_err (Pp.str &quot;No opened section.&quot;)
  | Some sec -&gt;
    let cmap, imap = sec.sec_data in
    let cmap = Cmap.mapi (fun con _ -&gt; extract_worklist @@ segment_of_constant env con s) cmap in
    let imap = Mindmap.mapi (fun ind _ -&gt; extract_worklist @@ segment_of_inductive env ind s) imap in
    (cmap, imap)
  in
  with_last_section with_sec s

let is_in_section env gr s =
  let with_sec sec = match sec with
  | None -&gt; false
  | Some sec -&gt;
    let open GlobRef in
    match gr with
    | VarRef id -&gt;
      let vars = List.firstn sec.sec_context (Environ.named_context env) in
      List.exists (fun decl -&gt; Id.equal id (NamedDecl.get_id decl)) vars
    | ConstRef con -&gt;
      Cmap.mem con (fst sec.sec_data)
    | IndRef (ind, _) | ConstructRef ((ind, _), _) -&gt;
      Mindmap.mem ind (snd sec.sec_data)
  in
  with_last_section with_sec s
</pre>
          </div>
          <div class="col-md-6">
            <code>section.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Util.

Import Names.

Import Univ.

Inductive section_entry : Type :=
| SecDefinition : Names.Constant.t -&gt; section_entry
| SecInductive : Names.MutInd.t -&gt; section_entry.

Definition entry_map (a : Type) := (Names.Cmap.t a) * (Names.Mindmap.t a).

Record section {a : Type} := {
  sec_context : Z;
  sec_mono_universes : Univ.ContextSet.t;
  sec_poly_universes : (array Names.Name.t) * Univ.UContext.t;
  has_poly_univs : bool;
  sec_entries : list section_entry;
  sec_data : entry_map (Univ.Instance.t * Univ.AUContext.t);
  sec_custom : a }.
Arguments section : clear implicits.

Definition t (a : Type) := list (section a).

Definition empty {A : Type} : list A := [].

Definition is_empty {A : Type} : (list A) -&gt; bool :=
  Util.List.(CList.ExtS.is_empty).

Definition depth {A : Type} : (list A) -&gt; Z := Util.List.(CList.ExtS.length).

Definition has_poly_univs {A : Type} (function_parameter : list (section A))
  : bool :=
  match function_parameter with
  | [] =&gt; false
  | cons sec _ =&gt; has_poly_univs sec
  end.

Definition find_emap {A : Type}
  (e : section_entry)
  (function_parameter : (Names.Cmap.t A) * (Names.Mindmap.t A)) : A :=
  match function_parameter with
  | (cmap, imap) =&gt;
    match e with
    | SecDefinition con =&gt; Names.Cmap.find con cmap
    | SecInductive ind =&gt; Names.Mindmap.find ind imap
    end
  end.

Definition add_emap {A : Type}
  (e : section_entry) (v : A)
  (function_parameter : (Names.Cmap.t A) * (Names.Mindmap.t A))
  : (Names.Cmap.t A) * (Names.Mindmap.t A) :=
  match function_parameter with
  | (cmap, imap) =&gt;
    match e with
    | SecDefinition con =&gt; ((Names.Cmap.add con v cmap), imap)
    | SecInductive ind =&gt; (cmap, (Names.Mindmap.add ind v imap))
    end
  end.

Definition on_last_section {A : Type} (f : A -&gt; A) (sections : list A)
  : list A :=
  match sections with
  | [] =&gt; CErrors.user_err None None (Pp.str &quot;No opened section&quot; % string)
  | cons sec rem =&gt; cons (f sec) rem
  end.

Definition with_last_section {A B : Type}
  (f : (option A) -&gt; B) (sections : list A) : B :=
  match sections with
  | [] =&gt; f None
  | cons sec _ =&gt; f (Some sec)
  end.

Definition push_local {A : Type} (s : list (section A)) : list (section A) :=
  let on_sec {B : Type} (sec : section B) : section B :=
    record in
  on_last_section on_sec s.

Definition push_context {A : Type}
  (function_parameter : (array Names.Name.t) * Univ.UContext.t)
  : (list (section A)) -&gt; list (section A) :=
  match function_parameter with
  | (nas, ctx) =&gt;
    fun s =&gt;
      let on_sec {B : Type} (sec : section B) : section B :=
        if Univ.UContext.is_empty ctx then
          sec
        else
          match sec_poly_universes sec with
          | (snas, sctx) =&gt;
            let sec_poly_universes :=
              ((Util.Array.(CArray.ExtS.append) snas nas),
                (Univ.UContext.union sctx ctx)) in
            record
          end in
      on_last_section on_sec s
  end.

Definition is_polymorphic_univ {A : Type}
  (u : Univ.Level.t) (s : list (section A)) : bool :=
  let check {B : Type} (sec : section B) : bool :=
    match sec_poly_universes sec with
    | (_, uctx) =&gt;
      Util.Array.(CArray.ExtS._exists) (fun u' =&gt; Univ.Level.equal u u')
        (Univ.Instance.to_array (Univ.UContext.instance uctx))
    end in
  Util.List.(CList.ExtS._exists) check s.

Definition push_constraints {A : Type}
  (uctx : Univ.ContextSet.t) (s : list (section A)) : list (section A) :=
  let on_sec {B : Type} (sec : section B) : section B :=
    if
      andb (has_poly_univs sec)
        (Univ.Constraint._exists
          (fun function_parameter =&gt;
            match function_parameter with
            | (l, _, r) =&gt;
              orb (is_polymorphic_univ l s) (is_polymorphic_univ r s)
            end) (snd uctx)) then
      CErrors.user_err None None
        (Pp.str
          &quot;Cannot add monomorphic constraints which refer to section polymorphic universes.&quot;
            % string)
    else
      tt;
    let uctx' := sec_mono_universes sec in
    let sec_mono_universes := Univ.ContextSet.union uctx uctx' in
    record in
  on_last_section on_sec s.

Definition open_section {A : Type} (custom : A) (sections : list (section A))
  : list (section A) :=
  let sec :=
    {| sec_context := 0; sec_mono_universes := Univ.ContextSet.empty;
      sec_poly_universes := (tt, Univ.UContext.empty);
      has_poly_univs := has_poly_univs sections; sec_entries := [];
      sec_data := (Names.Cmap.empty, Names.Mindmap.empty); sec_custom := custom
      |} in
  cons sec sections.

Definition close_section {A : Type} (sections : list (section A))
  : (list (section A)) * (list section_entry) * Univ.ContextSet.t * A :=
  match sections with
  | cons sec sections =&gt;
    (sections, (sec_entries sec), (sec_mono_universes sec), (sec_custom sec))
  | [] =&gt; CErrors.user_err None None (Pp.str &quot;No opened section.&quot; % string)
  end.

Definition make_decl_univs
  (function_parameter : (array Names.Name.t) * Univ.UContext.t)
  : Univ.Instance.t * Univ.AUContext.t :=
  match function_parameter with
  | (nas, uctx) =&gt; Univ.abstract_universes nas uctx
  end.

Definition push_global {A : Type}
  (poly : bool) (e : section_entry) (s : list (section A)) : list (section A) :=
  if is_empty s then
    s
  else
    if andb (has_poly_univs s) (negb poly) then
      CErrors.user_err None None
        (Pp.str
          &quot;Cannot add a universe monomorphic declaration when section polymorphic universes are present.&quot;
            % string)
    else
      let on_sec {B : Type} (sec : section B) : section B :=
        record in
      on_last_section on_sec s.

Definition push_constant {A : Type}
  (poly : bool) (con : Names.Constant.t) (s : list (section A))
  : list (section A) := push_global poly (SecDefinition con) s.

Definition push_inductive {A : Type}
  (poly : bool) (ind : Names.MutInd.t) (s : list (section A))
  : list (section A) := push_global poly (SecInductive ind) s.

Record abstr_info := {
  abstr_ctx : Constr.named_context;
  abstr_subst : Univ.Instance.t;
  abstr_uctx : Univ.AUContext.t }.

Definition empty_segment : abstr_info :=
  {| abstr_ctx := []; abstr_subst := Univ.Instance.empty;
    abstr_uctx := Univ.AUContext.empty |}.

Definition extract_hyps {A B C : Type}
  (sec : section A) (vars : list (NamedDecl.pt B C)) (used : Names.Id.Set.t)
  : list (NamedDecl.pt B C) :=
  let vars := Util.List.(CList.ExtS.firstn) (sec_context sec) vars in
  Util.List.(CList.ExtS.filter)
    (fun d =&gt; Names.Id.Set.mem (NamedDecl.get_id d) used) vars.

Definition section_segment_of_entry {A : Type}
  (vars : list (NamedDecl.pt Constr.constr Constr.types)) (e : section_entry)
  (hyps : Names.Id.Set.t) (sections : list (section A)) : abstr_info :=
  let with_sec {B : Type} (s : option (section B)) : abstr_info :=
    match s with
    | None =&gt; CErrors.user_err None None (Pp.str &quot;No opened section.&quot; % string)
    | Some sec =&gt;
      let hyps := extract_hyps sec vars hyps in
      match find_emap e (sec_data sec) with
      | (inst, auctx) =&gt;
        {| abstr_ctx := hyps; abstr_subst := inst; abstr_uctx := auctx |}
      end
    end in
  with_last_section with_sec sections.

Definition segment_of_constant {A : Type}
  (env : Environ.env) (con : Names.Constant.t) (s : list (section A))
  : abstr_info :=
  let body := Environ.lookup_constant con env in
  let vars := Environ.named_context env in
  let used := Context.Named.to_vars (Declarations.const_hyps body) in
  section_segment_of_entry vars (SecDefinition con) used s.

Definition segment_of_inductive {A : Type}
  (env : Environ.env) (mind : Names.MutInd.t) (s : list (section A))
  : abstr_info :=
  let mib := Environ.lookup_mind mind env in
  let vars := Environ.named_context env in
  let used := Context.Named.to_vars (Declarations.mind_hyps mib) in
  section_segment_of_entry vars (SecInductive mind) used s.

Definition instance_from_variable_context
  : (list (NamedDecl.pt Constr.constr Constr.types)) -&gt; array Names.Id.t :=
  Util.op_percent_gt
    (Util.op_percent_gt
      (Util.op_percent_gt Util.List.(CList.ExtS.rev)
        (Util.List.(CList.ExtS.filter) NamedDecl.is_local_assum))
      (Util.List.(CList.ExtS.map) NamedDecl.get_id))
    Util.Array.(CArray.ExtS.of_list).

Definition extract_worklist (info : abstr_info)
  : Univ.Instance.t * (array Names.Id.t) :=
  let args := instance_from_variable_context (abstr_ctx info) in
  ((abstr_subst info), args).

Definition replacement_context {A : Type}
  (env : Environ.env) (s : list (section A))
  : (Names.Cmap.t (Univ.Instance.t * (array Names.Id.t))) *
    (Names.Mindmap.t (Univ.Instance.t * (array Names.Id.t))) :=
  let with_sec {B : Type} (sec : option (section B))
    : (Names.Cmap.t (Univ.Instance.t * (array Names.Id.t))) *
      (Names.Mindmap.t (Univ.Instance.t * (array Names.Id.t))) :=
    match sec with
    | None =&gt; CErrors.user_err None None (Pp.str &quot;No opened section.&quot; % string)
    | Some sec =&gt;
      match sec_data sec with
      | (cmap, imap) =&gt;
        let cmap :=
          Names.Cmap.mapi
            (fun con =&gt;
              fun function_parameter =&gt;
                match function_parameter with
                | _ =&gt; apply extract_worklist (segment_of_constant env con s)
                end) cmap in
        let imap :=
          Names.Mindmap.mapi
            (fun ind =&gt;
              fun function_parameter =&gt;
                match function_parameter with
                | _ =&gt; apply extract_worklist (segment_of_inductive env ind s)
                end) imap in
        (cmap, imap)
      end
    end in
  with_last_section with_sec s.

Definition is_in_section {A : Type}
  (env : Environ.env) (gr : Names.GlobRef.t) (s : list (section A)) : bool :=
  let with_sec {B : Type} (sec : option (section B)) : bool :=
    match sec with
    | None =&gt; false
    | Some sec =&gt;
      match gr with
      | VarRef id =&gt;
        let vars :=
          Util.List.(CList.ExtS.firstn) (sec_context sec)
            (Environ.named_context env) in
        Util.List.(CList.ExtS._exists)
          (fun decl =&gt; Names.Id.equal id (NamedDecl.get_id decl)) vars
      | ConstRef con =&gt; Names.Cmap.mem con (fst (sec_data sec))
      | IndRef (ind, _) | ConstructRef ((ind, _), _) =&gt;
        Names.Mindmap.mem ind (snd (sec_data sec))
      end
    end in
  with_last_section with_sec s.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="sorts" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>sorts.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Univ

type family = InSProp | InProp | InSet | InType

type t =
  | SProp
  | Prop
  | Set
  | Type of Universe.t

let sprop = SProp
let prop = Prop
let set = Set
let type1 = Type type1_univ

let univ_of_sort = function
  | Type u -&gt; u
  | Set -&gt; Universe.type0
  | Prop -&gt; Universe.type0m
  | SProp -&gt; Universe.sprop

let sort_of_univ u =
  if Universe.is_sprop u then sprop
  else if is_type0m_univ u then prop
  else if is_type0_univ u then set
  else Type u

let compare s1 s2 =
  if s1 == s2 then 0 else
    match s1, s2 with
    | SProp, SProp -&gt; 0
    | SProp, _ -&gt; -1
    | _, SProp -&gt; 1
    | Prop, Prop -&gt; 0
    | Prop, _ -&gt; -1
    | Set, Prop -&gt; 1
    | Set, Set -&gt; 0
    | Set, _ -&gt; -1
    | Type u1, Type u2 -&gt; Universe.compare u1 u2
    | Type _, _ -&gt; -1

let equal s1 s2 = Int.equal (compare s1 s2) 0

let super = function
  | SProp | Prop | Set -&gt; Type (Universe.type1)
  | Type u -&gt; Type (Universe.super u)

let is_sprop = function
  | SProp -&gt; true
  | Prop | Set | Type _ -&gt; false

let is_prop = function
  | Prop -&gt; true
  | SProp | Set | Type _ -&gt; false

let is_set = function
  | Set -&gt; true
  | SProp | Prop | Type _ -&gt; false

let is_small = function
  | SProp | Prop | Set -&gt; true
  | Type _ -&gt; false

let family = function
  | SProp -&gt; InSProp
  | Prop -&gt; InProp
  | Set -&gt; InSet
  | Type _ -&gt; InType

let family_compare a b = match a,b with
  | InSProp, InSProp -&gt; 0
  | InSProp, _ -&gt; -1
  | _, InSProp -&gt; 1
  | InProp, InProp -&gt; 0
  | InProp, _ -&gt; -1
  | _, InProp -&gt; 1
  | InSet, InSet -&gt; 0
  | InSet, _ -&gt; -1
  | _, InSet -&gt; 1
  | InType, InType -&gt; 0

let family_equal = (==)

let family_leq a b = family_compare a b &lt;= 0

open Hashset.Combine

let hash = function
  | SProp -&gt; combinesmall 1 0
  | Prop -&gt; combinesmall 1 1
  | Set -&gt; combinesmall 1 2
  | Type u -&gt;
    let h = Univ.Universe.hash u in
    combinesmall 2 h

module Hsorts =
  Hashcons.Make(
    struct
      type _t = t
      type t = _t
      type u = Universe.t -&gt; Universe.t

      let hashcons huniv = function
        | Type u as c -&gt; 
	  let u' = huniv u in 
	    if u' == u then c else Type u'
        | s -&gt; s
      let eq s1 s2 = match (s1,s2) with
        | Prop, Prop | Set, Set -&gt; true
        | (Type u1, Type u2) -&gt; u1 == u2
        |_ -&gt; false

      let hash = hash
    end)

let hcons = Hashcons.simple_hcons Hsorts.generate Hsorts.hcons hcons_univ

(** On binders: is this variable proof relevant *)
type relevance = Relevant | Irrelevant

let relevance_equal r1 r2 = match r1,r2 with
  | Relevant, Relevant | Irrelevant, Irrelevant -&gt; true
  | (Relevant | Irrelevant), _ -&gt; false

let relevance_of_sort_family = function
  | InSProp -&gt; Irrelevant
  | _ -&gt; Relevant

let relevance_hash = function
  | Relevant -&gt; 0
  | Irrelevant -&gt; 1

let relevance_of_sort = function
  | SProp -&gt; Irrelevant
  | _ -&gt; Relevant

let debug_print = function
  | SProp -&gt; Pp.(str &quot;SProp&quot;)
  | Prop -&gt; Pp.(str &quot;Prop&quot;)
  | Set -&gt; Pp.(str &quot;Set&quot;)
  | Type u -&gt; Pp.(str &quot;Type(&quot; ++ Univ.Universe.pr u ++ str &quot;)&quot;)

let pr_sort_family = function
  | InSProp -&gt; Pp.(str &quot;SProp&quot;)
  | InProp -&gt; Pp.(str &quot;Prop&quot;)
  | InSet -&gt; Pp.(str &quot;Set&quot;)
  | InType -&gt; Pp.(str &quot;Type&quot;)
</pre>
          </div>
          <div class="col-md-6">
            <code>sorts.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Univ.

Inductive family : Type :=
| InSProp : family
| InProp : family
| InSet : family
| InType : family.

Inductive t : Type :=
| SProp : t
| Prop : t
| Set : t
| Type : Univ.Universe.t -&gt; t.

Definition sprop : t := SProp.

Definition prop : t := Prop.

Definition set : t := Set.

Definition type1 : t := Type Univ.type1_univ.

Definition univ_of_sort (function_parameter : t) : Univ.Universe.t :=
  match function_parameter with
  | Type u =&gt; u
  | Set =&gt; Univ.Universe.type0
  | Prop =&gt; Univ.Universe.type0m
  | SProp =&gt; Univ.Universe.sprop
  end.

Definition sort_of_univ (u : Univ.Universe.t) : t :=
  if Univ.Universe.is_sprop u then
    sprop
  else
    if Univ.is_type0m_univ u then
      prop
    else
      if Univ.is_type0_univ u then
        set
      else
        Type u.

Definition compare (s1 : t) (s2 : t) : Z :=
  if Stdlib.op_eq_eq s1 s2 then
    0
  else
    match (s1, s2) with
    | (SProp, SProp) =&gt; 0
    | (SProp, _) =&gt; (-1)
    | (_, SProp) =&gt; 1
    | (Prop, Prop) =&gt; 0
    | (Prop, _) =&gt; (-1)
    | (Set, Prop) =&gt; 1
    | (Set, Set) =&gt; 0
    | (Set, _) =&gt; (-1)
    | (Type u1, Type u2) =&gt; Univ.Universe.compare u1 u2
    | (Type _, _) =&gt; (-1)
    end.

Definition equal (s1 : t) (s2 : t) : bool := Int.equal (compare s1 s2) 0.

Definition super (function_parameter : t) : t :=
  match function_parameter with
  | SProp | Prop | Set =&gt; Type Univ.Universe.type1
  | Type u =&gt; Type (Univ.Universe.super u)
  end.

Definition is_sprop (function_parameter : t) : bool :=
  match function_parameter with
  | SProp =&gt; true
  | Prop | Set | Type _ =&gt; false
  end.

Definition is_prop (function_parameter : t) : bool :=
  match function_parameter with
  | Prop =&gt; true
  | SProp | Set | Type _ =&gt; false
  end.

Definition is_set (function_parameter : t) : bool :=
  match function_parameter with
  | Set =&gt; true
  | SProp | Prop | Type _ =&gt; false
  end.

Definition is_small (function_parameter : t) : bool :=
  match function_parameter with
  | SProp | Prop | Set =&gt; true
  | Type _ =&gt; false
  end.

Definition family (function_parameter : t) : family :=
  match function_parameter with
  | SProp =&gt; InSProp
  | Prop =&gt; InProp
  | Set =&gt; InSet
  | Type _ =&gt; InType
  end.

Definition family_compare (a : family) (b : family) : Z :=
  match (a, b) with
  | (InSProp, InSProp) =&gt; 0
  | (InSProp, _) =&gt; (-1)
  | (_, InSProp) =&gt; 1
  | (InProp, InProp) =&gt; 0
  | (InProp, _) =&gt; (-1)
  | (_, InProp) =&gt; 1
  | (InSet, InSet) =&gt; 0
  | (InSet, _) =&gt; (-1)
  | (_, InSet) =&gt; 1
  | (InType, InType) =&gt; 0
  end.

Definition family_equal {A : Type} : A -&gt; A -&gt; bool := Stdlib.op_eq_eq.

Definition family_leq (a : family) (b : family) : bool :=
  OCaml.Stdlib.le (family_compare a b) 0.

Import Hashset.Combine.

Definition hash (function_parameter : t) : Z :=
  match function_parameter with
  | SProp =&gt; Hashset.Combine.combinesmall 1 0
  | Prop =&gt; Hashset.Combine.combinesmall 1 1
  | Set =&gt; Hashset.Combine.combinesmall 1 2
  | Type u =&gt;
    let h := Univ.Universe.hash u in
    Hashset.Combine.combinesmall 2 h
  end.

Definition hcons : Hsorts.t -&gt; Hsorts.t :=
  Hashcons.simple_hcons Hsorts.(Hashcons.S.generate) Hsorts.(Hashcons.S.hcons)
    Univ.hcons_univ.

Inductive relevance : Type :=
| Relevant : relevance
| Irrelevant : relevance.

Definition relevance_equal (r1 : relevance) (r2 : relevance) : bool :=
  match (r1, r2) with
  | (Relevant, Relevant) | (Irrelevant, Irrelevant) =&gt; true
  | (Relevant | Irrelevant, _) =&gt; false
  end.

Definition relevance_of_sort_family (function_parameter : family) : relevance :=
  match function_parameter with
  | InSProp =&gt; Irrelevant
  | _ =&gt; Relevant
  end.

Definition relevance_hash (function_parameter : relevance) : Z :=
  match function_parameter with
  | Relevant =&gt; 0
  | Irrelevant =&gt; 1
  end.

Definition relevance_of_sort (function_parameter : t) : relevance :=
  match function_parameter with
  | SProp =&gt; Irrelevant
  | _ =&gt; Relevant
  end.

Definition debug_print (function_parameter : t) : Pp.t :=
  match function_parameter with
  | SProp =&gt; Pp.str &quot;SProp&quot; % string
  | Prop =&gt; Pp.str &quot;Prop&quot; % string
  | Set =&gt; Pp.str &quot;Set&quot; % string
  | Type u =&gt;
    Pp.op_plus_plus
      (Pp.op_plus_plus (Pp.str &quot;Type(&quot; % string) (Univ.Universe.pr u))
      (Pp.str &quot;)&quot; % string)
  end.

Definition pr_sort_family (function_parameter : family) : Pp.t :=
  match function_parameter with
  | InSProp =&gt; Pp.str &quot;SProp&quot; % string
  | InProp =&gt; Pp.str &quot;Prop&quot; % string
  | InSet =&gt; Pp.str &quot;Set&quot; % string
  | InType =&gt; Pp.str &quot;Type&quot; % string
  end.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="subtyping" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>subtyping.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Jacek Chrzaszcz, Aug 2002 as part of the implementation of
   the Coq module system *)

(* This module checks subtyping of module types *)

(*i*)
open Names
open Univ
open Util
open Constr
open Declarations
open Declareops
open Reduction
open Inductive
open Modops
open Context
open Mod_subst
(*i*)

(* This local type is used to subtype a constant with a constructor or
   an inductive type. It can also be useful to allow reorderings in
   inductive types *)
type namedobject =
  | Constant of Opaqueproof.opaque constant_body
  | IndType of inductive * mutual_inductive_body
  | IndConstr of constructor * mutual_inductive_body

type namedmodule =
  | Module of module_body
  | Modtype of module_type_body

(* adds above information about one mutual inductive: all types and
   constructors *)

let add_mib_nameobjects mp l mib map =
  let ind = MutInd.make2 mp l in
  let add_mip_nameobjects j oib map =
    let ip = (ind,j) in
    let map =
      Array.fold_right_i
      (fun i id map -&gt;
        Label.Map.add (Label.of_id id) (IndConstr((ip,i+1), mib)) map)
      oib.mind_consnames
      map
    in
      Label.Map.add (Label.of_id oib.mind_typename) (IndType (ip, mib)) map
  in
  Array.fold_right_i add_mip_nameobjects mib.mind_packets map


(* creates (namedobject/namedmodule) map for the whole signature *)

type labmap = { objs : namedobject Label.Map.t; mods : namedmodule Label.Map.t }

let empty_labmap = { objs = Label.Map.empty; mods = Label.Map.empty }

let get_obj mp map l =
  try Label.Map.find l map.objs
  with Not_found -&gt; error_no_such_label_sub l (ModPath.to_string mp)

let get_mod mp map l =
  try Label.Map.find l map.mods
  with Not_found -&gt; error_no_such_label_sub l (ModPath.to_string mp)

let make_labmap mp list =
  let add_one (l,e) map =
   match e with
    | SFBconst cb -&gt; { map with objs = Label.Map.add l (Constant cb) map.objs }
    | SFBmind mib -&gt; { map with objs = add_mib_nameobjects mp l mib map.objs }
    | SFBmodule mb -&gt; { map with mods = Label.Map.add l (Module mb) map.mods }
    | SFBmodtype mtb -&gt; { map with mods = Label.Map.add l (Modtype mtb) map.mods }
  in
  CList.fold_right add_one list empty_labmap


let check_conv_error error why cst poly f env a1 a2 =
  try 
    let cst' = f env (Environ.universes env) a1 a2 in
      if poly then 
	if Constraint.is_empty cst' then cst
	else error (IncompatiblePolymorphism (env, a1, a2))
      else Constraint.union cst cst'
  with NotConvertible -&gt; error why
     | Univ.UniverseInconsistency e -&gt; error (IncompatibleUniverses e)

let check_universes error env u1 u2 =
  match u1, u2 with
  | Monomorphic _, Monomorphic _ -&gt; env
  | Polymorphic auctx1, Polymorphic auctx2 -&gt;
    let lbound = Environ.universes_lbound env in
    if not (UGraph.check_subtype ~lbound (Environ.universes env) auctx2 auctx1) then
      error (IncompatibleConstraints { got = auctx1; expect = auctx2; } )
    else
      Environ.push_context ~strict:false (Univ.AUContext.repr auctx2) env
  | Monomorphic _, Polymorphic _ -&gt; error (PolymorphicStatusExpected true)
  | Polymorphic _, Monomorphic _ -&gt; error (PolymorphicStatusExpected false)

let check_variance error v1 v2 =
  match v1, v2 with
  | None, None -&gt; ()
  | Some v1, Some v2 -&gt;
    if not (Array.for_all2 Variance.check_subtype v2 v1) then
      error IncompatibleVariance
  | None, Some _ -&gt; error (CumulativeStatusExpected true)
  | Some _, None -&gt; error (CumulativeStatusExpected false)

(* for now we do not allow reorderings *)

let check_inductive cst env mp1 l info1 mp2 mib2 spec2 subst1 subst2 reso1 reso2= 
  let kn1 = KerName.make mp1 l in
  let kn2 = KerName.make mp2 l in
  let error why = error_signature_mismatch l spec2 why in
  let check_conv why cst poly f = check_conv_error error why cst poly f in
  let mib1 =
    match info1 with
      | IndType ((_,0), mib) -&gt; Declareops.subst_mind_body subst1 mib
      | _ -&gt; error (InductiveFieldExpected mib2)
  in
  let env = check_universes error env mib1.mind_universes mib2.mind_universes in
  let () = check_variance error mib1.mind_variance mib2.mind_variance in
  let inst = make_abstract_instance (Declareops.inductive_polymorphic_context mib1) in
  let mib2 =  Declareops.subst_mind_body subst2 mib2 in
  let check_inductive_type cst name t1 t2 =
    check_conv (NotConvertibleInductiveField name)
      cst (inductive_is_polymorphic mib1) (infer_conv_leq ?l2r:None ?evars:None ?ts:None) env t1 t2
  in

  let check_packet cst p1 p2 =
    let check f test why = if not (test (f p1) (f p2)) then error why in
      check (fun p -&gt; p.mind_consnames) (Array.equal Id.equal) NotSameConstructorNamesField;
      check (fun p -&gt; p.mind_typename) Id.equal NotSameInductiveNameInBlockField;
      (* nf_lc later *)
      (* nf_arity later *)
      (* user_lc ignored *)
      (* user_arity ignored *)
      check (fun p -&gt; p.mind_nrealargs) Int.equal (NotConvertibleInductiveField p2.mind_typename); (* How can it fail since the type of inductive are checked below? [HH] *)
      (* kelim ignored *)
      (* listrec ignored *)
      (* finite done *)
      (* nparams done *)
      (* params_ctxt done because part of the inductive types *)
      (* Don't check the sort of the type if polymorphic *)
      let ty1 = type_of_inductive env ((mib1, p1), inst) in
      let ty2 = type_of_inductive env ((mib2, p2), inst) in
      let cst = check_inductive_type cst p2.mind_typename ty1 ty2 in
	cst
  in
  let mind = MutInd.make1 kn1 in
  let check_cons_types _i cst p1 p2 =
    Array.fold_left3
      (fun cst id t1 t2 -&gt; check_conv (NotConvertibleConstructorField id) cst
        (inductive_is_polymorphic mib1) (infer_conv ?l2r:None ?evars:None ?ts:None) env t1 t2)
      cst
      p2.mind_consnames
      (arities_of_specif (mind, inst) (mib1, p1))
      (arities_of_specif (mind, inst) (mib2, p2))
  in
  let check f test why = if not (test (f mib1) (f mib2)) then error (why (f mib2)) in
  check (fun mib -&gt; mib.mind_finite&lt;&gt;CoFinite) (==) (fun x -&gt; FiniteInductiveFieldExpected x);
  check (fun mib -&gt; mib.mind_ntypes) Int.equal (fun x -&gt; InductiveNumbersFieldExpected x);
  assert (List.is_empty mib1.mind_hyps &amp;&amp; List.is_empty mib2.mind_hyps);
  assert (Array.length mib1.mind_packets &gt;= 1
	    &amp;&amp; Array.length mib2.mind_packets &gt;= 1);

  (* Check that the expected numbers of uniform parameters are the same *)
  (* No need to check the contexts of parameters: it is checked *)
  (* at the time of checking the inductive arities in check_packet. *)
  (* Notice that we don't expect the local definitions to match: only *)
  (* the inductive types and constructors types have to be convertible *)
  check (fun mib -&gt; mib.mind_nparams) Int.equal (fun x -&gt; InductiveParamsNumberField x);

  begin
    let kn2' = kn_of_delta reso2 kn2 in
    if KerName.equal kn2 kn2' ||
       MutInd.equal (mind_of_delta_kn reso1 kn1)
                    (subst_mind subst2 (MutInd.make kn2 kn2'))
    then ()
    else error NotEqualInductiveAliases
  end;
  (* we check that records and their field names are preserved. *)
  (** FIXME: this check looks nonsense *)
  check (fun mib -&gt; mib.mind_record &lt;&gt; NotRecord) (==) (fun x -&gt; RecordFieldExpected x);
  if mib1.mind_record &lt;&gt; NotRecord then begin
    let rec names_prod_letin t = match kind t with
      | Prod(n,_,t) -&gt; n.binder_name::(names_prod_letin t)
      | LetIn(n,_,_,t) -&gt; n.binder_name::(names_prod_letin t)
      | Cast(t,_,_) -&gt; names_prod_letin t
      | _ -&gt; []
    in
    assert (Int.equal (Array.length mib1.mind_packets) 1);
    assert (Int.equal (Array.length mib2.mind_packets) 1);
    assert (Int.equal (Array.length mib1.mind_packets.(0).mind_user_lc) 1);
    assert (Int.equal (Array.length mib2.mind_packets.(0).mind_user_lc) 1);
    check (fun mib -&gt;
      let nparamdecls = List.length mib.mind_params_ctxt in
      let names = names_prod_letin (mib.mind_packets.(0).mind_user_lc.(0)) in
      snd (List.chop nparamdecls names)) (List.equal Name.equal)
      (fun x -&gt; RecordProjectionsExpected x);
  end;
  (* we first check simple things *)
  let cst =
    Array.fold_left2 check_packet cst mib1.mind_packets mib2.mind_packets
  in
  (* and constructor types in the end *)
  let cst =
    Array.fold_left2_i check_cons_types cst mib1.mind_packets mib2.mind_packets
  in
    cst

    
let check_constant cst env l info1 cb2 spec2 subst1 subst2 =
  let error why = error_signature_mismatch l spec2 why in
  let check_conv cst poly f = check_conv_error error cst poly f in
  let check_type poly cst env t1 t2 =
    let err = NotConvertibleTypeField (env, t1, t2) in
    check_conv err cst poly (infer_conv_leq ?l2r:None ?evars:None ?ts:None) env t1 t2
  in
  match info1 with
    | Constant cb1 -&gt;
      let () = assert (List.is_empty cb1.const_hyps &amp;&amp; List.is_empty cb2.const_hyps) in
      let cb1 = Declareops.subst_const_body subst1 cb1 in
      let cb2 = Declareops.subst_const_body subst2 cb2 in
      (* Start by checking universes *)
      let env = check_universes error env cb1.const_universes cb2.const_universes in
      let poly = Declareops.constant_is_polymorphic cb1 in
      (* Now check types *)
      let typ1 = cb1.const_type in
      let typ2 = cb2.const_type in
      let cst = check_type poly cst env typ1 typ2 in
      (* Now we check the bodies:
	 - A transparent constant can only be implemented by a compatible
	   transparent constant.
         - In the signature, an opaque is handled just as a parameter:
           anything of the right type can implement it, even if bodies differ.
      *)
      (match cb2.const_body with
        | Primitive _ | Undef _ | OpaqueDef _ -&gt; cst
	| Def lc2 -&gt;
	  (match cb1.const_body with
            | Primitive _ | Undef _ | OpaqueDef _ -&gt; error NotConvertibleBodyField
	    | Def lc1 -&gt;
	      (* NB: cb1 might have been strengthened and appear as transparent.
		 Anyway [check_conv] will handle that afterwards. *)
	      let c1 = Mod_subst.force_constr lc1 in
	      let c2 = Mod_subst.force_constr lc2 in
              check_conv NotConvertibleBodyField cst poly (infer_conv ?l2r:None ?evars:None ?ts:None) env c1 c2))
   | IndType ((_kn,_i),_mind1) -&gt;
       CErrors.user_err Pp.(str @@
       &quot;The kernel does not recognize yet that a parameter can be &quot; ^
       &quot;instantiated by an inductive type. Hint: you can rename the &quot; ^
       &quot;inductive type and give a definition to map the old name to the new &quot; ^
       &quot;name.&quot;)
   | IndConstr (((_kn,_i),_j),_mind1) -&gt;
      CErrors.user_err Pp.(str @@
       &quot;The kernel does not recognize yet that a parameter can be &quot; ^
       &quot;instantiated by a constructor. Hint: you can rename the &quot; ^
       &quot;constructor and give a definition to map the old name to the new &quot; ^
       &quot;name.&quot;)

let rec check_modules cst env msb1 msb2 subst1 subst2 =
  let mty1 = module_type_of_module msb1 in
  let mty2 =  module_type_of_module msb2 in
  check_modtypes cst env mty1 mty2 subst1 subst2 false

and check_signatures cst env mp1 sig1 mp2 sig2 subst1 subst2 reso1 reso2= 
  let map1 = make_labmap mp1 sig1 in
  let check_one_body cst (l,spec2) =
    match spec2 with
	| SFBconst cb2 -&gt;
            check_constant cst env l (get_obj mp1 map1 l)
	      cb2 spec2 subst1 subst2
	| SFBmind mib2 -&gt;
	    check_inductive cst env mp1 l (get_obj mp1 map1 l)
	      mp2 mib2 spec2 subst1 subst2 reso1 reso2
	| SFBmodule msb2 -&gt;
	    begin match get_mod mp1 map1 l with
	      | Module msb -&gt; check_modules cst env msb msb2 subst1 subst2
	      | _ -&gt; error_signature_mismatch l spec2 ModuleFieldExpected
	    end
	| SFBmodtype mtb2 -&gt;
	    let mtb1 = match get_mod mp1 map1 l with
	      | Modtype mtb -&gt; mtb
	      | _ -&gt; error_signature_mismatch l spec2 ModuleTypeFieldExpected
	    in
	    let env =
              add_module_type mtb2.mod_mp mtb2
	        (add_module_type mtb1.mod_mp mtb1 env)
            in
	    check_modtypes cst env mtb1 mtb2 subst1 subst2 true
  in
    List.fold_left check_one_body cst sig2

and check_modtypes cst env mtb1 mtb2 subst1 subst2 equiv =
  if mtb1==mtb2 || mtb1.mod_type == mtb2.mod_type then cst
  else
    let rec check_structure cst env str1 str2 equiv subst1 subst2 =
      match str1,str2 with
      |NoFunctor list1,
       NoFunctor list2 -&gt;
	if equiv then
	  let subst2 = add_mp mtb2.mod_mp mtb1.mod_mp mtb1.mod_delta subst2 in
          let cst1 = check_signatures cst env
	    mtb1.mod_mp list1 mtb2.mod_mp list2 subst1 subst2
	    mtb1.mod_delta mtb2.mod_delta
          in
          let cst2 = check_signatures cst env
	    mtb2.mod_mp list2 mtb1.mod_mp list1 subst2 subst1
	    mtb2.mod_delta  mtb1.mod_delta
	  in
	  Univ.Constraint.union cst1 cst2
	else
	  check_signatures cst env
	    mtb1.mod_mp list1 mtb2.mod_mp list2 subst1 subst2
	    mtb1.mod_delta  mtb2.mod_delta
      |MoreFunctor (arg_id1,arg_t1,body_t1),
       MoreFunctor (arg_id2,arg_t2,body_t2) -&gt;
        let mp2 = MPbound arg_id2 in
	let subst1 = join (map_mbid arg_id1 mp2 arg_t2.mod_delta) subst1 in
	let cst = check_modtypes cst env arg_t2 arg_t1 subst2 subst1 equiv in
        (* contravariant *)
	let env = add_module_type mp2 arg_t2 env in
	let env =
          if Modops.is_functor body_t1 then env
          else add_module
            {mod_mp = mtb1.mod_mp;
	     mod_expr = Abstract;
	     mod_type = subst_signature subst1 body_t1;
	     mod_type_alg = None;
	     mod_constraints = mtb1.mod_constraints;
	     mod_retroknowledge = ModBodyRK [];
	     mod_delta = mtb1.mod_delta} env
	in
	check_structure cst env body_t1 body_t2 equiv subst1 subst2
      | _ , _ -&gt; error_incompatible_modtypes mtb1 mtb2
    in
    check_structure cst env mtb1.mod_type mtb2.mod_type equiv subst1 subst2

let check_subtypes env sup super =
  let env = add_module_type sup.mod_mp sup env in
  let env = Environ.push_context_set ~strict:true super.mod_constraints env in
  check_modtypes Univ.Constraint.empty env
    (strengthen sup sup.mod_mp) super empty_subst
    (map_mp super.mod_mp sup.mod_mp sup.mod_delta) false

</pre>
          </div>
          <div class="col-md-6">
            <code>subtyping.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Names.

Import Univ.

Import Util.

Import Constr.

Import Declarations.

Import Declareops.

Import Reduction.

Import Inductive.

Import Modops.

Import Context.

Import Mod_subst.

Inductive namedobject : Type :=
| Constant : (Declarations.constant_body Opaqueproof.opaque) -&gt; namedobject
| IndType : Names.inductive -&gt; Declarations.mutual_inductive_body -&gt; namedobject
| IndConstr : Names.constructor -&gt; Declarations.mutual_inductive_body -&gt;
  namedobject.

Inductive namedmodule : Type :=
| Module : Declarations.module_body -&gt; namedmodule
| Modtype : Declarations.module_type_body -&gt; namedmodule.

Definition add_mib_nameobjects
  (mp : Names.ModPath.t) (l : Names.Label.t)
  (mib : Declarations.mutual_inductive_body)
  (map : Names.Label.Map.t namedobject) : Names.Label.Map.t namedobject :=
  let ind := Names.MutInd.make2 mp l in
  let add_mip_nameobjects
    (j : Z) (oib : Declarations.one_inductive_body) (map :
    Names.Label.Map.t namedobject) : Names.Label.Map.t namedobject :=
    let ip := (ind, j) in
    let map :=
      Util.Array.(CArray.ExtS.fold_right_i)
        (fun i =&gt;
          fun id =&gt;
            fun map =&gt;
              Names.Label.Map.add (Names.Label.of_id id)
                (IndConstr (ip, (Util.op_plus i 1)) mib) map)
        (mind_consnames oib) map in
    Names.Label.Map.add (Names.Label.of_id (mind_typename oib)) (IndType ip mib)
      map in
  Util.Array.(CArray.ExtS.fold_right_i) add_mip_nameobjects (mind_packets mib)
    map.

Record labmap := {
  objs : Names.Label.Map.t namedobject;
  mods : Names.Label.Map.t namedmodule }.

Definition empty_labmap : labmap :=
  {| objs := Names.Label.Map.empty; mods := Names.Label.Map.empty |}.

Definition get_obj
  (mp : Names.ModPath.t) (map : labmap) (l : Names.Label.Map.key)
  : namedobject := try.

Definition get_mod
  (mp : Names.ModPath.t) (map : labmap) (l : Names.Label.Map.key)
  : namedmodule := try.

Definition make_labmap
  (mp : Names.ModPath.t)
  (list : list (Names.Label.Map.key * Declarations.structure_field_body))
  : labmap :=
  let add_one
    (function_parameter :
    Names.Label.Map.key * Declarations.structure_field_body)
    : labmap -&gt; labmap :=
    match function_parameter with
    | (l, e) =&gt;
      fun map =&gt;
        match e with
        | SFBconst cb =&gt; record
        | SFBmind mib =&gt; record
        | SFBmodule mb =&gt; record
        | SFBmodtype mtb =&gt; record
        end
    end in
  CList.fold_right add_one list empty_labmap.

Definition check_conv_error
  (error : Modops.signature_mismatch_error -&gt; Univ.Constraint.t)
  (why : Modops.signature_mismatch_error) (cst : Univ.Constraint.t)
  (poly : bool)
  (f :
    Environ.env -&gt; UGraph.t -&gt; Constr.types -&gt; Constr.types -&gt; Univ.Constraint.t)
  (env : Environ.env) (a1 : Constr.types) (a2 : Constr.types)
  : Univ.Constraint.t := try.

Definition check_universes
  (error : Modops.signature_mismatch_error -&gt; Environ.env) (env : Environ.env)
  (u1 : Declarations.universes) (u2 : Declarations.universes) : Environ.env :=
  match (u1, u2) with
  | (Monomorphic _, Monomorphic _) =&gt; env
  | (Polymorphic auctx1, Polymorphic auctx2) =&gt;
    let lbound := Environ.universes_lbound env in
    if negb (UGraph.check_subtype lbound (Environ.universes env) auctx2 auctx1)
      then
      error (IncompatibleConstraints {| got := auctx1; expect := auctx2 |})
    else
      Environ.push_context (Some false) (Univ.AUContext.repr auctx2) env
  | (Monomorphic _, Polymorphic _) =&gt; error (PolymorphicStatusExpected true)
  | (Polymorphic _, Monomorphic _) =&gt; error (PolymorphicStatusExpected false)
  end.

Definition check_variance
  (error : Modops.signature_mismatch_error -&gt; unit)
  (v1 : option (array Univ.Variance.t)) (v2 : option (array Univ.Variance.t))
  : unit :=
  match (v1, v2) with
  | (None, None) =&gt; tt
  | (Some v1, Some v2) =&gt;
    if
      negb (Util.Array.(CArray.ExtS.for_all2) Univ.Variance.check_subtype v2 v1)
      then
      error IncompatibleVariance
    else
      tt
  | (None, Some _) =&gt; error (CumulativeStatusExpected true)
  | (Some _, None) =&gt; error (CumulativeStatusExpected false)
  end.

Definition check_inductive
  (cst : Univ.Constraint.t) (env : Environ.env) (mp1 : Names.ModPath.t)
  (l : Names.Label.t) (info1 : namedobject) (mp2 : Names.ModPath.t)
  (mib2 : Declarations.mutual_inductive_body)
  (spec2 : Declarations.structure_field_body) (subst1 : Mod_subst.substitution)
  (subst2 : Mod_subst.substitution) (reso1 : Mod_subst.delta_resolver)
  (reso2 : Mod_subst.delta_resolver) : Univ.Constraint.t :=
  let kn1 := Names.KerName.make mp1 l in
  let kn2 := Names.KerName.make mp2 l in
  let error {A : Type} (why : Modops.signature_mismatch_error) : A :=
    Modops.error_signature_mismatch l spec2 why in
  let check_conv
    (why : Modops.signature_mismatch_error) (cst : Univ.Constraint.t) (poly :
    bool) (f :
    Environ.env -&gt; UGraph.t -&gt; Constr.types -&gt; Constr.types -&gt; Univ.Constraint.t)
    : Environ.env -&gt; Constr.types -&gt; Constr.types -&gt; Univ.Constraint.t :=
    check_conv_error error why cst poly f in
  let mib1 :=
    match info1 with
    | IndType (_, 0) mib =&gt; Declareops.subst_mind_body subst1 mib
    | _ =&gt; error (InductiveFieldExpected mib2)
    end in
  let env :=
    check_universes error env (mind_universes mib1) (mind_universes mib2) in
  match check_variance error (mind_variance mib1) (mind_variance mib2) with
  | tt =&gt;
    let inst :=
      Univ.make_abstract_instance
        (Declareops.inductive_polymorphic_context mib1) in
    let mib2 := Declareops.subst_mind_body subst2 mib2 in
    let check_inductive_type
      (cst : Univ.Constraint.t) (name : Names.Id.t) (t1 : Constr.types) (t2 :
      Constr.types) : Univ.Constraint.t :=
      check_conv (NotConvertibleInductiveField name) cst
        (Declareops.inductive_is_polymorphic mib1)
        (Reduction.infer_conv_leq None None None) env t1 t2 in
    let check_packet
      (cst : Univ.Constraint.t) (p1 : Declarations.one_inductive_body) (p2 :
      Declarations.one_inductive_body) : Univ.Constraint.t :=
      let check {A : Type}
        (f : Declarations.one_inductive_body -&gt; A) (test : A -&gt; A -&gt; bool) (why
        : Modops.signature_mismatch_error) : unit :=
        if negb (test (f p1) (f p2)) then
          error why
        else
          tt in
      check (fun p =&gt; mind_consnames p)
        (Util.Array.(CArray.ExtS.equal) Names.Id.equal)
        NotSameConstructorNamesField;
      check (fun p =&gt; mind_typename p) Names.Id.equal
        NotSameInductiveNameInBlockField;
      check (fun p =&gt; mind_nrealargs p) Int.equal
        (NotConvertibleInductiveField (mind_typename p2));
      let ty1 := Inductive.type_of_inductive env ((mib1, p1), inst) in
      let ty2 := Inductive.type_of_inductive env ((mib2, p2), inst) in
      let cst := check_inductive_type cst (mind_typename p2) ty1 ty2 in
      cst in
    let mind := Names.MutInd.make1 kn1 in
    let check_cons_types {A : Type}
      (_i : A) (cst : Univ.Constraint.t) (p1 : Declarations.one_inductive_body)
      (p2 : Declarations.one_inductive_body) : Univ.Constraint.t :=
      Util.Array.(CArray.ExtS.fold_left3)
        (fun cst =&gt;
          fun id =&gt;
            fun t1 =&gt;
              fun t2 =&gt;
                check_conv (NotConvertibleConstructorField id) cst
                  (Declareops.inductive_is_polymorphic mib1)
                  (Reduction.infer_conv None None None) env t1 t2) cst
        (mind_consnames p2)
        (Inductive.arities_of_specif (mind, inst) (mib1, p1))
        (Inductive.arities_of_specif (mind, inst) (mib2, p2)) in
    let check {A : Type}
      (f : Declarations.mutual_inductive_body -&gt; A) (test : A -&gt; A -&gt; bool) (why
      : A -&gt; Modops.signature_mismatch_error) : unit :=
      if negb (test (f mib1) (f mib2)) then
        error (why (f mib2))
      else
        tt in
    check (fun mib =&gt; nequiv_decb (mind_finite mib) CoFinite) Stdlib.op_eq_eq
      (fun x =&gt; FiniteInductiveFieldExpected x);
    check (fun mib =&gt; mind_ntypes mib) Int.equal
      (fun x =&gt; InductiveNumbersFieldExpected x);
    andb (Util.List.(CList.ExtS.is_empty) (mind_hyps mib1))
      (Util.List.(CList.ExtS.is_empty) (mind_hyps mib2));
    andb
      (OCaml.Stdlib.ge (Util.Array.(CArray.ExtS.length) (mind_packets mib1)) 1)
      (OCaml.Stdlib.ge (Util.Array.(CArray.ExtS.length) (mind_packets mib2)) 1);
    check (fun mib =&gt; mind_nparams mib) Int.equal
      (fun x =&gt; InductiveParamsNumberField x);
    let kn2' := Mod_subst.kn_of_delta reso2 kn2 in
    if
      orb (Names.KerName.equal kn2 kn2')
        (Names.MutInd.equal (Mod_subst.mind_of_delta_kn reso1 kn1)
          (Mod_subst.subst_mind subst2 (Names.MutInd.make kn2 kn2'))) then
      tt
    else
      error NotEqualInductiveAliases;
    check (fun mib =&gt; nequiv_decb (mind_record mib) NotRecord) Stdlib.op_eq_eq
      (fun x =&gt; RecordFieldExpected x);
    if nequiv_decb (mind_record mib1) NotRecord then
      let fix names_prod_letin (t : Constr.constr) : list Names.Name.t :=
        match Constr.kind t with
        | Prod n _ t =&gt; cons (binder_name n) (names_prod_letin t)
        | LetIn n _ _ t =&gt; cons (binder_name n) (names_prod_letin t)
        | Cast t _ _ =&gt; names_prod_letin t
        | _ =&gt; []
        end in
      Int.equal (Util.Array.(CArray.ExtS.length) (mind_packets mib1)) 1;
      Int.equal (Util.Array.(CArray.ExtS.length) (mind_packets mib2)) 1;
      Int.equal
        (Util.Array.(CArray.ExtS.length)
          (mind_user_lc (Util.Array.(CArray.ExtS.get) (mind_packets mib1) 0))) 1;
      Int.equal
        (Util.Array.(CArray.ExtS.length)
          (mind_user_lc (Util.Array.(CArray.ExtS.get) (mind_packets mib2) 0))) 1;
      check
        (fun mib =&gt;
          let nparamdecls :=
            Util.List.(CList.ExtS.length) (mind_params_ctxt mib) in
          let names :=
            names_prod_letin
              (Util.Array.(CArray.ExtS.get)
                (mind_user_lc
                  (Util.Array.(CArray.ExtS.get) (mind_packets mib) 0)) 0) in
          snd (Util.List.(CList.ExtS.chop) nparamdecls names))
        (Util.List.(CList.ExtS.equal) Names.Name.equal)
        (fun x =&gt; RecordProjectionsExpected x)
    else
      tt;
    let cst :=
      Util.Array.(CArray.ExtS.fold_left2) check_packet cst (mind_packets mib1)
        (mind_packets mib2) in
    let cst :=
      Util.Array.(CArray.ExtS.fold_left2_i) check_cons_types cst
        (mind_packets mib1) (mind_packets mib2) in
    cst
  end.

Definition check_constant
  (cst : Univ.Constraint.t) (env : Environ.env) (l : Names.Label.t)
  (info1 : namedobject) (cb2 : Declarations.constant_body Opaqueproof.opaque)
  (spec2 : Declarations.structure_field_body) (subst1 : Mod_subst.substitution)
  (subst2 : Mod_subst.substitution) : Univ.Constraint.t :=
  let error {A : Type} (why : Modops.signature_mismatch_error) : A :=
    Modops.error_signature_mismatch l spec2 why in
  let check_conv
    (cst : Modops.signature_mismatch_error) (poly : Univ.Constraint.t) (f :
    bool)
    : (Environ.env -&gt;
      UGraph.t -&gt; Constr.types -&gt; Constr.types -&gt; Univ.Constraint.t) -&gt;
      Environ.env -&gt; Constr.types -&gt; Constr.types -&gt; Univ.Constraint.t :=
    check_conv_error error cst poly f in
  let check_type
    (poly : bool) (cst : Univ.Constraint.t) (env : Environ.env) (t1 :
    Constr.types) (t2 : Constr.types) : Univ.Constraint.t :=
    let err := NotConvertibleTypeField env t1 t2 in
    check_conv err cst poly (Reduction.infer_conv_leq None None None) env t1 t2
    in
  match info1 with
  | Constant cb1 =&gt;
    match
      andb (Util.List.(CList.ExtS.is_empty) (const_hyps cb1))
        (Util.List.(CList.ExtS.is_empty) (const_hyps cb2)) with
    | tt =&gt;
      let cb1 := Declareops.subst_const_body subst1 cb1 in
      let cb2 := Declareops.subst_const_body subst2 cb2 in
      let env :=
        check_universes error env (const_universes cb1) (const_universes cb2) in
      let poly := Declareops.constant_is_polymorphic cb1 in
      let typ1 := const_type cb1 in
      let typ2 := const_type cb2 in
      let cst := check_type poly cst env typ1 typ2 in
      match const_body cb2 with
      | Primitive _ | Undef _ | OpaqueDef _ =&gt; cst
      | Def lc2 =&gt;
        match const_body cb1 with
        | Primitive _ | Undef _ | OpaqueDef _ =&gt; error NotConvertibleBodyField
        | Def lc1 =&gt;
          let c1 := Mod_subst.force_constr lc1 in
          let c2 := Mod_subst.force_constr lc2 in
          check_conv NotConvertibleBodyField cst poly
            (Reduction.infer_conv None None None) env c1 c2
        end
      end
    end
  | IndType (_kn, _i) _mind1 =&gt;
    CErrors.user_err None None
      (apply Pp.str
        (String.append
          &quot;The kernel does not recognize yet that a parameter can be &quot; % string
          (String.append
            &quot;instantiated by an inductive type. Hint: you can rename the &quot; %
              string
            (String.append
              &quot;inductive type and give a definition to map the old name to the new &quot;
                % string &quot;name.&quot; % string))))
  | IndConstr ((_kn, _i), _j) _mind1 =&gt;
    CErrors.user_err None None
      (apply Pp.str
        (String.append
          &quot;The kernel does not recognize yet that a parameter can be &quot; % string
          (String.append
            &quot;instantiated by a constructor. Hint: you can rename the &quot; % string
            (String.append
              &quot;constructor and give a definition to map the old name to the new &quot;
                % string &quot;name.&quot; % string))))
  end.

Fixpoint check_modules
  (cst : Univ.Constraint.t) (env : Environ.env)
  (msb1 : Declarations.module_body) (msb2 : Declarations.module_body)
  (subst1 : Mod_subst.substitution) (subst2 : Mod_subst.substitution)
  : Univ.Constraint.t :=
  let mty1 := Modops.module_type_of_module msb1 in
  let mty2 := Modops.module_type_of_module msb2 in
  check_modtypes cst env mty1 mty2 subst1 subst2 false

with check_signatures
  (cst : Univ.Constraint.t) (env : Environ.env) (mp1 : Names.ModPath.t)
  (sig1 : list (Names.Label.Map.key * Declarations.structure_field_body))
  (mp2 : Names.ModPath.t)
  (sig2 : list (Names.Label.Map.key * Declarations.structure_field_body))
  (subst1 : Mod_subst.substitution) (subst2 : Mod_subst.substitution)
  (reso1 : Mod_subst.delta_resolver) (reso2 : Mod_subst.delta_resolver)
  : Univ.Constraint.t :=
  let map1 := make_labmap mp1 sig1 in
  let check_one_body
    (cst : Univ.Constraint.t) (function_parameter :
    Names.Label.Map.key * Declarations.structure_field_body)
    : Univ.Constraint.t :=
    match function_parameter with
    | (l, spec2) =&gt;
      match spec2 with
      | SFBconst cb2 =&gt;
        check_constant cst env l (get_obj mp1 map1 l) cb2 spec2 subst1 subst2
      | SFBmind mib2 =&gt;
        check_inductive cst env mp1 l (get_obj mp1 map1 l) mp2 mib2 spec2 subst1
          subst2 reso1 reso2
      | SFBmodule msb2 =&gt;
        match get_mod mp1 map1 l with
        | Module msb =&gt; check_modules cst env msb msb2 subst1 subst2
        | _ =&gt; Modops.error_signature_mismatch l spec2 ModuleFieldExpected
        end
      | SFBmodtype mtb2 =&gt;
        let mtb1 :=
          match get_mod mp1 map1 l with
          | Modtype mtb =&gt; mtb
          | _ =&gt; Modops.error_signature_mismatch l spec2 ModuleTypeFieldExpected
          end in
        let env :=
          Modops.add_module_type (mod_mp mtb2) mtb2
            (Modops.add_module_type (mod_mp mtb1) mtb1 env) in
        check_modtypes cst env mtb1 mtb2 subst1 subst2 true
      end
    end in
  Util.List.(CList.ExtS.fold_left) check_one_body cst sig2

with check_modtypes
  (cst : Univ.Constraint.t) (env : Environ.env)
  (mtb1 : Declarations.module_type_body) (mtb2 : Declarations.module_type_body)
  (subst1 : Mod_subst.substitution) (subst2 : Mod_subst.substitution)
  (equiv : bool) : Univ.Constraint.t :=
  if
    orb (Stdlib.op_eq_eq mtb1 mtb2)
      (Stdlib.op_eq_eq (mod_type mtb1) (mod_type mtb2)) then
    cst
  else
    let fix check_structure
      (cst : Univ.Constraint.t) (env : Environ.env) (str1 :
      Declarations.functorize Declarations.module_type_body
        Declarations.structure_body) (str2 :
      Declarations.functorize Declarations.module_type_body
        (list (Names.Label.Map.key * Declarations.structure_field_body))) (equiv
      : bool) (subst1 : Mod_subst.substitution) (subst2 :
      Mod_subst.substitution) : Univ.Constraint.t :=
      match (str1, str2) with
      | (NoFunctor list1, NoFunctor list2) =&gt;
        if equiv then
          let subst2 :=
            Mod_subst.add_mp (mod_mp mtb2) (mod_mp mtb1) (mod_delta mtb1) subst2
            in
          let cst1 :=
            check_signatures cst env (mod_mp mtb1) list1 (mod_mp mtb2) list2
              subst1 subst2 (mod_delta mtb1) (mod_delta mtb2) in
          let cst2 :=
            check_signatures cst env (mod_mp mtb2) list2 (mod_mp mtb1) list1
              subst2 subst1 (mod_delta mtb2) (mod_delta mtb1) in
          Univ.Constraint.union cst1 cst2
        else
          check_signatures cst env (mod_mp mtb1) list1 (mod_mp mtb2) list2
            subst1 subst2 (mod_delta mtb1) (mod_delta mtb2)
      | (MoreFunctor arg_id1 arg_t1 body_t1, MoreFunctor arg_id2 arg_t2 body_t2)
        =&gt;
        let mp2 := MPbound arg_id2 in
        let subst1 :=
          Mod_subst.join (Mod_subst.map_mbid arg_id1 mp2 (mod_delta arg_t2))
            subst1 in
        let cst := check_modtypes cst env arg_t2 arg_t1 subst2 subst1 equiv in
        let env := Modops.add_module_type mp2 arg_t2 env in
        let env :=
          if Modops.is_functor body_t1 then
            env
          else
            Modops.add_module
              {| mod_mp := mod_mp mtb1; mod_expr := Abstract;
                mod_type := Modops.subst_signature subst1 body_t1;
                mod_type_alg := None; mod_constraints := mod_constraints mtb1;
                mod_delta := mod_delta mtb1; mod_retroknowledge := ModBodyRK []
                |} env in
        check_structure cst env body_t1 body_t2 equiv subst1 subst2
      | (_, _) =&gt; Modops.error_incompatible_modtypes mtb1 mtb2
      end in
    check_structure cst env (mod_type mtb1) (mod_type mtb2) equiv subst1 subst2.

Definition check_subtypes
  (env : Environ.env) (sup : Declarations.module_type_body)
  (super : Declarations.module_type_body) : Univ.Constraint.t :=
  let env := Modops.add_module_type (mod_mp sup) sup env in
  let env := Environ.push_context_set (Some true) (mod_constraints super) env in
  check_modtypes Univ.Constraint.empty env (Modops.strengthen sup (mod_mp sup))
    super Mod_subst.empty_subst
    (Mod_subst.map_mp (mod_mp super) (mod_mp sup) (mod_delta sup)) false.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="term" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>term.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Util
open Pp
open CErrors
open Names
open Vars
open Constr
open Context

(* Deprecated *)
type sorts_family = Sorts.family = InSProp | InProp | InSet | InType
[@@ocaml.deprecated &quot;Alias for Sorts.family&quot;]

type sorts = Sorts.t = private
  | SProp | Prop | Set
  | Type of Univ.Universe.t  (** Type *)
[@@ocaml.deprecated &quot;Alias for Sorts.t&quot;]

(****************************************************************************)
(*              Functions for dealing with constr terms                     *)
(****************************************************************************)

(***************************)
(* Other term constructors *)
(***************************)

let name_annot = map_annot Name.mk_name

let mkNamedProd id typ c = mkProd (name_annot id, typ, subst_var id.binder_name c)
let mkNamedLambda id typ c = mkLambda (name_annot id, typ, subst_var id.binder_name c)
let mkNamedLetIn id c1 t c2 = mkLetIn (name_annot id, c1, t, subst_var id.binder_name c2)

(* Constructs either [(x:t)c] or [[x=b:t]c] *)
let mkProd_or_LetIn decl c =
  let open Context.Rel.Declaration in
  match decl with
  | LocalAssum (na,t) -&gt; mkProd (na, t, c)
  | LocalDef (na,b,t) -&gt; mkLetIn (na, b, t, c)

let mkNamedProd_or_LetIn decl c =
  let open Context.Named.Declaration in
  match decl with
    | LocalAssum (id,t) -&gt; mkNamedProd id t c
    | LocalDef (id,b,t) -&gt; mkNamedLetIn id b t c

(* Constructs either [(x:t)c] or [c] where [x] is replaced by [b] *)
let mkProd_wo_LetIn decl c =
  let open Context.Rel.Declaration in
  match decl with
  | LocalAssum (na,t) -&gt; mkProd (na, t, c)
  | LocalDef (_na,b,_t) -&gt; subst1 b c

let mkNamedProd_wo_LetIn decl c =
  let open Context.Named.Declaration in
  match decl with
    | LocalAssum (id,t) -&gt; mkNamedProd id t c
    | LocalDef (id,b,_) -&gt; subst1 b (subst_var id.binder_name c)

(* non-dependent product t1 -&gt; t2 *)
let mkArrow t1 r t2 = mkProd (make_annot Anonymous r, t1, t2)
let mkArrowR t1 t2 = mkArrow t1 Sorts.Relevant t2

(* Constructs either [[x:t]c] or [[x=b:t]c] *)
let mkLambda_or_LetIn decl c =
  let open Context.Rel.Declaration in
  match decl with
    | LocalAssum (na,t) -&gt; mkLambda (na, t, c)
    | LocalDef (na,b,t) -&gt; mkLetIn (na, b, t, c)

let mkNamedLambda_or_LetIn decl c =
  let open Context.Named.Declaration in
  match decl with
    | LocalAssum (id,t) -&gt; mkNamedLambda id t c
    | LocalDef (id,b,t) -&gt; mkNamedLetIn id b t c

(* prodn n [xn:Tn;..;x1:T1;Gamma] b = (x1:T1)..(xn:Tn)b *)
let prodn n env b =
  let rec prodrec = function
    | (0, _env, b)        -&gt; b
    | (n, ((v,t)::l), b) -&gt; prodrec (n-1,  l, mkProd (v,t,b))
    | _ -&gt; assert false
  in
  prodrec (n,env,b)

(* compose_prod [xn:Tn;..;x1:T1] b = (x1:T1)..(xn:Tn)b *)
let compose_prod l b = prodn (List.length l) l b

(* lamn n [xn:Tn;..;x1:T1;Gamma] b = [x1:T1]..[xn:Tn]b *)
let lamn n env b =
  let rec lamrec = function
    | (0, _env, b)        -&gt; b
    | (n, ((v,t)::l), b) -&gt; lamrec (n-1,  l, mkLambda (v,t,b))
    | _ -&gt; assert false
  in
  lamrec (n,env,b)

(* compose_lam [xn:Tn;..;x1:T1] b = [x1:T1]..[xn:Tn]b *)
let compose_lam l b = lamn (List.length l) l b

let applist (f,l) = mkApp (f, Array.of_list l)

let applistc f l = mkApp (f, Array.of_list l)

let appvect = mkApp

let appvectc f l = mkApp (f,l)

(* to_lambda n (x1:T1)...(xn:Tn)T =
 * [x1:T1]...[xn:Tn]T *)
let rec to_lambda n prod =
  if Int.equal n 0 then
    prod
  else
    match kind prod with
      | Prod (na,ty,bd) -&gt; mkLambda (na,ty,to_lambda (n-1) bd)
      | Cast (c,_,_) -&gt; to_lambda n c
      | _   -&gt; user_err ~hdr:&quot;to_lambda&quot; (mt ())

let rec to_prod n lam =
  if Int.equal n 0 then
    lam
  else
    match kind lam with
      | Lambda (na,ty,bd) -&gt; mkProd (na,ty,to_prod (n-1) bd)
      | Cast (c,_,_) -&gt; to_prod n c
      | _   -&gt; user_err ~hdr:&quot;to_prod&quot; (mt ())

let it_mkProd_or_LetIn   = List.fold_left (fun c d -&gt; mkProd_or_LetIn d c)
let it_mkLambda_or_LetIn = List.fold_left (fun c d -&gt; mkLambda_or_LetIn d c)

(* Application with expected on-the-fly reduction *)

let lambda_applist c l =
  let rec app subst c l =
    match kind c, l with
    | Lambda(_,_,c), arg::l -&gt; app (arg::subst) c l
    | _, [] -&gt; substl subst c
    | _ -&gt; anomaly (Pp.str &quot;Not enough lambda's.&quot;) in
  app [] c l

let lambda_appvect c v = lambda_applist c (Array.to_list v)

let lambda_applist_assum n c l =
  let rec app n subst t l =
    if Int.equal n 0 then
      if l == [] then substl subst t
      else anomaly (Pp.str &quot;Too many arguments.&quot;)
    else match kind t, l with
    | Lambda(_,_,c), arg::l -&gt; app (n-1) (arg::subst) c l
    | LetIn(_,b,_,c), _ -&gt; app (n-1) (substl subst b::subst) c l
    | _, [] -&gt; anomaly (Pp.str &quot;Not enough arguments.&quot;)
    | _ -&gt; anomaly (Pp.str &quot;Not enough lambda/let's.&quot;) in
  app n [] c l

let lambda_appvect_assum n c v = lambda_applist_assum n c (Array.to_list v)

(* prod_applist T [ a1 ; ... ; an ] -&gt; (T a1 ... an) *)
let prod_applist c l =
  let rec app subst c l =
    match kind c, l with
    | Prod(_,_,c), arg::l -&gt; app (arg::subst) c l
    | _, [] -&gt; substl subst c
    | _ -&gt; anomaly (Pp.str &quot;Not enough prod's.&quot;) in
  app [] c l

(* prod_appvect T [| a1 ; ... ; an |] -&gt; (T a1 ... an) *)
let prod_appvect c v = prod_applist c (Array.to_list v)

let prod_applist_assum n c l =
  let rec app n subst t l =
    if Int.equal n 0 then
      if l == [] then substl subst t
      else anomaly (Pp.str &quot;Too many arguments.&quot;)
    else match kind t, l with
    | Prod(_,_,c), arg::l -&gt; app (n-1) (arg::subst) c l
    | LetIn(_,b,_,c), _ -&gt; app (n-1) (substl subst b::subst) c l
    | _, [] -&gt; anomaly (Pp.str &quot;Not enough arguments.&quot;)
    | _ -&gt; anomaly (Pp.str &quot;Not enough prod/let's.&quot;) in
  app n [] c l

let prod_appvect_assum n c v = prod_applist_assum n c (Array.to_list v)

(*********************************)
(* Other term destructors        *)
(*********************************)

(* Transforms a product term (x1:T1)..(xn:Tn)T into the pair
   ([(xn,Tn);...;(x1,T1)],T), where T is not a product *)
let decompose_prod =
  let rec prodec_rec l c = match kind c with
    | Prod (x,t,c) -&gt; prodec_rec ((x,t)::l) c
    | Cast (c,_,_)   -&gt; prodec_rec l c
    | _              -&gt; l,c
  in
  prodec_rec []

(* Transforms a lambda term [x1:T1]..[xn:Tn]T into the pair
   ([(xn,Tn);...;(x1,T1)],T), where T is not a lambda *)
let decompose_lam =
  let rec lamdec_rec l c = match kind c with
    | Lambda (x,t,c) -&gt; lamdec_rec ((x,t)::l) c
    | Cast (c,_,_)     -&gt; lamdec_rec l c
    | _                -&gt; l,c
  in
  lamdec_rec []

(* Given a positive integer n, transforms a product term (x1:T1)..(xn:Tn)T
   into the pair ([(xn,Tn);...;(x1,T1)],T) *)
let decompose_prod_n n =
  if n &lt; 0 then user_err (str &quot;decompose_prod_n: integer parameter must be positive&quot;);
  let rec prodec_rec l n c =
    if Int.equal n 0 then l,c
    else match kind c with
      | Prod (x,t,c) -&gt; prodec_rec ((x,t)::l) (n-1) c
      | Cast (c,_,_)   -&gt; prodec_rec l n c
      | _ -&gt; user_err (str &quot;decompose_prod_n: not enough products&quot;)
  in
  prodec_rec [] n

(* Given a positive integer n, transforms a lambda term [x1:T1]..[xn:Tn]T
   into the pair ([(xn,Tn);...;(x1,T1)],T) *)
let decompose_lam_n n =
  if n &lt; 0 then user_err (str &quot;decompose_lam_n: integer parameter must be positive&quot;);
  let rec lamdec_rec l n c =
    if Int.equal n 0 then l,c
    else match kind c with
      | Lambda (x,t,c) -&gt; lamdec_rec ((x,t)::l) (n-1) c
      | Cast (c,_,_)     -&gt; lamdec_rec l n c
      | _ -&gt; user_err (str &quot;decompose_lam_n: not enough abstractions&quot;)
  in
  lamdec_rec [] n

(* Transforms a product term (x1:T1)..(xn:Tn)T into the pair
   ([(xn,Tn);...;(x1,T1)],T), where T is not a product *)
let decompose_prod_assum =
  let open Context.Rel.Declaration in
  let rec prodec_rec l c =
    match kind c with
    | Prod (x,t,c)    -&gt; prodec_rec (Context.Rel.add (LocalAssum (x,t)) l) c
    | LetIn (x,b,t,c) -&gt; prodec_rec (Context.Rel.add (LocalDef (x,b,t)) l) c
    | Cast (c,_,_)      -&gt; prodec_rec l c
    | _               -&gt; l,c
  in
  prodec_rec Context.Rel.empty

(* Transforms a lambda term [x1:T1]..[xn:Tn]T into the pair
   ([(xn,Tn);...;(x1,T1)],T), where T is not a lambda *)
let decompose_lam_assum =
  let rec lamdec_rec l c =
    let open Context.Rel.Declaration in
    match kind c with
    | Lambda (x,t,c)  -&gt; lamdec_rec (Context.Rel.add (LocalAssum (x,t)) l) c
    | LetIn (x,b,t,c) -&gt; lamdec_rec (Context.Rel.add (LocalDef (x,b,t)) l) c
    | Cast (c,_,_)      -&gt; lamdec_rec l c
    | _               -&gt; l,c
  in
  lamdec_rec Context.Rel.empty

(* Given a positive integer n, decompose a product or let-in term
   of the form [forall (x1:T1)..(xi:=ci:Ti)..(xn:Tn), T] into the pair
   of the quantifying context [(xn,None,Tn);..;(xi,Some
   ci,Ti);..;(x1,None,T1)] and of the inner type [T]) *)
let decompose_prod_n_assum n =
  if n &lt; 0 then
    user_err (str &quot;decompose_prod_n_assum: integer parameter must be positive&quot;);
  let rec prodec_rec l n c =
    if Int.equal n 0 then l,c
    else
      let open Context.Rel.Declaration in
      match kind c with
      | Prod (x,t,c)    -&gt; prodec_rec (Context.Rel.add (LocalAssum (x,t)) l) (n-1) c
      | LetIn (x,b,t,c) -&gt; prodec_rec (Context.Rel.add (LocalDef (x,b,t)) l) (n-1) c
      | Cast (c,_,_)      -&gt; prodec_rec l n c
      | _ -&gt; user_err (str  &quot;decompose_prod_n_assum: not enough assumptions&quot;)
  in
  prodec_rec Context.Rel.empty n

(* Given a positive integer n, decompose a lambda or let-in term [fun
   (x1:T1)..(xi:=ci:Ti)..(xn:Tn) =&gt; T] into the pair of the abstracted
   context [(xn,None,Tn);...;(xi,Some ci,Ti);...;(x1,None,T1)] and of
   the inner body [T].
   Lets in between are not expanded but turn into local definitions,
   but n is the actual number of destructurated lambdas. *)
let decompose_lam_n_assum n =
  if n &lt; 0 then
    user_err (str  &quot;decompose_lam_n_assum: integer parameter must be positive&quot;);
  let rec lamdec_rec l n c =
    if Int.equal n 0 then l,c
    else
      let open Context.Rel.Declaration in
      match kind c with
      | Lambda (x,t,c)  -&gt; lamdec_rec (Context.Rel.add (LocalAssum (x,t)) l) (n-1) c
      | LetIn (x,b,t,c) -&gt; lamdec_rec (Context.Rel.add (LocalDef (x,b,t)) l) n c
      | Cast (c,_,_)      -&gt; lamdec_rec l n c
      | _c -&gt; user_err (str &quot;decompose_lam_n_assum: not enough abstractions&quot;)
  in
  lamdec_rec Context.Rel.empty n

(* Same, counting let-in *)
let decompose_lam_n_decls n =
  if n &lt; 0 then
    user_err (str &quot;decompose_lam_n_decls: integer parameter must be positive&quot;);
  let rec lamdec_rec l n c =
    if Int.equal n 0 then l,c
    else
      let open Context.Rel.Declaration in
      match kind c with
      | Lambda (x,t,c)  -&gt; lamdec_rec (Context.Rel.add (LocalAssum (x,t)) l) (n-1) c
      | LetIn (x,b,t,c) -&gt; lamdec_rec (Context.Rel.add (LocalDef (x,b,t)) l) (n-1) c
      | Cast (c,_,_)      -&gt; lamdec_rec l n c
      | _ -&gt; user_err (str &quot;decompose_lam_n_decls: not enough abstractions&quot;)
  in
  lamdec_rec Context.Rel.empty n

let prod_assum t = fst (decompose_prod_assum t)
let prod_n_assum n t = fst (decompose_prod_n_assum n t)
let strip_prod_assum t = snd (decompose_prod_assum t)
let strip_prod t = snd (decompose_prod t)
let strip_prod_n n t = snd (decompose_prod_n n t)
let lam_assum t = fst (decompose_lam_assum t)
let lam_n_assum n t = fst (decompose_lam_n_assum n t)
let strip_lam_assum t = snd (decompose_lam_assum t)
let strip_lam t = snd (decompose_lam t)
let strip_lam_n n t = snd (decompose_lam_n n t)

(***************************)
(* Arities                 *)
(***************************)

(* An &quot;arity&quot; is a term of the form [[x1:T1]...[xn:Tn]s] with [s] a sort.
   Such a term can canonically be seen as the pair of a context of types
   and of a sort *)

type arity = Constr.rel_context * Sorts.t

let destArity =
  let open Context.Rel.Declaration in
  let rec prodec_rec l c =
    match kind c with
    | Prod (x,t,c)    -&gt; prodec_rec (LocalAssum (x,t) :: l) c
    | LetIn (x,b,t,c) -&gt; prodec_rec (LocalDef (x,b,t) :: l) c
    | Cast (c,_,_)      -&gt; prodec_rec l c
    | Sort s          -&gt; l,s
    | _               -&gt; anomaly ~label:&quot;destArity&quot; (Pp.str &quot;not an arity.&quot;)
  in
  prodec_rec []

let mkArity (sign,s) = it_mkProd_or_LetIn (mkSort s) sign

let rec isArity c =
  match kind c with
  | Prod (_,_,c)    -&gt; isArity c
  | LetIn (_,b,_,c) -&gt; isArity (subst1 b c)
  | Cast (c,_,_)      -&gt; isArity c
  | Sort _          -&gt; true
  | _               -&gt; false

(** Kind of type *)

(* Experimental, used in Presburger contrib *)
type ('constr, 'types) kind_of_type =
  | SortType   of Sorts.t
  | CastType   of 'types * 'types
  | ProdType   of Name.t Context.binder_annot * 'types * 'types
  | LetInType  of Name.t Context.binder_annot * 'constr * 'types * 'types
  | AtomicType of 'constr * 'constr array

let kind_of_type t = match kind t with
  | Sort s -&gt; SortType s
  | Cast (c,_,t) -&gt; CastType (c, t)
  | Prod (na,t,c) -&gt; ProdType (na, t, c)
  | LetIn (na,b,t,c) -&gt; LetInType (na, b, t, c)
  | App (c,l) -&gt; AtomicType (c, l)
  | (Rel _ | Meta _ | Var _ | Evar _ | Const _ 
  | Proj _ | Case _ | Fix _ | CoFix _ | Ind _)
    -&gt; AtomicType (t,[||])
  | (Lambda _ | Construct _ | Int _) -&gt; failwith &quot;Not a type&quot;
</pre>
          </div>
          <div class="col-md-6">
            <code>term.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Util.

Import Pp.

Import CErrors.

Import Names.

Import Vars.

Import Constr.

Import Context.

Inductive sorts_family : Type :=
| InSProp : sorts_family
| InProp : sorts_family
| InSet : sorts_family
| InType : sorts_family.

Inductive sorts : Type :=
| SProp : sorts
| Prop : sorts
| Set : sorts
| Type : Univ.Universe.t -&gt; sorts.

Definition name_annot
  : (Context.binder_annot Names.Id.t) -&gt; Context.binder_annot Names.Name.t :=
  Context.map_annot Names.Name.mk_name.

Definition mkNamedProd
  (id : Context.binder_annot Names.Id.t) (typ : Constr.types)
  (c : Constr.constr) : Constr.types :=
  Constr.mkProd ((name_annot id), typ, (Vars.subst_var (binder_name id) c)).

Definition mkNamedLambda
  (id : Context.binder_annot Names.Id.t) (typ : Constr.types)
  (c : Constr.constr) : Constr.constr :=
  Constr.mkLambda ((name_annot id), typ, (Vars.subst_var (binder_name id) c)).

Definition mkNamedLetIn
  (id : Context.binder_annot Names.Id.t) (c1 : Constr.constr) (t : Constr.types)
  (c2 : Constr.constr) : Constr.constr :=
  Constr.mkLetIn ((name_annot id), c1, t, (Vars.subst_var (binder_name id) c2)).

Definition mkProd_or_LetIn
  (decl : Context.Rel.Declaration.pt Constr.constr Constr.types)
  (c : Constr.types) : Constr.types :=
  match decl with
  | LocalAssum na t =&gt; Constr.mkProd (na, t, c)
  | LocalDef na b t =&gt; Constr.mkLetIn (na, b, t, c)
  end.

Definition mkNamedProd_or_LetIn
  (decl : Context.Named.Declaration.pt Constr.constr Constr.types)
  (c : Constr.constr) : Constr.types :=
  match decl with
  | LocalAssum id t =&gt; mkNamedProd id t c
  | LocalDef id b t =&gt; mkNamedLetIn id b t c
  end.

Definition mkProd_wo_LetIn
  (decl : Context.Rel.Declaration.pt Constr.constr Constr.types)
  (c : Constr.types) : Constr.types :=
  match decl with
  | LocalAssum na t =&gt; Constr.mkProd (na, t, c)
  | LocalDef _na b _t =&gt; Vars.subst1 b c
  end.

Definition mkNamedProd_wo_LetIn
  (decl : Context.Named.Declaration.pt Constr.constr Constr.types)
  (c : Constr.constr) : Constr.types :=
  match decl with
  | LocalAssum id t =&gt; mkNamedProd id t c
  | LocalDef id b _ =&gt; Vars.subst1 b (Vars.subst_var (binder_name id) c)
  end.

Definition mkArrow (t1 : Constr.types) (r : Sorts.relevance) (t2 : Constr.types)
  : Constr.types := Constr.mkProd ((Context.make_annot Anonymous r), t1, t2).

Definition mkArrowR (t1 : Constr.types) (t2 : Constr.types) : Constr.types :=
  mkArrow t1 Sorts.Relevant t2.

Definition mkLambda_or_LetIn
  (decl : Context.Rel.Declaration.pt Constr.constr Constr.types)
  (c : Constr.constr) : Constr.constr :=
  match decl with
  | LocalAssum na t =&gt; Constr.mkLambda (na, t, c)
  | LocalDef na b t =&gt; Constr.mkLetIn (na, b, t, c)
  end.

Definition mkNamedLambda_or_LetIn
  (decl : Context.Named.Declaration.pt Constr.constr Constr.types)
  (c : Constr.constr) : Constr.constr :=
  match decl with
  | LocalAssum id t =&gt; mkNamedLambda id t c
  | LocalDef id b t =&gt; mkNamedLetIn id b t c
  end.

Definition prodn
  (n : Z) (env : list ((Context.binder_annot Names.Name.t) * Constr.types))
  (b : Constr.types) : Constr.types :=
  let fix prodrec
    (function_parameter :
    Z * (list ((Context.binder_annot Names.Name.t) * Constr.types)) *
      Constr.types) : Constr.types :=
    match function_parameter with
    | (0, _env, b) =&gt; b
    | (n, cons (v, t) l, b) =&gt;
      prodrec ((Util.op_minus n 1), l, (Constr.mkProd (v, t, b)))
    | _ =&gt; false
    end in
  prodrec (n, env, b).

Definition compose_prod
  (l : list ((Context.binder_annot Names.Name.t) * Constr.types))
  (b : Constr.types) : Constr.types :=
  prodn (Util.List.(CList.ExtS.length) l) l b.

Definition lamn
  (n : Z) (env : list ((Context.binder_annot Names.Name.t) * Constr.types))
  (b : Constr.constr) : Constr.constr :=
  let fix lamrec
    (function_parameter :
    Z * (list ((Context.binder_annot Names.Name.t) * Constr.types)) *
      Constr.constr) : Constr.constr :=
    match function_parameter with
    | (0, _env, b) =&gt; b
    | (n, cons (v, t) l, b) =&gt;
      lamrec ((Util.op_minus n 1), l, (Constr.mkLambda (v, t, b)))
    | _ =&gt; false
    end in
  lamrec (n, env, b).

Definition compose_lam
  (l : list ((Context.binder_annot Names.Name.t) * Constr.types))
  (b : Constr.constr) : Constr.constr :=
  lamn (Util.List.(CList.ExtS.length) l) l b.

Definition applist (function_parameter : Constr.constr * (list Constr.constr))
  : Constr.constr :=
  match function_parameter with
  | (f, l) =&gt; Constr.mkApp (f, (Util.Array.(CArray.ExtS.of_list) l))
  end.

Definition applistc (f : Constr.constr) (l : list Constr.constr)
  : Constr.constr := Constr.mkApp (f, (Util.Array.(CArray.ExtS.of_list) l)).

Definition appvect : (Constr.constr * (array Constr.constr)) -&gt; Constr.constr :=
  Constr.mkApp.

Definition appvectc (f : Constr.constr) (l : array Constr.constr)
  : Constr.constr := Constr.mkApp (f, l).

Fixpoint to_lambda (n : Int.t) (prod : Constr.constr) : Constr.constr :=
  if Int.equal n 0 then
    prod
  else
    match Constr.kind prod with
    | Prod na ty bd =&gt;
      Constr.mkLambda (na, ty, (to_lambda (Util.op_minus n 1) bd))
    | Cast c _ _ =&gt; to_lambda n c
    | _ =&gt; CErrors.user_err None (Some &quot;to_lambda&quot; % string) (Pp.mt tt)
    end.

Fixpoint to_prod (n : Int.t) (lam : Constr.constr) : Constr.constr :=
  if Int.equal n 0 then
    lam
  else
    match Constr.kind lam with
    | Lambda na ty bd =&gt;
      Constr.mkProd (na, ty, (to_prod (Util.op_minus n 1) bd))
    | Cast c _ _ =&gt; to_prod n c
    | _ =&gt; CErrors.user_err None (Some &quot;to_prod&quot; % string) (Pp.mt tt)
    end.

Definition it_mkProd_or_LetIn
  : Constr.types -&gt;
    (list (Context.Rel.Declaration.pt Constr.constr Constr.types)) -&gt;
      Constr.types :=
  Util.List.(CList.ExtS.fold_left) (fun c =&gt; fun d =&gt; mkProd_or_LetIn d c).

Definition it_mkLambda_or_LetIn
  : Constr.constr -&gt;
    (list (Context.Rel.Declaration.pt Constr.constr Constr.types)) -&gt;
      Constr.constr :=
  Util.List.(CList.ExtS.fold_left) (fun c =&gt; fun d =&gt; mkLambda_or_LetIn d c).

Definition lambda_applist (c : Constr.constr) (l : list Constr.constr)
  : Constr.constr :=
  let fix app (subst : Vars.substl) (c : Constr.constr) (l : list Constr.constr)
    : Constr.constr :=
    match ((Constr.kind c), l) with
    | (Lambda _ _ c, cons arg l) =&gt; app (cons arg subst) c l
    | (_, []) =&gt; Vars.substl subst c
    | _ =&gt; CErrors.anomaly None None (Pp.str &quot;Not enough lambda's.&quot; % string)
    end in
  app [] c l.

Definition lambda_appvect (c : Constr.constr) (v : array Constr.constr)
  : Constr.constr := lambda_applist c (Util.Array.(CArray.ExtS.to_list) v).

Definition lambda_applist_assum
  (n : Int.t) (c : Constr.constr) (l : list Constr.constr) : Constr.constr :=
  let fix app
    (n : Int.t) (subst : Vars.substl) (t : Constr.constr) (l :
    list Constr.constr) : Constr.constr :=
    if Int.equal n 0 then
      if Stdlib.op_eq_eq l [] then
        Vars.substl subst t
      else
        CErrors.anomaly None None (Pp.str &quot;Too many arguments.&quot; % string)
    else
      match ((Constr.kind t), l) with
      | (Lambda _ _ c, cons arg l) =&gt;
        app (Util.op_minus n 1) (cons arg subst) c l
      | (LetIn _ b _ c, _) =&gt;
        app (Util.op_minus n 1) (cons (Vars.substl subst b) subst) c l
      | (_, []) =&gt;
        CErrors.anomaly None None (Pp.str &quot;Not enough arguments.&quot; % string)
      | _ =&gt;
        CErrors.anomaly None None (Pp.str &quot;Not enough lambda/let's.&quot; % string)
      end in
  app n [] c l.

Definition lambda_appvect_assum
  (n : Int.t) (c : Constr.constr) (v : array Constr.constr) : Constr.constr :=
  lambda_applist_assum n c (Util.Array.(CArray.ExtS.to_list) v).

Definition prod_applist (c : Constr.constr) (l : list Constr.constr)
  : Constr.constr :=
  let fix app (subst : Vars.substl) (c : Constr.constr) (l : list Constr.constr)
    : Constr.constr :=
    match ((Constr.kind c), l) with
    | (Prod _ _ c, cons arg l) =&gt; app (cons arg subst) c l
    | (_, []) =&gt; Vars.substl subst c
    | _ =&gt; CErrors.anomaly None None (Pp.str &quot;Not enough prod's.&quot; % string)
    end in
  app [] c l.

Definition prod_appvect (c : Constr.constr) (v : array Constr.constr)
  : Constr.constr := prod_applist c (Util.Array.(CArray.ExtS.to_list) v).

Definition prod_applist_assum
  (n : Int.t) (c : Constr.constr) (l : list Constr.constr) : Constr.constr :=
  let fix app
    (n : Int.t) (subst : Vars.substl) (t : Constr.constr) (l :
    list Constr.constr) : Constr.constr :=
    if Int.equal n 0 then
      if Stdlib.op_eq_eq l [] then
        Vars.substl subst t
      else
        CErrors.anomaly None None (Pp.str &quot;Too many arguments.&quot; % string)
    else
      match ((Constr.kind t), l) with
      | (Prod _ _ c, cons arg l) =&gt; app (Util.op_minus n 1) (cons arg subst) c l
      | (LetIn _ b _ c, _) =&gt;
        app (Util.op_minus n 1) (cons (Vars.substl subst b) subst) c l
      | (_, []) =&gt;
        CErrors.anomaly None None (Pp.str &quot;Not enough arguments.&quot; % string)
      | _ =&gt;
        CErrors.anomaly None None (Pp.str &quot;Not enough prod/let's.&quot; % string)
      end in
  app n [] c l.

Definition prod_appvect_assum
  (n : Int.t) (c : Constr.constr) (v : array Constr.constr) : Constr.constr :=
  prod_applist_assum n c (Util.Array.(CArray.ExtS.to_list) v).

Definition decompose_prod
  : Constr.constr -&gt;
    (list ((Context.binder_annot Names.Name.t) * Constr.types)) * Constr.constr :=
  let fix prodec_rec
    (l : list ((Context.binder_annot Names.Name.t) * Constr.types)) (c :
    Constr.constr)
    : (list ((Context.binder_annot Names.Name.t) * Constr.types)) *
      Constr.constr :=
    match Constr.kind c with
    | Prod x t c =&gt; prodec_rec (cons (x, t) l) c
    | Cast c _ _ =&gt; prodec_rec l c
    | _ =&gt; (l, c)
    end in
  prodec_rec [].

Definition decompose_lam
  : Constr.constr -&gt;
    (list ((Context.binder_annot Names.Name.t) * Constr.types)) * Constr.constr :=
  let fix lamdec_rec
    (l : list ((Context.binder_annot Names.Name.t) * Constr.types)) (c :
    Constr.constr)
    : (list ((Context.binder_annot Names.Name.t) * Constr.types)) *
      Constr.constr :=
    match Constr.kind c with
    | Lambda x t c =&gt; lamdec_rec (cons (x, t) l) c
    | Cast c _ _ =&gt; lamdec_rec l c
    | _ =&gt; (l, c)
    end in
  lamdec_rec [].

Definition decompose_prod_n (n : Int.t)
  : Constr.constr -&gt;
    (list ((Context.binder_annot Names.Name.t) * Constr.types)) * Constr.constr :=
  if OCaml.Stdlib.lt n 0 then
    CErrors.user_err None None
      (Pp.str &quot;decompose_prod_n: integer parameter must be positive&quot; % string)
  else
    tt;
  let fix prodec_rec
    (l : list ((Context.binder_annot Names.Name.t) * Constr.types)) (n : Int.t)
    (c : Constr.constr)
    : (list ((Context.binder_annot Names.Name.t) * Constr.types)) *
      Constr.constr :=
    if Int.equal n 0 then
      (l, c)
    else
      match Constr.kind c with
      | Prod x t c =&gt; prodec_rec (cons (x, t) l) (Util.op_minus n 1) c
      | Cast c _ _ =&gt; prodec_rec l n c
      | _ =&gt;
        CErrors.user_err None None
          (Pp.str &quot;decompose_prod_n: not enough products&quot; % string)
      end in
  prodec_rec [] n.

Definition decompose_lam_n (n : Int.t)
  : Constr.constr -&gt;
    (list ((Context.binder_annot Names.Name.t) * Constr.types)) * Constr.constr :=
  if OCaml.Stdlib.lt n 0 then
    CErrors.user_err None None
      (Pp.str &quot;decompose_lam_n: integer parameter must be positive&quot; % string)
  else
    tt;
  let fix lamdec_rec
    (l : list ((Context.binder_annot Names.Name.t) * Constr.types)) (n : Int.t)
    (c : Constr.constr)
    : (list ((Context.binder_annot Names.Name.t) * Constr.types)) *
      Constr.constr :=
    if Int.equal n 0 then
      (l, c)
    else
      match Constr.kind c with
      | Lambda x t c =&gt; lamdec_rec (cons (x, t) l) (Util.op_minus n 1) c
      | Cast c _ _ =&gt; lamdec_rec l n c
      | _ =&gt;
        CErrors.user_err None None
          (Pp.str &quot;decompose_lam_n: not enough abstractions&quot; % string)
      end in
  lamdec_rec [] n.

Definition decompose_prod_assum
  : Constr.constr -&gt; (Context.Rel.pt Constr.constr Constr.types) * Constr.constr :=
  let fix prodec_rec
    (l : Context.Rel.pt Constr.constr Constr.types) (c : Constr.constr)
    : (Context.Rel.pt Constr.constr Constr.types) * Constr.constr :=
    match Constr.kind c with
    | Prod x t c =&gt; prodec_rec (Context.Rel.add (LocalAssum x t) l) c
    | LetIn x b t c =&gt; prodec_rec (Context.Rel.add (LocalDef x b t) l) c
    | Cast c _ _ =&gt; prodec_rec l c
    | _ =&gt; (l, c)
    end in
  prodec_rec Context.Rel.empty.

Definition decompose_lam_assum
  : Constr.constr -&gt; (Context.Rel.pt Constr.constr Constr.types) * Constr.constr :=
  let fix lamdec_rec
    (l : Context.Rel.pt Constr.constr Constr.types) (c : Constr.constr)
    : (Context.Rel.pt Constr.constr Constr.types) * Constr.constr :=
    match Constr.kind c with
    | Lambda x t c =&gt; lamdec_rec (Context.Rel.add (LocalAssum x t) l) c
    | LetIn x b t c =&gt; lamdec_rec (Context.Rel.add (LocalDef x b t) l) c
    | Cast c _ _ =&gt; lamdec_rec l c
    | _ =&gt; (l, c)
    end in
  lamdec_rec Context.Rel.empty.

Definition decompose_prod_n_assum (n : Int.t)
  : Constr.constr -&gt; (Context.Rel.pt Constr.constr Constr.types) * Constr.constr :=
  if OCaml.Stdlib.lt n 0 then
    CErrors.user_err None None
      (Pp.str
        &quot;decompose_prod_n_assum: integer parameter must be positive&quot; % string)
  else
    tt;
  let fix prodec_rec
    (l : Context.Rel.pt Constr.constr Constr.types) (n : Int.t) (c :
    Constr.constr)
    : (Context.Rel.pt Constr.constr Constr.types) * Constr.constr :=
    if Int.equal n 0 then
      (l, c)
    else
      match Constr.kind c with
      | Prod x t c =&gt;
        prodec_rec (Context.Rel.add (LocalAssum x t) l) (Util.op_minus n 1) c
      | LetIn x b t c =&gt;
        prodec_rec (Context.Rel.add (LocalDef x b t) l) (Util.op_minus n 1) c
      | Cast c _ _ =&gt; prodec_rec l n c
      | _ =&gt;
        CErrors.user_err None None
          (Pp.str &quot;decompose_prod_n_assum: not enough assumptions&quot; % string)
      end in
  prodec_rec Context.Rel.empty n.

Definition decompose_lam_n_assum (n : Int.t)
  : Constr.constr -&gt; (Context.Rel.pt Constr.constr Constr.types) * Constr.constr :=
  if OCaml.Stdlib.lt n 0 then
    CErrors.user_err None None
      (Pp.str
        &quot;decompose_lam_n_assum: integer parameter must be positive&quot; % string)
  else
    tt;
  let fix lamdec_rec
    (l : Context.Rel.pt Constr.constr Constr.types) (n : Int.t) (c :
    Constr.constr)
    : (Context.Rel.pt Constr.constr Constr.types) * Constr.constr :=
    if Int.equal n 0 then
      (l, c)
    else
      match Constr.kind c with
      | Lambda x t c =&gt;
        lamdec_rec (Context.Rel.add (LocalAssum x t) l) (Util.op_minus n 1) c
      | LetIn x b t c =&gt; lamdec_rec (Context.Rel.add (LocalDef x b t) l) n c
      | Cast c _ _ =&gt; lamdec_rec l n c
      | _c =&gt;
        CErrors.user_err None None
          (Pp.str &quot;decompose_lam_n_assum: not enough abstractions&quot; % string)
      end in
  lamdec_rec Context.Rel.empty n.

Definition decompose_lam_n_decls (n : Int.t)
  : Constr.constr -&gt; (Context.Rel.pt Constr.constr Constr.types) * Constr.constr :=
  if OCaml.Stdlib.lt n 0 then
    CErrors.user_err None None
      (Pp.str
        &quot;decompose_lam_n_decls: integer parameter must be positive&quot; % string)
  else
    tt;
  let fix lamdec_rec
    (l : Context.Rel.pt Constr.constr Constr.types) (n : Int.t) (c :
    Constr.constr)
    : (Context.Rel.pt Constr.constr Constr.types) * Constr.constr :=
    if Int.equal n 0 then
      (l, c)
    else
      match Constr.kind c with
      | Lambda x t c =&gt;
        lamdec_rec (Context.Rel.add (LocalAssum x t) l) (Util.op_minus n 1) c
      | LetIn x b t c =&gt;
        lamdec_rec (Context.Rel.add (LocalDef x b t) l) (Util.op_minus n 1) c
      | Cast c _ _ =&gt; lamdec_rec l n c
      | _ =&gt;
        CErrors.user_err None None
          (Pp.str &quot;decompose_lam_n_decls: not enough abstractions&quot; % string)
      end in
  lamdec_rec Context.Rel.empty n.

Definition prod_assum (t : Constr.constr)
  : Context.Rel.pt Constr.constr Constr.types := fst (decompose_prod_assum t).

Definition prod_n_assum (n : Int.t) (t : Constr.constr)
  : Context.Rel.pt Constr.constr Constr.types :=
  fst (decompose_prod_n_assum n t).

Definition strip_prod_assum (t : Constr.constr) : Constr.constr :=
  snd (decompose_prod_assum t).

Definition strip_prod (t : Constr.constr) : Constr.constr :=
  snd (decompose_prod t).

Definition strip_prod_n (n : Int.t) (t : Constr.constr) : Constr.constr :=
  snd (decompose_prod_n n t).

Definition lam_assum (t : Constr.constr)
  : Context.Rel.pt Constr.constr Constr.types := fst (decompose_lam_assum t).

Definition lam_n_assum (n : Int.t) (t : Constr.constr)
  : Context.Rel.pt Constr.constr Constr.types := fst (decompose_lam_n_assum n t).

Definition strip_lam_assum (t : Constr.constr) : Constr.constr :=
  snd (decompose_lam_assum t).

Definition strip_lam (t : Constr.constr) : Constr.constr :=
  snd (decompose_lam t).

Definition strip_lam_n (n : Int.t) (t : Constr.constr) : Constr.constr :=
  snd (decompose_lam_n n t).

Definition arity := Constr.rel_context * Sorts.t.

Definition destArity
  : Constr.constr -&gt;
    (list (Context.Rel.Declaration.pt Constr.constr Constr.types)) * Sorts.t :=
  let fix prodec_rec
    (l : list (Context.Rel.Declaration.pt Constr.constr Constr.types)) (c :
    Constr.constr)
    : (list (Context.Rel.Declaration.pt Constr.constr Constr.types)) * Sorts.t :=
    match Constr.kind c with
    | Prod x t c =&gt; prodec_rec (cons (LocalAssum x t) l) c
    | LetIn x b t c =&gt; prodec_rec (cons (LocalDef x b t) l) c
    | Cast c _ _ =&gt; prodec_rec l c
    | Sort s =&gt; (l, s)
    | _ =&gt;
      CErrors.anomaly None (Some &quot;destArity&quot; % string)
        (Pp.str &quot;not an arity.&quot; % string)
    end in
  prodec_rec [].

Definition mkArity
  (function_parameter :
    (list (Context.Rel.Declaration.pt Constr.constr Constr.types)) * Sorts.t)
  : Constr.types :=
  match function_parameter with
  | (sign, s) =&gt; it_mkProd_or_LetIn (Constr.mkSort s) sign
  end.

Fixpoint isArity (c : Constr.constr) : bool :=
  match Constr.kind c with
  | Prod _ _ c =&gt; isArity c
  | LetIn _ b _ c =&gt; isArity (Vars.subst1 b c)
  | Cast c _ _ =&gt; isArity c
  | Sort _ =&gt; true
  | _ =&gt; false
  end.

Inductive kind_of_type (constr types : Type) : Type :=
| SortType : Sorts.t -&gt; kind_of_type constr types
| CastType : types -&gt; types -&gt; kind_of_type constr types
| ProdType : (Context.binder_annot Names.Name.t) -&gt; types -&gt; types -&gt;
  kind_of_type constr types
| LetInType : (Context.binder_annot Names.Name.t) -&gt; constr -&gt; types -&gt; types -&gt;
  kind_of_type constr types
| AtomicType : constr -&gt; (array constr) -&gt; kind_of_type constr types.

Arguments SortType {_ _}.
Arguments CastType {_ _}.
Arguments ProdType {_ _}.
Arguments LetInType {_ _}.
Arguments AtomicType {_ _}.

Definition kind_of_type (t : Constr.constr)
  : kind_of_type Constr.constr Constr.constr :=
  match Constr.kind t with
  | Sort s =&gt; SortType s
  | Cast c _ t =&gt; CastType c t
  | Prod na t c =&gt; ProdType na t c
  | LetIn na b t c =&gt; LetInType na b t c
  | App c l =&gt; AtomicType c l
  |
    Rel _ | Meta _ | Var _ | Evar _ | Const _ | Proj _ _ | Case _ _ _ _ | Fix _
      | CoFix _ | Ind _ =&gt; AtomicType t tt
  | Lambda _ _ _ | Construct _ | Int _ =&gt;
    OCaml.Stdlib.failwith &quot;Not a type&quot; % string
  end.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="term_typing" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>term_typing.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Jacek Chrzaszcz, Aug 2002 as part of the implementation of
   the Coq module system *)

(* This module provides the main entry points for type-checking basic
   declarations *)

open CErrors
open Util
open Names
open Constr
open Declarations
open Environ
open Entries

module NamedDecl = Context.Named.Declaration

(* Insertion of constants and parameters in environment. *)

type 'a effect_handler =
  env -&gt; Constr.t -&gt; 'a -&gt; (Constr.t * Univ.ContextSet.t * int)

let skip_trusted_seff sl b e =
  let rec aux sl b e acc =
    let open Context.Rel.Declaration in
    if Int.equal sl 0 then b, e, acc
    else match kind b with
    | LetIn (n,c,ty,bo) -&gt;
       aux (sl - 1) bo
         (Environ.push_rel (LocalDef (n,c,ty)) e) (`Let(n,c,ty)::acc)
    | App(hd,arg) -&gt;
       begin match kind hd with
       | Lambda (n,ty,bo) -&gt;
           aux (sl - 1) bo
             (Environ.push_rel (LocalAssum (n,ty)) e) (`Cut(n,ty,arg)::acc)
       | _ -&gt; assert false
       end
    | _ -&gt; assert false
    in
  aux sl b e []

let rec unzip ctx j =
  match ctx with
  | [] -&gt; j
  | `Let (n,c,ty) :: ctx -&gt;
      unzip ctx { j with uj_val = mkLetIn (n,c,ty,j.uj_val) }
  | `Cut (n,ty,arg) :: ctx -&gt;
      unzip ctx { j with uj_val = mkApp (mkLambda (n,ty,j.uj_val),arg) }

let feedback_completion_typecheck =
  Option.iter (fun state_id -&gt;
      Feedback.feedback ~id:state_id Feedback.Complete)

type typing_context =
| MonoTyCtx of Environ.env * unsafe_type_judgment * Univ.ContextSet.t * Id.Set.t * Stateid.t option
| PolyTyCtx of Environ.env * unsafe_type_judgment * Univ.universe_level_subst * Univ.AUContext.t * Id.Set.t * Stateid.t option

let infer_declaration env (dcl : constant_entry) =
  match dcl with
    | ParameterEntry (ctx,(t,uctx),nl) -&gt;
      let env = match uctx with
        | Monomorphic_entry uctx -&gt; push_context_set ~strict:true uctx env
        | Polymorphic_entry (_, uctx) -&gt; push_context ~strict:false uctx env
      in
      let j = Typeops.infer env t in
      let usubst, univs = Declareops.abstract_universes uctx in
      let r = Typeops.assumption_of_judgment env j in
      let t = Vars.subst_univs_level_constr usubst j.uj_val in
      {
        Cooking.cook_body = Undef nl;
        cook_type = t;
        cook_universes = univs;
        cook_relevance = r;
        cook_inline = false;
        cook_context = ctx;
      }

    (** Primitives cannot be universe polymorphic *)
    | PrimitiveEntry ({ prim_entry_type = otyp;
                        prim_entry_univs = uctxt;
                        prim_entry_content = op_t;
                      }) -&gt;
      let env = push_context_set ~strict:true uctxt env in
      let ty = match otyp with
      | Some typ -&gt;
        let typ = Typeops.infer_type env typ in
        Typeops.check_primitive_type env op_t typ.utj_val;
        typ.utj_val
      | None -&gt;
        match op_t with
        | CPrimitives.OT_op op -&gt; Typeops.type_of_prim env op
        | CPrimitives.OT_type _ -&gt; mkSet
      in
      let cd =
        match op_t with
        | CPrimitives.OT_op op -&gt; Declarations.Primitive op
        | CPrimitives.OT_type _ -&gt; Undef None in
      { Cooking.cook_body = cd;
        cook_type = ty;
        cook_universes = Monomorphic uctxt;
        cook_inline = false;
        cook_context = None;
        cook_relevance = Sorts.Relevant;
      }

  | DefinitionEntry c -&gt;
      let { const_entry_type = typ; _ } = c in
      let { const_entry_body = body; const_entry_feedback = feedback_id; _ } = c in
      let env, usubst, univs = match c.const_entry_universes with
      | Monomorphic_entry ctx -&gt;
        let env = push_context_set ~strict:true ctx env in
        env, Univ.empty_level_subst, Monomorphic ctx
      | Polymorphic_entry (nas, uctx) -&gt;
        (** [ctx] must contain local universes, such that it has no impact
            on the rest of the graph (up to transitivity). *)
        let env = push_context ~strict:false uctx env in
        let sbst, auctx = Univ.abstract_universes nas uctx in
        let sbst = Univ.make_instance_subst sbst in
        env, sbst, Polymorphic auctx
      in
      let j = Typeops.infer env body in
      let typ = match typ with
        | None -&gt;
          Vars.subst_univs_level_constr usubst j.uj_type
        | Some t -&gt;
           let tj = Typeops.infer_type env t in
           let _ = Typeops.judge_of_cast env j DEFAULTcast tj in
           Vars.subst_univs_level_constr usubst tj.utj_val
      in
      let def = Vars.subst_univs_level_constr usubst j.uj_val in
      let def = Def (Mod_subst.from_val def) in
	feedback_completion_typecheck feedback_id;
      {
        Cooking.cook_body = def;
        cook_type = typ;
        cook_universes = univs;
        cook_relevance = Retypeops.relevance_of_term env j.uj_val;
        cook_inline = c.const_entry_inline_code;
        cook_context = c.const_entry_secctx;
      }

(** Definition is opaque (Qed), so we delay the typing of its body. *)
let infer_opaque env = function
  | ({ opaque_entry_type = typ;
                       opaque_entry_universes = Monomorphic_entry univs; _ } as c) -&gt;
      let env = push_context_set ~strict:true univs env in
      let { opaque_entry_feedback = feedback_id; _ } = c in
      let tyj = Typeops.infer_type env typ in
      let context = MonoTyCtx (env, tyj, univs, c.opaque_entry_secctx, feedback_id) in
      let def = OpaqueDef () in
      {
        Cooking.cook_body = def;
        cook_type = tyj.utj_val;
        cook_universes = Monomorphic univs;
        cook_relevance = Sorts.relevance_of_sort tyj.utj_type;
        cook_inline = false;
        cook_context = Some c.opaque_entry_secctx;
      }, context

  | ({ opaque_entry_type = typ;
                       opaque_entry_universes = Polymorphic_entry (nas, uctx); _ } as c) -&gt;
      let { opaque_entry_feedback = feedback_id; _ } = c in
      let env = push_context ~strict:false uctx env in
      let tj = Typeops.infer_type env typ in
      let sbst, auctx = Univ.abstract_universes nas uctx in
      let usubst = Univ.make_instance_subst sbst in
      let context = PolyTyCtx (env, tj, usubst, auctx, c.opaque_entry_secctx, feedback_id) in
      let def = OpaqueDef () in
      let typ = Vars.subst_univs_level_constr usubst tj.utj_val in
      {
        Cooking.cook_body = def;
        cook_type = typ;
        cook_universes = Polymorphic auctx;
        cook_relevance = Sorts.relevance_of_sort tj.utj_type;
        cook_inline = false;
        cook_context = Some c.opaque_entry_secctx;
      }, context

let check_section_variables env declared_set typ body =
  let ids_typ = global_vars_set env typ in
  let ids_def = global_vars_set env body in
  let inferred_set = Environ.really_needed env (Id.Set.union ids_typ ids_def) in
  if not (Id.Set.subset inferred_set declared_set) then
    let l = Id.Set.elements (Id.Set.diff inferred_set declared_set) in
    let n = List.length l in
    let declared_vars = Pp.pr_sequence Id.print (Id.Set.elements declared_set) in
    let inferred_vars = Pp.pr_sequence Id.print (Id.Set.elements inferred_set) in
    let missing_vars  = Pp.pr_sequence Id.print (List.rev l) in
    user_err Pp.(prlist str
        [&quot;The following section &quot;; (String.plural n &quot;variable&quot;); &quot; &quot;;
        (String.conjugate_verb_to_be n); &quot; used but not declared:&quot;] ++ fnl () ++
        missing_vars ++ str &quot;.&quot; ++ fnl () ++ fnl () ++
        str &quot;You can either update your proof to not depend on &quot; ++ missing_vars ++
        str &quot;, or you can update your Proof line from&quot; ++ fnl () ++
        str &quot;Proof using &quot; ++ declared_vars ++ fnl () ++
        str &quot;to&quot; ++ fnl () ++
        str &quot;Proof using &quot; ++ inferred_vars)

let build_constant_declaration env result =
  let open Cooking in
  let typ = result.cook_type in
  (* We try to postpone the computation of used section variables *)
  let hyps, def =
    let context_ids = List.map NamedDecl.get_id (named_context env) in
    let def = result.cook_body in
    match result.cook_context with
    | None -&gt;
      if List.is_empty context_ids then
        (* Empty section context: no need to check *)
        Id.Set.empty, def
      else
        (* No declared section vars, and non-empty section context:
           we must look at the body NOW, if any *)
        let ids_typ = global_vars_set env typ in
        let ids_def = match def with
        | Undef _ | Primitive _ -&gt; Id.Set.empty
        | Def cs -&gt; global_vars_set env (Mod_subst.force_constr cs)
        | OpaqueDef _ -&gt;
          (* Opaque definitions always come with their section variables *)
          assert false
        in
        Environ.really_needed env (Id.Set.union ids_typ ids_def), def
    | Some declared -&gt;
      let needed = Environ.really_needed env declared in
      (* Transitive closure ensured by the upper layers *)
      let () = assert (Id.Set.equal needed declared) in
        (* We use the declared set and chain a check of correctness *)
        declared,
        match def with
        | Undef _ | Primitive _ | OpaqueDef _ as x -&gt; x (* nothing to check *)
        | Def cs as x -&gt;
          let () = check_section_variables env declared typ (Mod_subst.force_constr cs) in
          x
  in
  let univs = result.cook_universes in
  let hyps = List.filter (fun d -&gt; Id.Set.mem (NamedDecl.get_id d) hyps) (Environ.named_context env) in
  let tps = 
    let res = Cbytegen.compile_constant_body ~fail_on_error:false env univs def in
    Option.map Cemitcodes.from_val res
  in
  { const_hyps = hyps;
    const_body = def;
    const_type = typ;
    const_body_code = tps;
    const_universes = univs;
    const_relevance = result.cook_relevance;
    const_inline_code = result.cook_inline;
    const_typing_flags = Environ.typing_flags env }

let check_delayed (type a) (handle : a effect_handler) tyenv (body : a proof_output) = match tyenv with
| MonoTyCtx (env, tyj, univs, declared, feedback_id) -&gt;
  let ((body, uctx), side_eff) = body in
  (* don't redeclare universes which are declared for the type *)
  let uctx = Univ.ContextSet.diff uctx univs in
  let (body, uctx', valid_signatures) = handle env body side_eff in
  let uctx = Univ.ContextSet.union uctx uctx' in
  let env = push_context_set uctx env in
  let body,env,ectx = skip_trusted_seff valid_signatures body env in
  let j = Typeops.infer env body in
  let j = unzip ectx j in
  let _ = Typeops.judge_of_cast env j DEFAULTcast tyj in
  let c = j.uj_val in
  let () = check_section_variables env declared tyj.utj_val body in
  feedback_completion_typecheck feedback_id;
  c, Opaqueproof.PrivateMonomorphic uctx
| PolyTyCtx (env, tj, usubst, auctx, declared, feedback_id) -&gt;
  let ((body, ctx), side_eff) = body in
  let body, ctx', _ = handle env body side_eff in
  let ctx = Univ.ContextSet.union ctx ctx' in
  (** [ctx] must contain local universes, such that it has no impact
      on the rest of the graph (up to transitivity). *)
  let env = push_subgraph ctx env in
  let private_univs = on_snd (Univ.subst_univs_level_constraints usubst) ctx in
  let j = Typeops.infer env body in
  let _ = Typeops.judge_of_cast env j DEFAULTcast tj in
  let () = check_section_variables env declared tj.utj_val body in
  let def = Vars.subst_univs_level_constr usubst j.uj_val in
  let () = feedback_completion_typecheck feedback_id in
  def, Opaqueproof.PrivatePolymorphic (Univ.AUContext.size auctx, private_univs)

(*s Global and local constant declaration. *)

let translate_constant env _kn ce =
  build_constant_declaration env
    (infer_declaration env ce)

let translate_opaque env _kn ce =
  let def, ctx = infer_opaque env ce in
  build_constant_declaration env def, ctx

let translate_local_assum env t =
  let j = Typeops.infer env t in
  let t = Typeops.assumption_of_judgment env j in
    j.uj_val, t

let translate_recipe env _kn r =
  let open Cooking in
  let result = Cooking.cook_constant r in
  let univs = result.cook_universes in
  let res = Cbytegen.compile_constant_body ~fail_on_error:false env univs result.cook_body in
  let tps = Option.map Cemitcodes.from_val res in
  let hyps = Option.get result.cook_context in
  (* Trust the set of section hypotheses generated by Cooking *)
  let hyps = List.filter (fun d -&gt; Id.Set.mem (NamedDecl.get_id d) hyps) (Environ.named_context env) in
  { const_hyps = hyps;
    const_body = result.cook_body;
    const_type = result.cook_type;
    const_body_code = tps;
    const_universes = univs;
    const_relevance = result.cook_relevance;
    const_inline_code = result.cook_inline;
    const_typing_flags = Environ.typing_flags env }

let translate_local_def env _id centry =
  let open Cooking in
  let centry = {
    const_entry_body = centry.secdef_body;
    const_entry_secctx = centry.secdef_secctx;
    const_entry_feedback = centry.secdef_feedback;
    const_entry_type = centry.secdef_type;
    const_entry_universes = Monomorphic_entry Univ.ContextSet.empty;
    const_entry_inline_code = false;
  } in
  let decl = infer_declaration env (DefinitionEntry centry) in
  let typ = decl.cook_type in
  let () = match decl.cook_universes with
  | Monomorphic ctx -&gt; assert (Univ.ContextSet.is_empty ctx)
  | Polymorphic _ -&gt; assert false
  in
  let c = match decl.cook_body with
  | Def c -&gt; Mod_subst.force_constr c
  | Undef _ | Primitive _ | OpaqueDef _ -&gt; assert false
  in
  c, decl.cook_relevance, typ
</pre>
          </div>
          <div class="col-md-6">
            <code>term_typing.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import CErrors.

Import Util.

Import Names.

Import Constr.

Import Declarations.

Import Environ.

Import Entries.

Definition effect_handler (a : Type) :=
  Environ.env -&gt; Constr.t -&gt; a -&gt; Constr.t * Univ.ContextSet.t * Z.

Definition skip_trusted_seff (sl : Int.t) (b : Constr.constr) (e : Environ.env)
  : Constr.constr * Environ.env * (list variant) :=
  let fix aux
    (sl : Int.t) (b : Constr.constr) (e : Environ.env) (acc : list variant)
    : Constr.constr * Environ.env * (list variant) :=
    if Int.equal sl 0 then
      (b, e, acc)
    else
      match Constr.kind b with
      | LetIn n c ty bo =&gt;
        aux (Util.op_minus sl 1) bo (Environ.push_rel (LocalDef n c ty) e)
          (cons variant acc)
      | App hd arg =&gt;
        match Constr.kind hd with
        | Lambda n ty bo =&gt;
          aux (Util.op_minus sl 1) bo (Environ.push_rel (LocalAssum n ty) e)
            (cons variant acc)
        | _ =&gt; false
        end
      | _ =&gt; false
      end in
  aux sl b e [].

Fixpoint unzip {A : Type}
  (ctx : list variant) (j : Environ.punsafe_judgment Constr.constr A)
  : Environ.punsafe_judgment Constr.constr A :=
  match ctx with
  | [] =&gt; j
  | cons (Let (n, c, ty)) ctx =&gt; unzip ctx record
  | cons (Cut (n, ty, arg)) ctx =&gt; unzip ctx record
  end.

Definition feedback_completion_typecheck : (option Stateid.t) -&gt; unit :=
  Option.iter
    (fun state_id =&gt;
      Feedback.feedback None (Some state_id) None Feedback.Complete).

Inductive typing_context : Type :=
| MonoTyCtx : Environ.env -&gt; Environ.unsafe_type_judgment -&gt; Univ.ContextSet.t
  -&gt; Names.Id.Set.t -&gt; (option Stateid.t) -&gt; typing_context
| PolyTyCtx : Environ.env -&gt; Environ.unsafe_type_judgment -&gt;
  Univ.universe_level_subst -&gt; Univ.AUContext.t -&gt; Names.Id.Set.t -&gt;
  (option Stateid.t) -&gt; typing_context.

Definition infer_declaration {A : Type}
  (env : Environ.env) (dcl : Entries.constant_entry) : Cooking.result A :=
  match dcl with
  | ParameterEntry (ctx, (t, uctx), nl) =&gt;
    let env :=
      match uctx with
      | Monomorphic_entry uctx =&gt; Environ.push_context_set (Some true) uctx env
      | Polymorphic_entry _ uctx =&gt; Environ.push_context (Some false) uctx env
      end in
    let j := Typeops.infer env t in
    match Declareops.abstract_universes uctx with
    | (usubst, univs) =&gt;
      let r := Typeops.assumption_of_judgment env j in
      let t := Vars.subst_univs_level_constr usubst (uj_val j) in
      {| Cooking.cook_body := Undef nl; Cooking.cook_type := t;
        Cooking.cook_universes := univs; Cooking.cook_relevance := r;
        Cooking.cook_inline := false; Cooking.cook_context := ctx |}
    end
  |
    PrimitiveEntry {|
      prim_entry_type := otyp;
        prim_entry_univs := uctxt;
        prim_entry_content := op_t
        |} =&gt;
    let env := Environ.push_context_set (Some true) uctxt env in
    let ty :=
      match otyp with
      | Some typ =&gt;
        let typ := Typeops.infer_type env typ in
        Typeops.check_primitive_type env op_t (utj_val typ);
        utj_val typ
      | None =&gt;
        match op_t with
        | CPrimitives.OT_op op =&gt; Typeops.type_of_prim env op
        | CPrimitives.OT_type _ =&gt; Constr.mkSet
        end
      end in
    let cd :=
      match op_t with
      | CPrimitives.OT_op op =&gt; Declarations.Primitive op
      | CPrimitives.OT_type _ =&gt; Undef None
      end in
    {| Cooking.cook_body := cd; Cooking.cook_type := ty;
      Cooking.cook_universes := Monomorphic uctxt;
      Cooking.cook_relevance := Sorts.Relevant; Cooking.cook_inline := false;
      Cooking.cook_context := None |}
  | DefinitionEntry c =&gt;
    match c with
    | {| const_entry_type := typ |} =&gt;
      match c with
      | {| const_entry_body := body; const_entry_feedback := feedback_id |} =&gt;
        match
          match const_entry_universes c with
          | Monomorphic_entry ctx =&gt;
            let env := Environ.push_context_set (Some true) ctx env in
            (env, Univ.empty_level_subst, (Monomorphic ctx))
          | Polymorphic_entry nas uctx =&gt;
            let env := Environ.push_context (Some false) uctx env in
            match Univ.abstract_universes nas uctx with
            | (sbst, auctx) =&gt;
              let sbst := Univ.make_instance_subst sbst in
              (env, sbst, (Polymorphic auctx))
            end
          end with
        | (env, usubst, univs) =&gt;
          let j := Typeops.infer env body in
          let typ :=
            match typ with
            | None =&gt; Vars.subst_univs_level_constr usubst (uj_type j)
            | Some t =&gt;
              let tj := Typeops.infer_type env t in
              match Typeops.judge_of_cast env j DEFAULTcast tj with
              | _ =&gt; Vars.subst_univs_level_constr usubst (utj_val tj)
              end
            end in
          let def := Vars.subst_univs_level_constr usubst (uj_val j) in
          let def := Def (Mod_subst.from_val def) in
          feedback_completion_typecheck feedback_id;
          {| Cooking.cook_body := def; Cooking.cook_type := typ;
            Cooking.cook_universes := univs;
            Cooking.cook_relevance := Retypeops.relevance_of_term env (uj_val j);
            Cooking.cook_inline := const_entry_inline_code c;
            Cooking.cook_context := const_entry_secctx c |}
        end
      end
    end
  end.

Definition infer_opaque {A : Type}
  (env : Environ.env) (function_parameter : Entries.opaque_entry A)
  : (Cooking.result unit) * typing_context :=
  match function_parameter with
  |
    {|
      opaque_entry_type := typ;
        opaque_entry_universes := Monomorphic_entry univs
        |} as c =&gt;
    let env := Environ.push_context_set (Some true) univs env in
    match c with
    | {| opaque_entry_feedback := feedback_id |} =&gt;
      let tyj := Typeops.infer_type env typ in
      let context := MonoTyCtx env tyj univs (opaque_entry_secctx c) feedback_id
        in
      let def := OpaqueDef tt in
      ({| Cooking.cook_body := def; Cooking.cook_type := utj_val tyj;
        Cooking.cook_universes := Monomorphic univs;
        Cooking.cook_relevance := Sorts.relevance_of_sort (utj_type tyj);
        Cooking.cook_inline := false;
        Cooking.cook_context := Some (opaque_entry_secctx c) |}, context)
    end
  |
    {|
      opaque_entry_type := typ;
        opaque_entry_universes := Polymorphic_entry nas uctx
        |} as c =&gt;
    match c with
    | {| opaque_entry_feedback := feedback_id |} =&gt;
      let env := Environ.push_context (Some false) uctx env in
      let tj := Typeops.infer_type env typ in
      match Univ.abstract_universes nas uctx with
      | (sbst, auctx) =&gt;
        let usubst := Univ.make_instance_subst sbst in
        let context :=
          PolyTyCtx env tj usubst auctx (opaque_entry_secctx c) feedback_id in
        let def := OpaqueDef tt in
        let typ := Vars.subst_univs_level_constr usubst (utj_val tj) in
        ({| Cooking.cook_body := def; Cooking.cook_type := typ;
          Cooking.cook_universes := Polymorphic auctx;
          Cooking.cook_relevance := Sorts.relevance_of_sort (utj_type tj);
          Cooking.cook_inline := false;
          Cooking.cook_context := Some (opaque_entry_secctx c) |}, context)
      end
    end
  end.

Definition check_section_variables
  (env : Environ.env) (declared_set : Names.Id.Set.t) (typ : Constr.constr)
  (body : Constr.constr) : unit :=
  let ids_typ := Environ.global_vars_set env typ in
  let ids_def := Environ.global_vars_set env body in
  let inferred_set :=
    Environ.really_needed env (Names.Id.Set.union ids_typ ids_def) in
  if negb (Names.Id.Set.subset inferred_set declared_set) then
    let l := Names.Id.Set.elements (Names.Id.Set.diff inferred_set declared_set)
      in
    let n := Util.List.(CList.ExtS.length) l in
    let declared_vars :=
      Pp.pr_sequence Names.Id.print (Names.Id.Set.elements declared_set) in
    let inferred_vars :=
      Pp.pr_sequence Names.Id.print (Names.Id.Set.elements inferred_set) in
    let missing_vars :=
      Pp.pr_sequence Names.Id.print (Util.List.(CList.ExtS.rev) l) in
    CErrors.user_err None None
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus
            (Pp.op_plus_plus
              (Pp.op_plus_plus
                (Pp.op_plus_plus
                  (Pp.op_plus_plus
                    (Pp.op_plus_plus
                      (Pp.op_plus_plus
                        (Pp.op_plus_plus
                          (Pp.op_plus_plus
                            (Pp.op_plus_plus
                              (Pp.op_plus_plus
                                (Pp.op_plus_plus
                                  (Pp.op_plus_plus
                                    (Pp.op_plus_plus
                                      (Pp.prlist Pp.str
                                        (cons &quot;The following section &quot; % string
                                          (cons
                                            (Util.String.(CString.ExtS.plural) n
                                              &quot;variable&quot; % string)
                                            (cons &quot; &quot; % string
                                              (cons
                                                (Util.String.(CString.ExtS.conjugate_verb_to_be)
                                                  n)
                                                (cons
                                                  &quot; used but not declared:&quot; %
                                                    string [])))))) (Pp.fnl tt))
                                    missing_vars) (Pp.str &quot;.&quot; % string))
                                (Pp.fnl tt)) (Pp.fnl tt))
                            (Pp.str
                              &quot;You can either update your proof to not depend on &quot;
                                % string)) missing_vars)
                        (Pp.str
                          &quot;, or you can update your Proof line from&quot; % string))
                      (Pp.fnl tt)) (Pp.str &quot;Proof using &quot; % string))
                  declared_vars) (Pp.fnl tt)) (Pp.str &quot;to&quot; % string))
            (Pp.fnl tt)) (Pp.str &quot;Proof using &quot; % string)) inferred_vars)
  else
    tt.

Definition build_constant_declaration {A : Type}
  (env : Environ.env) (result : Cooking.result A)
  : Declarations.constant_body A :=
  let typ := cook_type result in
  match
    let context_ids :=
      Util.List.(CList.ExtS.map) NamedDecl.get_id (Environ.named_context env) in
    let def := cook_body result in
    match cook_context result with
    | None =&gt;
      if Util.List.(CList.ExtS.is_empty) context_ids then
        (Names.Id.Set.empty, def)
      else
        let ids_typ := Environ.global_vars_set env typ in
        let ids_def :=
          match def with
          | Undef _ | Primitive _ =&gt; Names.Id.Set.empty
          | Def cs =&gt; Environ.global_vars_set env (Mod_subst.force_constr cs)
          | OpaqueDef _ =&gt; false
          end in
        ((Environ.really_needed env (Names.Id.Set.union ids_typ ids_def)), def)
    | Some declared =&gt;
      let needed := Environ.really_needed env declared in
      match Names.Id.Set.equal needed declared with
      | tt =&gt;
        (declared,
          match def with
          | (Undef _ | Primitive _ | OpaqueDef _) as x =&gt; x
          | (Def cs) as x =&gt;
            match
              check_section_variables env declared typ
                (Mod_subst.force_constr cs) with
            | tt =&gt; x
            end
          end)
      end
    end with
  | (hyps, def) =&gt;
    let univs := cook_universes result in
    let hyps :=
      Util.List.(CList.ExtS.filter)
        (fun d =&gt; Names.Id.Set.mem (NamedDecl.get_id d) hyps)
        (Environ.named_context env) in
    let tps :=
      let res := Cbytegen.compile_constant_body false env univs def in
      Option.map Cemitcodes.from_val res in
    {| const_hyps := hyps; const_body := def; const_type := typ;
      const_relevance := cook_relevance result; const_body_code := tps;
      const_universes := univs; const_inline_code := cook_inline result;
      const_typing_flags := Environ.typing_flags env |}
  end.

Definition check_delayed {A : Type}
  (handle : effect_handler A) (tyenv : typing_context)
  (body : Entries.proof_output A)
  : Constr.constr * (Opaqueproof.delayed_universes Univ.ContextSet.t) :=
  match tyenv with
  | MonoTyCtx env tyj univs declared feedback_id =&gt;
    match body with
    | ((body, uctx), side_eff) =&gt;
      let uctx := Univ.ContextSet.diff uctx univs in
      match handle env body side_eff with
      | (body, uctx', valid_signatures) =&gt;
        let uctx := Univ.ContextSet.union uctx uctx' in
        let env := Environ.push_context_set None uctx env in
        match skip_trusted_seff valid_signatures body env with
        | (body, env, ectx) =&gt;
          let j := Typeops.infer env body in
          let j := unzip ectx j in
          match Typeops.judge_of_cast env j DEFAULTcast tyj with
          | _ =&gt;
            let c := uj_val j in
            match check_section_variables env declared (utj_val tyj) body with
            | tt =&gt;
              feedback_completion_typecheck feedback_id;
              (c, (Opaqueproof.PrivateMonomorphic uctx))
            end
          end
        end
      end
    end
  | PolyTyCtx env tj usubst auctx declared feedback_id =&gt;
    match body with
    | ((body, ctx), side_eff) =&gt;
      match handle env body side_eff with
      | (body, ctx', _) =&gt;
        let ctx := Univ.ContextSet.union ctx ctx' in
        let env := Environ.push_subgraph ctx env in
        let private_univs :=
          Util.on_snd (Univ.subst_univs_level_constraints usubst) ctx in
        let j := Typeops.infer env body in
        match Typeops.judge_of_cast env j DEFAULTcast tj with
        | _ =&gt;
          match check_section_variables env declared (utj_val tj) body with
          | tt =&gt;
            let def := Vars.subst_univs_level_constr usubst (uj_val j) in
            match feedback_completion_typecheck feedback_id with
            | tt =&gt;
              (def,
                (Opaqueproof.PrivatePolymorphic (Univ.AUContext.size auctx)
                  private_univs))
            end
          end
        end
      end
    end
  end.

Definition translate_constant {A B : Type}
  (env : Environ.env) (_kn : A) (ce : Entries.constant_entry)
  : Declarations.constant_body B :=
  build_constant_declaration env (infer_declaration env ce).

Definition translate_opaque {A B : Type}
  (env : Environ.env) (_kn : A) (ce : Entries.opaque_entry B)
  : (Declarations.constant_body unit) * typing_context :=
  match infer_opaque env ce with
  | (def, ctx) =&gt; ((build_constant_declaration env def), ctx)
  end.

Definition translate_local_assum (env : Environ.env) (t : Constr.constr)
  : Constr.constr * Sorts.relevance :=
  let j := Typeops.infer env t in
  let t := Typeops.assumption_of_judgment env j in
  ((uj_val j), t).

Definition translate_recipe {A : Type}
  (env : Environ.env) (_kn : A) (r : Cooking.recipe)
  : Declarations.constant_body Opaqueproof.opaque :=
  let result := Cooking.cook_constant r in
  let univs := cook_universes result in
  let res := Cbytegen.compile_constant_body false env univs (cook_body result)
    in
  let tps := Option.map Cemitcodes.from_val res in
  let hyps := Option.get (cook_context result) in
  let hyps :=
    Util.List.(CList.ExtS.filter)
      (fun d =&gt; Names.Id.Set.mem (NamedDecl.get_id d) hyps)
      (Environ.named_context env) in
  {| const_hyps := hyps; const_body := cook_body result;
    const_type := cook_type result; const_relevance := cook_relevance result;
    const_body_code := tps; const_universes := univs;
    const_inline_code := cook_inline result;
    const_typing_flags := Environ.typing_flags env |}.

Definition translate_local_def {A : Type}
  (env : Environ.env) (_id : A) (centry : Entries.section_def_entry)
  : Constr.constr * Sorts.relevance * Constr.types :=
  let centry :=
    {| const_entry_body := secdef_body centry;
      const_entry_secctx := secdef_secctx centry;
      const_entry_feedback := secdef_feedback centry;
      const_entry_type := secdef_type centry;
      const_entry_universes := Monomorphic_entry Univ.ContextSet.empty;
      const_entry_inline_code := false |} in
  let decl := infer_declaration env (DefinitionEntry centry) in
  let typ := cook_type decl in
  match
    match cook_universes decl with
    | Monomorphic ctx =&gt; Univ.ContextSet.is_empty ctx
    | Polymorphic _ =&gt; false
    end with
  | tt =&gt;
    let c :=
      match cook_body decl with
      | Def c =&gt; Mod_subst.force_constr c
      | Undef _ | Primitive _ | OpaqueDef _ =&gt; false
      end in
    (c, (cook_relevance decl), typ)
  end.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="transparentState" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>transparentState.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names

type t = {
  tr_var : Id.Pred.t;
  tr_cst : Cpred.t;
}

let empty = {
  tr_var = Id.Pred.empty;
  tr_cst = Cpred.empty;
}

let full = {
  tr_var = Id.Pred.full;
  tr_cst = Cpred.full;
}

let var_full = {
  tr_var = Id.Pred.full;
  tr_cst = Cpred.empty;
}

let cst_full = {
  tr_var = Id.Pred.empty;
  tr_cst = Cpred.full;
}

let is_empty ts =
  Id.Pred.is_empty ts.tr_var &amp;&amp; Cpred.is_empty ts.tr_cst

let is_transparent_variable ts id =
  Id.Pred.mem id ts.tr_var

let is_transparent_constant ts cst =
  Cpred.mem cst ts.tr_cst
</pre>
          </div>
          <div class="col-md-6">
            <code>transparentState.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Names.

Record t := {
  tr_var : Names.Id.Pred.t;
  tr_cst : Names.Cpred.t }.

Definition empty : t :=
  {| tr_var := Names.Id.Pred.empty; tr_cst := Names.Cpred.empty |}.

Definition full : t :=
  {| tr_var := Names.Id.Pred.full; tr_cst := Names.Cpred.full |}.

Definition var_full : t :=
  {| tr_var := Names.Id.Pred.full; tr_cst := Names.Cpred.empty |}.

Definition cst_full : t :=
  {| tr_var := Names.Id.Pred.empty; tr_cst := Names.Cpred.full |}.

Definition is_empty (ts : t) : bool :=
  andb (Names.Id.Pred.is_empty (tr_var ts)) (Names.Cpred.is_empty (tr_cst ts)).

Definition is_transparent_variable (ts : t) (id : Names.Id.Pred.elt) : bool :=
  Names.Id.Pred.mem id (tr_var ts).

Definition is_transparent_constant (ts : t) (cst : Names.Cpred.elt) : bool :=
  Names.Cpred.mem cst (tr_cst ts).</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="type_errors" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>type_errors.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Constr
open Environ
open Reduction

(* Type errors. *)

type 'constr pguard_error =
  (* Fixpoints *)
  | NotEnoughAbstractionInFixBody
  | RecursionNotOnInductiveType of 'constr
  | RecursionOnIllegalTerm of int * (env * 'constr) * int list * int list
  | NotEnoughArgumentsForFixCall of int
  (* CoFixpoints *)
  | CodomainNotInductiveType of 'constr
  | NestedRecursiveOccurrences
  | UnguardedRecursiveCall of 'constr
  | RecCallInTypeOfAbstraction of 'constr
  | RecCallInNonRecArgOfConstructor of 'constr
  | RecCallInTypeOfDef of 'constr
  | RecCallInCaseFun of 'constr
  | RecCallInCaseArg of 'constr
  | RecCallInCasePred of 'constr
  | NotGuardedForm of 'constr
  | ReturnPredicateNotCoInductive of 'constr
  | FixpointOnIrrelevantInductive

type guard_error = constr pguard_error

type arity_error =
  | NonInformativeToInformative
  | StrongEliminationOnNonSmallType
  | WrongArity

type ('constr, 'types) ptype_error =
  | UnboundRel of int
  | UnboundVar of variable
  | NotAType of ('constr, 'types) punsafe_judgment
  | BadAssumption of ('constr, 'types) punsafe_judgment
  | ReferenceVariables of Id.t * 'constr
  | ElimArity of pinductive * 'constr * ('constr, 'types) punsafe_judgment
      * (Sorts.family * Sorts.family * Sorts.family * arity_error) option
  | CaseNotInductive of ('constr, 'types) punsafe_judgment
  | WrongCaseInfo of pinductive * case_info
  | NumberBranches of ('constr, 'types) punsafe_judgment * int
  | IllFormedBranch of 'constr * pconstructor * 'constr * 'constr
  | Generalization of (Name.t * 'types) * ('constr, 'types) punsafe_judgment
  | ActualType of ('constr, 'types) punsafe_judgment * 'types
  | IncorrectPrimitive of (CPrimitives.op_or_type,'types) punsafe_judgment * 'types
  | CantApplyBadType of
      (int * 'constr * 'constr) * ('constr, 'types) punsafe_judgment * ('constr, 'types) punsafe_judgment array
  | CantApplyNonFunctional of ('constr, 'types) punsafe_judgment * ('constr, 'types) punsafe_judgment array
  | IllFormedRecBody of 'constr pguard_error * Name.t Context.binder_annot array * int * env * ('constr, 'types) punsafe_judgment array
  | IllTypedRecBody of
      int * Name.t Context.binder_annot array * ('constr, 'types) punsafe_judgment array * 'types array
  | UnsatisfiedConstraints of Univ.Constraint.t
  | UndeclaredUniverse of Univ.Level.t
  | DisallowedSProp
  | BadRelevance

type type_error = (constr, types) ptype_error

exception TypeError of env * type_error

type inductive_error =
  | NonPos of env * constr * constr
  | NotEnoughArgs of env * constr * constr
  | NotConstructor of env * Id.t * constr * constr * int * int
  | NonPar of env * constr * int * constr * constr
  | SameNamesTypes of Id.t
  | SameNamesConstructors of Id.t
  | SameNamesOverlap of Id.t list
  | NotAnArity of env * constr
  | BadEntry
  | LargeNonPropInductiveNotInType
  | BadUnivs

exception InductiveError of inductive_error

let nfj env {uj_val=c;uj_type=ct} =
  {uj_val=c;uj_type=nf_betaiota env ct}

let error_unbound_rel env n =
  raise (TypeError (env, UnboundRel n))

let error_unbound_var env v =
  raise (TypeError (env, UnboundVar v))

let error_not_type env j =
  raise (TypeError (env, NotAType j))

let error_assumption env j =
  raise (TypeError (env, BadAssumption j))

let error_reference_variables env id c =
  raise (TypeError (env, ReferenceVariables (id,c)))

let error_elim_arity env ind c pj okinds =
  raise (TypeError (env, ElimArity (ind,c,pj,okinds)))

let error_case_not_inductive env j =
  raise (TypeError (env, CaseNotInductive j))

let error_number_branches env cj expn =
  raise (TypeError (env, NumberBranches (nfj env cj,expn)))

let error_ill_formed_branch env c i actty expty =
  raise (TypeError (env,
    IllFormedBranch (c,i,nf_betaiota env actty, nf_betaiota env expty)))

let error_generalization env nvar c =
  raise (TypeError (env, Generalization (nvar,c)))

let error_actual_type env j expty =
  raise (TypeError (env, ActualType (j,expty)))

let error_incorrect_primitive env p t =
  raise (TypeError (env, IncorrectPrimitive (p, t)))

let error_cant_apply_not_functional env rator randl =
  raise (TypeError (env, CantApplyNonFunctional (rator,randl)))

let error_cant_apply_bad_type env t rator randl =
  raise (TypeError (env, CantApplyBadType (t,rator,randl)))

let error_ill_formed_rec_body env why lna i fixenv vdefj =
  raise (TypeError (env, IllFormedRecBody (why,lna,i,fixenv,vdefj)))

let error_ill_typed_rec_body env i lna vdefj vargs =
  raise (TypeError (env, IllTypedRecBody (i,lna,vdefj,vargs)))

let error_elim_explain kp ki =
  let open Sorts in
  match kp,ki with
  | (InType | InSet), InProp -&gt; NonInformativeToInformative
  | InType, InSet -&gt; StrongEliminationOnNonSmallType (* if Set impredicative *)
  | _ -&gt; WrongArity

let error_unsatisfied_constraints env c =
  raise (TypeError (env, UnsatisfiedConstraints c))

let error_undeclared_universe env l =
  raise (TypeError (env, UndeclaredUniverse l))

let error_disallowed_sprop env =
  raise (TypeError (env, DisallowedSProp))

let error_bad_relevance env =
  raise (TypeError (env, BadRelevance))

let map_pguard_error f = function
| NotEnoughAbstractionInFixBody -&gt; NotEnoughAbstractionInFixBody
| RecursionNotOnInductiveType c -&gt; RecursionNotOnInductiveType (f c)
| RecursionOnIllegalTerm (n, (env, c), l1, l2) -&gt; RecursionOnIllegalTerm (n, (env, f c), l1, l2)
| NotEnoughArgumentsForFixCall n -&gt; NotEnoughArgumentsForFixCall n
| CodomainNotInductiveType c -&gt; CodomainNotInductiveType (f c)
| NestedRecursiveOccurrences -&gt; NestedRecursiveOccurrences
| UnguardedRecursiveCall c -&gt; UnguardedRecursiveCall (f c)
| RecCallInTypeOfAbstraction c -&gt; RecCallInTypeOfAbstraction (f c)
| RecCallInNonRecArgOfConstructor c -&gt; RecCallInNonRecArgOfConstructor (f c)
| RecCallInTypeOfDef c -&gt; RecCallInTypeOfDef (f c)
| RecCallInCaseFun c -&gt; RecCallInCaseFun (f c)
| RecCallInCaseArg c -&gt; RecCallInCaseArg (f c)
| RecCallInCasePred c -&gt; RecCallInCasePred (f c)
| NotGuardedForm c -&gt; NotGuardedForm (f c)
| ReturnPredicateNotCoInductive c -&gt; ReturnPredicateNotCoInductive (f c)
| FixpointOnIrrelevantInductive -&gt; FixpointOnIrrelevantInductive

let map_ptype_error f = function
| UnboundRel n -&gt; UnboundRel n
| UnboundVar id -&gt; UnboundVar id
| NotAType j -&gt; NotAType (on_judgment f j)
| BadAssumption j -&gt; BadAssumption (on_judgment f j)
| ReferenceVariables (id, c) -&gt; ReferenceVariables (id, f c)
| ElimArity (pi, c, j, ar) -&gt; ElimArity (pi, f c, on_judgment f j, ar)
| CaseNotInductive j -&gt; CaseNotInductive (on_judgment f j)
| WrongCaseInfo (pi, ci) -&gt; WrongCaseInfo (pi, ci)
| NumberBranches (j, n) -&gt; NumberBranches (on_judgment f j, n)
| IllFormedBranch (c, pc, t1, t2) -&gt; IllFormedBranch (f c, pc, f t1, f t2)
| Generalization ((na, t), j) -&gt; Generalization ((na, f t), on_judgment f j)
| ActualType (j, t) -&gt; ActualType (on_judgment f j, f t)
| IncorrectPrimitive (p, t) -&gt; IncorrectPrimitive ({p with uj_type=f p.uj_type}, f t)
| CantApplyBadType ((n, c1, c2), j, vj) -&gt;
  CantApplyBadType ((n, f c1, f c2), on_judgment f j, Array.map (on_judgment f) vj)
| CantApplyNonFunctional (j, jv) -&gt; CantApplyNonFunctional (on_judgment f j, Array.map (on_judgment f) jv)
| IllFormedRecBody (ge, na, n, env, jv) -&gt;
  IllFormedRecBody (map_pguard_error f ge, na, n, env, Array.map (on_judgment f) jv)
| IllTypedRecBody (n, na, jv, t) -&gt;
  IllTypedRecBody (n, na, Array.map (on_judgment f) jv, Array.map f t)
| UnsatisfiedConstraints g -&gt; UnsatisfiedConstraints g
| UndeclaredUniverse l -&gt; UndeclaredUniverse l
| DisallowedSProp -&gt; DisallowedSProp
| BadRelevance -&gt; BadRelevance
</pre>
          </div>
          <div class="col-md-6">
            <code>type_errors.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Names.

Import Constr.

Import Environ.

Import Reduction.

Inductive pguard_error (constr : Type) : Type :=
| NotEnoughAbstractionInFixBody : pguard_error constr
| RecursionNotOnInductiveType : constr -&gt; pguard_error constr
| RecursionOnIllegalTerm : Z -&gt; (Environ.env * constr) -&gt; (list Z) -&gt; (list Z)
  -&gt; pguard_error constr
| NotEnoughArgumentsForFixCall : Z -&gt; pguard_error constr
| CodomainNotInductiveType : constr -&gt; pguard_error constr
| NestedRecursiveOccurrences : pguard_error constr
| UnguardedRecursiveCall : constr -&gt; pguard_error constr
| RecCallInTypeOfAbstraction : constr -&gt; pguard_error constr
| RecCallInNonRecArgOfConstructor : constr -&gt; pguard_error constr
| RecCallInTypeOfDef : constr -&gt; pguard_error constr
| RecCallInCaseFun : constr -&gt; pguard_error constr
| RecCallInCaseArg : constr -&gt; pguard_error constr
| RecCallInCasePred : constr -&gt; pguard_error constr
| NotGuardedForm : constr -&gt; pguard_error constr
| ReturnPredicateNotCoInductive : constr -&gt; pguard_error constr
| FixpointOnIrrelevantInductive : pguard_error constr.

Arguments NotEnoughAbstractionInFixBody {_}.
Arguments RecursionNotOnInductiveType {_}.
Arguments RecursionOnIllegalTerm {_}.
Arguments NotEnoughArgumentsForFixCall {_}.
Arguments CodomainNotInductiveType {_}.
Arguments NestedRecursiveOccurrences {_}.
Arguments UnguardedRecursiveCall {_}.
Arguments RecCallInTypeOfAbstraction {_}.
Arguments RecCallInNonRecArgOfConstructor {_}.
Arguments RecCallInTypeOfDef {_}.
Arguments RecCallInCaseFun {_}.
Arguments RecCallInCaseArg {_}.
Arguments RecCallInCasePred {_}.
Arguments NotGuardedForm {_}.
Arguments ReturnPredicateNotCoInductive {_}.
Arguments FixpointOnIrrelevantInductive {_}.

Definition guard_error := pguard_error Constr.constr.

Inductive arity_error : Type :=
| NonInformativeToInformative : arity_error
| StrongEliminationOnNonSmallType : arity_error
| WrongArity : arity_error.

Inductive ptype_error (constr types : Type) : Type :=
| UnboundRel : Z -&gt; ptype_error constr types
| UnboundVar : Names.variable -&gt; ptype_error constr types
| NotAType : (Environ.punsafe_judgment constr types) -&gt; ptype_error constr types
| BadAssumption : (Environ.punsafe_judgment constr types) -&gt;
  ptype_error constr types
| ReferenceVariables : Names.Id.t -&gt; constr -&gt; ptype_error constr types
| ElimArity : Constr.pinductive -&gt; constr -&gt;
  (Environ.punsafe_judgment constr types) -&gt;
  (option (Sorts.family * Sorts.family * Sorts.family * arity_error)) -&gt;
  ptype_error constr types
| CaseNotInductive : (Environ.punsafe_judgment constr types) -&gt;
  ptype_error constr types
| WrongCaseInfo : Constr.pinductive -&gt; Constr.case_info -&gt;
  ptype_error constr types
| NumberBranches : (Environ.punsafe_judgment constr types) -&gt; Z -&gt;
  ptype_error constr types
| IllFormedBranch : constr -&gt; Constr.pconstructor -&gt; constr -&gt; constr -&gt;
  ptype_error constr types
| Generalization : (Names.Name.t * types) -&gt;
  (Environ.punsafe_judgment constr types) -&gt; ptype_error constr types
| ActualType : (Environ.punsafe_judgment constr types) -&gt; types -&gt;
  ptype_error constr types
| IncorrectPrimitive : (Environ.punsafe_judgment CPrimitives.op_or_type types)
  -&gt; types -&gt; ptype_error constr types
| CantApplyBadType : (Z * constr * constr) -&gt;
  (Environ.punsafe_judgment constr types) -&gt;
  (array (Environ.punsafe_judgment constr types)) -&gt; ptype_error constr types
| CantApplyNonFunctional : (Environ.punsafe_judgment constr types) -&gt;
  (array (Environ.punsafe_judgment constr types)) -&gt; ptype_error constr types
| IllFormedRecBody : (pguard_error constr) -&gt;
  (array (Context.binder_annot Names.Name.t)) -&gt; Z -&gt; Environ.env -&gt;
  (array (Environ.punsafe_judgment constr types)) -&gt; ptype_error constr types
| IllTypedRecBody : Z -&gt; (array (Context.binder_annot Names.Name.t)) -&gt;
  (array (Environ.punsafe_judgment constr types)) -&gt; (array types) -&gt;
  ptype_error constr types
| UnsatisfiedConstraints : Univ.Constraint.t -&gt; ptype_error constr types
| UndeclaredUniverse : Univ.Level.t -&gt; ptype_error constr types
| DisallowedSProp : ptype_error constr types
| BadRelevance : ptype_error constr types.

Arguments UnboundRel {_ _}.
Arguments UnboundVar {_ _}.
Arguments NotAType {_ _}.
Arguments BadAssumption {_ _}.
Arguments ReferenceVariables {_ _}.
Arguments ElimArity {_ _}.
Arguments CaseNotInductive {_ _}.
Arguments WrongCaseInfo {_ _}.
Arguments NumberBranches {_ _}.
Arguments IllFormedBranch {_ _}.
Arguments Generalization {_ _}.
Arguments ActualType {_ _}.
Arguments IncorrectPrimitive {_ _}.
Arguments CantApplyBadType {_ _}.
Arguments CantApplyNonFunctional {_ _}.
Arguments IllFormedRecBody {_ _}.
Arguments IllTypedRecBody {_ _}.
Arguments UnsatisfiedConstraints {_ _}.
Arguments UndeclaredUniverse {_ _}.
Arguments DisallowedSProp {_ _}.
Arguments BadRelevance {_ _}.

Definition type_error := ptype_error Constr.constr Constr.types.

Inductive inductive_error : Type :=
| NonPos : Environ.env -&gt; Constr.constr -&gt; Constr.constr -&gt; inductive_error
| NotEnoughArgs : Environ.env -&gt; Constr.constr -&gt; Constr.constr -&gt;
  inductive_error
| NotConstructor : Environ.env -&gt; Names.Id.t -&gt; Constr.constr -&gt; Constr.constr
  -&gt; Z -&gt; Z -&gt; inductive_error
| NonPar : Environ.env -&gt; Constr.constr -&gt; Z -&gt; Constr.constr -&gt; Constr.constr
  -&gt; inductive_error
| SameNamesTypes : Names.Id.t -&gt; inductive_error
| SameNamesConstructors : Names.Id.t -&gt; inductive_error
| SameNamesOverlap : (list Names.Id.t) -&gt; inductive_error
| NotAnArity : Environ.env -&gt; Constr.constr -&gt; inductive_error
| BadEntry : inductive_error
| LargeNonPropInductiveNotInType : inductive_error
| BadUnivs : inductive_error.

Definition nfj {A : Type}
  (env : Environ.env)
  (function_parameter : Environ.punsafe_judgment A Constr.constr)
  : Environ.punsafe_judgment A Constr.constr :=
  match function_parameter with
  | {| uj_val := c; uj_type := ct |} =&gt;
    {| uj_val := c; uj_type := Reduction.nf_betaiota env ct |}
  end.

Definition error_unbound_rel {A : Type} (env : Environ.env) (n : Z) : A :=
  Stdlib.raise (TypeError env (UnboundRel n)).

Definition error_unbound_var {A : Type} (env : Environ.env) (v : Names.variable)
  : A := Stdlib.raise (TypeError env (UnboundVar v)).

Definition error_not_type {A : Type}
  (env : Environ.env) (j : Environ.punsafe_judgment Constr.constr Constr.types)
  : A := Stdlib.raise (TypeError env (NotAType j)).

Definition error_assumption {A : Type}
  (env : Environ.env) (j : Environ.punsafe_judgment Constr.constr Constr.types)
  : A := Stdlib.raise (TypeError env (BadAssumption j)).

Definition error_reference_variables {A : Type}
  (env : Environ.env) (id : Names.Id.t) (c : Constr.constr) : A :=
  Stdlib.raise (TypeError env (ReferenceVariables id c)).

Definition error_elim_arity {A : Type}
  (env : Environ.env) (ind : Constr.pinductive) (c : Constr.constr)
  (pj : Environ.punsafe_judgment Constr.constr Constr.types)
  (okinds : option (Sorts.family * Sorts.family * Sorts.family * arity_error))
  : A := Stdlib.raise (TypeError env (ElimArity ind c pj okinds)).

Definition error_case_not_inductive {A : Type}
  (env : Environ.env) (j : Environ.punsafe_judgment Constr.constr Constr.types)
  : A := Stdlib.raise (TypeError env (CaseNotInductive j)).

Definition error_number_branches {A : Type}
  (env : Environ.env)
  (cj : Environ.punsafe_judgment Constr.constr Constr.constr) (expn : Z) : A :=
  Stdlib.raise (TypeError env (NumberBranches (nfj env cj) expn)).

Definition error_ill_formed_branch {A : Type}
  (env : Environ.env) (c : Constr.constr) (i : Constr.pconstructor)
  (actty : Constr.constr) (expty : Constr.constr) : A :=
  Stdlib.raise
    (TypeError env
      (IllFormedBranch c i (Reduction.nf_betaiota env actty)
        (Reduction.nf_betaiota env expty))).

Definition error_generalization {A : Type}
  (env : Environ.env) (nvar : Names.Name.t * Constr.types)
  (c : Environ.punsafe_judgment Constr.constr Constr.types) : A :=
  Stdlib.raise (TypeError env (Generalization nvar c)).

Definition error_actual_type {A : Type}
  (env : Environ.env) (j : Environ.punsafe_judgment Constr.constr Constr.types)
  (expty : Constr.types) : A :=
  Stdlib.raise (TypeError env (ActualType j expty)).

Definition error_incorrect_primitive {A : Type}
  (env : Environ.env)
  (p : Environ.punsafe_judgment CPrimitives.op_or_type Constr.types)
  (t : Constr.types) : A :=
  Stdlib.raise (TypeError env (IncorrectPrimitive p t)).

Definition error_cant_apply_not_functional {A : Type}
  (env : Environ.env)
  (rator : Environ.punsafe_judgment Constr.constr Constr.types)
  (randl : array (Environ.punsafe_judgment Constr.constr Constr.types)) : A :=
  Stdlib.raise (TypeError env (CantApplyNonFunctional rator randl)).

Definition error_cant_apply_bad_type {A : Type}
  (env : Environ.env) (t : Z * Constr.constr * Constr.constr)
  (rator : Environ.punsafe_judgment Constr.constr Constr.types)
  (randl : array (Environ.punsafe_judgment Constr.constr Constr.types)) : A :=
  Stdlib.raise (TypeError env (CantApplyBadType t rator randl)).

Definition error_ill_formed_rec_body {A : Type}
  (env : Environ.env) (why : pguard_error Constr.constr)
  (lna : array (Context.binder_annot Names.Name.t)) (i : Z)
  (fixenv : Environ.env)
  (vdefj : array (Environ.punsafe_judgment Constr.constr Constr.types)) : A :=
  Stdlib.raise (TypeError env (IllFormedRecBody why lna i fixenv vdefj)).

Definition error_ill_typed_rec_body {A : Type}
  (env : Environ.env) (i : Z) (lna : array (Context.binder_annot Names.Name.t))
  (vdefj : array (Environ.punsafe_judgment Constr.constr Constr.types))
  (vargs : array Constr.types) : A :=
  Stdlib.raise (TypeError env (IllTypedRecBody i lna vdefj vargs)).

Definition error_elim_explain (kp : Sorts.family) (ki : Sorts.family)
  : arity_error :=
  match (kp, ki) with
  | (InType | InSet, InProp) =&gt; NonInformativeToInformative
  | (InType, InSet) =&gt; StrongEliminationOnNonSmallType
  | _ =&gt; WrongArity
  end.

Definition error_unsatisfied_constraints {A : Type}
  (env : Environ.env) (c : Univ.Constraint.t) : A :=
  Stdlib.raise (TypeError env (UnsatisfiedConstraints c)).

Definition error_undeclared_universe {A : Type}
  (env : Environ.env) (l : Univ.Level.t) : A :=
  Stdlib.raise (TypeError env (UndeclaredUniverse l)).

Definition error_disallowed_sprop {A : Type} (env : Environ.env) : A :=
  Stdlib.raise (TypeError env DisallowedSProp).

Definition error_bad_relevance {A : Type} (env : Environ.env) : A :=
  Stdlib.raise (TypeError env BadRelevance).

Definition map_pguard_error {A B : Type}
  (f : A -&gt; B) (function_parameter : pguard_error A) : pguard_error B :=
  match function_parameter with
  | NotEnoughAbstractionInFixBody =&gt; NotEnoughAbstractionInFixBody
  | RecursionNotOnInductiveType c =&gt; RecursionNotOnInductiveType (f c)
  | RecursionOnIllegalTerm n (env, c) l1 l2 =&gt;
    RecursionOnIllegalTerm n (env, (f c)) l1 l2
  | NotEnoughArgumentsForFixCall n =&gt; NotEnoughArgumentsForFixCall n
  | CodomainNotInductiveType c =&gt; CodomainNotInductiveType (f c)
  | NestedRecursiveOccurrences =&gt; NestedRecursiveOccurrences
  | UnguardedRecursiveCall c =&gt; UnguardedRecursiveCall (f c)
  | RecCallInTypeOfAbstraction c =&gt; RecCallInTypeOfAbstraction (f c)
  | RecCallInNonRecArgOfConstructor c =&gt; RecCallInNonRecArgOfConstructor (f c)
  | RecCallInTypeOfDef c =&gt; RecCallInTypeOfDef (f c)
  | RecCallInCaseFun c =&gt; RecCallInCaseFun (f c)
  | RecCallInCaseArg c =&gt; RecCallInCaseArg (f c)
  | RecCallInCasePred c =&gt; RecCallInCasePred (f c)
  | NotGuardedForm c =&gt; NotGuardedForm (f c)
  | ReturnPredicateNotCoInductive c =&gt; ReturnPredicateNotCoInductive (f c)
  | FixpointOnIrrelevantInductive =&gt; FixpointOnIrrelevantInductive
  end.

Definition map_ptype_error {A B : Type}
  (f : A -&gt; B) (function_parameter : ptype_error A A) : ptype_error B B :=
  match function_parameter with
  | UnboundRel n =&gt; UnboundRel n
  | UnboundVar id =&gt; UnboundVar id
  | NotAType j =&gt; NotAType (Environ.on_judgment f j)
  | BadAssumption j =&gt; BadAssumption (Environ.on_judgment f j)
  | ReferenceVariables id c =&gt; ReferenceVariables id (f c)
  | ElimArity pi c j ar =&gt; ElimArity pi (f c) (Environ.on_judgment f j) ar
  | CaseNotInductive j =&gt; CaseNotInductive (Environ.on_judgment f j)
  | WrongCaseInfo pi ci =&gt; WrongCaseInfo pi ci
  | NumberBranches j n =&gt; NumberBranches (Environ.on_judgment f j) n
  | IllFormedBranch c pc t1 t2 =&gt; IllFormedBranch (f c) pc (f t1) (f t2)
  | Generalization (na, t) j =&gt;
    Generalization (na, (f t)) (Environ.on_judgment f j)
  | ActualType j t =&gt; ActualType (Environ.on_judgment f j) (f t)
  | IncorrectPrimitive p t =&gt; IncorrectPrimitive record (f t)
  | CantApplyBadType (n, c1, c2) j vj =&gt;
    CantApplyBadType (n, (f c1), (f c2)) (Environ.on_judgment f j)
      (Stdlib.Array.map (Environ.on_judgment f) vj)
  | CantApplyNonFunctional j jv =&gt;
    CantApplyNonFunctional (Environ.on_judgment f j)
      (Stdlib.Array.map (Environ.on_judgment f) jv)
  | IllFormedRecBody ge na n env jv =&gt;
    IllFormedRecBody (map_pguard_error f ge) na n env
      (Stdlib.Array.map (Environ.on_judgment f) jv)
  | IllTypedRecBody n na jv t =&gt;
    IllTypedRecBody n na (Stdlib.Array.map (Environ.on_judgment f) jv)
      (Stdlib.Array.map f t)
  | UnsatisfiedConstraints g =&gt; UnsatisfiedConstraints g
  | UndeclaredUniverse l =&gt; UndeclaredUniverse l
  | DisallowedSProp =&gt; DisallowedSProp
  | BadRelevance =&gt; BadRelevance
  end.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="typeops" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>typeops.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open CErrors
open Util
open Names
open Univ
open Sorts
open Term
open Constr
open Context
open Vars
open Declarations
open Environ
open Reduction
open Inductive
open Type_errors

module RelDecl = Context.Rel.Declaration
module NamedDecl = Context.Named.Declaration

exception NotConvertibleVect of int

let conv_leq l2r env x y = default_conv CUMUL ~l2r env x y

let conv_leq_vecti env v1 v2 =
  Array.fold_left2_i
    (fun i _ t1 t2 -&gt;
      try conv_leq false env t1 t2
      with NotConvertible -&gt; raise (NotConvertibleVect i))
    ()
    v1
    v2

let check_constraints cst env = 
  if Environ.check_constraints cst env then ()
  else error_unsatisfied_constraints env cst

(* This should be a type (a priori without intention to be an assumption) *)
let check_type env c t =
  match kind(whd_all env t) with
  | Sort s -&gt; s
  | _ -&gt; error_not_type env (make_judge c t)

(* This should be a type intended to be assumed. The error message is
   not as useful as for [type_judgment]. *)
let infer_assumption env t ty =
  try
    let s = check_type env t ty in
    (match s with Sorts.SProp -&gt; Irrelevant | _ -&gt; Relevant)
  with TypeError _ -&gt;
    error_assumption env (make_judge t ty)

let warn_bad_relevance_name = &quot;bad-relevance&quot;
let warn_bad_relevance =
  CWarnings.create ~name:warn_bad_relevance_name ~category:&quot;debug&quot; ~default:CWarnings.Disabled
    Pp.(function
        | None -&gt;  str &quot;Bad relevance in case annotation.&quot;
        | Some x -&gt; str &quot;Bad relevance for binder &quot; ++ Name.print x.binder_name ++ str &quot;.&quot;)

let warn_bad_relevance_ci ?loc () = warn_bad_relevance ?loc None
let warn_bad_relevance ?loc x = warn_bad_relevance ?loc (Some x)

let check_assumption env x t ty =
  let r = x.binder_relevance in
  let r' = infer_assumption env t ty in
  let x = if Sorts.relevance_equal r r'
    then x
    else (warn_bad_relevance x; {x with binder_relevance = r'})
  in
  x

(************************************************)
(* Incremental typing rules: builds a typing judgment given the *)
(* judgments for the subterms. *)

(*s Type of sorts *)

(* Prop and Set *)

let type1 = mkSort Sorts.type1

(* Type of Type(i). *)

let type_of_type u =
  let uu = Universe.super u in
    mkType uu

let type_of_sort = function
  | SProp | Prop | Set -&gt; type1
  | Type u -&gt; type_of_type u

(*s Type of a de Bruijn index. *)

let type_of_relative env n =
  try
    env |&gt; lookup_rel n |&gt; RelDecl.get_type |&gt; lift n
  with Not_found -&gt;
    error_unbound_rel env n

(* Type of variables *)
let type_of_variable env id =
  try named_type id env
  with Not_found -&gt;
    error_unbound_var env id

(* Management of context of variables. *)

(* Checks if a context of variables can be instantiated by the
   variables of the current env.
   Order does not have to be checked assuming that all names are distinct *)
let check_hyps_inclusion env ?evars f c sign =
  let conv env a b = conv env ?evars a b in
  Context.Named.fold_outside
    (fun d1 () -&gt;
      let open Context.Named.Declaration in
      let id = NamedDecl.get_id d1 in
      try
        let d2 = lookup_named id env in
        conv env (get_type d2) (get_type d1);
        (match d2,d1 with
        | LocalAssum _, LocalAssum _ -&gt; ()
        | LocalAssum _, LocalDef _ -&gt;
            (* This is wrong, because we don't know if the body is
               needed or not for typechecking: *) ()
        | LocalDef _, LocalAssum _ -&gt; raise NotConvertible
        | LocalDef (_,b2,_), LocalDef (_,b1,_) -&gt; conv env b2 b1);
      with Not_found | NotConvertible | Option.Heterogeneous -&gt;
        error_reference_variables env id (f c))
    sign
    ~init:()

(* Instantiation of terms on real arguments. *)

(* Make a type polymorphic if an arity *)

(* Type of constants *)


let type_of_constant env (kn,_u as cst) =
  let cb = lookup_constant kn env in
  let () = check_hyps_inclusion env mkConstU cst cb.const_hyps in
  let ty, cu = constant_type env cst in
  let () = check_constraints cu env in
    ty

let type_of_constant_in env (kn,_u as cst) =
  let cb = lookup_constant kn env in
  let () = check_hyps_inclusion env mkConstU cst cb.const_hyps in
  constant_type_in env cst

(* Type of a lambda-abstraction. *)

(* [judge_of_abstraction env name var j] implements the rule

 env, name:typ |- j.uj_val:j.uj_type     env, |- (name:typ)j.uj_type : s
 -----------------------------------------------------------------------
          env |- [name:typ]j.uj_val : (name:typ)j.uj_type

  Since all products are defined in the Calculus of Inductive Constructions
  and no upper constraint exists on the sort $s$, we don't need to compute $s$
*)

let type_of_abstraction _env name var ty =
  mkProd (name, var, ty)

(* Type of an application. *)

let make_judgev c t = 
  Array.map2 make_judge c t

let rec check_empty_stack = function
| [] -&gt; true
| CClosure.Zupdate _ :: s -&gt; check_empty_stack s
| _ -&gt; false

let type_of_apply env func funt argsv argstv =
  let open CClosure in
  let len = Array.length argsv in
  let infos = create_clos_infos all env in
  let tab = create_tab () in
  let rec apply_rec i typ =
    if Int.equal i len then term_of_fconstr typ
    else
      let typ, stk = whd_stack infos tab typ [] in
      (** The return stack is known to be empty *)
      let () = assert (check_empty_stack stk) in
      match fterm_of typ with
      | FProd (_, c1, c2, e) -&gt;
        let arg = argsv.(i) in
        let argt = argstv.(i) in
        let c1 = term_of_fconstr c1 in
        begin match conv_leq false env argt c1 with
        | () -&gt; apply_rec (i+1) (mk_clos (Esubst.subs_cons ([| inject arg |], e)) c2)
        | exception NotConvertible -&gt;
          error_cant_apply_bad_type env
            (i+1,c1,argt)
            (make_judge func funt)
            (make_judgev argsv argstv)
        end
      | _ -&gt;
        error_cant_apply_not_functional env
          (make_judge func funt)
          (make_judgev argsv argstv)
  in
  apply_rec 0 (inject funt)

(* Type of primitive constructs *)
let type_of_prim_type _env = function
  | CPrimitives.PT_int63 -&gt; Constr.mkSet

let type_of_int env =
  match env.retroknowledge.Retroknowledge.retro_int63 with
  | Some c -&gt; mkConst c
  | None -&gt; CErrors.user_err Pp.(str&quot;The type int must be registered before this construction can be typechecked.&quot;)

let type_of_prim env t =
  let int_ty = type_of_int env in
  let bool_ty () =
    match env.retroknowledge.Retroknowledge.retro_bool with
    | Some ((ind,_),_) -&gt; Constr.mkInd ind
    | None -&gt; CErrors.user_err Pp.(str&quot;The type bool must be registered before this primitive.&quot;)
  in
  let compare_ty () =
    match env.retroknowledge.Retroknowledge.retro_cmp with
    | Some ((ind,_),_,_) -&gt; Constr.mkInd ind
    | None -&gt; CErrors.user_err Pp.(str&quot;The type compare must be registered before this primitive.&quot;)
  in
  let pair_ty fst_ty snd_ty =
    match env.retroknowledge.Retroknowledge.retro_pair with
    | Some (ind,_) -&gt; Constr.mkApp(Constr.mkInd ind, [|fst_ty;snd_ty|])
    | None -&gt; CErrors.user_err Pp.(str&quot;The type pair must be registered before this primitive.&quot;)
  in
  let carry_ty int_ty =
    match env.retroknowledge.Retroknowledge.retro_carry with
    | Some ((ind,_),_) -&gt; Constr.mkApp(Constr.mkInd ind, [|int_ty|])
    | None -&gt; CErrors.user_err Pp.(str&quot;The type carry must be registered before this primitive.&quot;)
  in
  let rec nary_int63_op arity ty =
    if Int.equal arity 0 then ty
      else Constr.mkProd(Context.nameR (Id.of_string &quot;x&quot;), int_ty, nary_int63_op (arity-1) ty)
  in
  let return_ty =
    let open CPrimitives in
    match t with
    | Int63head0
    | Int63tail0
    | Int63add
    | Int63sub
    | Int63mul
    | Int63div
    | Int63mod
    | Int63lsr
    | Int63lsl
    | Int63land
    | Int63lor
    | Int63lxor
    | Int63addMulDiv -&gt; int_ty
    | Int63eq
    | Int63lt
    | Int63le -&gt; bool_ty ()
    | Int63mulc
    | Int63div21
    | Int63diveucl -&gt; pair_ty int_ty int_ty
    | Int63addc
    | Int63subc
    | Int63addCarryC
    | Int63subCarryC -&gt; carry_ty int_ty
    | Int63compare -&gt; compare_ty ()
  in
  nary_int63_op (CPrimitives.arity t) return_ty

let type_of_prim_or_type env = let open CPrimitives in
  function
  | OT_type t -&gt; type_of_prim_type env t
  | OT_op op -&gt; type_of_prim env op

let judge_of_int env i =
  make_judge (Constr.mkInt i) (type_of_int env)

(* Type of product *)

let sort_of_product env domsort rangsort =
  match (domsort, rangsort) with
    | (_, SProp) | (SProp, _) -&gt; rangsort
    (* Product rule (s,Prop,Prop) *)
    | (_,       Prop)  -&gt; rangsort
    (* Product rule (Prop/Set,Set,Set) *)
    | ((Prop | Set),  Set) -&gt; rangsort
    (* Product rule (Type,Set,?) *)
    | (Type u1, Set) -&gt;
        if is_impredicative_set env then
          (* Rule is (Type,Set,Set) in the Set-impredicative calculus *)
          rangsort
        else
          (* Rule is (Type_i,Set,Type_i) in the Set-predicative calculus *)
          Sorts.sort_of_univ (Universe.sup Universe.type0 u1)
    (* Product rule (Prop,Type_i,Type_i) *)
    | (Set,  Type u2)  -&gt; Sorts.sort_of_univ (Universe.sup Universe.type0 u2)
    (* Product rule (Prop,Type_i,Type_i) *)
    | (Prop, Type _)  -&gt; rangsort
    (* Product rule (Type_i,Type_i,Type_i) *)
    | (Type u1, Type u2) -&gt; Sorts.sort_of_univ (Universe.sup u1 u2)

(* [judge_of_product env name (typ1,s1) (typ2,s2)] implements the rule

    env |- typ1:s1       env, name:typ1 |- typ2 : s2
    -------------------------------------------------------------------------
         s' &gt;= (s1,s2), env |- (name:typ)j.uj_val : s'

  where j.uj_type is convertible to a sort s2
*)
let type_of_product env _name s1 s2 =
  let s = sort_of_product env s1 s2 in
    mkSort s

(* Type of a type cast *)

(* [judge_of_cast env (c,typ1) (typ2,s)] implements the rule

    env |- c:typ1    env |- typ2:s    env |- typ1 &lt;= typ2
    ---------------------------------------------------------------------
         env |- c:typ2
*)

let check_cast env c ct k expected_type =
  try
    match k with
    | VMcast -&gt;
      Vconv.vm_conv CUMUL env ct expected_type
    | DEFAULTcast -&gt;
      default_conv ~l2r:false CUMUL env ct expected_type
    | REVERTcast -&gt;
      default_conv ~l2r:true CUMUL env ct expected_type
    | NATIVEcast -&gt;
      let sigma = Nativelambda.empty_evars in
      Nativeconv.native_conv CUMUL sigma env ct expected_type
  with NotConvertible -&gt;
    error_actual_type env (make_judge c ct) expected_type

(* Inductive types. *)

(* The type is parametric over the uniform parameters whose conclusion
   is in Type; to enforce the internal constraints between the
   parameters and the instances of Type occurring in the type of the
   constructors, we use the level variables _statically_ assigned to
   the conclusions of the parameters as mediators: e.g. if a parameter
   has conclusion Type(alpha), static constraints of the form alpha&lt;=v
   exist between alpha and the Type's occurring in the constructor
   types; when the parameters is finally instantiated by a term of
   conclusion Type(u), then the constraints u&lt;=alpha is computed in
   the App case of execute; from this constraints, the expected
   dynamic constraints of the form u&lt;=v are enforced *)

let type_of_inductive_knowing_parameters env (ind,u as indu) args =
  let (mib,_mip) as spec = lookup_mind_specif env ind in
  check_hyps_inclusion env mkIndU indu mib.mind_hyps;
  let t,cst = Inductive.constrained_type_of_inductive_knowing_parameters 
    env (spec,u) args
  in
  check_constraints cst env;
  t

let type_of_inductive env (ind,u as indu) =
  let (mib,mip) = lookup_mind_specif env ind in
  check_hyps_inclusion env mkIndU indu mib.mind_hyps;
  let t,cst = Inductive.constrained_type_of_inductive env ((mib,mip),u) in
  check_constraints cst env;
  t

(* Constructors. *)

let type_of_constructor env (c,_u as cu) =
  let () =
    let ((kn,_),_) = c in
    let mib = lookup_mind kn env in
    check_hyps_inclusion env mkConstructU cu mib.mind_hyps
  in
  let specif = lookup_mind_specif env (inductive_of_constructor c) in
  let t,cst = constrained_type_of_constructor cu specif in
  let () = check_constraints cst env in
  t

(* Case. *)

let check_branch_types env (ind,u) c ct lft explft =
  try conv_leq_vecti env lft explft
  with
      NotConvertibleVect i -&gt;
        error_ill_formed_branch env c ((ind,i+1),u) lft.(i) explft.(i)
    | Invalid_argument _ -&gt;
        error_number_branches env (make_judge c ct) (Array.length explft)

let type_of_case env ci p pt c ct _lf lft =
  let (pind, _ as indspec) =
    try find_rectype env ct
    with Not_found -&gt; error_case_not_inductive env (make_judge c ct) in
  let _, sp = try dest_arity env pt
    with NotArity -&gt; error_elim_arity env pind c (make_judge p pt) None in
  let rp = Sorts.relevance_of_sort sp in
  let ci = if ci.ci_relevance == rp then ci
    else (warn_bad_relevance_ci (); {ci with ci_relevance=rp})
  in
  let () = check_case_info env pind rp ci in
  let (bty,rslty) =
    type_case_branches env indspec (make_judge p pt) c in
  let () = check_branch_types env pind c ct lft bty in
  ci, rslty

let type_of_projection env p c ct =
  let pty = lookup_projection p env in
  let (ind,u), args =
    try find_rectype env ct
    with Not_found -&gt; error_case_not_inductive env (make_judge c ct)
  in
  assert(eq_ind (Projection.inductive p) ind);
  let ty = Vars.subst_instance_constr u pty in
  substl (c :: CList.rev args) ty
      

(* Fixpoints. *)

(* Checks the type of a general (co)fixpoint, i.e. without checking *)
(* the specific guard condition. *)

let check_fixpoint env lna lar vdef vdeft =
  let lt = Array.length vdeft in
  assert (Int.equal (Array.length lar) lt);
  try
    conv_leq_vecti env vdeft (Array.map (fun ty -&gt; lift lt ty) lar)
  with NotConvertibleVect i -&gt;
    error_ill_typed_rec_body env i lna (make_judgev vdef vdeft) lar

(* Global references *)

let type_of_global_in_context env r =
  let open Names.GlobRef in
  match r with
  | VarRef id -&gt; Environ.named_type id env, Univ.AUContext.empty
  | ConstRef c -&gt;
    let cb = Environ.lookup_constant c env in
    let univs = Declareops.constant_polymorphic_context cb in
    cb.Declarations.const_type, univs
  | IndRef ind -&gt;
    let (mib,_ as specif) = Inductive.lookup_mind_specif env ind in
    let univs = Declareops.inductive_polymorphic_context mib in
    let inst = Univ.make_abstract_instance univs in
    let env = Environ.push_context ~strict:false (Univ.AUContext.repr univs) env in
    Inductive.type_of_inductive env (specif, inst), univs
  | ConstructRef cstr -&gt;
    let (mib,_ as specif) =
      Inductive.lookup_mind_specif env (inductive_of_constructor cstr)
    in
    let univs = Declareops.inductive_polymorphic_context mib in
    let inst = Univ.make_abstract_instance univs in
    Inductive.type_of_constructor (cstr,inst) specif, univs

(************************************************************************)
(************************************************************************)

let check_binder_annot s x =
  let r = x.binder_relevance in
  let r' = Sorts.relevance_of_sort s in
  if r' == r
  then x
  else (warn_bad_relevance x; {x with binder_relevance = r'})

(* The typing machine. *)
    (* ATTENTION : faudra faire le typage du contexte des Const,
    Ind et Constructsi un jour cela devient des constructions
    arbitraires et non plus des variables *)
let rec execute env cstr =
  let open Context.Rel.Declaration in
  match kind cstr with
    (* Atomic terms *)
    | Sort s -&gt;
      (match s with
       | SProp -&gt; if not (Environ.sprop_allowed env) then error_disallowed_sprop env
       | _ -&gt; ());
      cstr, type_of_sort s

    | Rel n -&gt;
      cstr, type_of_relative env n

    | Var id -&gt;
      cstr, type_of_variable env id

    | Const c -&gt;
      cstr, type_of_constant env c
	
    | Proj (p, c) -&gt;
      let c', ct = execute env c in
      let cstr = if c == c' then cstr else mkProj (p,c') in
      cstr, type_of_projection env p c' ct

    (* Lambda calculus operators *)
    | App (f,args) -&gt;
      let args', argst = execute_array env args in
        let f', ft =
	  match kind f with
	  | Ind ind when Environ.template_polymorphic_pind ind env -&gt;
	    let args = Array.map (fun t -&gt; lazy t) argst in
              f, type_of_inductive_knowing_parameters env ind args
	  | _ -&gt;
	    (* No template polymorphism *)
            execute env f
	in
        let cstr = if f == f' &amp;&amp; args == args' then cstr else mkApp (f',args') in
        cstr, type_of_apply env f' ft args' argst

    | Lambda (name,c1,c2) -&gt;
      let c1', s = execute_is_type env c1 in
      let name' = check_binder_annot s name in
      let env1 = push_rel (LocalAssum (name',c1')) env in
      let c2', c2t = execute env1 c2 in
      let cstr = if name == name' &amp;&amp; c1 == c1' &amp;&amp; c2 == c2' then cstr else mkLambda(name',c1',c2') in
      cstr, type_of_abstraction env name' c1 c2t

    | Prod (name,c1,c2) -&gt;
      let c1', vars = execute_is_type env c1 in
      let name' = check_binder_annot vars name in
      let env1 = push_rel (LocalAssum (name',c1')) env in
      let c2', vars' = execute_is_type env1 c2 in
      let cstr = if name == name' &amp;&amp; c1 == c1' &amp;&amp; c2 == c2' then cstr else mkProd(name',c1',c2') in
      cstr, type_of_product env name' vars vars'

    | LetIn (name,c1,c2,c3) -&gt;
      let c1', c1t = execute env c1 in
      let c2', c2s = execute_is_type env c2 in
      let name' = check_binder_annot c2s name in
      let () = check_cast env c1' c1t DEFAULTcast c2' in
      let env1 = push_rel (LocalDef (name',c1',c2')) env in
      let c3', c3t = execute env1 c3 in
      let cstr = if name == name' &amp;&amp; c1 == c1' &amp;&amp; c2 == c2' &amp;&amp; c3 == c3' then cstr
        else mkLetIn(name',c1',c2',c3')
      in
      cstr, subst1 c1 c3t

    | Cast (c,k,t) -&gt;
      let c', ct = execute env c in
      let t', _ts = execute_is_type env t in
      let () = check_cast env c' ct k t' in
      let cstr = if c == c' &amp;&amp; t == t' then cstr else mkCast(c',k,t') in
      cstr, t'

    (* Inductive types *)
    | Ind ind -&gt;
      cstr, type_of_inductive env ind

    | Construct c -&gt;
      cstr, type_of_constructor env c

    | Case (ci,p,c,lf) -&gt;
        let c', ct = execute env c in
        let p', pt = execute env p in
        let lf', lft = execute_array env lf in
        let ci', t = type_of_case env ci p' pt c' ct lf' lft in
        let cstr = if ci == ci' &amp;&amp; c == c' &amp;&amp; p == p' &amp;&amp; lf == lf' then cstr
          else mkCase(ci',p',c',lf')
        in
        cstr, t

    | Fix ((_vn,i as vni),recdef as fix) -&gt;
      let (fix_ty,recdef') = execute_recdef env recdef i in
      let cstr, fix = if recdef == recdef' then cstr, fix else
          let fix = (vni,recdef') in mkFix fix, fix
      in
      check_fix env fix; cstr, fix_ty
	  
    | CoFix (i,recdef as cofix) -&gt;
      let (fix_ty,recdef') = execute_recdef env recdef i in
      let cstr, cofix = if recdef == recdef' then cstr, cofix else
          let cofix = (i,recdef') in mkCoFix cofix, cofix
      in
      check_cofix env cofix; cstr, fix_ty

    (* Primitive types *)
    | Int _ -&gt; cstr, type_of_int env

    (* Partial proofs: unsupported by the kernel *)
    | Meta _ -&gt;
	anomaly (Pp.str &quot;the kernel does not support metavariables.&quot;)

    | Evar _ -&gt;
	anomaly (Pp.str &quot;the kernel does not support existential variables.&quot;)

and execute_is_type env constr =
  let c, t = execute env constr in
    c, check_type env constr t

and execute_recdef env (names,lar,vdef as recdef) i =
  let lar', lart = execute_array env lar in
  let names' = Array.Smart.map_i (fun i na -&gt; check_assumption env na lar'.(i) lart.(i)) names in
  let env1 = push_rec_types (names',lar',vdef) env in (* vdef is ignored *)
  let vdef', vdeft = execute_array env1 vdef in
  let () = check_fixpoint env1 names' lar' vdef' vdeft in
  let recdef = if names == names' &amp;&amp; lar == lar' &amp;&amp; vdef == vdef' then recdef else (names',lar',vdef') in
    (lar'.(i),recdef)

and execute_array env cs =
  let tys = Array.make (Array.length cs) mkProp in
  let cs = Array.Smart.map_i (fun i c -&gt; let c, ty = execute env c in tys.(i) &lt;- ty; c) cs in
  cs, tys

(* Derived functions *)

let check_wellformed_universes env c =
  let univs = universes_of_constr c in
  try UGraph.check_declared_universes (universes env) univs
  with UGraph.UndeclaredLevel u -&gt;
    error_undeclared_universe env u

let infer env constr =
  let () = check_wellformed_universes env constr in
  let constr, t = execute env constr in
  make_judge constr t

let infer = 
  if Flags.profile then
    let infer_key = CProfile.declare_profile &quot;Fast_infer&quot; in
      CProfile.profile2 infer_key (fun b c -&gt; infer b c)
  else (fun b c -&gt; infer b c)

let assumption_of_judgment env {uj_val=c; uj_type=t} =
  infer_assumption env c t

let type_judgment env {uj_val=c; uj_type=t} =
  let s = check_type env c t in
  {utj_val = c; utj_type = s }

let infer_type env constr =
  let () = check_wellformed_universes env constr in
  let constr, t = execute env constr in
  let s = check_type env constr t in
  {utj_val = constr; utj_type = s}

(* Typing of several terms. *)

let check_context env rels =
  let open Context.Rel.Declaration in
  Context.Rel.fold_outside (fun d (env,rels) -&gt;
    match d with
      | LocalAssum (x,ty) -&gt;
        let jty = infer_type env ty in
        let x = check_binder_annot jty.utj_type x in
        push_rel d env, LocalAssum (x,jty.utj_val) :: rels
      | LocalDef (x,bd,ty) -&gt;
        let j1 = infer env bd in
        let jty = infer_type env ty in
        conv_leq false env j1.uj_type ty;
        let x = check_binder_annot jty.utj_type x in
        push_rel d env, LocalDef (x,j1.uj_val,jty.utj_val) :: rels)
    rels ~init:(env,[])

let judge_of_prop = make_judge mkProp type1
let judge_of_set = make_judge mkSet type1
let judge_of_type u = make_judge (mkType u) (type_of_type u)

let judge_of_relative env k = make_judge (mkRel k) (type_of_relative env k)

let judge_of_variable env x = make_judge (mkVar x) (type_of_variable env x)

let judge_of_constant env cst = make_judge (mkConstU cst) (type_of_constant env cst)

let judge_of_projection env p cj =
  make_judge (mkProj (p,cj.uj_val)) (type_of_projection env p cj.uj_val cj.uj_type)

let dest_judgev v =
  Array.map j_val v, Array.map j_type v

let judge_of_apply env funj argjv =
  let args, argtys = dest_judgev argjv in
  make_judge (mkApp (funj.uj_val, args)) (type_of_apply env funj.uj_val funj.uj_type args argtys)

(* let judge_of_abstraction env x varj bodyj = *)
(*   make_judge (mkLambda (x, varj.utj_val, bodyj.uj_val)) *)
(*              (type_of_abstraction env x varj.utj_val bodyj.uj_type) *)

(* let judge_of_product env x varj outj = *)
(*   make_judge (mkProd (x, varj.utj_val, outj.utj_val)) *)
(*              (mkSort (sort_of_product env varj.utj_type outj.utj_type)) *)

(* let judge_of_letin env name defj typj j = *)
(*   make_judge (mkLetIn (name, defj.uj_val, typj.utj_val, j.uj_val)) *)
(*              (subst1 defj.uj_val j.uj_type) *)

let judge_of_cast env cj k tj =
  let () = check_cast env cj.uj_val cj.uj_type k tj.utj_val in
  let c = match k with | REVERTcast -&gt; cj.uj_val | _ -&gt; mkCast (cj.uj_val, k, tj.utj_val) in
  make_judge c tj.utj_val

let judge_of_inductive env indu =
  make_judge (mkIndU indu) (type_of_inductive env indu)

let judge_of_constructor env cu =
  make_judge (mkConstructU cu) (type_of_constructor env cu)

let judge_of_case env ci pj cj lfj =
  let lf, lft = dest_judgev lfj in
  let ci, t = type_of_case env ci pj.uj_val pj.uj_type cj.uj_val cj.uj_type lf lft in
  make_judge (mkCase (ci, (*nf_betaiota*) pj.uj_val, cj.uj_val, lft)) t

(* Building type of primitive operators and type *)

let check_primitive_type env op_t t =
  let inft = type_of_prim_or_type env op_t in
  try default_conv ~l2r:false CUMUL env inft t
  with NotConvertible -&gt; error_incorrect_primitive env (make_judge op_t inft) t
</pre>
          </div>
          <div class="col-md-6">
            <code>typeops.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import CErrors.

Import Util.

Import Names.

Import Univ.

Import Sorts.

Import Term.

Import Constr.

Import Context.

Import Vars.

Import Declarations.

Import Environ.

Import Reduction.

Import Inductive.

Import Type_errors.

Definition conv_leq
  (l2r : bool) (env : Environ.env) (x : Constr.types) (y : Constr.types)
  : unit := Reduction.default_conv CUMUL (Some l2r) env x y.

Definition conv_leq_vecti
  (env : Environ.env) (v1 : array Constr.types) (v2 : array Constr.types)
  : unit :=
  Util.Array.(CArray.ExtS.fold_left2_i)
    (fun i =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | _ =&gt; fun t1 =&gt; fun t2 =&gt; try
        end) tt v1 v2.

Definition check_constraints (cst : Univ.Constraint.t) (env : Environ.env)
  : unit :=
  if Environ.check_constraints cst env then
    tt
  else
    Type_errors.error_unsatisfied_constraints env cst.

Definition check_type
  (env : Environ.env) (c : Constr.constr) (t : Constr.constr) : Sorts.t :=
  match Constr.kind (Reduction.whd_all env t) with
  | Sort s =&gt; s
  | _ =&gt; Type_errors.error_not_type env (Environ.make_judge c t)
  end.

Definition infer_assumption
  (env : Environ.env) (t : Constr.constr) (ty : Constr.constr)
  : Sorts.relevance := try.

Definition warn_bad_relevance_name : string := &quot;bad-relevance&quot; % string.

Definition warn_bad_relevance
  : (option Loc.t) -&gt; (option (Context.binder_annot Names.Name.t)) -&gt; unit :=
  CWarnings.create warn_bad_relevance_name &quot;debug&quot; % string
    (Some CWarnings.Disabled)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt; Pp.str &quot;Bad relevance in case annotation.&quot; % string
      | Some x =&gt;
        Pp.op_plus_plus
          (Pp.op_plus_plus (Pp.str &quot;Bad relevance for binder &quot; % string)
            (Names.Name.print (binder_name x))) (Pp.str &quot;.&quot; % string)
      end).

Definition warn_bad_relevance_ci
  (loc : option Loc.t) (function_parameter : unit) : unit :=
  match function_parameter with
  | tt =&gt; warn_bad_relevance loc None
  end.

Definition warn_bad_relevance
  (loc : option Loc.t) (x : Context.binder_annot Names.Name.t) : unit :=
  warn_bad_relevance loc (Some x).

Definition check_assumption
  (env : Environ.env) (x : Context.binder_annot Names.Name.t)
  (t : Constr.constr) (ty : Constr.constr)
  : Context.binder_annot Names.Name.t :=
  let r := binder_relevance x in
  let r' := infer_assumption env t ty in
  let x :=
    if Sorts.relevance_equal r r' then
      x
    else
      warn_bad_relevance None x;
      record in
  x.

Definition type1 : Constr.types := Constr.mkSort Sorts.type1.

Definition type_of_type (u : Univ.Universe.t) : Constr.types :=
  let uu := Univ.Universe.super u in
  Constr.mkType uu.

Definition type_of_sort (function_parameter : Term.sorts) : Constr.types :=
  match function_parameter with
  | SProp | Prop | Set =&gt; type1
  | Type u =&gt; type_of_type u
  end.

Definition type_of_relative (env : Environ.env) (n : Z) : Constr.constr := try.

Definition type_of_variable (env : Environ.env) (id : Names.variable)
  : Constr.types := try.

Definition check_hyps_inclusion {A : Type}
  (env : Environ.env)
  (evars : option ((Constr.existential -&gt; option Constr.constr) * UGraph.t))
  (f : A -&gt; Constr.constr) (c : A)
  (sign : Context.Named.pt Constr.constr Constr.constr) : unit :=
  let conv (env : Environ.env) (a : Constr.constr) (b : Constr.constr) : unit :=
    Reduction.conv None None env evars a b in
  Context.Named.fold_outside
    (fun d1 =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | tt =&gt;
          let id := NamedDecl.get_id d1 in
          try
        end) sign tt.

Definition type_of_constant
  (env : Environ.env) (function_parameter : Names.Constant.t * Univ.Instance.t)
  : Constr.types :=
  match function_parameter with
  | (kn, _u) as cst =&gt;
    let cb := Environ.lookup_constant kn env in
    match check_hyps_inclusion env None Constr.mkConstU cst (const_hyps cb) with
    | tt =&gt;
      match Environ.constant_type env cst with
      | (ty, cu) =&gt;
        match check_constraints cu env with
        | tt =&gt; ty
        end
      end
    end
  end.

Definition type_of_constant_in
  (env : Environ.env) (function_parameter : Names.Constant.t * Univ.Instance.t)
  : Constr.types :=
  match function_parameter with
  | (kn, _u) as cst =&gt;
    let cb := Environ.lookup_constant kn env in
    match check_hyps_inclusion env None Constr.mkConstU cst (const_hyps cb) with
    | tt =&gt; Environ.constant_type_in env cst
    end
  end.

Definition type_of_abstraction {A : Type}
  (_env : A) (name : Context.binder_annot Names.Name.t) (var : Constr.types)
  (ty : Constr.types) : Constr.types := Constr.mkProd (name, var, ty).

Definition make_judgev {A B : Type} (c : array A) (t : array B)
  : array (Environ.punsafe_judgment A B) :=
  Util.Array.(CArray.ExtS.map2) Environ.make_judge c t.

Fixpoint check_empty_stack (function_parameter : list CClosure.stack_member)
  : bool :=
  match function_parameter with
  | [] =&gt; true
  | cons (CClosure.Zupdate _) s =&gt; check_empty_stack s
  | _ =&gt; false
  end.

Definition type_of_apply
  (env : Environ.env) (func : Constr.constr) (funt : Constr.types)
  (argsv : array Constr.constr) (argstv : array Constr.types) : Constr.constr :=
  let len := Util.Array.(CArray.ExtS.length) argsv in
  let infos := CClosure.create_clos_infos None CClosure.all env in
  let tab := CClosure.create_tab tt in
  let fix apply_rec (i : Int.t) (typ : CClosure.fconstr) : Constr.constr :=
    if Int.equal i len then
      CClosure.term_of_fconstr typ
    else
      match CClosure.whd_stack infos tab typ [] with
      | (typ, stk) =&gt;
        match check_empty_stack stk with
        | tt =&gt;
          match CClosure.fterm_of typ with
          | FProd _ c1 c2 e =&gt;
            let arg := Util.Array.(CArray.ExtS.get) argsv i in
            let argt := Util.Array.(CArray.ExtS.get) argstv i in
            let c1 := CClosure.term_of_fconstr c1 in
            match conv_leq false env argt c1 with
            | tt =&gt;
              apply_rec (Util.op_plus i 1)
                (CClosure.mk_clos
                  (Esubst.subs_cons (((CClosure.inject arg)), e)) c2)
            end
          | _ =&gt;
            Type_errors.error_cant_apply_not_functional env
              (Environ.make_judge func funt) (make_judgev argsv argstv)
          end
        end
      end in
  apply_rec 0 (CClosure.inject funt).

Definition type_of_prim_type {A : Type}
  (_env : A) (function_parameter : CPrimitives.prim_type) : Constr.types :=
  match function_parameter with
  | CPrimitives.PT_int63 =&gt; Constr.mkSet
  end.

Definition type_of_int (env : Environ.env) : Constr.constr :=
  match Retroknowledge.retro_int63 (retroknowledge env) with
  | Some c =&gt; Constr.mkConst c
  | None =&gt;
    CErrors.user_err None None
      (Pp.str
        &quot;The type int must be registered before this construction can be typechecked.&quot;
          % string)
  end.

Definition type_of_prim (env : Environ.env) (t : CPrimitives.t)
  : Constr.types :=
  let int_ty := type_of_int env in
  let bool_ty (function_parameter : unit) : Constr.constr :=
    match function_parameter with
    | tt =&gt;
      match Retroknowledge.retro_bool (retroknowledge env) with
      | Some ((ind, _), _) =&gt; Constr.mkInd ind
      | None =&gt;
        CErrors.user_err None None
          (Pp.str
            &quot;The type bool must be registered before this primitive.&quot; % string)
      end
    end in
  let compare_ty (function_parameter : unit) : Constr.constr :=
    match function_parameter with
    | tt =&gt;
      match Retroknowledge.retro_cmp (retroknowledge env) with
      | Some ((ind, _), _, _) =&gt; Constr.mkInd ind
      | None =&gt;
        CErrors.user_err None None
          (Pp.str
            &quot;The type compare must be registered before this primitive.&quot; %
              string)
      end
    end in
  let pair_ty (fst_ty : Constr.constr) (snd_ty : Constr.constr)
    : Constr.constr :=
    match Retroknowledge.retro_pair (retroknowledge env) with
    | Some (ind, _) =&gt; Constr.mkApp ((Constr.mkInd ind), (fst_ty, snd_ty))
    | None =&gt;
      CErrors.user_err None None
        (Pp.str
          &quot;The type pair must be registered before this primitive.&quot; % string)
    end in
  let carry_ty (int_ty : Constr.constr) : Constr.constr :=
    match Retroknowledge.retro_carry (retroknowledge env) with
    | Some ((ind, _), _) =&gt; Constr.mkApp ((Constr.mkInd ind), (int_ty))
    | None =&gt;
      CErrors.user_err None None
        (Pp.str
          &quot;The type carry must be registered before this primitive.&quot; % string)
    end in
  let fix nary_int63_op (arity : Int.t) (ty : Constr.types) : Constr.types :=
    if Int.equal arity 0 then
      ty
    else
      Constr.mkProd
        ((Context.nameR (Names.Id.of_string &quot;x&quot; % string)), int_ty,
          (nary_int63_op (Util.op_minus arity 1) ty)) in
  let return_ty :=
    match t with
    |
      Int63head0 | Int63tail0 | Int63add | Int63sub | Int63mul | Int63div |
        Int63mod | Int63lsr | Int63lsl | Int63land | Int63lor | Int63lxor |
        Int63addMulDiv =&gt; int_ty
    | Int63eq | Int63lt | Int63le =&gt; bool_ty tt
    | Int63mulc | Int63div21 | Int63diveucl =&gt; pair_ty int_ty int_ty
    | Int63addc | Int63subc | Int63addCarryC | Int63subCarryC =&gt; carry_ty int_ty
    | Int63compare =&gt; compare_ty tt
    end in
  nary_int63_op (CPrimitives.arity t) return_ty.

Definition type_of_prim_or_type
  (env : Environ.env) (function_parameter : CPrimitives.op_or_type)
  : Constr.types :=
  match function_parameter with
  | OT_type t =&gt; type_of_prim_type env t
  | OT_op op =&gt; type_of_prim env op
  end.

Definition judge_of_int (env : Environ.env) (i : Uint63.t)
  : Environ.punsafe_judgment Constr.constr Constr.constr :=
  Environ.make_judge (Constr.mkInt i) (type_of_int env).

Definition sort_of_product
  (env : Environ.env) (domsort : Term.sorts) (rangsort : Term.sorts)
  : Term.sorts :=
  match (domsort, rangsort) with
  | (_, SProp) | (SProp, _) =&gt; rangsort
  | (_, Prop) =&gt; rangsort
  | (Prop | Set, Set) =&gt; rangsort
  | (Type u1, Set) =&gt;
    if Environ.is_impredicative_set env then
      rangsort
    else
      Sorts.sort_of_univ (Univ.Universe.sup Univ.Universe.type0 u1)
  | (Set, Type u2) =&gt;
    Sorts.sort_of_univ (Univ.Universe.sup Univ.Universe.type0 u2)
  | (Prop, Type _) =&gt; rangsort
  | (Type u1, Type u2) =&gt; Sorts.sort_of_univ (Univ.Universe.sup u1 u2)
  end.

Definition type_of_product {A : Type}
  (env : Environ.env) (_name : A) (s1 : Term.sorts) (s2 : Term.sorts)
  : Constr.types :=
  let s := sort_of_product env s1 s2 in
  Constr.mkSort s.

Definition check_cast
  (env : Environ.env) (c : Constr.constr) (ct : Constr.types)
  (k : Constr.cast_kind) (expected_type : Constr.types) : unit := try.

Definition type_of_inductive_knowing_parameters
  (env : Environ.env) (function_parameter : Names.inductive * Univ.Instance.t)
  : (array (Stdlib.Lazy.t Constr.types)) -&gt; Constr.types :=
  match function_parameter with
  | (ind, u) as indu =&gt;
    fun args =&gt;
      match Inductive.lookup_mind_specif env ind with
      | (mib, _mip) as spec =&gt;
        check_hyps_inclusion env None Constr.mkIndU indu (mind_hyps mib);
        match
          Inductive.constrained_type_of_inductive_knowing_parameters env
            (spec, u) args with
        | (t, cst) =&gt;
          check_constraints cst env;
          t
        end
      end
  end.

Definition type_of_inductive
  (env : Environ.env) (function_parameter : Names.inductive * Univ.Instance.t)
  : Constr.types :=
  match function_parameter with
  | (ind, u) as indu =&gt;
    match Inductive.lookup_mind_specif env ind with
    | (mib, mip) =&gt;
      check_hyps_inclusion env None Constr.mkIndU indu (mind_hyps mib);
      match Inductive.constrained_type_of_inductive env ((mib, mip), u) with
      | (t, cst) =&gt;
        check_constraints cst env;
        t
      end
    end
  end.

Definition type_of_constructor
  (env : Environ.env) (function_parameter : Names.constructor * Univ.Instance.t)
  : Constr.types :=
  match function_parameter with
  | (c, _u) as cu =&gt;
    match
      match c with
      | ((kn, _), _) =&gt;
        let mib := Environ.lookup_mind kn env in
        check_hyps_inclusion env None Constr.mkConstructU cu (mind_hyps mib)
      end with
    | tt =&gt;
      let specif :=
        Inductive.lookup_mind_specif env (Names.inductive_of_constructor c) in
      match Inductive.constrained_type_of_constructor cu specif with
      | (t, cst) =&gt;
        match check_constraints cst env with
        | tt =&gt; t
        end
      end
    end
  end.

Definition check_branch_types
  (env : Environ.env) (function_parameter : Names.inductive * Univ.Instance.t)
  : Constr.constr -&gt;
    Constr.types -&gt; (array Constr.types) -&gt; (array Constr.types) -&gt; unit :=
  match function_parameter with
  | (ind, u) =&gt; fun c =&gt; fun ct =&gt; fun lft =&gt; fun explft =&gt; try
  end.

Definition type_of_case {A : Type}
  (env : Environ.env) (ci : Constr.case_info) (p : Constr.constr)
  (pt : Constr.types) (c : Constr.constr) (ct : Constr.types) (_lf : A)
  (lft : array Constr.types) : Constr.case_info * Constr.types :=
  match try with
  | (pind, _) as indspec =&gt;
    match try with
    | (_, sp) =&gt;
      let rp := Sorts.relevance_of_sort sp in
      let ci :=
        if Stdlib.op_eq_eq (ci_relevance ci) rp then
          ci
        else
          warn_bad_relevance_ci None tt;
          record in
      match Inductive.check_case_info env pind rp ci with
      | tt =&gt;
        match
          Inductive.type_case_branches env indspec (Environ.make_judge p pt) c
          with
        | (bty, rslty) =&gt;
          match check_branch_types env pind c ct lft bty with
          | tt =&gt; (ci, rslty)
          end
        end
      end
    end
  end.

Definition type_of_projection
  (env : Environ.env) (p : Names.Projection.t) (c : Constr.constr)
  (ct : Constr.types) : Constr.constr :=
  let pty := Environ.lookup_projection p env in
  match try with
  | ((ind, u), args) =&gt;
    Names.eq_ind (Names.Projection.inductive p) ind;
    let ty := Vars.subst_instance_constr u pty in
    Vars.substl (cons c (CList.rev args)) ty
  end.

Definition check_fixpoint
  (env : Environ.env) (lna : array (Context.binder_annot Names.Name.t))
  (lar : array Constr.constr) (vdef : array Constr.constr)
  (vdeft : array Constr.types) : unit :=
  let lt := Util.Array.(CArray.ExtS.length) vdeft in
  Int.equal (Util.Array.(CArray.ExtS.length) lar) lt;
  try.

Definition type_of_global_in_context (env : Environ.env) (r : Names.GlobRef.t)
  : Constr.types * Univ.AUContext.t :=
  match r with
  | VarRef id =&gt; ((Environ.named_type id env), Univ.AUContext.empty)
  | ConstRef c =&gt;
    let cb := Environ.lookup_constant c env in
    let univs := Declareops.constant_polymorphic_context cb in
    ((Declarations.const_type cb), univs)
  | IndRef ind =&gt;
    match Inductive.lookup_mind_specif env ind with
    | (mib, _) as specif =&gt;
      let univs := Declareops.inductive_polymorphic_context mib in
      let inst := Univ.make_abstract_instance univs in
      let env :=
        Environ.push_context (Some false) (Univ.AUContext.repr univs) env in
      ((Inductive.type_of_inductive env (specif, inst)), univs)
    end
  | ConstructRef cstr =&gt;
    match Inductive.lookup_mind_specif env (Names.inductive_of_constructor cstr)
      with
    | (mib, _) as specif =&gt;
      let univs := Declareops.inductive_polymorphic_context mib in
      let inst := Univ.make_abstract_instance univs in
      ((Inductive.type_of_constructor (cstr, inst) specif), univs)
    end
  end.

Definition check_binder_annot
  (s : Sorts.t) (x : Context.binder_annot Names.Name.t)
  : Context.binder_annot Names.Name.t :=
  let r := binder_relevance x in
  let r' := Sorts.relevance_of_sort s in
  if Stdlib.op_eq_eq r' r then
    x
  else
    warn_bad_relevance None x;
    record.

Fixpoint execute (env : Environ.env) (cstr : Constr.constr)
  : Constr.constr * Constr.types :=
  match Constr.kind cstr with
  | Sort s =&gt;
    match s with
    | SProp =&gt;
      if negb (Environ.sprop_allowed env) then
        Type_errors.error_disallowed_sprop env
      else
        tt
    | _ =&gt; tt
    end;
    (cstr, (type_of_sort s))
  | Rel n =&gt; (cstr, (type_of_relative env n))
  | Var id =&gt; (cstr, (type_of_variable env id))
  | Const c =&gt; (cstr, (type_of_constant env c))
  | Proj p c =&gt;
    match execute env c with
    | (c', ct) =&gt;
      let cstr :=
        if Stdlib.op_eq_eq c c' then
          cstr
        else
          Constr.mkProj (p, c') in
      (cstr, (type_of_projection env p c' ct))
    end
  | App f args =&gt;
    match execute_array env args with
    | (args', argst) =&gt;
      match
        match Constr.kind f with
        | _ =&gt; execute env f
        end with
      | (f', ft) =&gt;
        let cstr :=
          if andb (Stdlib.op_eq_eq f f') (Stdlib.op_eq_eq args args') then
            cstr
          else
            Constr.mkApp (f', args') in
        (cstr, (type_of_apply env f' ft args' argst))
      end
    end
  | Lambda name c1 c2 =&gt;
    match execute_is_type env c1 with
    | (c1', s) =&gt;
      let name' := check_binder_annot s name in
      let env1 := Environ.push_rel (LocalAssum name' c1') env in
      match execute env1 c2 with
      | (c2', c2t) =&gt;
        let cstr :=
          if
            andb (Stdlib.op_eq_eq name name')
              (andb (Stdlib.op_eq_eq c1 c1') (Stdlib.op_eq_eq c2 c2')) then
            cstr
          else
            Constr.mkLambda (name', c1', c2') in
        (cstr, (type_of_abstraction env name' c1 c2t))
      end
    end
  | Prod name c1 c2 =&gt;
    match execute_is_type env c1 with
    | (c1', vars) =&gt;
      let name' := check_binder_annot vars name in
      let env1 := Environ.push_rel (LocalAssum name' c1') env in
      match execute_is_type env1 c2 with
      | (c2', vars') =&gt;
        let cstr :=
          if
            andb (Stdlib.op_eq_eq name name')
              (andb (Stdlib.op_eq_eq c1 c1') (Stdlib.op_eq_eq c2 c2')) then
            cstr
          else
            Constr.mkProd (name', c1', c2') in
        (cstr, (type_of_product env name' vars vars'))
      end
    end
  | LetIn name c1 c2 c3 =&gt;
    match execute env c1 with
    | (c1', c1t) =&gt;
      match execute_is_type env c2 with
      | (c2', c2s) =&gt;
        let name' := check_binder_annot c2s name in
        match check_cast env c1' c1t DEFAULTcast c2' with
        | tt =&gt;
          let env1 := Environ.push_rel (LocalDef name' c1' c2') env in
          match execute env1 c3 with
          | (c3', c3t) =&gt;
            let cstr :=
              if
                andb (Stdlib.op_eq_eq name name')
                  (andb (Stdlib.op_eq_eq c1 c1')
                    (andb (Stdlib.op_eq_eq c2 c2') (Stdlib.op_eq_eq c3 c3')))
                then
                cstr
              else
                Constr.mkLetIn (name', c1', c2', c3') in
            (cstr, (Vars.subst1 c1 c3t))
          end
        end
      end
    end
  | Cast c k t =&gt;
    match execute env c with
    | (c', ct) =&gt;
      match execute_is_type env t with
      | (t', _ts) =&gt;
        match check_cast env c' ct k t' with
        | tt =&gt;
          let cstr :=
            if andb (Stdlib.op_eq_eq c c') (Stdlib.op_eq_eq t t') then
              cstr
            else
              Constr.mkCast (c', k, t') in
          (cstr, t')
        end
      end
    end
  | Ind ind =&gt; (cstr, (type_of_inductive env ind))
  | Construct c =&gt; (cstr, (type_of_constructor env c))
  | Case ci p c lf =&gt;
    match execute env c with
    | (c', ct) =&gt;
      match execute env p with
      | (p', pt) =&gt;
        match execute_array env lf with
        | (lf', lft) =&gt;
          match type_of_case env ci p' pt c' ct lf' lft with
          | (ci', t) =&gt;
            let cstr :=
              if
                andb (Stdlib.op_eq_eq ci ci')
                  (andb (Stdlib.op_eq_eq c c')
                    (andb (Stdlib.op_eq_eq p p') (Stdlib.op_eq_eq lf lf'))) then
                cstr
              else
                Constr.mkCase (ci', p', c', lf') in
            (cstr, t)
          end
        end
      end
    end
  | Fix (((_vn, i) as vni, recdef) as fix) =&gt;
    match execute_recdef env recdef i with
    | (fix_ty, recdef') =&gt;
      match
        if Stdlib.op_eq_eq recdef recdef' then
          (cstr, fix)
        else
          let fix := (vni, recdef') in
          ((Constr.mkFix fix), fix) with
      | (cstr, fix) =&gt;
        Inductive.check_fix env fix;
        (cstr, fix_ty)
      end
    end
  | CoFix ((i, recdef) as cofix) =&gt;
    match execute_recdef env recdef i with
    | (fix_ty, recdef') =&gt;
      match
        if Stdlib.op_eq_eq recdef recdef' then
          (cstr, cofix)
        else
          let cofix := (i, recdef') in
          ((Constr.mkCoFix cofix), cofix) with
      | (cstr, cofix) =&gt;
        Inductive.check_cofix env cofix;
        (cstr, fix_ty)
      end
    end
  | Int _ =&gt; (cstr, (type_of_int env))
  | Meta _ =&gt;
    CErrors.anomaly None None
      (Pp.str &quot;the kernel does not support metavariables.&quot; % string)
  | Evar _ =&gt;
    CErrors.anomaly None None
      (Pp.str &quot;the kernel does not support existential variables.&quot; % string)
  end

with execute_is_type (env : Environ.env) (constr : Constr.types)
  : Constr.types * Term.sorts :=
  match execute env constr with
  | (c, t) =&gt; (c, (check_type env constr t))
  end

with execute_recdef
  (env : Environ.env)
  (function_parameter : Constr.prec_declaration Constr.constr Constr.types)
  : Z -&gt; Constr.types * (Constr.prec_declaration Constr.constr Constr.types) :=
  match function_parameter with
  | (names, lar, vdef) as recdef =&gt;
    fun i =&gt;
      match execute_array env lar with
      | (lar', lart) =&gt;
        let names' :=
          Util.Array.Smart.map_i
            (fun i =&gt;
              fun na =&gt;
                check_assumption env na (Util.Array.(CArray.ExtS.get) lar' i)
                  (Util.Array.(CArray.ExtS.get) lart i)) names in
        let env1 := Environ.push_rec_types (names', lar', vdef) env in
        match execute_array env1 vdef with
        | (vdef', vdeft) =&gt;
          match check_fixpoint env1 names' lar' vdef' vdeft with
          | tt =&gt;
            let recdef :=
              if
                andb (Stdlib.op_eq_eq names names')
                  (andb (Stdlib.op_eq_eq lar lar') (Stdlib.op_eq_eq vdef vdef'))
                then
                recdef
              else
                (names', lar', vdef') in
            ((Util.Array.(CArray.ExtS.get) lar' i), recdef)
          end
        end
      end
  end

with execute_array (env : Environ.env) (cs : array Constr.constr)
  : (array Constr.constr) * (array Constr.types) :=
  let tys :=
    Util.Array.(CArray.ExtS.make) (Util.Array.(CArray.ExtS.length) cs)
      Constr.mkProp in
  let cs :=
    Util.Array.Smart.map_i
      (fun i =&gt;
        fun c =&gt;
          match execute env c with
          | (c, ty) =&gt;
            Util.Array.(CArray.ExtS.set) tys i ty;
            c
          end) cs in
  (cs, tys).

Definition check_wellformed_universes (env : Environ.env) (c : Constr.constr)
  : unit :=
  let univs := Vars.universes_of_constr c in
  try.

Definition infer (env : Environ.env) (constr : Constr.constr)
  : Environ.punsafe_judgment Constr.constr Constr.types :=
  match check_wellformed_universes env constr with
  | tt =&gt;
    match execute env constr with
    | (constr, t) =&gt; Environ.make_judge constr t
    end
  end.

Definition infer
  : Environ.env -&gt;
    Constr.constr -&gt; Environ.punsafe_judgment Constr.constr Constr.types :=
  if Flags.profile then
    let infer_key := CProfile.declare_profile &quot;Fast_infer&quot; % string in
    CProfile.profile2 infer_key (fun b =&gt; fun c =&gt; infer b c)
  else
    fun b =&gt; fun c =&gt; infer b c.

Definition assumption_of_judgment
  (env : Environ.env)
  (function_parameter : Environ.punsafe_judgment Constr.constr Constr.constr)
  : Sorts.relevance :=
  match function_parameter with
  | {| uj_val := c; uj_type := t |} =&gt; infer_assumption env c t
  end.

Definition type_judgment
  (env : Environ.env)
  (function_parameter : Environ.punsafe_judgment Constr.constr Constr.constr)
  : Environ.punsafe_type_judgment Constr.constr :=
  match function_parameter with
  | {| uj_val := c; uj_type := t |} =&gt;
    let s := check_type env c t in
    {| utj_val := c; utj_type := s |}
  end.

Definition infer_type (env : Environ.env) (constr : Constr.constr)
  : Environ.punsafe_type_judgment Constr.constr :=
  match check_wellformed_universes env constr with
  | tt =&gt;
    match execute env constr with
    | (constr, t) =&gt;
      let s := check_type env constr t in
      {| utj_val := constr; utj_type := s |}
    end
  end.

Definition check_context
  (env : Environ.env) (rels : Context.Rel.pt Constr.constr Constr.constr)
  : Environ.env *
    (list (Context.Rel.Declaration.pt Constr.constr Constr.constr)) :=
  Context.Rel.fold_outside
    (fun d =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | (env, rels) =&gt;
          match d with
          | LocalAssum x ty =&gt;
            let jty := infer_type env ty in
            let x := check_binder_annot (utj_type jty) x in
            ((Environ.push_rel d env), (cons (LocalAssum x (utj_val jty)) rels))
          | LocalDef x bd ty =&gt;
            let j1 := infer env bd in
            let jty := infer_type env ty in
            conv_leq false env (uj_type j1) ty;
            let x := check_binder_annot (utj_type jty) x in
            ((Environ.push_rel d env),
              (cons (LocalDef x (uj_val j1) (utj_val jty)) rels))
          end
        end) rels (env, []).

Definition judge_of_prop : Environ.punsafe_judgment Constr.types Constr.types :=
  Environ.make_judge Constr.mkProp type1.

Definition judge_of_set : Environ.punsafe_judgment Constr.types Constr.types :=
  Environ.make_judge Constr.mkSet type1.

Definition judge_of_type (u : Univ.Universe.t)
  : Environ.punsafe_judgment Constr.types Constr.types :=
  Environ.make_judge (Constr.mkType u) (type_of_type u).

Definition judge_of_relative (env : Environ.env) (k : Z)
  : Environ.punsafe_judgment Constr.constr Constr.constr :=
  Environ.make_judge (Constr.mkRel k) (type_of_relative env k).

Definition judge_of_variable (env : Environ.env) (x : Names.variable)
  : Environ.punsafe_judgment Constr.constr Constr.types :=
  Environ.make_judge (Constr.mkVar x) (type_of_variable env x).

Definition judge_of_constant (env : Environ.env) (cst : Constr.pconstant)
  : Environ.punsafe_judgment Constr.constr Constr.types :=
  Environ.make_judge (Constr.mkConstU cst) (type_of_constant env cst).

Definition judge_of_projection
  (env : Environ.env) (p : Names.Projection.t)
  (cj : Environ.punsafe_judgment Constr.constr Constr.types)
  : Environ.punsafe_judgment Constr.constr Constr.constr :=
  Environ.make_judge (Constr.mkProj (p, (uj_val cj)))
    (type_of_projection env p (uj_val cj) (uj_type cj)).

Definition dest_judgev {A B : Type} (v : array (Environ.punsafe_judgment A B))
  : (array A) * (array B) :=
  ((Util.Array.(CArray.ExtS.map) Environ.j_val v),
    (Util.Array.(CArray.ExtS.map) Environ.j_type v)).

Definition judge_of_apply
  (env : Environ.env)
  (funj : Environ.punsafe_judgment Constr.constr Constr.types)
  (argjv : array (Environ.punsafe_judgment Constr.constr Constr.types))
  : Environ.punsafe_judgment Constr.constr Constr.constr :=
  match dest_judgev argjv with
  | (args, argtys) =&gt;
    Environ.make_judge (Constr.mkApp ((uj_val funj), args))
      (type_of_apply env (uj_val funj) (uj_type funj) args argtys)
  end.

Definition judge_of_cast
  (env : Environ.env) (cj : Environ.punsafe_judgment Constr.constr Constr.types)
  (k : Constr.cast_kind) (tj : Environ.punsafe_type_judgment Constr.types)
  : Environ.punsafe_judgment Constr.constr Constr.types :=
  match check_cast env (uj_val cj) (uj_type cj) k (utj_val tj) with
  | tt =&gt;
    let c :=
      match k with
      | REVERTcast =&gt; uj_val cj
      | _ =&gt; Constr.mkCast ((uj_val cj), k, (utj_val tj))
      end in
    Environ.make_judge c (utj_val tj)
  end.

Definition judge_of_inductive (env : Environ.env) (indu : Constr.pinductive)
  : Environ.punsafe_judgment Constr.constr Constr.types :=
  Environ.make_judge (Constr.mkIndU indu) (type_of_inductive env indu).

Definition judge_of_constructor (env : Environ.env) (cu : Constr.pconstructor)
  : Environ.punsafe_judgment Constr.constr Constr.types :=
  Environ.make_judge (Constr.mkConstructU cu) (type_of_constructor env cu).

Definition judge_of_case {A : Type}
  (env : Environ.env) (ci : Constr.case_info)
  (pj : Environ.punsafe_judgment Constr.constr Constr.types)
  (cj : Environ.punsafe_judgment Constr.constr Constr.types)
  (lfj : array (Environ.punsafe_judgment A Constr.types))
  : Environ.punsafe_judgment Constr.constr Constr.types :=
  match dest_judgev lfj with
  | (lf, lft) =&gt;
    match
      type_of_case env ci (uj_val pj) (uj_type pj) (uj_val cj) (uj_type cj) lf
        lft with
    | (ci, t) =&gt;
      Environ.make_judge (Constr.mkCase (ci, (uj_val pj), (uj_val cj), lft)) t
    end
  end.

Definition check_primitive_type
  (env : Environ.env) (op_t : CPrimitives.op_or_type) (t : Constr.types)
  : unit :=
  let inft := type_of_prim_or_type env op_t in
  try.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="uGraph" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>uGraph.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Univ

module G = AcyclicGraph.Make(struct
    type t = Level.t
    module Set = LSet
    module Map = LMap
    module Constraint = Constraint

    let equal = Level.equal
    let compare = Level.compare

    type explanation = Univ.explanation
    let error_inconsistency d u v p =
      raise (UniverseInconsistency (d,Universe.make u, Universe.make v, p))

    let pr = Level.pr
  end) [@@inlined] (* without inline, +1% ish on HoTT, compcert. See jenkins 594 vs 596 *)
(* Do not include G to make it easier to control universe specific
   code (eg add_universe with a constraint vs G.add with no
   constraint) *)

type t = { graph: G.t; sprop_cumulative : bool }
type 'a check_function = t -&gt; 'a -&gt; 'a -&gt; bool

let g_map f g =
  let g' = f g.graph in
  if g.graph == g' then g
  else {g with graph=g'}

let make_sprop_cumulative g = {g with sprop_cumulative=true}

let check_smaller_expr g (u,n) (v,m) =
  let diff = n - m in
    match diff with
    | 0 -&gt; G.check_leq g.graph u v
    | 1 -&gt; G.check_lt g.graph u v
    | x when x &lt; 0 -&gt; G.check_leq g.graph u v
    | _ -&gt; false

let exists_bigger g ul l =
  Universe.exists (fun ul' -&gt;
    check_smaller_expr g ul ul') l

let real_check_leq g u v =
  Universe.for_all (fun ul -&gt; exists_bigger g ul v) u

let check_leq g u v =
  Universe.equal u v || (g.sprop_cumulative &amp;&amp; Universe.is_sprop u) ||
  (not (Universe.is_sprop u) &amp;&amp; not (Universe.is_sprop v) &amp;&amp;
    (is_type0m_univ u ||
     real_check_leq g u v))

let check_eq g u v =
  Universe.equal u v ||
  (not (Universe.is_sprop u || Universe.is_sprop v) &amp;&amp;
   (real_check_leq g u v &amp;&amp; real_check_leq g v u))

let check_eq_level g u v =
  u == v ||
  (not (Level.is_sprop u || Level.is_sprop v) &amp;&amp; G.check_eq g.graph u v)

let empty_universes = {graph=G.empty; sprop_cumulative=false}

let initial_universes =
  let big_rank = 1000000 in
  let g = G.empty in
  let g = G.add ~rank:big_rank Level.prop g in
  let g = G.add ~rank:big_rank Level.set g in
  {graph=G.enforce_lt Level.prop Level.set g; sprop_cumulative=false}

let enforce_constraint (u,d,v) g =
  match d with
  | Le -&gt; G.enforce_leq u v g
  | Lt -&gt; G.enforce_lt u v g
  | Eq -&gt; G.enforce_eq u v g

let enforce_constraint (u,d,v as cst) g =
  match Level.is_sprop u, d, Level.is_sprop v with
  | false, _, false -&gt; g_map (enforce_constraint cst) g
  | true, (Eq|Le), true -&gt; g
  | true, Le, false when g.sprop_cumulative -&gt; g
  | _ -&gt;  raise (UniverseInconsistency (d,Universe.make u, Universe.make v, None))

let merge_constraints csts g = Constraint.fold enforce_constraint csts g

let check_constraint g (u,d,v) =
  match d with
  | Le -&gt; G.check_leq g u v
  | Lt -&gt; G.check_lt g u v
  | Eq -&gt; G.check_eq g u v

let check_constraint g (u,d,v as cst) =
  match Level.is_sprop u, d, Level.is_sprop v with
  | false, _, false -&gt; check_constraint g.graph cst
  | true, (Eq|Le), true -&gt; true
  | true, Le, false -&gt; g.sprop_cumulative
  | _ -&gt; false

let check_constraints csts g = Constraint.for_all (check_constraint g) csts

let leq_expr (u,m) (v,n) =
  let d = match m - n with
    | 1 -&gt; Lt
    | diff -&gt; assert (diff &lt;= 0); Le
  in
  (u,d,v)

let enforce_leq_alg u v g =
  let open Util in
  let enforce_one (u,v) = function
    | Inr _ as orig -&gt; orig
    | Inl (cstrs,g) as orig -&gt;
      if check_smaller_expr g u v then orig
      else
        (let c = leq_expr u v in
         match enforce_constraint c g with
         | g -&gt; Inl (Constraint.add c cstrs,g)
         | exception (UniverseInconsistency _ as e) -&gt; Inr e)
  in
  (* max(us) &lt;= max(vs) &lt;-&gt; forall u in us, exists v in vs, u &lt;= v *)
  let c = Universe.map (fun u -&gt; Universe.map (fun v -&gt; (u,v)) v) u in
  let c = List.cartesians enforce_one (Inl (Constraint.empty,g)) c in
  (* We pick a best constraint: smallest number of constraints, not an error if possible. *)
  let order x y = match x, y with
    | Inr _, Inr _ -&gt; 0
    | Inl _, Inr _ -&gt; -1
    | Inr _, Inl _ -&gt; 1
    | Inl (c,_), Inl (c',_) -&gt;
      Int.compare (Constraint.cardinal c) (Constraint.cardinal c')
  in
  match List.min order c with
  | Inl x -&gt; x
  | Inr e -&gt; raise e

(* sanity check wrapper *)
let enforce_leq_alg u v g =
  let _,g as cg = enforce_leq_alg u v g in
  assert (check_leq g u v);
  cg

exception AlreadyDeclared = G.AlreadyDeclared
let add_universe u ~lbound ~strict g =
  let graph = G.add u g.graph in
  let d = if strict then Lt else Le in
  enforce_constraint (lbound,d,u) {g with graph}

let add_universe_unconstrained u g = {g with graph=G.add u g.graph}

exception UndeclaredLevel = G.Undeclared
let check_declared_universes g l = G.check_declared g.graph (LSet.remove Level.sprop l)

let constraints_of_universes g = G.constraints_of g.graph
let constraints_for ~kept g = G.constraints_for ~kept:(LSet.remove Level.sprop kept) g.graph

(** Subtyping of polymorphic contexts *)

let check_subtype ~lbound univs ctxT ctx =
  if AUContext.size ctxT == AUContext.size ctx then
    let (inst, cst) = UContext.dest (AUContext.repr ctx) in
    let cstT = UContext.constraints (AUContext.repr ctxT) in
    let push accu v = add_universe v ~lbound ~strict:false accu in
    let univs = Array.fold_left push univs (Instance.to_array inst) in
    let univs = merge_constraints cstT univs in
    check_constraints cst univs
  else false

(** Instances *)

let check_eq_instances g t1 t2 =
  let t1 = Instance.to_array t1 in
  let t2 = Instance.to_array t2 in
  t1 == t2 ||
    (Int.equal (Array.length t1) (Array.length t2) &amp;&amp;
        let rec aux i =
          (Int.equal i (Array.length t1)) || (check_eq_level g t1.(i) t2.(i) &amp;&amp; aux (i + 1))
        in aux 0)

let domain g = LSet.add Level.sprop (G.domain g.graph)
let choose p g u = if Level.is_sprop u
  then if p u then Some u else None
  else G.choose p g.graph u

let dump_universes f g = G.dump f g.graph

let check_universes_invariants g = G.check_invariants ~required_canonical:Level.is_small g.graph

let pr_universes prl g = G.pr prl g.graph

let dummy_mp = Names.DirPath.make [Names.Id.of_string &quot;Type&quot;]
let make_dummy i = Level.(make (UGlobal.make dummy_mp i))
let sort_universes g = g_map (G.sort make_dummy [Level.prop;Level.set]) g

(** Profiling *)

let merge_constraints =
  if Flags.profile then
    let key = CProfile.declare_profile &quot;merge_constraints&quot; in
      CProfile.profile2 key merge_constraints
  else merge_constraints
let check_constraints =
  if Flags.profile then
    let key = CProfile.declare_profile &quot;check_constraints&quot; in
      CProfile.profile2 key check_constraints
  else check_constraints

let check_eq =
  if Flags.profile then
    let check_eq_key = CProfile.declare_profile &quot;check_eq&quot; in
      CProfile.profile3 check_eq_key check_eq
  else check_eq

let check_leq =
  if Flags.profile then
    let check_leq_key = CProfile.declare_profile &quot;check_leq&quot; in
      CProfile.profile3 check_leq_key check_leq
  else check_leq
</pre>
          </div>
          <div class="col-md-6">
            <code>uGraph.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Univ.

Record t := {
  graph : G.t;
  sprop_cumulative : bool }.

Definition check_function (a : Type) := t -&gt; a -&gt; a -&gt; bool.

Definition g_map (f : G.t -&gt; G.t) (g : t) : t :=
  let g' := f (graph g) in
  if Stdlib.op_eq_eq (graph g) g' then
    g
  else
    record.

Definition make_sprop_cumulative (g : t) : t := record.

Definition check_smaller_expr (g : t) (function_parameter : Univ.Level.t * Z)
  : (Univ.Level.t * Z) -&gt; bool :=
  match function_parameter with
  | (u, n) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (v, m) =&gt;
        let diff := Z.sub n m in
        match diff with
        | 0 =&gt; G.check_leq (graph g) u v
        | 1 =&gt; G.check_lt (graph g) u v
        | _ =&gt; false
        end
      end
  end.

Definition exists_bigger (g : t) (ul : Univ.Level.t * Z) (l : Univ.Universe.t)
  : bool := Univ.Universe._exists (fun ul' =&gt; check_smaller_expr g ul ul') l.

Definition real_check_leq (g : t) (u : Univ.Universe.t) (v : Univ.Universe.t)
  : bool := Univ.Universe.for_all (fun ul =&gt; exists_bigger g ul v) u.

Definition check_leq (g : t) (u : Univ.Universe.t) (v : Univ.Universe.t)
  : bool :=
  orb (Univ.Universe.equal u v)
    (orb (andb (sprop_cumulative g) (Univ.Universe.is_sprop u))
      (andb (negb (Univ.Universe.is_sprop u))
        (andb (negb (Univ.Universe.is_sprop v))
          (orb (Univ.is_type0m_univ u) (real_check_leq g u v))))).

Definition check_eq (g : t) (u : Univ.Universe.t) (v : Univ.Universe.t)
  : bool :=
  orb (Univ.Universe.equal u v)
    (andb (negb (orb (Univ.Universe.is_sprop u) (Univ.Universe.is_sprop v)))
      (andb (real_check_leq g u v) (real_check_leq g v u))).

Definition check_eq_level (g : t) (u : Univ.Level.t) (v : Univ.Level.t)
  : bool :=
  orb (Stdlib.op_eq_eq u v)
    (andb (negb (orb (Univ.Level.is_sprop u) (Univ.Level.is_sprop v)))
      (G.check_eq (graph g) u v)).

Definition empty_universes : t :=
  {| graph := G.empty; sprop_cumulative := false |}.

Definition initial_universes : t :=
  let big_rank := 1000000 in
  let g := G.empty in
  let g := G.add (Some big_rank) Univ.Level.prop g in
  let g := G.add (Some big_rank) Univ.Level.set g in
  {| graph := G.enforce_lt Univ.Level.prop Univ.Level.set g;
    sprop_cumulative := false |}.

Definition enforce_constraint
  (function_parameter : Univ.Level.t * Univ.constraint_type * Univ.Level.t)
  : G.t -&gt; G.t :=
  match function_parameter with
  | (u, d, v) =&gt;
    fun g =&gt;
      match d with
      | Le =&gt; G.enforce_leq u v g
      | Lt =&gt; G.enforce_lt u v g
      | Eq =&gt; G.enforce_eq u v g
      end
  end.

Definition enforce_constraint
  (function_parameter : Univ.Level.t * Univ.constraint_type * Univ.Level.t)
  : t -&gt; t :=
  match function_parameter with
  | (u, d, v) as cst =&gt;
    fun g =&gt;
      match ((Univ.Level.is_sprop u), d, (Univ.Level.is_sprop v)) with
      | (false, _, false) =&gt; g_map (enforce_constraint cst) g
      | (true, Eq | Le, true) =&gt; g
      | _ =&gt;
        Stdlib.raise
          (UniverseInconsistency
            (d, (Univ.Universe.make u), (Univ.Universe.make v), None))
      end
  end.

Definition merge_constraints (csts : Univ.Constraint.t) (g : t) : t :=
  Univ.Constraint.fold enforce_constraint csts g.

Definition check_constraint
  (g : G.t)
  (function_parameter : Univ.Level.t * Univ.constraint_type * Univ.Level.t)
  : bool :=
  match function_parameter with
  | (u, d, v) =&gt;
    match d with
    | Le =&gt; G.check_leq g u v
    | Lt =&gt; G.check_lt g u v
    | Eq =&gt; G.check_eq g u v
    end
  end.

Definition check_constraint
  (g : t)
  (function_parameter : Univ.Level.t * Univ.constraint_type * Univ.Level.t)
  : bool :=
  match function_parameter with
  | (u, d, v) as cst =&gt;
    match ((Univ.Level.is_sprop u), d, (Univ.Level.is_sprop v)) with
    | (false, _, false) =&gt; check_constraint (graph g) cst
    | (true, Eq | Le, true) =&gt; true
    | (true, Le, false) =&gt; sprop_cumulative g
    | _ =&gt; false
    end
  end.

Definition check_constraints (csts : Univ.Constraint.t) (g : t) : bool :=
  Univ.Constraint.for_all (check_constraint g) csts.

Definition leq_expr {A B : Type} (function_parameter : A * Z)
  : (B * Z) -&gt; A * Univ.constraint_type * B :=
  match function_parameter with
  | (u, m) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (v, n) =&gt;
        let d :=
          match Z.sub m n with
          | 1 =&gt; Lt
          | diff =&gt;
            OCaml.Stdlib.le diff 0;
            Le
          end in
        (u, d, v)
      end
  end.

Definition enforce_leq_alg (u : Univ.Universe.t) (v : Univ.Universe.t) (g : t)
  : Univ.Constraint.t * t :=
  let enforce_one (function_parameter : (Univ.Level.t * Z) * (Univ.Level.t * Z))
    : (Util.union (Univ.Constraint.t * t) exn) -&gt;
      Util.union (Univ.Constraint.t * t) exn :=
    match function_parameter with
    | (u, v) =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | (Inr _) as orig =&gt; orig
        | (Inl (cstrs, g)) as orig =&gt;
          if check_smaller_expr g u v then
            orig
          else
            let c := leq_expr u v in
            match enforce_constraint c g with
            | g =&gt; Inl ((Univ.Constraint.add c cstrs), g)
            end
        end
    end in
  let c := Univ.Universe.map (fun u =&gt; Univ.Universe.map (fun v =&gt; (u, v)) v) u
    in
  let c :=
    Util.List.(CList.ExtS.cartesians) enforce_one
      (Inl (Univ.Constraint.empty, g)) c in
  let order {A B C D : Type}
    (x : Util.union (Univ.Constraint.t * A) B) (y :
    Util.union (Univ.Constraint.t * C) D) : Z :=
    match (x, y) with
    | (Inr _, Inr _) =&gt; 0
    | (Inl _, Inr _) =&gt; (-1)
    | (Inr _, Inl _) =&gt; 1
    | (Inl (c, _), Inl (c', _)) =&gt;
      Int.compare (Univ.Constraint.cardinal c) (Univ.Constraint.cardinal c')
    end in
  match Util.List.(CList.ExtS.min) order c with
  | Inl x =&gt; x
  | Inr e =&gt; Stdlib.raise e
  end.

Definition enforce_leq_alg (u : Univ.Universe.t) (v : Univ.Universe.t) (g : t)
  : Univ.Constraint.t * t :=
  match enforce_leq_alg u v g with
  | (_, g) as cg =&gt;
    check_leq g u v;
    cg
  end.

Definition add_universe
  (u : Univ.Level.t) (lbound : Univ.Level.t) (strict : bool) (g : t) : t :=
  let graph := G.add None u (graph g) in
  let d :=
    if strict then
      Lt
    else
      Le in
  enforce_constraint (lbound, d, u) record.

Definition add_universe_unconstrained (u : Univ.Level.t) (g : t) : t := record.

Definition check_declared_universes (g : t) (l : Univ.LSet.t) : unit :=
  G.check_declared (graph g) (Univ.LSet.remove Univ.Level.sprop l).

Definition constraints_of_universes (g : t)
  : Univ.Constraint.t * (list Univ.LSet.t) := G.constraints_of (graph g).

Definition constraints_for (kept : Univ.LSet.t) (g : t) : Univ.Constraint.t :=
  G.constraints_for (Univ.LSet.remove Univ.Level.sprop kept) (graph g).

Definition check_subtype
  (lbound : Univ.Level.t) (univs : t) (ctxT : Univ.AUContext.t)
  (ctx : Univ.AUContext.t) : bool :=
  if Stdlib.op_eq_eq (Univ.AUContext.size ctxT) (Univ.AUContext.size ctx) then
    match Univ.UContext.dest (Univ.AUContext.repr ctx) with
    | (inst, cst) =&gt;
      let cstT := Univ.UContext.constraints (Univ.AUContext.repr ctxT) in
      let push (accu : t) (v : Univ.Level.t) : t :=
        add_universe v lbound false accu in
      let univs :=
        Stdlib.Array.fold_left push univs (Univ.Instance.to_array inst) in
      let univs := merge_constraints cstT univs in
      check_constraints cst univs
    end
  else
    false.

Definition check_eq_instances
  (g : t) (t1 : Univ.Instance.t) (t2 : Univ.Instance.t) : bool :=
  let t1 := Univ.Instance.to_array t1 in
  let t2 := Univ.Instance.to_array t2 in
  orb (Stdlib.op_eq_eq t1 t2)
    (andb (Int.equal (Stdlib.Array.length t1) (Stdlib.Array.length t2))
      (let fix aux (i : Int.t) : bool :=
        orb (Int.equal i (Stdlib.Array.length t1))
          (andb
            (check_eq_level g (Stdlib.Array.get t1 i) (Stdlib.Array.get t2 i))
            (aux (Z.add i 1))) in
      aux 0)).

Definition domain (g : t) : Univ.LSet.t :=
  Univ.LSet.add Univ.Level.sprop (G.domain (graph g)).

Definition choose (p : Univ.Level.t -&gt; bool) (g : t) (u : Univ.Level.t)
  : option Univ.Level.t :=
  if Univ.Level.is_sprop u then
    if p u then
      Some u
    else
      None
  else
    G.choose p (graph g) u.

Definition dump_universes
  (f : AcyclicGraph.constraint_type -&gt; Univ.Level.t -&gt; Univ.Level.t -&gt; unit)
  (g : t) : unit := G.dump f (graph g).

Definition check_universes_invariants (g : t) : unit :=
  G.check_invariants Univ.Level.is_small (graph g).

Definition pr_universes (prl : Univ.Level.t -&gt; Pp.t) (g : t) : Pp.t :=
  G.pr prl (graph g).

Definition dummy_mp : Names.DirPath.t :=
  Names.DirPath.make (cons (Names.Id.of_string &quot;Type&quot; % string) []).

Definition make_dummy (i : Z) : Univ.Level.t :=
  Univ.Level.make (Univ.Level.UGlobal.make dummy_mp i).

Definition sort_universes (g : t) : t :=
  g_map (G.sort make_dummy (cons Univ.Level.prop (cons Univ.Level.set []))) g.

Definition merge_constraints : Univ.Constraint.t -&gt; t -&gt; t :=
  if Flags.profile then
    let key := CProfile.declare_profile &quot;merge_constraints&quot; % string in
    CProfile.profile2 key merge_constraints
  else
    merge_constraints.

Definition check_constraints : Univ.Constraint.t -&gt; t -&gt; bool :=
  if Flags.profile then
    let key := CProfile.declare_profile &quot;check_constraints&quot; % string in
    CProfile.profile2 key check_constraints
  else
    check_constraints.

Definition check_eq : t -&gt; Univ.Universe.t -&gt; Univ.Universe.t -&gt; bool :=
  if Flags.profile then
    let check_eq_key := CProfile.declare_profile &quot;check_eq&quot; % string in
    CProfile.profile3 check_eq_key check_eq
  else
    check_eq.

Definition check_leq : t -&gt; Univ.Universe.t -&gt; Univ.Universe.t -&gt; bool :=
  if Flags.profile then
    let check_leq_key := CProfile.declare_profile &quot;check_leq&quot; % string in
    CProfile.profile3 check_leq_key check_leq
  else
    check_leq.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="uint63_31" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>uint63_31.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Invariant: the msb should be 0 *)
type t = Int64.t

let _ = assert (Sys.word_size = 32)

let uint_size = 63

let maxuint63 = Int64.of_string &quot;0x7FFFFFFFFFFFFFFF&quot;
let maxuint31 = Int64.of_string &quot;0x7FFFFFFF&quot;

let zero = Int64.zero
let one = Int64.one

    (* conversion from an int *)
let mask63 i = Int64.logand i maxuint63
let of_int i = Int64.of_int i
let to_int2 i = (Int64.to_int (Int64.shift_right_logical i 31), Int64.to_int i)
let of_int64 i = i
let hash i =
  let (h,l) = to_int2 i in
  (*Hashset.combine h l*)
  h * 65599 + l

    (* conversion of an uint63 to a string *)
let to_string i = Int64.to_string i

let of_string s =
  let i64 = Int64.of_string s in
  if Int64.compare Int64.zero i64 &lt;= 0
      &amp;&amp; Int64.compare i64 maxuint63 &lt;= 0
  then i64
  else raise (Failure &quot;Int63.of_string&quot;)

(* Compiles an unsigned int to OCaml code *)
let compile i = Printf.sprintf &quot;Uint63.of_int64 (%LiL)&quot; i

    (* comparison *)
let lt x y =
  Int64.compare x y &lt; 0

let le x y =
  Int64.compare x y &lt;= 0

    (* logical shift *)
let l_sl x y =
  if le 0L y &amp;&amp; lt y 63L then mask63 (Int64.shift_left x (Int64.to_int y)) else 0L

let l_sr x y =
  if le 0L y &amp;&amp; lt y 63L then Int64.shift_right x (Int64.to_int y) else 0L

let l_and x y = Int64.logand x y
let l_or x y = Int64.logor x y
let l_xor x y = Int64.logxor x y

    (* addition of int63 *)
let add x y = mask63 (Int64.add x y)

let addcarry x y = add (add x y) Int64.one

    (* subtraction *)
let sub x y = mask63 (Int64.sub x y)

let subcarry x y = sub (sub x y) Int64.one

    (* multiplication *)
let mul x y = mask63 (Int64.mul x y)

    (* division *)
let div x y =
  if y = 0L then 0L else Int64.div x y

    (* modulo *)
let rem x y =
  if y = 0L then 0L else Int64.rem x y

let diveucl x y = (div x y, rem x y)

let addmuldiv p x y =
  l_or (l_sl x p) (l_sr y Int64.(sub (of_int uint_size) p))

    (* division of two numbers by one *)
(* precondition: xh &lt; y *)
(* outputs: q, r s.t. x = q * y + r, r &lt; y *)
let div21 xh xl y =
  let nh = ref xh in
  let nl = ref xl in
  let q = ref 0L in
  for _i = 0 to 62 do
    (* invariants: 0 &lt;= nh &lt; y, nl = (xl*2^i) % 2^64,
       (q*y + nh) * 2^(63-i) + (xl % 2^(63-i)) = (xh%y) * 2^63 + xl *)
    nl := Int64.shift_left !nl 1;
    nh := Int64.logor (Int64.shift_left !nh 1) (Int64.shift_right_logical !nl 63);
    q := Int64.shift_left !q 1;
    (* TODO: use &quot;Int64.unsigned_compare !nh y &gt;= 0&quot;,
       once OCaml 4.08 becomes the minimal required version *)
    if Int64.compare !nh 0L &lt; 0 || Int64.compare !nh y &gt;= 0 then
      begin q := Int64.logor !q 1L; nh := Int64.sub !nh y; end
  done;
  !q, !nh

let div21 xh xl y =
  if Int64.compare y xh &lt;= 0 then zero, zero else div21 xh xl y

     (* exact multiplication *)
let mulc x y =
  let lx = ref (Int64.logand x maxuint31) in
  let ly = ref (Int64.logand y maxuint31) in
  let hx = Int64.shift_right x 31 in
  let hy = Int64.shift_right y 31 in
  let hr = ref (Int64.mul hx hy) in
  let lr = ref (Int64.logor (Int64.mul !lx !ly) (Int64.shift_left !hr 62)) in
  hr := (Int64.shift_right_logical !hr 1);
  lx := Int64.mul !lx hy;
  ly := Int64.mul hx !ly;
  hr := Int64.logor !hr (Int64.add (Int64.shift_right !lx 32) (Int64.shift_right !ly 32));
  lr := Int64.add !lr (Int64.shift_left !lx 31);
  hr := Int64.add !hr (Int64.shift_right_logical !lr 63);
  lr := Int64.add (Int64.shift_left !ly 31) (mask63 !lr);
  hr := Int64.add !hr (Int64.shift_right_logical !lr 63);
  if Int64.logand !lr Int64.min_int &lt;&gt; 0L
  then Int64.(sub !hr one, mask63 !lr)
  else (!hr, !lr)

let equal x y = mask63 x = mask63 y

let compare x y = Int64.compare x y

(* Number of leading zeroes *)
let head0 x =
  let r = ref 0 in
  let x = ref x in
  if Int64.logand !x 0x7FFFFFFF00000000L = 0L then r := !r + 31
  else x := Int64.shift_right !x 31;
  if Int64.logand !x 0xFFFF0000L = 0L then (x := Int64.shift_left !x 16; r := !r + 16);
  if Int64.logand !x 0xFF000000L = 0L then (x := Int64.shift_left !x 8; r := !r + 8);
  if Int64.logand !x 0xF0000000L = 0L then (x := Int64.shift_left !x 4; r := !r + 4);
  if Int64.logand !x 0xC0000000L = 0L then (x := Int64.shift_left !x 2; r := !r + 2);
  if Int64.logand !x 0x80000000L = 0L then (x := Int64.shift_left !x 1; r := !r + 1);
  if Int64.logand !x 0x80000000L = 0L then (r := !r + 1);
  Int64.of_int !r

(* Number of trailing zeroes *)
let tail0 x =
  let r = ref 0 in
  let x = ref x in
  if Int64.logand !x 0xFFFFFFFFL = 0L then (x := Int64.shift_right !x 32; r := !r + 32);
  if Int64.logand !x 0xFFFFL = 0L then (x := Int64.shift_right !x 16; r := !r + 16);
  if Int64.logand !x 0xFFL = 0L then (x := Int64.shift_right !x 8; r := !r + 8);
  if Int64.logand !x 0xFL = 0L then (x := Int64.shift_right !x 4; r := !r + 4);
  if Int64.logand !x 0x3L = 0L then (x := Int64.shift_right !x 2; r := !r + 2);
  if Int64.logand !x 0x1L = 0L then (r := !r + 1);
  Int64.of_int !r

(* May an object be safely cast into an Uint63.t ? *)
let is_uint63 t =
  Obj.is_block t &amp;&amp; Int.equal (Obj.tag t) Obj.custom_tag
  &amp;&amp; le (Obj.magic t) maxuint63

(* Arithmetic with explicit carries *)

(* Analog of Numbers.Abstract.Cyclic.carry *)
type 'a carry = C0 of 'a | C1 of 'a

let addc x y =
  let r = add x y in
  if lt r x then C1 r else C0 r

let addcarryc x y =
  let r = addcarry x y in
  if le r x then C1 r else C0 r

let subc x y =
  let r = sub x y in
  if le y x then C0 r else C1 r

let subcarryc x y =
  let r = subcarry x y in
  if lt y x then C0 r else C1 r

(* Register all exported functions so that they can be called from C code *)

let () =
  Callback.register &quot;uint63 add&quot; add;
  Callback.register &quot;uint63 addcarry&quot; addcarry;
  Callback.register &quot;uint63 addmuldiv&quot; addmuldiv;
  Callback.register &quot;uint63 div&quot; div;
  Callback.register &quot;uint63 div21_ml&quot; div21;
  Callback.register &quot;uint63 eq&quot; equal;
  Callback.register &quot;uint63 eq0&quot; (equal Int64.zero);
  Callback.register &quot;uint63 head0&quot; head0;
  Callback.register &quot;uint63 land&quot; l_and;
  Callback.register &quot;uint63 leq&quot; le;
  Callback.register &quot;uint63 lor&quot; l_or;
  Callback.register &quot;uint63 lsl&quot; l_sl;
  Callback.register &quot;uint63 lsl1&quot; (fun x -&gt; l_sl x Int64.one);
  Callback.register &quot;uint63 lsr&quot; l_sr;
  Callback.register &quot;uint63 lsr1&quot; (fun x -&gt; l_sr x Int64.one);
  Callback.register &quot;uint63 lt&quot; lt;
  Callback.register &quot;uint63 lxor&quot; l_xor;
  Callback.register &quot;uint63 mod&quot; rem;
  Callback.register &quot;uint63 mul&quot; mul;
  Callback.register &quot;uint63 mulc_ml&quot; mulc;
  Callback.register &quot;uint63 one&quot; one;
  Callback.register &quot;uint63 sub&quot; sub;
  Callback.register &quot;uint63 subcarry&quot; subcarry;
  Callback.register &quot;uint63 tail0&quot; tail0
</pre>
          </div>
          <div class="col-md-6">
            <code>uint63_31.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Definition t := Stdlib.Int64.t.

Definition uint_size : Z := 63.

Definition maxuint63 : int64 :=
  Stdlib.Int64.of_string &quot;0x7FFFFFFFFFFFFFFF&quot; % string.

Definition maxuint31 : int64 := Stdlib.Int64.of_string &quot;0x7FFFFFFF&quot; % string.

Definition zero : int64 := Stdlib.Int64.zero.

Definition one : int64 := Stdlib.Int64.one.

Definition mask63 (i : int64) : int64 := Stdlib.Int64.logand i maxuint63.

Definition of_int (i : Z) : int64 := Stdlib.Int64.of_int i.

Definition to_int2 (i : int64) : Z * Z :=
  ((Stdlib.Int64.to_int (Stdlib.Int64.shift_right_logical i 31)),
    (Stdlib.Int64.to_int i)).

Definition of_int64 {A : Type} (i : A) : A := i.

Definition hash (i : int64) : Z :=
  match to_int2 i with
  | (h, l) =&gt; Z.add (Z.mul h 65599) l
  end.

Definition to_string (i : int64) : string := Stdlib.Int64.to_string i.

Definition of_string (s : string) : int64 :=
  let i64 := Stdlib.Int64.of_string s in
  if
    andb (OCaml.Stdlib.le (Stdlib.Int64.compare Stdlib.Int64.zero i64) 0)
      (OCaml.Stdlib.le (Stdlib.Int64.compare i64 maxuint63) 0) then
    i64
  else
    Stdlib.raise (OCaml.Failure &quot;Int63.of_string&quot; % string).

Definition compile (i : int64) : string :=
  Stdlib.Printf.sprintf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.String_literal &quot;Uint63.of_int64 (&quot; % string
        (CamlinternalFormatBasics.Int64 CamlinternalFormatBasics.Int_i
          CamlinternalFormatBasics.No_padding
          CamlinternalFormatBasics.No_precision
          (CamlinternalFormatBasics.String_literal &quot;L)&quot; % string
            CamlinternalFormatBasics.End_of_format)))
      &quot;Uint63.of_int64 (%LiL)&quot; % string) i.

Definition lt (x : Stdlib.Int64.t) (y : Stdlib.Int64.t) : bool :=
  OCaml.Stdlib.lt (Stdlib.Int64.compare x y) 0.

Definition le (x : Stdlib.Int64.t) (y : Stdlib.Int64.t) : bool :=
  OCaml.Stdlib.le (Stdlib.Int64.compare x y) 0.

Definition l_sl (x : int64) (y : Stdlib.Int64.t) : int64 :=
  if andb (le 0 y) (lt y 63) then
    mask63 (Stdlib.Int64.shift_left x (Stdlib.Int64.to_int y))
  else
    0.

Definition l_sr (x : int64) (y : Stdlib.Int64.t) : int64 :=
  if andb (le 0 y) (lt y 63) then
    Stdlib.Int64.shift_right x (Stdlib.Int64.to_int y)
  else
    0.

Definition l_and (x : int64) (y : int64) : int64 := Stdlib.Int64.logand x y.

Definition l_or (x : int64) (y : int64) : int64 := Stdlib.Int64.logor x y.

Definition l_xor (x : int64) (y : int64) : int64 := Stdlib.Int64.logxor x y.

Definition add (x : int64) (y : int64) : int64 := mask63 (Stdlib.Int64.add x y).

Definition addcarry (x : int64) (y : int64) : int64 :=
  add (add x y) Stdlib.Int64.one.

Definition sub (x : int64) (y : int64) : int64 := mask63 (Stdlib.Int64.sub x y).

Definition subcarry (x : int64) (y : int64) : int64 :=
  sub (sub x y) Stdlib.Int64.one.

Definition mul (x : int64) (y : int64) : int64 := mask63 (Stdlib.Int64.mul x y).

Definition div (x : int64) (y : int64) : int64 :=
  if equiv_decb y 0 then
    0
  else
    Stdlib.Int64.div x y.

Definition rem (x : int64) (y : int64) : int64 :=
  if equiv_decb y 0 then
    0
  else
    Stdlib.Int64.rem x y.

Definition diveucl (x : int64) (y : int64) : int64 * int64 :=
  ((div x y), (rem x y)).

Definition addmuldiv (p : Stdlib.Int64.t) (x : int64) (y : int64) : int64 :=
  l_or (l_sl x p) (l_sr y (Stdlib.Int64.sub (Stdlib.Int64.of_int uint_size) p)).

Definition div21 (xh : Stdlib.Int64.t) (xl : int64) (y : Stdlib.Int64.t)
  : int64 * Stdlib.Int64.t :=
  let nh := Stdlib.ref xh in
  let nl := Stdlib.ref xl in
  let q := Stdlib.ref 0 in
  for;
  ((Stdlib.op_exclamation q), (Stdlib.op_exclamation nh)).

Definition div21 (xh : Stdlib.Int64.t) (xl : int64) (y : Stdlib.Int64.t)
  : int64 * Stdlib.Int64.t :=
  if OCaml.Stdlib.le (Stdlib.Int64.compare y xh) 0 then
    (zero, zero)
  else
    div21 xh xl y.

Definition mulc (x : int64) (y : int64) : int64 * int64 :=
  let lx := Stdlib.ref (Stdlib.Int64.logand x maxuint31) in
  let ly := Stdlib.ref (Stdlib.Int64.logand y maxuint31) in
  let hx := Stdlib.Int64.shift_right x 31 in
  let hy := Stdlib.Int64.shift_right y 31 in
  let hr := Stdlib.ref (Stdlib.Int64.mul hx hy) in
  let lr :=
    Stdlib.ref
      (Stdlib.Int64.logor
        (Stdlib.Int64.mul (Stdlib.op_exclamation lx) (Stdlib.op_exclamation ly))
        (Stdlib.Int64.shift_left (Stdlib.op_exclamation hr) 62)) in
  Stdlib.op_colon_eq hr
    (Stdlib.Int64.shift_right_logical (Stdlib.op_exclamation hr) 1);
  Stdlib.op_colon_eq lx (Stdlib.Int64.mul (Stdlib.op_exclamation lx) hy);
  Stdlib.op_colon_eq ly (Stdlib.Int64.mul hx (Stdlib.op_exclamation ly));
  Stdlib.op_colon_eq hr
    (Stdlib.Int64.logor (Stdlib.op_exclamation hr)
      (Stdlib.Int64.add (Stdlib.Int64.shift_right (Stdlib.op_exclamation lx) 32)
        (Stdlib.Int64.shift_right (Stdlib.op_exclamation ly) 32)));
  Stdlib.op_colon_eq lr
    (Stdlib.Int64.add (Stdlib.op_exclamation lr)
      (Stdlib.Int64.shift_left (Stdlib.op_exclamation lx) 31));
  Stdlib.op_colon_eq hr
    (Stdlib.Int64.add (Stdlib.op_exclamation hr)
      (Stdlib.Int64.shift_right_logical (Stdlib.op_exclamation lr) 63));
  Stdlib.op_colon_eq lr
    (Stdlib.Int64.add (Stdlib.Int64.shift_left (Stdlib.op_exclamation ly) 31)
      (mask63 (Stdlib.op_exclamation lr)));
  Stdlib.op_colon_eq hr
    (Stdlib.Int64.add (Stdlib.op_exclamation hr)
      (Stdlib.Int64.shift_right_logical (Stdlib.op_exclamation lr) 63));
  if
    nequiv_decb
      (Stdlib.Int64.logand (Stdlib.op_exclamation lr) Stdlib.Int64.min_int) 0
    then
    ((Stdlib.Int64.sub (Stdlib.op_exclamation hr) Stdlib.Int64.one),
      (mask63 (Stdlib.op_exclamation lr)))
  else
    ((Stdlib.op_exclamation hr), (Stdlib.op_exclamation lr)).

Definition equal (x : int64) (y : int64) : bool :=
  equiv_decb (mask63 x) (mask63 y).

Definition compare (x : Stdlib.Int64.t) (y : Stdlib.Int64.t) : Z :=
  Stdlib.Int64.compare x y.

Definition head0 (x : int64) : int64 :=
  let r := Stdlib.ref 0 in
  let x := Stdlib.ref x in
  if equiv_decb (Stdlib.Int64.logand (Stdlib.op_exclamation x) (-4294967296)) 0
    then
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 31)
  else
    Stdlib.op_colon_eq x (Stdlib.Int64.shift_right (Stdlib.op_exclamation x) 31);
  if equiv_decb (Stdlib.Int64.logand (Stdlib.op_exclamation x) 4294901760) 0
    then
    Stdlib.op_colon_eq x (Stdlib.Int64.shift_left (Stdlib.op_exclamation x) 16);
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 16)
  else
    tt;
  if equiv_decb (Stdlib.Int64.logand (Stdlib.op_exclamation x) 4278190080) 0
    then
    Stdlib.op_colon_eq x (Stdlib.Int64.shift_left (Stdlib.op_exclamation x) 8);
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 8)
  else
    tt;
  if equiv_decb (Stdlib.Int64.logand (Stdlib.op_exclamation x) 4026531840) 0
    then
    Stdlib.op_colon_eq x (Stdlib.Int64.shift_left (Stdlib.op_exclamation x) 4);
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 4)
  else
    tt;
  if equiv_decb (Stdlib.Int64.logand (Stdlib.op_exclamation x) 3221225472) 0
    then
    Stdlib.op_colon_eq x (Stdlib.Int64.shift_left (Stdlib.op_exclamation x) 2);
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 2)
  else
    tt;
  if equiv_decb (Stdlib.Int64.logand (Stdlib.op_exclamation x) 2147483648) 0
    then
    Stdlib.op_colon_eq x (Stdlib.Int64.shift_left (Stdlib.op_exclamation x) 1);
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 1)
  else
    tt;
  if equiv_decb (Stdlib.Int64.logand (Stdlib.op_exclamation x) 2147483648) 0
    then
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 1)
  else
    tt;
  Stdlib.Int64.of_int (Stdlib.op_exclamation r).

Definition tail0 (x : int64) : int64 :=
  let r := Stdlib.ref 0 in
  let x := Stdlib.ref x in
  if equiv_decb (Stdlib.Int64.logand (Stdlib.op_exclamation x) 4294967295) 0
    then
    Stdlib.op_colon_eq x (Stdlib.Int64.shift_right (Stdlib.op_exclamation x) 32);
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 32)
  else
    tt;
  if equiv_decb (Stdlib.Int64.logand (Stdlib.op_exclamation x) 65535) 0 then
    Stdlib.op_colon_eq x (Stdlib.Int64.shift_right (Stdlib.op_exclamation x) 16);
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 16)
  else
    tt;
  if equiv_decb (Stdlib.Int64.logand (Stdlib.op_exclamation x) 255) 0 then
    Stdlib.op_colon_eq x (Stdlib.Int64.shift_right (Stdlib.op_exclamation x) 8);
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 8)
  else
    tt;
  if equiv_decb (Stdlib.Int64.logand (Stdlib.op_exclamation x) 15) 0 then
    Stdlib.op_colon_eq x (Stdlib.Int64.shift_right (Stdlib.op_exclamation x) 4);
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 4)
  else
    tt;
  if equiv_decb (Stdlib.Int64.logand (Stdlib.op_exclamation x) 3) 0 then
    Stdlib.op_colon_eq x (Stdlib.Int64.shift_right (Stdlib.op_exclamation x) 2);
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 2)
  else
    tt;
  if equiv_decb (Stdlib.Int64.logand (Stdlib.op_exclamation x) 1) 0 then
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 1)
  else
    tt;
  Stdlib.Int64.of_int (Stdlib.op_exclamation r).

Definition is_uint63 (t : Stdlib.Obj.t) : bool :=
  andb (Stdlib.Obj.is_block t)
    (andb (Int.equal (Stdlib.Obj.tag t) Stdlib.Obj.custom_tag)
      (le (Stdlib.Obj.magic t) maxuint63)).

Inductive carry (a : Type) : Type :=
| C0 : a -&gt; carry a
| C1 : a -&gt; carry a.

Arguments C0 {_}.
Arguments C1 {_}.

Definition addc (x : Stdlib.Int64.t) (y : int64) : carry int64 :=
  let r := add x y in
  if lt r x then
    C1 r
  else
    C0 r.

Definition addcarryc (x : Stdlib.Int64.t) (y : int64) : carry int64 :=
  let r := addcarry x y in
  if le r x then
    C1 r
  else
    C0 r.

Definition subc (x : Stdlib.Int64.t) (y : Stdlib.Int64.t) : carry int64 :=
  let r := sub x y in
  if le y x then
    C0 r
  else
    C1 r.

Definition subcarryc (x : Stdlib.Int64.t) (y : Stdlib.Int64.t) : carry int64 :=
  let r := subcarry x y in
  if lt y x then
    C0 r
  else
    C1 r.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="uint63_63" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>uint63_63.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

type t = int

let _ = assert (Sys.word_size = 64)

let uint_size = 63

let maxuint63 = Int64.of_string &quot;0x7FFFFFFFFFFFFFFF&quot;
let maxuint31 = 0x7FFFFFFF

    (* conversion from an int *)
let to_uint64 i = Int64.logand (Int64.of_int i) maxuint63

let of_int i = i
[@@ocaml.inline always]

let to_int2 i = (0,i)

let of_int64 _i = assert false

let hash i = i
[@@ocaml.inline always]

    (* conversion of an uint63 to a string *)
let to_string i = Int64.to_string (to_uint64 i)

let of_string s =
  let i64 = Int64.of_string s in
  if Int64.compare Int64.zero i64 &lt;= 0
      &amp;&amp; Int64.compare i64 maxuint63 &lt;= 0
  then Int64.to_int i64
  else raise (Failure &quot;Int64.of_string&quot;)

(* Compiles an unsigned int to OCaml code *)
let compile i = Printf.sprintf &quot;Uint63.of_int (%i)&quot; i

let zero = 0
let one = 1

    (* logical shift *)
let l_sl x y =
  if 0 &lt;= y &amp;&amp; y &lt; 63 then x lsl y else 0

let l_sr x y =
  if 0 &lt;= y &amp;&amp; y &lt; 63 then x lsr y else 0

let l_and x y = x land y
[@@ocaml.inline always]

let l_or x y = x lor y
[@@ocaml.inline always]

let l_xor x y = x lxor y
[@@ocaml.inline always]

    (* addition of int63 *)
let add x y = x + y
[@@ocaml.inline always]

    (* subtraction *)
let sub x y = x - y
[@@ocaml.inline always]

    (* multiplication *)
let mul x y = x * y
[@@ocaml.inline always]

    (* division *)
let div (x : int) (y : int) =
  if y = 0 then 0 else Int64.to_int (Int64.div (to_uint64 x) (to_uint64 y))

    (* modulo *)
let rem (x : int) (y : int) =
  if y = 0 then 0 else Int64.to_int (Int64.rem (to_uint64 x) (to_uint64 y))

let diveucl x y = (div x y, rem x y)

let addmuldiv p x y =
  l_or (l_sl x p) (l_sr y (uint_size - p))

    (* comparison *)
let lt (x : int) (y : int) =
  (x lxor 0x4000000000000000) &lt; (y lxor 0x4000000000000000)
[@@ocaml.inline always]

let le (x : int) (y : int) =
  (x lxor 0x4000000000000000) &lt;= (y lxor 0x4000000000000000)
[@@ocaml.inline always]

    (* division of two numbers by one *)
(* precondition: xh &lt; y *)
(* outputs: q, r s.t. x = q * y + r, r &lt; y *)
let div21 xh xl y =
  (* nh might temporarily grow as large as 2*y - 1 in the loop body,
     so we store it as a 64-bit unsigned integer *)
  let nh = ref xh in
  let nl = ref xl in
  let q = ref 0 in
  for _i = 0 to 62 do
    (* invariants: 0 &lt;= nh &lt; y, nl = (xl*2^i) % 2^63,
       (q*y + nh) * 2^(63-i) + (xl % 2^(63-i)) = (xh%y) * 2^63 + xl *)
    nh := Int64.logor (Int64.shift_left !nh 1) (Int64.of_int (!nl lsr 62));
    nl := !nl lsl 1;
    q := !q lsl 1;
    (* TODO: use &quot;Int64.unsigned_compare !nh y &gt;= 0&quot;,
       once OCaml 4.08 becomes the minimal required version *)
    if Int64.compare !nh 0L &lt; 0 || Int64.compare !nh y &gt;= 0 then
      begin q := !q lor 1; nh := Int64.sub !nh y; end
  done;
  !q, Int64.to_int !nh

let div21 xh xl y =
  let xh = to_uint64 xh in
  let y = to_uint64 y in
  if Int64.compare y xh &lt;= 0 then 0, 0 else div21 xh xl y

     (* exact multiplication *)
(* TODO: check that none of these additions could be a logical or *)


(* size = 32 + 31
   (hx &lt;&lt; 31 + lx) * (hy &lt;&lt; 31 + ly) =
   hxhy &lt;&lt; 62 + (hxly + lxhy) &lt;&lt; 31 + lxly
*)

(* precondition : (x lsr 62 = 0 || y lsr 62 = 0) *)
let mulc_aux x y =
  let lx = x land maxuint31 in
  let ly = y land maxuint31 in
  let hx = x lsr 31  in
  let hy = y lsr 31 in
    (* hx and hy are 32 bits value but at most one is 32 *)
  let hxy  = hx * hy in (* 63 bits *)
  let hxly = hx * ly in (* 63 bits *)
  let lxhy = lx * hy in (* 63 bits *)
  let lxy  = lx * ly in (* 62 bits *)
  let l  = lxy lor (hxy lsl 62) (* 63 bits *) in
  let h  = hxy lsr 1 in (* 62 bits *)
  let hl = hxly + lxhy in (* We can have a carry *)
  let h  = if lt hl hxly then h + (1 lsl 31) else h in
  let hl'= hl lsl 31 in
  let l  = l + hl' in
  let h  = if lt l hl' then h + 1 else h in
  let h  = h + (hl lsr 32) in
  (h,l)

let mulc x y =
  if (x lsr 62 = 0 || y lsr 62 = 0) then mulc_aux x y
  else
    let yl = y lxor (1 lsl 62) in
    let (h,l) = mulc_aux x yl in
    (* h &lt;&lt; 63 + l = x * yl
       x * y = x * (1 &lt;&lt; 62 + yl)  =
       x &lt;&lt; 62 + x*yl = x &lt;&lt; 62 + h &lt;&lt; 63 + l *)
    let l' = l + (x lsl 62) in
    let h = if lt l' l then h + 1 else h in
    (h + (x lsr 1), l')

let equal (x : int) (y : int) = x = y
[@@ocaml.inline always]

let compare (x:int) (y:int) =
  let x = x lxor 0x4000000000000000 in
  let y = y lxor 0x4000000000000000 in
  if x &gt; y then 1
  else if y &gt; x then -1
  else 0

    (* head tail *)

let head0 x =
  let r = ref 0 in
  let x = ref x in
  if !x land 0x7FFFFFFF00000000 = 0 then r := !r + 31
  else x := !x lsr 31;
  if !x land 0xFFFF0000 = 0 then (x := !x lsl 16; r := !r + 16);
  if !x land 0xFF000000 = 0 then (x := !x lsl 8; r := !r + 8);
  if !x land 0xF0000000 = 0 then (x := !x lsl 4; r := !r + 4);
  if !x land 0xC0000000 = 0 then (x := !x lsl 2; r := !r + 2);
  if !x land 0x80000000 = 0 then (x := !x lsl 1; r := !r + 1);
  if !x land 0x80000000 = 0 then (               r := !r + 1);
  !r;;

let tail0 x =
  let r = ref 0 in
  let x = ref x in
  if !x land 0xFFFFFFFF = 0 then (x := !x lsr 32; r := !r + 32);
  if !x land 0xFFFF = 0 then (x := !x lsr 16; r := !r + 16);
  if !x land 0xFF = 0   then (x := !x lsr 8;  r := !r + 8);
  if !x land 0xF = 0    then (x := !x lsr 4;  r := !r + 4);
  if !x land 0x3 = 0    then (x := !x lsr 2;  r := !r + 2);
  if !x land 0x1 = 0    then (                r := !r + 1);
  !r

let is_uint63 t =
  Obj.is_int t
[@@ocaml.inline always]

(* Arithmetic with explicit carries *)

(* Analog of Numbers.Abstract.Cyclic.carry *)
type 'a carry = C0 of 'a | C1 of 'a

let addc x y =
  let r = x + y in
  if lt r x then C1 r else C0 r

let addcarryc x y =
  let r = x + y + 1 in
  if le r x then C1 r else C0 r

let subc x y =
  let r = x - y in
  if le y x then C0 r else C1 r

let subcarryc x y =
  let r = x - y - 1 in
  if lt y x then C0 r else C1 r
</pre>
          </div>
          <div class="col-md-6">
            <code>uint63_63.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Definition t := Z.

Definition uint_size : Z := 63.

Definition maxuint63 : int64 :=
  Stdlib.Int64.of_string &quot;0x7FFFFFFFFFFFFFFF&quot; % string.

Definition maxuint31 : Z := 2147483647.

Definition to_uint64 (i : Z) : int64 :=
  Stdlib.Int64.logand (Stdlib.Int64.of_int i) maxuint63.

Definition of_int {A : Type} (i : A) : A := i.

Definition to_int2 {A : Type} (i : A) : Z * A := (0, i).

Definition of_int64 {A B : Type} (_i : A) : B := false.

Definition hash {A : Type} (i : A) : A := i.

Definition to_string (i : Z) : string := Stdlib.Int64.to_string (to_uint64 i).

Definition of_string (s : string) : Z :=
  let i64 := Stdlib.Int64.of_string s in
  if
    andb (OCaml.Stdlib.le (Stdlib.Int64.compare Stdlib.Int64.zero i64) 0)
      (OCaml.Stdlib.le (Stdlib.Int64.compare i64 maxuint63) 0) then
    Stdlib.Int64.to_int i64
  else
    Stdlib.raise (OCaml.Failure &quot;Int64.of_string&quot; % string).

Definition compile (i : Z) : string :=
  Stdlib.Printf.sprintf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.String_literal &quot;Uint63.of_int (&quot; % string
        (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
          CamlinternalFormatBasics.No_padding
          CamlinternalFormatBasics.No_precision
          (CamlinternalFormatBasics.Char_literal &quot;)&quot; % char
            CamlinternalFormatBasics.End_of_format)))
      &quot;Uint63.of_int (%i)&quot; % string) i.

Definition zero : Z := 0.

Definition one : Z := 1.

Definition l_sl (x : Z) (y : Z) : Z :=
  if andb (OCaml.Stdlib.le 0 y) (OCaml.Stdlib.lt y 63) then
    Z.shiftl x y
  else
    0.

Definition l_sr (x : Z) (y : Z) : Z :=
  if andb (OCaml.Stdlib.le 0 y) (OCaml.Stdlib.lt y 63) then
    Z.shiftr x y
  else
    0.

Definition l_and (x : Z) (y : Z) : Z := Z.land x y.

Definition l_or (x : Z) (y : Z) : Z := Z.lor x y.

Definition l_xor (x : Z) (y : Z) : Z := Z.lxor x y.

Definition add (x : Z) (y : Z) : Z := Z.add x y.

Definition sub (x : Z) (y : Z) : Z := Z.sub x y.

Definition mul (x : Z) (y : Z) : Z := Z.mul x y.

Definition div (x : Z) (y : Z) : Z :=
  if equiv_decb y 0 then
    0
  else
    Stdlib.Int64.to_int (Stdlib.Int64.div (to_uint64 x) (to_uint64 y)).

Definition rem (x : Z) (y : Z) : Z :=
  if equiv_decb y 0 then
    0
  else
    Stdlib.Int64.to_int (Stdlib.Int64.rem (to_uint64 x) (to_uint64 y)).

Definition diveucl (x : Z) (y : Z) : Z * Z := ((div x y), (rem x y)).

Definition addmuldiv (p : Z) (x : Z) (y : Z) : Z :=
  l_or (l_sl x p) (l_sr y (Z.sub uint_size p)).

Definition lt (x : Z) (y : Z) : bool :=
  OCaml.Stdlib.lt (Z.lxor x (-4611686018427387904))
    (Z.lxor y (-4611686018427387904)).

Definition le (x : Z) (y : Z) : bool :=
  OCaml.Stdlib.le (Z.lxor x (-4611686018427387904))
    (Z.lxor y (-4611686018427387904)).

Definition div21 (xh : Stdlib.Int64.t) (xl : Z) (y : Stdlib.Int64.t) : Z * Z :=
  let nh := Stdlib.ref xh in
  let nl := Stdlib.ref xl in
  let q := Stdlib.ref 0 in
  for;
  ((Stdlib.op_exclamation q), (Stdlib.Int64.to_int (Stdlib.op_exclamation nh))).

Definition div21 (xh : Z) (xl : Z) (y : Z) : Z * Z :=
  let xh := to_uint64 xh in
  let y := to_uint64 y in
  if OCaml.Stdlib.le (Stdlib.Int64.compare y xh) 0 then
    (0, 0)
  else
    div21 xh xl y.

Definition mulc_aux (x : Z) (y : Z) : Z * Z :=
  let lx := Z.land x maxuint31 in
  let ly := Z.land y maxuint31 in
  let hx := Z.shiftr x 31 in
  let hy := Z.shiftr y 31 in
  let hxy := Z.mul hx hy in
  let hxly := Z.mul hx ly in
  let lxhy := Z.mul lx hy in
  let lxy := Z.mul lx ly in
  let l := Z.lor lxy (Z.shiftl hxy 62) in
  let h := Z.shiftr hxy 1 in
  let hl := Z.add hxly lxhy in
  let h :=
    if lt hl hxly then
      Z.add h (Z.shiftl 1 31)
    else
      h in
  let hl' := Z.shiftl hl 31 in
  let l := Z.add l hl' in
  let h :=
    if lt l hl' then
      Z.add h 1
    else
      h in
  let h := Z.add h (Z.shiftr hl 32) in
  (h, l).

Definition mulc (x : Z) (y : Z) : Z * Z :=
  if orb (equiv_decb (Z.shiftr x 62) 0) (equiv_decb (Z.shiftr y 62) 0) then
    mulc_aux x y
  else
    let yl := Z.lxor y (Z.shiftl 1 62) in
    match mulc_aux x yl with
    | (h, l) =&gt;
      let l' := Z.add l (Z.shiftl x 62) in
      let h :=
        if lt l' l then
          Z.add h 1
        else
          h in
      ((Z.add h (Z.shiftr x 1)), l')
    end.

Definition equal (x : Z) (y : Z) : bool := equiv_decb x y.

Definition compare (x : Z) (y : Z) : Z :=
  let x := Z.lxor x (-4611686018427387904) in
  let y := Z.lxor y (-4611686018427387904) in
  if OCaml.Stdlib.gt x y then
    1
  else
    if OCaml.Stdlib.gt y x then
      (-1)
    else
      0.

Definition head0 (x : Z) : Z :=
  let r := Stdlib.ref 0 in
  let x := Stdlib.ref x in
  if equiv_decb (Z.land (Stdlib.op_exclamation x) (-4294967296)) 0 then
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 31)
  else
    Stdlib.op_colon_eq x (Z.shiftr (Stdlib.op_exclamation x) 31);
  if equiv_decb (Z.land (Stdlib.op_exclamation x) 4294901760) 0 then
    Stdlib.op_colon_eq x (Z.shiftl (Stdlib.op_exclamation x) 16);
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 16)
  else
    tt;
  if equiv_decb (Z.land (Stdlib.op_exclamation x) 4278190080) 0 then
    Stdlib.op_colon_eq x (Z.shiftl (Stdlib.op_exclamation x) 8);
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 8)
  else
    tt;
  if equiv_decb (Z.land (Stdlib.op_exclamation x) 4026531840) 0 then
    Stdlib.op_colon_eq x (Z.shiftl (Stdlib.op_exclamation x) 4);
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 4)
  else
    tt;
  if equiv_decb (Z.land (Stdlib.op_exclamation x) 3221225472) 0 then
    Stdlib.op_colon_eq x (Z.shiftl (Stdlib.op_exclamation x) 2);
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 2)
  else
    tt;
  if equiv_decb (Z.land (Stdlib.op_exclamation x) 2147483648) 0 then
    Stdlib.op_colon_eq x (Z.shiftl (Stdlib.op_exclamation x) 1);
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 1)
  else
    tt;
  if equiv_decb (Z.land (Stdlib.op_exclamation x) 2147483648) 0 then
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 1)
  else
    tt;
  Stdlib.op_exclamation r.

Definition tail0 (x : Z) : Z :=
  let r := Stdlib.ref 0 in
  let x := Stdlib.ref x in
  if equiv_decb (Z.land (Stdlib.op_exclamation x) 4294967295) 0 then
    Stdlib.op_colon_eq x (Z.shiftr (Stdlib.op_exclamation x) 32);
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 32)
  else
    tt;
  if equiv_decb (Z.land (Stdlib.op_exclamation x) 65535) 0 then
    Stdlib.op_colon_eq x (Z.shiftr (Stdlib.op_exclamation x) 16);
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 16)
  else
    tt;
  if equiv_decb (Z.land (Stdlib.op_exclamation x) 255) 0 then
    Stdlib.op_colon_eq x (Z.shiftr (Stdlib.op_exclamation x) 8);
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 8)
  else
    tt;
  if equiv_decb (Z.land (Stdlib.op_exclamation x) 15) 0 then
    Stdlib.op_colon_eq x (Z.shiftr (Stdlib.op_exclamation x) 4);
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 4)
  else
    tt;
  if equiv_decb (Z.land (Stdlib.op_exclamation x) 3) 0 then
    Stdlib.op_colon_eq x (Z.shiftr (Stdlib.op_exclamation x) 2);
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 2)
  else
    tt;
  if equiv_decb (Z.land (Stdlib.op_exclamation x) 1) 0 then
    Stdlib.op_colon_eq r (Z.add (Stdlib.op_exclamation r) 1)
  else
    tt;
  Stdlib.op_exclamation r.

Definition is_uint63 (t : Stdlib.Obj.t) : bool := Stdlib.Obj.is_int t.

Inductive carry (a : Type) : Type :=
| C0 : a -&gt; carry a
| C1 : a -&gt; carry a.

Arguments C0 {_}.
Arguments C1 {_}.

Definition addc (x : Z) (y : Z) : carry Z :=
  let r := Z.add x y in
  if lt r x then
    C1 r
  else
    C0 r.

Definition addcarryc (x : Z) (y : Z) : carry Z :=
  let r := Z.add (Z.add x y) 1 in
  if le r x then
    C1 r
  else
    C0 r.

Definition subc (x : Z) (y : Z) : carry Z :=
  let r := Z.sub x y in
  if le y x then
    C0 r
  else
    C1 r.

Definition subcarryc (x : Z) (y : Z) : carry Z :=
  let r := Z.sub (Z.sub x y) 1 in
  if lt y x then
    C0 r
  else
    C1 r.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="univ" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>univ.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created in Caml by G√©rard Huet for CoC 4.8 [Dec 1988] *)
(* Functional code by Jean-Christophe Filli√¢tre for Coq V7.0 [1999] *)
(* Extension with algebraic universes by HH for Coq V7.0 [Sep 2001] *)
(* Additional support for sort-polymorphic inductive types by HH [Mar 2006] *)
(* Support for universe polymorphism by MS [2014] *)

(* Revisions by Bruno Barras, Hugo Herbelin, Pierre Letouzey, Matthieu
   Sozeau, Pierre-Marie P√©drot *)

open Pp
open CErrors
open Util

(* Universes are stratified by a partial ordering $\le$.
   Let $\~{}$ be the associated equivalence. We also have a strict ordering
   $&lt;$ between equivalence classes, and we maintain that $&lt;$ is acyclic,
   and contained in $\le$ in the sense that $[U]&lt;[V]$ implies $U\le V$.

   At every moment, we have a finite number of universes, and we
   maintain the ordering in the presence of assertions $U&lt;V$ and $U\le V$.

   The equivalence $\~{}$ is represented by a tree structure, as in the
   union-find algorithm. The assertions $&lt;$ and $\le$ are represented by
   adjacency lists *)

module RawLevel =
struct
  open Names

  module UGlobal = struct
    type t = DirPath.t * int

    let make dp i = (DirPath.hcons dp,i)

    let equal (d, i) (d', i') = DirPath.equal d d' &amp;&amp; Int.equal i i'

    let hash (d,i) = Hashset.Combine.combine i (DirPath.hash d)

    let compare (d, i) (d', i') =
      let c = Int.compare i i' in
      if Int.equal c 0 then DirPath.compare d d'
      else c
  end

  type t =
    | SProp
    | Prop
    | Set
    | Level of UGlobal.t
    | Var of int

  (* Hash-consing *)

  let equal x y =
    x == y ||
      match x, y with
      | SProp, SProp -&gt; true
      | Prop, Prop -&gt; true
      | Set, Set -&gt; true
      | Level l, Level l' -&gt; UGlobal.equal l l'
      | Var n, Var n' -&gt; Int.equal n n'
      | _ -&gt; false

  let compare u v =
    match u, v with
    | SProp, SProp -&gt; 0
    | SProp, _ -&gt; -1
    | _, SProp -&gt; 1
    | Prop,Prop -&gt; 0
    | Prop, _ -&gt; -1
    | _, Prop -&gt; 1
    | Set, Set -&gt; 0
    | Set, _ -&gt; -1
    | _, Set -&gt; 1
    | Level (dp1, i1), Level (dp2, i2) -&gt;
      if i1 &lt; i2 then -1
      else if i1 &gt; i2 then 1
      else DirPath.compare dp1 dp2
    | Level _, _ -&gt; -1
    | _, Level _ -&gt; 1
    | Var n, Var m -&gt; Int.compare n m

  let hequal x y =
    x == y ||
      match x, y with
      | SProp, SProp -&gt; true
      | Prop, Prop -&gt; true
      | Set, Set -&gt; true
      | Level (n,d), Level (n',d') -&gt;
        n == n' &amp;&amp; d == d'
      | Var n, Var n' -&gt; n == n'
      | _ -&gt; false

  let hcons = function
    | SProp as x -&gt; x
    | Prop as x -&gt; x
    | Set as x -&gt; x
    | Level (d,n) as x -&gt;
      let d' = Names.DirPath.hcons d in
        if d' == d then x else Level (d',n)
    | Var _n as x -&gt; x

  open Hashset.Combine

  let hash = function
    | SProp -&gt; combinesmall 1 0
    | Prop -&gt; combinesmall 1 1
    | Set -&gt; combinesmall 1 2
    | Var n -&gt; combinesmall 2 n
    | Level (d, n) -&gt; combinesmall 3 (combine n (Names.DirPath.hash d))

end

module Level = struct

  module UGlobal = RawLevel.UGlobal

  type raw_level = RawLevel.t =
  | SProp
  | Prop
  | Set
  | Level of UGlobal.t
  | Var of int

  (** Embed levels with their hash value *)
  type t = { 
    hash : int;
    data : RawLevel.t }

  let equal x y = 
    x == y || Int.equal x.hash y.hash &amp;&amp; RawLevel.equal x.data y.data

  let hash x = x.hash

  let data x = x.data

  (** Hashcons on levels + their hash *)

  module Self = struct
    type nonrec t = t
    type u = unit
    let eq x y = x.hash == y.hash &amp;&amp; RawLevel.hequal x.data y.data
    let hash x = x.hash
    let hashcons () x =
      let data' = RawLevel.hcons x.data in
      if x.data == data' then x else { x with data = data' }
  end

  let hcons =
    let module H = Hashcons.Make(Self) in
    Hashcons.simple_hcons H.generate H.hcons ()

  let make l = hcons { hash = RawLevel.hash l; data = l }

  let set = make Set
  let prop = make Prop
  let sprop = make SProp

  let is_small x = 
    match data x with
    | Level _ -&gt; false
    | Var _ -&gt; false
    | SProp -&gt; true
    | Prop -&gt; true
    | Set -&gt; true
 
  let is_prop x =
    match data x with
    | Prop -&gt; true
    | _ -&gt; false

  let is_set x =
    match data x with
    | Set -&gt; true
    | _ -&gt; false

  let is_sprop x =
    match data x with
    | SProp -&gt; true
    | _ -&gt; false

  let compare u v =
    if u == v then 0
    else RawLevel.compare (data u) (data v)
	    
  let to_string x = 
    match data x with
    | SProp -&gt; &quot;SProp&quot;
    | Prop -&gt; &quot;Prop&quot;
    | Set -&gt; &quot;Set&quot;
    | Level (d,n) -&gt; Names.DirPath.to_string d^&quot;.&quot;^string_of_int n
    | Var n -&gt; &quot;Var(&quot; ^ string_of_int n ^ &quot;)&quot;

  let pr u = str (to_string u)

  let apart u v =
    match data u, data v with
    | SProp, _ | _, SProp
    | Prop, Set | Set, Prop -&gt; true
    | _ -&gt; false

  let vars = Array.init 20 (fun i -&gt; make (Var i))

  let var n = 
    if n &lt; 20 then vars.(n) else make (Var n)

  let var_index u =
    match data u with
    | Var n -&gt; Some n | _ -&gt; None

  let make qid = make (Level qid)

  let name u =
    match data u with
    | Level (d, n) -&gt; Some (d, n)
    | _ -&gt; None
end

(** Level maps *)
module LMap = struct 
  module M = HMap.Make (Level)
  include M

  let lunion l r =
    union (fun _k l _r -&gt; Some l) l r

  let subst_union l r =
    union (fun _k l r -&gt;
      match l, r with
      | Some _, _ -&gt; Some l
      | None, None -&gt; Some l
      | _, _ -&gt; Some r) l r

  let diff ext orig =
    fold (fun u v acc -&gt; 
      if mem u orig then acc 
      else add u v acc)
      ext empty

  let pr f m =
    h 0 (prlist_with_sep fnl (fun (u, v) -&gt;
      Level.pr u ++ f v) (bindings m))
end

module LSet = struct
  include LMap.Set

  let pr prl s =
    str&quot;{&quot; ++ prlist_with_sep spc prl (elements s) ++ str&quot;}&quot;

  let of_array l =
    Array.fold_left (fun acc x -&gt; add x acc) empty l

end


type 'a universe_map = 'a LMap.t

type universe_level = Level.t

type universe_level_subst_fn = universe_level -&gt; universe_level

type universe_set = LSet.t

(* An algebraic universe [universe] is either a universe variable
   [Level.t] or a formal universe known to be greater than some
   universe variables and strictly greater than some (other) universe
   variables

   Universes variables denote universes initially present in the term
   to type-check and non variable algebraic universes denote the
   universes inferred while type-checking: it is either the successor
   of a universe present in the initial term to type-check or the
   maximum of two algebraic universes
*)

module Universe =
struct
  (* Invariants: non empty, sorted and without duplicates *)

  module Expr = 
  struct
    type t = Level.t * int

    (* Hashing of expressions *)
    module ExprHash = 
    struct
      type t = Level.t * int
      type u = Level.t -&gt; Level.t
      let hashcons hdir (b,n as x) = 
	let b' = hdir b in 
	  if b' == b then x else (b',n)
      let eq l1 l2 =
        l1 == l2 || 
        match l1,l2 with
	| (b,n), (b',n') -&gt; b == b' &amp;&amp; n == n'

      let hash (x, n) = n + Level.hash x

    end

    module H = Hashcons.Make(ExprHash)

    let hcons =
      Hashcons.simple_hcons H.generate H.hcons Level.hcons

    let make l = (l, 0)

    let compare u v =
      if u == v then 0
      else 
	let (x, n) = u and (x', n') = v in
	  if Int.equal n n' then Level.compare x x'
	  else n - n'

    let sprop = hcons (Level.sprop, 0)
    let prop = hcons (Level.prop, 0)
    let set = hcons (Level.set, 0)
    let type1 = hcons (Level.set, 1)

    let is_small = function
      | (l,0) -&gt; Level.is_small l
      | _ -&gt; false

    let equal x y = x == y ||
      (let (u,n) = x and (v,n') = y in
	 Int.equal n n' &amp;&amp; Level.equal u v)

    let hash = ExprHash.hash

    let leq (u,n) (v,n') =
      let cmp = Level.compare u v in
	if Int.equal cmp 0 then n &lt;= n'
	else if n &lt;= n' then 
          (Level.is_prop u &amp;&amp; not (Level.is_sprop v))
	else false

    let successor (u,n) =
      if Level.is_small u then type1
      else (u, n + 1)

    let addn k (u,n as x) = 
      if k = 0 then x 
      else if Level.is_small u then
	(Level.set,n+k)
      else (u,n+k)

    type super_result =
	SuperSame of bool
        (* The level expressions are in cumulativity relation. boolean
           indicates if left is smaller than right?  *)
      | SuperDiff of int
        (* The level expressions are unrelated, the comparison result
           is canonical *)

    (** [super u v] compares two level expressions,
       returning [SuperSame] if they refer to the same level at potentially different
       increments or [SuperDiff] if they are different. The booleans indicate if the
       left expression is &quot;smaller&quot; than the right one in both cases. *)
    let super (u,n) (v,n') =
      let cmp = Level.compare u v in
        if Int.equal cmp 0 then SuperSame (n &lt; n')
	else
          let open RawLevel in
          match Level.data u, n, Level.data v, n' with
          | SProp, _, SProp, _ | Prop, _, Prop, _ -&gt; SuperSame (n &lt; n')
          | SProp, 0, Prop, 0 -&gt; SuperSame true
          | Prop, 0, SProp, 0 -&gt; SuperSame false
          | (SProp | Prop), 0, _, _ -&gt; SuperSame true
          | _, _, (SProp | Prop), 0 -&gt; SuperSame false

          | _, _, _, _ -&gt; SuperDiff cmp

    let to_string (v, n) =
      if Int.equal n 0 then Level.to_string v
      else Level.to_string v ^ &quot;+&quot; ^ string_of_int n

    let pr x = str(to_string x)

    let pr_with f (v, n) = 
      if Int.equal n 0 then f v
      else f v ++ str&quot;+&quot; ++ int n

    let is_level = function
      | (_v, 0) -&gt; true
      | _ -&gt; false

    let level = function
      | (v,0) -&gt; Some v
      | _ -&gt; None
	
    let get_level (v,_n) = v

    let map f (v, n as x) = 
      let v' = f v in 
	if v' == v then x
	else if Level.is_prop v' &amp;&amp; n != 0 then
	  (Level.set, n)
	else (v', n)

  end

  type t = Expr.t list

  let tip l = [l]
  let cons x l = x :: l

  let rec hash = function
  | [] -&gt; 0
  | e :: l -&gt; Hashset.Combine.combinesmall (Expr.ExprHash.hash e) (hash l)

  let equal x y = x == y || List.equal Expr.equal x y

  let compare x y = if x == y then 0 else List.compare Expr.compare x y

  module Huniv = Hashcons.Hlist(Expr)

  let hcons = Hashcons.recursive_hcons Huniv.generate Huniv.hcons Expr.hcons

  let make l = tip (Expr.make l)
  let tip x = tip x

  let pr l = match l with
    | [u] -&gt; Expr.pr u
    | _ -&gt; 
      str &quot;max(&quot; ++ hov 0
	(prlist_with_sep pr_comma Expr.pr l) ++
        str &quot;)&quot;

  let pr_with f l = match l with
    | [u] -&gt; Expr.pr_with f u
    | _ -&gt; 
      str &quot;max(&quot; ++ hov 0
	(prlist_with_sep pr_comma (Expr.pr_with f) l) ++
        str &quot;)&quot;

  let is_level l = match l with
    | [l] -&gt; Expr.is_level l
    | _ -&gt; false

  let rec is_levels l = match l with
    | l :: r -&gt; Expr.is_level l &amp;&amp; is_levels r
    | [] -&gt; true

  let level l = match l with
    | [l] -&gt; Expr.level l
    | _ -&gt; None

  let levels l = 
    List.fold_left (fun acc x -&gt; LSet.add (Expr.get_level x) acc) LSet.empty l

  let is_small u = 
    match u with
    | [l] -&gt; Expr.is_small l
    | _ -&gt; false

  let sprop = tip Expr.sprop

  (* The lower predicative level of the hierarchy that contains (impredicative)
     Prop and singleton inductive types *)
  let type0m = tip Expr.prop

  (* The level of sets *)
  let type0 = tip Expr.set

  (* When typing [Prop] and [Set], there is no constraint on the level,
     hence the definition of [type1_univ], the type of [Prop] *)    
  let type1 = tip Expr.type1

  let is_sprop x = equal sprop x
  let is_type0m x = equal type0m x
  let is_type0 x = equal type0 x

  (* Returns the formal universe that lies just above the universe variable u.
     Used to type the sort u. *)
  let super l = 
    if is_small l then type1
    else
      List.Smart.map (fun x -&gt; Expr.successor x) l

  let addn n l =
    List.Smart.map (fun x -&gt; Expr.addn n x) l

  let rec merge_univs l1 l2 =
    match l1, l2 with
    | [], _ -&gt; l2
    | _, [] -&gt; l1
    | h1 :: t1, h2 :: t2 -&gt;
       let open Expr in
       (match super h1 h2 with
	| SuperSame true (* h1 &lt; h2 *) -&gt; merge_univs t1 l2
	| SuperSame false -&gt; merge_univs l1 t2
	| SuperDiff c -&gt;
           if c &lt;= 0 (* h1 &lt; h2 is name order *)
	   then cons h1 (merge_univs t1 l2)
	   else cons h2 (merge_univs l1 t2))

  let sort u =
    let rec aux a l = 
      match l with
      | b :: l' -&gt;
	let open Expr in
        (match super a b with
	 | SuperSame false -&gt; aux a l'
	 | SuperSame true -&gt; l
	 | SuperDiff c -&gt;
	    if c &lt;= 0 then cons a l
	    else cons b (aux a l'))
      | [] -&gt; cons a l
    in 
      List.fold_right (fun a acc -&gt; aux a acc) u []

  (* Returns the formal universe that is greater than the universes u and v.
     Used to type the products. *)
  let sup x y = merge_univs x y

  let empty = []

  let exists = List.exists

  let for_all = List.for_all

  let smart_map = List.Smart.map

  let map = List.map
end

type universe = Universe.t

(* The level of predicative Set *)
let type0m_univ = Universe.type0m
let type0_univ = Universe.type0
let type1_univ = Universe.type1
let is_type0m_univ = Universe.is_type0m
let is_type0_univ = Universe.is_type0
let is_univ_variable l = Universe.level l != None
let is_small_univ = Universe.is_small
let pr_uni = Universe.pr

let sup = Universe.sup
let super = Universe.super

open Universe

let universe_level = Universe.level


type constraint_type = AcyclicGraph.constraint_type = Lt | Le | Eq

type explanation = (constraint_type * Level.t) list

let constraint_type_ord c1 c2 = match c1, c2 with
| Lt, Lt -&gt; 0
| Lt, _ -&gt; -1
| Le, Lt -&gt; 1
| Le, Le -&gt; 0
| Le, Eq -&gt; -1
| Eq, Eq -&gt; 0
| Eq, _ -&gt; 1

(* Universe inconsistency: error raised when trying to enforce a relation
   that would create a cycle in the graph of universes. *)

type univ_inconsistency = constraint_type * universe * universe * explanation Lazy.t option

exception UniverseInconsistency of univ_inconsistency

let error_inconsistency o u v p =
  raise (UniverseInconsistency (o,make u,make v,p))

(* Constraints and sets of constraints. *)    

type univ_constraint = Level.t * constraint_type * Level.t

let pr_constraint_type op = 
  let op_str = match op with
    | Lt -&gt; &quot; &lt; &quot;
    | Le -&gt; &quot; &lt;= &quot;
    | Eq -&gt; &quot; = &quot;
  in str op_str

module UConstraintOrd =
struct
  type t = univ_constraint
  let compare (u,c,v) (u',c',v') =
    let i = constraint_type_ord c c' in
    if not (Int.equal i 0) then i
    else
      let i' = Level.compare u u' in
      if not (Int.equal i' 0) then i'
      else Level.compare v v'
end

module Constraint = 
struct 
  module S = Set.Make(UConstraintOrd)
  include S

  let pr prl c =
    v 0 (prlist_with_sep spc (fun (u1,op,u2) -&gt;
      hov 0 (prl u1 ++ pr_constraint_type op ++ prl u2))
       (elements c))

end

let empty_constraint = Constraint.empty
let union_constraint = Constraint.union
let eq_constraint = Constraint.equal

type constraints = Constraint.t

module Hconstraint =
  Hashcons.Make(
    struct
      type t = univ_constraint
      type u = universe_level -&gt; universe_level
      let hashcons hul (l1,k,l2) = (hul l1, k, hul l2)
      let eq (l1,k,l2) (l1',k',l2') =
	l1 == l1' &amp;&amp; k == k' &amp;&amp; l2 == l2'
      let hash = Hashtbl.hash
    end)

module Hconstraints =
  Hashcons.Make(
    struct
      type t = constraints
      type u = univ_constraint -&gt; univ_constraint
      let hashcons huc s =
	Constraint.fold (fun x -&gt; Constraint.add (huc x)) s Constraint.empty
      let eq s s' =
	List.for_all2eq (==)
	  (Constraint.elements s)
	  (Constraint.elements s')
      let hash = Hashtbl.hash
    end)

let hcons_constraint = Hashcons.simple_hcons Hconstraint.generate Hconstraint.hcons Level.hcons
let hcons_constraints = Hashcons.simple_hcons Hconstraints.generate Hconstraints.hcons hcons_constraint


(** A value with universe constraints. *)
type 'a constrained = 'a * constraints

let constraints_of (_, cst) = cst

(** Constraint functions. *)

type 'a constraint_function = 'a -&gt; 'a -&gt; constraints -&gt; constraints

let enforce_eq_level u v c =
  (* We discard trivial constraints like u=u *)
  if Level.equal u v then c 
  else if Level.apart u v then
    error_inconsistency Eq u v None
  else Constraint.add (u,Eq,v) c

let enforce_eq u v c =
  match Universe.level u, Universe.level v with
    | Some u, Some v -&gt; enforce_eq_level u v c
    | _ -&gt; anomaly (Pp.str &quot;A universe comparison can only happen between variables.&quot;)

let check_univ_eq u v = Universe.equal u v

let enforce_eq u v c =
  if check_univ_eq u v then c
  else enforce_eq u v c

let constraint_add_leq v u c =
  (* We just discard trivial constraints like u&lt;=u *)
  if Expr.equal v u then c
  else
    match v, u with
    | (x,n), (y,m) -&gt; 
    let j = m - n in
      if j = -1 (* n = m+1, v+1 &lt;= u &lt;-&gt; v &lt; u *) then
	Constraint.add (x,Lt,y) c
      else if j &lt;= -1 (* n = m+k, v+k &lt;= u &lt;-&gt; v+(k-1) &lt; u *) then
	if Level.equal x y then (* u+(k+1) &lt;= u *)
	  raise (UniverseInconsistency (Le, Universe.tip v, Universe.tip u, None))
	else anomaly (Pp.str&quot;Unable to handle arbitrary u+k &lt;= v constraints.&quot;)
      else if j = 0 then
	Constraint.add (x,Le,y) c
      else (* j &gt;= 1 *) (* m = n + k, u &lt;= v+k *)
	if Level.equal x y then c (* u &lt;= u+k, trivial *)
	else if Level.is_small x then c (* Prop,Set &lt;= u+S k, trivial *)
        else Constraint.add (x,Le,y) c (* u &lt;= v implies u &lt;= v+k *)
	  
let check_univ_leq_one u v = Universe.exists (Expr.leq u) v

let check_univ_leq u v = 
  Universe.for_all (fun u -&gt; check_univ_leq_one u v) u

let enforce_leq u v c =
  match is_sprop u, is_sprop v with
  | true, true -&gt; c
  | true, false | false, true -&gt;
    raise (UniverseInconsistency (Le, u, v, None))
  | false, false -&gt;
    List.fold_left (fun c v -&gt; (List.fold_left (fun c u -&gt; constraint_add_leq u v c) c u)) c v

let enforce_leq u v c =
  if check_univ_leq u v then c
  else enforce_leq u v c

let enforce_leq_level u v c =
  if Level.equal u v then c else Constraint.add (u,Le,v) c

(* Miscellaneous functions to remove or test local univ assumed to
   occur in a universe *)

let univ_level_mem u v =
  List.exists (fun (l, n) -&gt; Int.equal n 0 &amp;&amp; Level.equal u l) v

let univ_level_rem u v min = 
  match Universe.level v with
  | Some u' -&gt; if Level.equal u u' then min else v
  | None -&gt; List.filter (fun (l, n) -&gt; not (Int.equal n 0 &amp;&amp; Level.equal u l)) v

(* Is u mentioned in v (or equals to v) ? *)


(**********************************************************************)
(** Universe polymorphism                                             *)
(**********************************************************************)

(** A universe level substitution, note that no algebraic universes are
    involved *)

type universe_level_subst = universe_level universe_map

(** A full substitution might involve algebraic universes *)
type universe_subst = universe universe_map

module Variance =
struct
  (** A universe position in the instance given to a cumulative
     inductive can be the following. Note there is no Contravariant
     case because [forall x : A, B &lt;= forall x : A', B'] requires [A =
     A'] as opposed to [A' &lt;= A]. *)
  type t = Irrelevant | Covariant | Invariant

  let sup x y =
    match x, y with
    | Irrelevant, s | s, Irrelevant -&gt; s
    | Invariant, _ | _, Invariant -&gt; Invariant
    | Covariant, Covariant -&gt; Covariant

  let check_subtype x y = match x, y with
  | (Irrelevant | Covariant | Invariant), Irrelevant -&gt; true
  | Irrelevant, Covariant -&gt; false
  | (Covariant | Invariant), Covariant -&gt; true
  | (Irrelevant | Covariant), Invariant -&gt; false
  | Invariant, Invariant -&gt; true

  let pr = function
    | Irrelevant -&gt; str &quot;*&quot;
    | Covariant -&gt; str &quot;+&quot;
    | Invariant -&gt; str &quot;=&quot;

  let leq_constraint csts variance u u' =
    match variance with
    | Irrelevant -&gt; csts
    | Covariant -&gt; enforce_leq_level u u' csts
    | Invariant -&gt; enforce_eq_level u u' csts

  let eq_constraint csts variance u u' =
    match variance with
    | Irrelevant -&gt; csts
    | Covariant | Invariant -&gt; enforce_eq_level u u' csts

  let leq_constraints variance u u' csts =
    let len = Array.length u in
    assert (len = Array.length u' &amp;&amp; len = Array.length variance);
    Array.fold_left3 leq_constraint csts variance u u'

  let eq_constraints variance u u' csts =
    let len = Array.length u in
    assert (len = Array.length u' &amp;&amp; len = Array.length variance);
    Array.fold_left3 eq_constraint csts variance u u'
end

module Instance : sig
    type t = Level.t array

    val empty : t
    val is_empty : t -&gt; bool
      
    val of_array : Level.t array -&gt; t
    val to_array : t -&gt; Level.t array

    val append : t -&gt; t -&gt; t
    val equal : t -&gt; t -&gt; bool
    val length : t -&gt; int

    val hcons : t -&gt; t
    val hash : t -&gt; int

    val share : t -&gt; t * int

    val subst_fn : universe_level_subst_fn -&gt; t -&gt; t
    
    val pr : (Level.t -&gt; Pp.t) -&gt; ?variance:Variance.t array -&gt; t -&gt; Pp.t
    val levels : t -&gt; LSet.t
end = 
struct
  type t = Level.t array

  let empty : t = [||]

  module HInstancestruct =
  struct
    type nonrec t = t
    type u = Level.t -&gt; Level.t

    let hashcons huniv a = 
      let len = Array.length a in
	if Int.equal len 0 then empty
	else begin
	  for i = 0 to len - 1 do
	    let x = Array.unsafe_get a i in
	    let x' = huniv x in
	      if x == x' then ()
	      else Array.unsafe_set a i x'
	  done;
	  a
	end

    let eq t1 t2 =
      t1 == t2 ||
	(Int.equal (Array.length t1) (Array.length t2) &amp;&amp;
	   let rec aux i =
	     (Int.equal i (Array.length t1)) || (t1.(i) == t2.(i) &amp;&amp; aux (i + 1))
	   in aux 0)
	
    let hash a = 
      let accu = ref 0 in
	for i = 0 to Array.length a - 1 do
	  let l = Array.unsafe_get a i in
	  let h = Level.hash l in
	    accu := Hashset.Combine.combine !accu h;
	done;
	(* [h] must be positive. *)
	let h = !accu land 0x3FFFFFFF in
	  h
  end

  module HInstance = Hashcons.Make(HInstancestruct)

  let hcons = Hashcons.simple_hcons HInstance.generate HInstance.hcons Level.hcons
    
  let hash = HInstancestruct.hash
    
  let share a = (hcons a, hash a)
	      
  let empty = hcons [||]

  let is_empty x = Int.equal (Array.length x) 0

  let append x y =
    if Array.length x = 0 then y
    else if Array.length y = 0 then x 
    else Array.append x y

  let of_array a =
    assert(Array.for_all (fun x -&gt; not (Level.is_prop x || Level.is_sprop x)) a);
    a

  let to_array a = a

  let length a = Array.length a

  let subst_fn fn t = 
    let t' = CArray.Smart.map fn t in
      if t' == t then t else of_array t'

  let levels x = LSet.of_array x

  let pr prl ?variance =
    let ppu i u =
      let v = Option.map (fun v -&gt; v.(i)) variance in
      pr_opt_no_spc Variance.pr v ++ prl u
    in
    prvecti_with_sep spc ppu

  let equal t u = 
    t == u ||
      (Array.is_empty t &amp;&amp; Array.is_empty u) ||
      (CArray.for_all2 Level.equal t u 
	 (* Necessary as universe instances might come from different modules and 
	    unmarshalling doesn't preserve sharing *))

end

let enforce_eq_instances x y = 
  let ax = Instance.to_array x and ay = Instance.to_array y in
    if Array.length ax != Array.length ay then
      anomaly (Pp.(++) (Pp.str &quot;Invalid argument: enforce_eq_instances called with&quot;)
		 (Pp.str &quot; instances of different lengths.&quot;));
    CArray.fold_right2 enforce_eq_level ax ay

let enforce_eq_variance_instances = Variance.eq_constraints
let enforce_leq_variance_instances = Variance.leq_constraints

let subst_instance_level s l =
  match l.Level.data with
  | Level.Var n -&gt; s.(n) 
  | _ -&gt; l

let subst_instance_instance s i = 
  Array.Smart.map (fun l -&gt; subst_instance_level s l) i

let subst_instance_universe s u =
  let f x = Universe.Expr.map (fun u -&gt; subst_instance_level s u) x in
  let u' = Universe.smart_map f u in
    if u == u' then u
    else Universe.sort u'

let subst_instance_constraint s (u,d,v as c) =
  let u' = subst_instance_level s u in
  let v' = subst_instance_level s v in
    if u' == u &amp;&amp; v' == v then c
    else (u',d,v')

let subst_instance_constraints s csts =
  Constraint.fold 
    (fun c csts -&gt; Constraint.add (subst_instance_constraint s c) csts)
    csts Constraint.empty 

type 'a puniverses = 'a * Instance.t
let out_punivs (x, _y) = x
let in_punivs x = (x, Instance.empty)
let eq_puniverses f (x, u) (y, u') =
  f x y &amp;&amp; Instance.equal u u'

(** A context of universe levels with universe constraints,
    representing local universe variables and constraints *)

module UContext =
struct
  type t = Instance.t constrained

  let make x = x

  (** Universe contexts (variables as a list) *)
  let empty = (Instance.empty, Constraint.empty)
  let is_empty (univs, cst) = Instance.is_empty univs &amp;&amp; Constraint.is_empty cst

  let pr prl ?variance (univs, cst as ctx) =
    if is_empty ctx then mt() else
      h 0 (Instance.pr prl ?variance univs ++ str &quot; |= &quot;) ++ h 0 (v 0 (Constraint.pr prl cst))

  let hcons (univs, cst) =
    (Instance.hcons univs, hcons_constraints cst)

  let instance (univs, _cst) = univs
  let constraints (_univs, cst) = cst

  let union (univs, cst) (univs', cst') =
    Instance.append univs univs', Constraint.union cst cst'

  let dest x = x

  let size (x,_) = Instance.length x

end

type universe_context = UContext.t
let hcons_universe_context = UContext.hcons

module AUContext =
struct
  type t = Names.Name.t array constrained

  let repr (inst, cst) =
    (Array.init (Array.length inst) (fun i -&gt; Level.var i), cst)

  let pr f ?variance ctx = UContext.pr f ?variance (repr ctx)

  let instantiate inst (u, cst) =
    assert (Array.length u = Array.length inst);
    subst_instance_constraints inst cst

  let names (nas, _) = nas

  let hcons (univs, cst) =
    (Array.map Names.Name.hcons univs, hcons_constraints cst)

  let empty = ([||], Constraint.empty)

  let is_empty (nas, cst) = Array.is_empty nas &amp;&amp; Constraint.is_empty cst

  let union (nas, cst) (nas', cst') = (Array.append nas nas', Constraint.union cst cst')

  let size (nas, _) = Array.length nas

end

type 'a univ_abstracted = {
  univ_abstracted_value : 'a;
  univ_abstracted_binder : AUContext.t;
}

let map_univ_abstracted f {univ_abstracted_value;univ_abstracted_binder} =
  let univ_abstracted_value = f univ_abstracted_value in
  {univ_abstracted_value;univ_abstracted_binder}

let hcons_abstract_universe_context = AUContext.hcons

(** A set of universes with universe constraints.
    We linearize the set to a list after typechecking. 
    Beware, representation could change.
*)

module ContextSet =
struct
  type t = universe_set constrained

  let empty = (LSet.empty, Constraint.empty)
  let is_empty (univs, cst) = LSet.is_empty univs &amp;&amp; Constraint.is_empty cst

  let equal (univs, cst as x) (univs', cst' as y) =
    x == y || (LSet.equal univs univs' &amp;&amp; Constraint.equal cst cst')
									
  let of_set s = (s, Constraint.empty)
  let singleton l = of_set (LSet.singleton l)
  let of_instance i = of_set (Instance.levels i)

  let union (univs, cst as x) (univs', cst' as y) =
    if x == y then x
    else LSet.union univs univs', Constraint.union cst cst'

  let append (univs, cst) (univs', cst') =
    let univs = LSet.fold LSet.add univs univs' in
    let cst = Constraint.fold Constraint.add cst cst' in
    (univs, cst)

  let diff (univs, cst) (univs', cst') =
    LSet.diff univs univs', Constraint.diff cst cst'

  let add_universe u (univs, cst) =
    LSet.add u univs, cst

  let add_constraints cst' (univs, cst) =
    univs, Constraint.union cst cst'

  let add_instance inst (univs, cst) =
    let v = Instance.to_array inst in
    let fold accu u = LSet.add u accu in
    let univs = Array.fold_left fold univs v in
    (univs, cst)

  let sort_levels a = 
    Array.sort Level.compare a; a

  let to_context (ctx, cst) =
    (Instance.of_array (sort_levels (Array.of_list (LSet.elements ctx))), cst)

  let of_context (ctx, cst) =
    (Instance.levels ctx, cst)

  let pr prl (univs, cst as ctx) =
    if is_empty ctx then mt() else
      h 0 (LSet.pr prl univs ++ str &quot; |= &quot;) ++ h 0 (v 0 (Constraint.pr prl cst))

  let constraints (_univs, cst) = cst
  let levels (univs, _cst) = univs

  let size (univs,_) = LSet.cardinal univs
end

type universe_context_set = ContextSet.t

(** A value in a universe context (resp. context set). *)
type 'a in_universe_context = 'a * universe_context
type 'a in_universe_context_set = 'a * universe_context_set

let extend_in_context_set (a, ctx) ctx' =
  (a, ContextSet.union ctx ctx')

(** Substitutions. *)

let empty_subst = LMap.empty
let is_empty_subst = LMap.is_empty

let empty_level_subst = LMap.empty
let is_empty_level_subst = LMap.is_empty

(** Substitution functions *)

(** With level to level substitutions. *)
let subst_univs_level_level subst l =
  try LMap.find l subst
  with Not_found -&gt; l

let subst_univs_level_universe subst u =
  let f x = Universe.Expr.map (fun u -&gt; subst_univs_level_level subst u) x in
  let u' = Universe.smart_map f u in
    if u == u' then u
    else Universe.sort u'

let subst_univs_level_instance subst i =
  let i' = Instance.subst_fn (subst_univs_level_level subst) i in
    if i == i' then i
    else i'
	
let subst_univs_level_constraint subst (u,d,v) =
  let u' = subst_univs_level_level subst u 
  and v' = subst_univs_level_level subst v in
    if d != Lt &amp;&amp; Level.equal u' v' then None
    else Some (u',d,v')

let subst_univs_level_constraints subst csts =
  Constraint.fold 
    (fun c -&gt; Option.fold_right Constraint.add (subst_univs_level_constraint subst c))
    csts Constraint.empty 

let subst_univs_level_abstract_universe_context subst (inst, csts) =
  inst, subst_univs_level_constraints subst csts

(** With level to universe substitutions. *)
type universe_subst_fn = universe_level -&gt; universe

let make_subst subst = fun l -&gt; LMap.find l subst

let subst_univs_expr_opt fn (l,n) =
  Universe.addn n (fn l)

let subst_univs_universe fn ul =
  let subst, nosubst = 
    List.fold_right (fun u (subst,nosubst) -&gt; 
      try let a' = subst_univs_expr_opt fn u in
	    (a' :: subst, nosubst)
      with Not_found -&gt; (subst, u :: nosubst))
      ul ([], [])
  in 
    if CList.is_empty subst then ul
    else 
      let substs = 
	List.fold_left Universe.merge_univs Universe.empty subst
      in
	List.fold_left (fun acc u -&gt; Universe.merge_univs acc (Universe.tip u))
	  substs nosubst

let make_instance_subst i = 
  let arr = Instance.to_array i in
    Array.fold_left_i (fun i acc l -&gt;
      LMap.add l (Level.var i) acc)
      LMap.empty arr

let make_inverse_instance_subst i = 
  let arr = Instance.to_array i in
    Array.fold_left_i (fun i acc l -&gt;
      LMap.add (Level.var i) l acc)
      LMap.empty arr

let make_abstract_instance (ctx, _) = 
  Array.init (Array.length ctx) (fun i -&gt; Level.var i)

let abstract_universes nas ctx =
  let instance = UContext.instance ctx in
  let () = assert (Int.equal (Array.length nas) (Instance.length instance)) in
  let subst = make_instance_subst instance in
  let cstrs = subst_univs_level_constraints subst 
      (UContext.constraints ctx)
  in
  let ctx = (nas, cstrs) in
  instance, ctx

let rec compact_univ s vars i u =
  match u with
  | [] -&gt; (s, List.rev vars)
  | (lvl, _) :: u -&gt;
    match Level.var_index lvl with
    | Some k when not (LMap.mem lvl s) -&gt;
      let lvl' = Level.var i in
      compact_univ (LMap.add lvl lvl' s) (k :: vars) (i+1) u
    | _ -&gt; compact_univ s vars i u

let compact_univ u =
  let (s, s') = compact_univ LMap.empty [] 0 u in
  (subst_univs_level_universe s u, s')

(** Pretty-printing *)

let pr_constraints prl = Constraint.pr prl

let pr_universe_context = UContext.pr

let pr_abstract_universe_context = AUContext.pr

let pr_universe_context_set = ContextSet.pr

let pr_universe_subst = 
  LMap.pr (fun u -&gt; str&quot; := &quot; ++ Universe.pr u ++ spc ())

let pr_universe_level_subst = 
  LMap.pr (fun u -&gt; str&quot; := &quot; ++ Level.pr u ++ spc ())

module Huniverse_set = 
  Hashcons.Make(
    struct
      type t = universe_set
      type u = universe_level -&gt; universe_level
      let hashcons huc s =
	LSet.fold (fun x -&gt; LSet.add (huc x)) s LSet.empty
      let eq s s' =
	LSet.equal s s'
      let hash = Hashtbl.hash
    end)

let hcons_universe_set = 
  Hashcons.simple_hcons Huniverse_set.generate Huniverse_set.hcons Level.hcons

let hcons_universe_context_set (v, c) = 
  (hcons_universe_set v, hcons_constraints c)

let hcons_univ x = Universe.hcons x

let explain_universe_inconsistency prl (o,u,v,p : univ_inconsistency) =
  let pr_uni = Universe.pr_with prl in
  let pr_rel = function
    | Eq -&gt; str&quot;=&quot; | Lt -&gt; str&quot;&lt;&quot; | Le -&gt; str&quot;&lt;=&quot; 
  in
  let reason = match p with
    | None -&gt; mt()
    | Some p -&gt;
      let p = Lazy.force p in
      if p = [] then mt ()
      else
        str &quot; because&quot; ++ spc() ++ pr_uni v ++
        prlist (fun (r,v) -&gt; spc() ++ pr_rel r ++ str&quot; &quot; ++ prl v)
          p ++
        (if Universe.equal (Universe.make (snd (List.last p))) u then mt() else
           (spc() ++ str &quot;= &quot; ++ pr_uni u))
  in
    str &quot;Cannot enforce&quot; ++ spc() ++ pr_uni u ++ spc() ++
      pr_rel o ++ spc() ++ pr_uni v ++ reason
</pre>
          </div>
          <div class="col-md-6">
            <code>univ.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Pp.

Import CErrors.

Import Util.

Module RawLevel.
  Import Names.
  
  Module UGlobal.
    Definition t := Names.DirPath.t * Z.
    
    Definition make {A : Type} (dp : Names.DirPath.t) (i : A)
      : Names.DirPath.t * A := ((Names.DirPath.hcons dp), i).
    
    Definition equal (function_parameter : Names.DirPath.t * Int.t)
      : (Names.DirPath.t * Int.t) -&gt; bool :=
      match function_parameter with
      | (d, i) =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | (d', i') =&gt; andb (Names.DirPath.equal d d') (Int.equal i i')
          end
      end.
    
    Definition hash (function_parameter : Names.DirPath.t * Z) : Z :=
      match function_parameter with
      | (d, i) =&gt; Hashset.Combine.combine i (Names.DirPath.hash d)
      end.
    
    Definition compare (function_parameter : Names.DirPath.t * Int.t)
      : (Names.DirPath.t * Int.t) -&gt; Z :=
      match function_parameter with
      | (d, i) =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | (d', i') =&gt;
            let c := Int.compare i i' in
            if Int.equal c 0 then
              Names.DirPath.compare d d'
            else
              c
          end
      end.
  End UGlobal.
  
  Inductive t : Type :=
  | SProp : t
  | Prop : t
  | Set : t
  | Level : UGlobal.t -&gt; t
  | Var : Z -&gt; t.
  
  Definition equal (x : t) (y : t) : bool :=
    orb (Stdlib.op_eq_eq x y)
      match (x, y) with
      | (SProp, SProp) =&gt; true
      | (Prop, Prop) =&gt; true
      | (Set, Set) =&gt; true
      | (Level l, Level l') =&gt; UGlobal.equal l l'
      | (Var n, Var n') =&gt; Int.equal n n'
      | _ =&gt; false
      end.
  
  Definition compare (u : t) (v : t) : Z :=
    match (u, v) with
    | (SProp, SProp) =&gt; 0
    | (SProp, _) =&gt; (-1)
    | (_, SProp) =&gt; 1
    | (Prop, Prop) =&gt; 0
    | (Prop, _) =&gt; (-1)
    | (_, Prop) =&gt; 1
    | (Set, Set) =&gt; 0
    | (Set, _) =&gt; (-1)
    | (_, Set) =&gt; 1
    | (Level (dp1, i1), Level (dp2, i2)) =&gt;
      if OCaml.Stdlib.lt i1 i2 then
        (-1)
      else
        if OCaml.Stdlib.gt i1 i2 then
          1
        else
          Names.DirPath.compare dp1 dp2
    | (Level _, _) =&gt; (-1)
    | (_, Level _) =&gt; 1
    | (Var n, Var m) =&gt; Int.compare n m
    end.
  
  Definition hequal (x : t) (y : t) : bool :=
    orb (Stdlib.op_eq_eq x y)
      match (x, y) with
      | (SProp, SProp) =&gt; true
      | (Prop, Prop) =&gt; true
      | (Set, Set) =&gt; true
      | (Level (n, d), Level (n', d')) =&gt;
        andb (Stdlib.op_eq_eq n n') (Stdlib.op_eq_eq d d')
      | (Var n, Var n') =&gt; Stdlib.op_eq_eq n n'
      | _ =&gt; false
      end.
  
  Definition hcons (function_parameter : t) : t :=
    match function_parameter with
    | SProp as x =&gt; x
    | Prop as x =&gt; x
    | Set as x =&gt; x
    | (Level (d, n)) as x =&gt;
      let d' := Names.DirPath.hcons d in
      if Stdlib.op_eq_eq d' d then
        x
      else
        Level (d', n)
    | (Var _n) as x =&gt; x
    end.
  
  Import Hashset.Combine.
  
  Definition hash (function_parameter : t) : Z :=
    match function_parameter with
    | SProp =&gt; Hashset.Combine.combinesmall 1 0
    | Prop =&gt; Hashset.Combine.combinesmall 1 1
    | Set =&gt; Hashset.Combine.combinesmall 1 2
    | Var n =&gt; Hashset.Combine.combinesmall 2 n
    | Level (d, n) =&gt;
      Hashset.Combine.combinesmall 3
        (Hashset.Combine.combine n (Names.DirPath.hash d))
    end.
End RawLevel.

Module Level.
  Inductive raw_level : Type :=
  | SProp : raw_level
  | Prop : raw_level
  | Set : raw_level
  | Level : UGlobal.t -&gt; raw_level
  | Var : Z -&gt; raw_level.
  
  Record t := {
    hash : Z;
    data : RawLevel.t }.
  
  Definition equal (x : t) (y : t) : bool :=
    orb (Stdlib.op_eq_eq x y)
      (andb (Int.equal (hash x) (hash y)) (RawLevel.equal (data x) (data y))).
  
  Definition hash (x : t) : Z := hash x.
  
  Definition data (x : t) : RawLevel.t := data x.
  
  Module Self.
    Definition t := t.
    
    Definition u := unit.
    
    Definition eq (x : t) (y : t) : bool :=
      andb (Stdlib.op_eq_eq (hash x) (hash y))
        (RawLevel.hequal (data x) (data y)).
    
    Definition hash (x : t) : Z := hash x.
    
    Definition hashcons (function_parameter : unit) : t -&gt; t :=
      match function_parameter with
      | tt =&gt;
        fun x =&gt;
          let data' := RawLevel.hcons (data x) in
          if Stdlib.op_eq_eq (data x) data' then
            x
          else
            record
      end.
  End Self.
  
  Definition hcons : Self.t -&gt; Self.t :=
    let H := unsupported_functor_application in
    Hashcons.simple_hcons H.(Hashcons.S.generate) H.(Hashcons.S.hcons) tt.
  
  Definition make (l : RawLevel.t) : Self.(Hashcons.HashconsedType.t) :=
    hcons {| hash := RawLevel.hash l; data := l |}.
  
  Definition set : Self.(Hashcons.HashconsedType.t) := make Set.
  
  Definition prop : Self.(Hashcons.HashconsedType.t) := make Prop.
  
  Definition sprop : Self.(Hashcons.HashconsedType.t) := make SProp.
  
  Definition is_small (x : t) : bool :=
    match data x with
    | Level _ =&gt; false
    | Var _ =&gt; false
    | SProp =&gt; true
    | Prop =&gt; true
    | Set =&gt; true
    end.
  
  Definition is_prop (x : t) : bool :=
    match data x with
    | Prop =&gt; true
    | _ =&gt; false
    end.
  
  Definition is_set (x : t) : bool :=
    match data x with
    | Set =&gt; true
    | _ =&gt; false
    end.
  
  Definition is_sprop (x : t) : bool :=
    match data x with
    | SProp =&gt; true
    | _ =&gt; false
    end.
  
  Definition compare (u : t) (v : t) : Z :=
    if Stdlib.op_eq_eq u v then
      0
    else
      RawLevel.compare (data u) (data v).
  
  Definition to_string (x : t) : string :=
    match data x with
    | SProp =&gt; &quot;SProp&quot; % string
    | Prop =&gt; &quot;Prop&quot; % string
    | Set =&gt; &quot;Set&quot; % string
    | Level (d, n) =&gt;
      String.append (Names.DirPath.to_string d)
        (String.append &quot;.&quot; % string (OCaml.Stdlib.string_of_int n))
    | Var n =&gt;
      String.append &quot;Var(&quot; % string
        (String.append (OCaml.Stdlib.string_of_int n) &quot;)&quot; % string)
    end.
  
  Definition pr (u : t) : Pp.t := Pp.str (to_string u).
  
  Definition apart (u : t) (v : t) : bool :=
    match ((data u), (data v)) with
    | (SProp, _) | (_, SProp) | (Prop, Set) | (Set, Prop) =&gt; true
    | _ =&gt; false
    end.
  
  Definition vars : array Self.(Hashcons.HashconsedType.t) :=
    Util.Array.(CArray.ExtS.init) 20 (fun i =&gt; make (Var i)).
  
  Definition var (n : Z) : Self.(Hashcons.HashconsedType.t) :=
    if OCaml.Stdlib.lt n 20 then
      Util.Array.(CArray.ExtS.get) vars n
    else
      make (Var n).
  
  Definition var_index (u : t) : option Z :=
    match data u with
    | Var n =&gt; Some n
    | _ =&gt; None
    end.
  
  Definition make (qid : UGlobal.t) : Self.(Hashcons.HashconsedType.t) :=
    make (Level qid).
  
  Definition name (u : t) : option (Names.DirPath.t * Z) :=
    match data u with
    | Level (d, n) =&gt; Some (d, n)
    | _ =&gt; None
    end.
End Level.

Module LMap.
  Definition lunion {A : Type} (l : t A) (r : t A) : t A :=
    union (fun _k =&gt; fun l =&gt; fun _r =&gt; Some l) l r.
  
  Definition subst_union {A : Type} (l : t (option A)) (r : t (option A))
    : t (option A) :=
    union
      (fun _k =&gt;
        fun l =&gt;
          fun r =&gt;
            match (l, r) with
            | (Some _, _) =&gt; Some l
            | (None, None) =&gt; Some l
            | (_, _) =&gt; Some r
            end) l r.
  
  Definition diff {A B : Type} (ext : t A) (orig : t B) : t A :=
    fold
      (fun u =&gt;
        fun v =&gt;
          fun acc =&gt;
            if mem u orig then
              acc
            else
              add u v acc) ext empty.
  
  Definition pr {A : Type} (f : A -&gt; Pp.t) (m : t A) : Pp.t :=
    Pp.h 0
      (Pp.prlist_with_sep Pp.fnl
        (fun function_parameter =&gt;
          match function_parameter with
          | (u, v) =&gt; Pp.op_plus_plus (Level.pr u) (f v)
          end) (bindings m)).
End LMap.

Module LSet.
  Definition pr (prl : elt -&gt; Pp.t) (s : t) : Pp.t :=
    Pp.op_plus_plus
      (Pp.op_plus_plus (Pp.str &quot;{&quot; % string)
        (Pp.prlist_with_sep Pp.spc prl (elements s))) (Pp.str &quot;}&quot; % string).
  
  Definition of_array (l : array elt) : t :=
    Util.Array.(CArray.ExtS.fold_left) (fun acc =&gt; fun x =&gt; add x acc) empty l.
End LSet.

Definition universe_map (a : Type) := LMap.t a.

Definition universe_level := Level.t.

Definition universe_level_subst_fn := universe_level -&gt; universe_level.

Definition universe_set := LSet.t.

Module Universe.
  Module Expr.
    Definition t := Level.t * Z.
    
    Module ExprHash.
      Definition t := Level.t * Z.
      
      Definition u := Level.t -&gt; Level.t.
      
      Definition hashcons {A B : Type}
        (hdir : A -&gt; A) (function_parameter : A * B) : A * B :=
        match function_parameter with
        | (b, n) as x =&gt;
          let b' := hdir b in
          if Stdlib.op_eq_eq b' b then
            x
          else
            (b', n)
        end.
      
      Definition eq {A B : Type} (l1 : A * B) (l2 : A * B) : bool :=
        orb (Stdlib.op_eq_eq l1 l2)
          match (l1, l2) with
          | ((b, n), (b', n')) =&gt;
            andb (Stdlib.op_eq_eq b b') (Stdlib.op_eq_eq n n')
          end.
      
      Definition hash (function_parameter : Level.t * Z) : Z :=
        match function_parameter with
        | (x, n) =&gt; Util.op_plus n (Level.hash x)
        end.
    End ExprHash.
    
    Definition hcons : H.(Hashcons.S.t) -&gt; H.(Hashcons.S.t) :=
      Hashcons.simple_hcons H.(Hashcons.S.generate) H.(Hashcons.S.hcons)
        Level.hcons.
    
    Definition make {A : Type} (l : A) : A * Z := (l, 0).
    
    Definition compare (u : Level.t * Int.t) (v : Level.t * Int.t) : Z :=
      if Stdlib.op_eq_eq u v then
        0
      else
        in
        if Int.equal n n' then
          Level.compare x x'
        else
          Util.op_minus n n'.
    
    Definition sprop : H.(Hashcons.S.t) := hcons (Level.sprop, 0).
    
    Definition prop : H.(Hashcons.S.t) := hcons (Level.prop, 0).
    
    Definition set : H.(Hashcons.S.t) := hcons (Level.set, 0).
    
    Definition type1 : H.(Hashcons.S.t) := hcons (Level.set, 1).
    
    Definition is_small (function_parameter : Level.t * Z) : bool :=
      match function_parameter with
      | (l, 0) =&gt; Level.is_small l
      | _ =&gt; false
      end.
    
    Definition equal (x : Level.t * Int.t) (y : Level.t * Int.t) : bool :=
      orb (Stdlib.op_eq_eq x y)
        ( in
        andb (Int.equal n n') (Level.equal u v)).
    
    Definition hash : (Level.t * Z) -&gt; Z :=
      ExprHash.(Hashcons.HashconsedType.hash).
    
    Definition leq {A : Type} (function_parameter : Level.t * A)
      : (Level.t * A) -&gt; bool :=
      match function_parameter with
      | (u, n) =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | (v, n') =&gt;
            let cmp := Level.compare u v in
            if Int.equal cmp 0 then
              OCaml.Stdlib.le n n'
            else
              if OCaml.Stdlib.le n n' then
                andb (Level.is_prop u) (negb (Level.is_sprop v))
              else
                false
          end
      end.
    
    Definition successor (function_parameter : Level.t * Z)
      : H.(Hashcons.S.t) :=
      match function_parameter with
      | (u, n) =&gt;
        if Level.is_small u then
          type1
        else
          (u, (Util.op_plus n 1))
      end.
    
    Definition addn
      (k : Z) (function_parameter : Level.Self.(Hashcons.HashconsedType.t) * Z)
      : Level.Self.(Hashcons.HashconsedType.t) * Z :=
      match function_parameter with
      | (u, n) as x =&gt;
        if equiv_decb k 0 then
          x
        else
          if Level.is_small u then
            (Level.set, (Util.op_plus n k))
          else
            (u, (Util.op_plus n k))
      end.
    
    Inductive super_result : Type :=
    | SuperSame : bool -&gt; super_result
    | SuperDiff : Z -&gt; super_result.
    
    Definition super (function_parameter : Level.t * Z)
      : (Level.t * Z) -&gt; super_result :=
      match function_parameter with
      | (u, n) =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | (v, n') =&gt;
            let cmp := Level.compare u v in
            if Int.equal cmp 0 then
              SuperSame (OCaml.Stdlib.lt n n')
            else
              match ((Level.data u), n, (Level.data v), n') with
              | (SProp, _, SProp, _) | (Prop, _, Prop, _) =&gt;
                SuperSame (OCaml.Stdlib.lt n n')
              | (SProp, 0, Prop, 0) =&gt; SuperSame true
              | (Prop, 0, SProp, 0) =&gt; SuperSame false
              | (SProp | Prop, 0, _, _) =&gt; SuperSame true
              | (_, _, SProp | Prop, 0) =&gt; SuperSame false
              | (_, _, _, _) =&gt; SuperDiff cmp
              end
          end
      end.
    
    Definition to_string (function_parameter : Level.t * Int.t) : string :=
      match function_parameter with
      | (v, n) =&gt;
        if Int.equal n 0 then
          Level.to_string v
        else
          String.append (Level.to_string v)
            (String.append &quot;+&quot; % string (OCaml.Stdlib.string_of_int n))
      end.
    
    Definition pr (x : Level.t * Int.t) : Pp.t := Pp.str (to_string x).
    
    Definition pr_with {A : Type}
      (f : A -&gt; Pp.t) (function_parameter : A * Int.t) : Pp.t :=
      match function_parameter with
      | (v, n) =&gt;
        if Int.equal n 0 then
          f v
        else
          Pp.op_plus_plus (Pp.op_plus_plus (f v) (Pp.str &quot;+&quot; % string))
            (Pp.int n)
      end.
    
    Definition is_level {A : Type} (function_parameter : A * Z) : bool :=
      match function_parameter with
      | (_v, 0) =&gt; true
      | _ =&gt; false
      end.
    
    Definition level {A : Type} (function_parameter : A * Z) : option A :=
      match function_parameter with
      | (v, 0) =&gt; Some v
      | _ =&gt; None
      end.
    
    Definition get_level {A B : Type} (function_parameter : A * B) : A :=
      match function_parameter with
      | (v, _n) =&gt; v
      end.
    
    Definition map
      (f :
        Level.Self.(Hashcons.HashconsedType.t) -&gt;
          Level.Self.(Hashcons.HashconsedType.t))
      (function_parameter : Level.Self.(Hashcons.HashconsedType.t) * Z)
      : Level.Self.(Hashcons.HashconsedType.t) * Z :=
      match function_parameter with
      | (v, n) as x =&gt;
        let v' := f v in
        if Stdlib.op_eq_eq v' v then
          x
        else
          if andb (Level.is_prop v') (Stdlib.op_exclamation_eq n 0) then
            (Level.set, n)
          else
            (v', n)
      end.
  End Expr.
  
  Definition t := list Expr.t.
  
  Definition tip {A : Type} (l : A) : list A := cons l [].
  
  Definition cons {A : Type} (x : A) (l : list A) : list A := cons x l.
  
  Fixpoint hash (function_parameter : list (Level.t * Z)) : Z :=
    match function_parameter with
    | [] =&gt; 0
    | cons e l =&gt;
      Hashset.Combine.combinesmall
        (Expr.ExprHash.(Hashcons.HashconsedType.hash) e) (hash l)
    end.
  
  Definition equal (x : list (Level.t * Int.t)) (y : list (Level.t * Int.t))
    : bool :=
    orb (Stdlib.op_eq_eq x y) (Util.List.(CList.ExtS.equal) Expr.equal x y).
  
  Definition compare (x : list (Level.t * Int.t)) (y : list (Level.t * Int.t))
    : Z :=
    if Stdlib.op_eq_eq x y then
      0
    else
      Util.List.(CList.ExtS.compare) Expr.compare x y.
  
  Definition hcons : Huniv.(Hashcons.S.t) -&gt; Huniv.(Hashcons.S.t) :=
    Hashcons.recursive_hcons Huniv.(Hashcons.S.generate)
      Huniv.(Hashcons.S.hcons) Expr.hcons.
  
  Definition make {A : Type} (l : A) : list (A * Z) := tip (Expr.make l).
  
  Definition tip {A : Type} (x : A) : list A := tip x.
  
  Definition pr (l : list (Level.t * Int.t)) : Pp.t :=
    match l with
    | cons u [] =&gt; Expr.pr u
    | _ =&gt;
      Pp.op_plus_plus
        (Pp.op_plus_plus (Pp.str &quot;max(&quot; % string)
          (Pp.hov 0 (Pp.prlist_with_sep Pp.pr_comma Expr.pr l)))
        (Pp.str &quot;)&quot; % string)
    end.
  
  Definition pr_with {A : Type} (f : A -&gt; Pp.t) (l : list (A * Int.t)) : Pp.t :=
    match l with
    | cons u [] =&gt; Expr.pr_with f u
    | _ =&gt;
      Pp.op_plus_plus
        (Pp.op_plus_plus (Pp.str &quot;max(&quot; % string)
          (Pp.hov 0 (Pp.prlist_with_sep Pp.pr_comma (Expr.pr_with f) l)))
        (Pp.str &quot;)&quot; % string)
    end.
  
  Definition is_level {A : Type} (l : list (A * Z)) : bool :=
    match l with
    | cons l [] =&gt; Expr.is_level l
    | _ =&gt; false
    end.
  
  Fixpoint is_levels {A : Type} (l : list (A * Z)) : bool :=
    match l with
    | cons l r =&gt; andb (Expr.is_level l) (is_levels r)
    | [] =&gt; true
    end.
  
  Definition level {A : Type} (l : list (A * Z)) : option A :=
    match l with
    | cons l [] =&gt; Expr.level l
    | _ =&gt; None
    end.
  
  Definition levels {A : Type} (l : list (LSet.elt * A)) : LSet.t :=
    Util.List.(CList.ExtS.fold_left)
      (fun acc =&gt; fun x =&gt; LSet.add (Expr.get_level x) acc) LSet.empty l.
  
  Definition is_small (u : list (Level.t * Z)) : bool :=
    match u with
    | cons l [] =&gt; Expr.is_small l
    | _ =&gt; false
    end.
  
  Definition sprop : list Expr.H.(Hashcons.S.t) := tip Expr.sprop.
  
  Definition type0m : list Expr.H.(Hashcons.S.t) := tip Expr.prop.
  
  Definition type0 : list Expr.H.(Hashcons.S.t) := tip Expr.set.
  
  Definition type1 : list Expr.H.(Hashcons.S.t) := tip Expr.type1.
  
  Definition is_sprop (x : list Expr.H.(Hashcons.S.t)) : bool := equal sprop x.
  
  Definition is_type0m (x : list Expr.H.(Hashcons.S.t)) : bool := equal type0m x.
  
  Definition is_type0 (x : list Expr.H.(Hashcons.S.t)) : bool := equal type0 x.
  
  Definition super (l : list Expr.H.(Hashcons.S.t))
    : list Expr.H.(Hashcons.S.t) :=
    if is_small l then
      type1
    else
      Util.List.Smart.map (fun x =&gt; Expr.successor x) l.
  
  Definition addn
    (n : Z) (l : list (Level.Self.(Hashcons.HashconsedType.t) * Z))
    : list (Level.Self.(Hashcons.HashconsedType.t) * Z) :=
    Util.List.Smart.map (fun x =&gt; Expr.addn n x) l.
  
  Fixpoint merge_univs (l1 : list (Level.t * Z)) (l2 : list (Level.t * Z))
    : list (Level.t * Z) :=
    match (l1, l2) with
    | ([], _) =&gt; l2
    | (_, []) =&gt; l1
    | (cons h1 t1, cons h2 t2) =&gt;
      match Expr.super h1 h2 with
      | SuperSame true =&gt; merge_univs t1 l2
      | SuperSame false =&gt; merge_univs l1 t2
      | SuperDiff c =&gt;
        if OCaml.Stdlib.le c 0 then
          cons h1 (merge_univs t1 l2)
        else
          cons h2 (merge_univs l1 t2)
      end
    end.
  
  Definition sort (u : list (Level.t * Z)) : list (Level.t * Z) :=
    let fix aux (a : Level.t * Z) (l : list (Level.t * Z))
      : list (Level.t * Z) :=
      match l with
      | cons b l' =&gt;
        match Expr.super a b with
        | SuperSame false =&gt; aux a l'
        | SuperSame true =&gt; l
        | SuperDiff c =&gt;
          if OCaml.Stdlib.le c 0 then
            cons a l
          else
            cons b (aux a l')
        end
      | [] =&gt; cons a l
      end in
    Util.List.(CList.ExtS.fold_right) (fun a =&gt; fun acc =&gt; aux a acc) u [].
  
  Definition sup (x : list (Level.t * Z)) (y : list (Level.t * Z))
    : list (Level.t * Z) := merge_univs x y.
  
  Definition empty {A : Type} : list A := [].
  
  Definition _exists {A : Type} : (A -&gt; bool) -&gt; (list A) -&gt; bool :=
    Util.List.(CList.ExtS._exists).
  
  Definition for_all {A : Type} : (A -&gt; bool) -&gt; (list A) -&gt; bool :=
    Util.List.(CList.ExtS.for_all).
  
  Definition smart_map {A : Type} : (A -&gt; A) -&gt; (list A) -&gt; list A :=
    Util.List.Smart.map.
  
  Definition map {A B : Type} : (A -&gt; B) -&gt; (list A) -&gt; list B :=
    Util.List.(CList.ExtS.map).
End Universe.

Definition universe := Universe.t.

Definition type0m_univ : list Universe.Expr.H.(Hashcons.S.t) := Universe.type0m.

Definition type0_univ : list Universe.Expr.H.(Hashcons.S.t) := Universe.type0.

Definition type1_univ : list Universe.Expr.H.(Hashcons.S.t) := Universe.type1.

Definition is_type0m_univ : (list Universe.Expr.H.(Hashcons.S.t)) -&gt; bool :=
  Universe.is_type0m.

Definition is_type0_univ : (list Universe.Expr.H.(Hashcons.S.t)) -&gt; bool :=
  Universe.is_type0.

Definition is_univ_variable {A : Type} (l : list (A * Z)) : bool :=
  Stdlib.op_exclamation_eq (Universe.level l) None.

Definition is_small_univ : (list (Level.t * Z)) -&gt; bool := Universe.is_small.

Definition pr_uni : (list (Level.t * Int.t)) -&gt; Pp.t := Universe.pr.

Definition sup
  : (list (Level.t * Z)) -&gt; (list (Level.t * Z)) -&gt; list (Level.t * Z) :=
  Universe.sup.

Definition super
  : (list Universe.Expr.H.(Hashcons.S.t)) -&gt; list Universe.Expr.H.(Hashcons.S.t) :=
  Universe.super.

Import Universe.

Definition universe_level {A : Type} : (list (A * Z)) -&gt; option A :=
  Universe.level.

Inductive constraint_type : Type :=
| Lt : constraint_type
| Le : constraint_type
| Eq : constraint_type.

Definition explanation := list (constraint_type * Level.t).

Definition constraint_type_ord (c1 : constraint_type) (c2 : constraint_type)
  : Z :=
  match (c1, c2) with
  | (Lt, Lt) =&gt; 0
  | (Lt, _) =&gt; (-1)
  | (Le, Lt) =&gt; 1
  | (Le, Le) =&gt; 0
  | (Le, Eq) =&gt; (-1)
  | (Eq, Eq) =&gt; 0
  | (Eq, _) =&gt; 1
  end.

Definition univ_inconsistency :=
  constraint_type * universe * universe * (option (Stdlib.Lazy.t explanation)).

Definition error_inconsistency {A : Type}
  (o : constraint_type) (u : Level.t) (v : Level.t)
  (p : option (Stdlib.Lazy.t explanation)) : A :=
  Stdlib.raise
    (UniverseInconsistency (o, (Universe.make u), (Universe.make v), p)).

Definition univ_constraint := Level.t * constraint_type * Level.t.

Definition pr_constraint_type (op : constraint_type) : Pp.t :=
  let op_str :=
    match op with
    | Lt =&gt; &quot; &lt; &quot; % string
    | Le =&gt; &quot; &lt;= &quot; % string
    | Eq =&gt; &quot; = &quot; % string
    end in
  Pp.str op_str.

Module UConstraintOrd.
  Definition t := univ_constraint.
  
  Definition compare (function_parameter : Level.t * constraint_type * Level.t)
    : (Level.t * constraint_type * Level.t) -&gt; Z :=
    match function_parameter with
    | (u, c, v) =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | (u', c', v') =&gt;
          let i := constraint_type_ord c c' in
          if negb (Int.equal i 0) then
            i
          else
            let i' := Level.compare u u' in
            if negb (Int.equal i' 0) then
              i'
            else
              Level.compare v v'
        end
    end.
End UConstraintOrd.

Module Constraint.
  Definition pr (prl : Level.t -&gt; Pp.t) (c : t) : Pp.t :=
    Pp.v 0
      (Pp.prlist_with_sep Pp.spc
        (fun function_parameter =&gt;
          match function_parameter with
          | (u1, op, u2) =&gt;
            Pp.hov 0
              (Pp.op_plus_plus
                (Pp.op_plus_plus (prl u1) (pr_constraint_type op)) (prl u2))
          end) (elements c)).
End Constraint.

Definition empty_constraint : Constraint.t := Constraint.empty.

Definition union_constraint : Constraint.t -&gt; Constraint.t -&gt; Constraint.t :=
  Constraint.union.

Definition eq_constraint : Constraint.t -&gt; Constraint.t -&gt; bool :=
  Constraint.equal.

Definition constraints := Constraint.t.

Definition hcons_constraint
  : Hconstraint.(Hashcons.S.t) -&gt; Hconstraint.(Hashcons.S.t) :=
  Hashcons.simple_hcons Hconstraint.(Hashcons.S.generate)
    Hconstraint.(Hashcons.S.hcons) Level.hcons.

Definition hcons_constraints
  : Hconstraints.(Hashcons.S.t) -&gt; Hconstraints.(Hashcons.S.t) :=
  Hashcons.simple_hcons Hconstraints.(Hashcons.S.generate)
    Hconstraints.(Hashcons.S.hcons) hcons_constraint.

Definition constrained (a : Type) := a * constraints.

Definition constraints_of {A B : Type} (function_parameter : A * B) : B :=
  match function_parameter with
  | (_, cst) =&gt; cst
  end.

Definition constraint_function (a : Type) :=
  a -&gt; a -&gt; constraints -&gt; constraints.

Definition enforce_eq_level (u : Level.t) (v : Level.t) (c : Constraint.t)
  : Constraint.t :=
  if Level.equal u v then
    c
  else
    if Level.apart u v then
      error_inconsistency Eq u v None
    else
      Constraint.add (u, Eq, v) c.

Definition enforce_eq
  (u : list (Level.t * Z)) (v : list (Level.t * Z)) (c : Constraint.t)
  : Constraint.t :=
  match ((Universe.level u), (Universe.level v)) with
  | (Some u, Some v) =&gt; enforce_eq_level u v c
  | _ =&gt;
    CErrors.anomaly None None
      (Pp.str
        &quot;A universe comparison can only happen between variables.&quot; % string)
  end.

Definition check_univ_eq
  (u : list (Level.t * Int.t)) (v : list (Level.t * Int.t)) : bool :=
  Universe.equal u v.

Definition enforce_eq
  (u : list (Level.t * Int.t)) (v : list (Level.t * Int.t)) (c : Constraint.t)
  : Constraint.t :=
  if check_univ_eq u v then
    c
  else
    enforce_eq u v c.

Definition constraint_add_leq
  (v : Universe.Expr.t) (u : Universe.Expr.t) (c : Constraint.t)
  : Constraint.t :=
  if Universe.Expr.equal v u then
    c
  else
    match (v, u) with
    | ((x, n), (y, m)) =&gt;
      let j := Util.op_minus m n in
      if equiv_decb j (-1) then
        Constraint.add (x, Lt, y) c
      else
        if OCaml.Stdlib.le j (-1) then
          if Level.equal x y then
            Stdlib.raise
              (UniverseInconsistency
                (Le, (Universe.tip v), (Universe.tip u), None))
          else
            CErrors.anomaly None None
              (Pp.str
                &quot;Unable to handle arbitrary u+k &lt;= v constraints.&quot; % string)
        else
          if equiv_decb j 0 then
            Constraint.add (x, Le, y) c
          else
            if Level.equal x y then
              c
            else
              if Level.is_small x then
                c
              else
                Constraint.add (x, Le, y) c
    end.

Definition check_univ_leq_one {A : Type}
  (u : Level.t * A) (v : list (Level.t * A)) : bool :=
  Universe._exists (Universe.Expr.leq u) v.

Definition check_univ_leq {A : Type}
  (u : list (Level.t * A)) (v : list (Level.t * A)) : bool :=
  Universe.for_all (fun u =&gt; check_univ_leq_one u v) u.

Definition enforce_leq
  (u : list Universe.Expr.H.(Hashcons.S.t))
  (v : list Universe.Expr.H.(Hashcons.S.t)) (c : Constraint.t) : Constraint.t :=
  match ((Universe.is_sprop u), (Universe.is_sprop v)) with
  | (true, true) =&gt; c
  | (true, false) | (false, true) =&gt;
    Stdlib.raise (UniverseInconsistency (Le, u, v, None))
  | (false, false) =&gt;
    Util.List.(CList.ExtS.fold_left)
      (fun c =&gt;
        fun v =&gt;
          Util.List.(CList.ExtS.fold_left)
            (fun c =&gt; fun u =&gt; constraint_add_leq u v c) c u) c v
  end.

Definition enforce_leq
  (u : list Universe.Expr.H.(Hashcons.S.t))
  (v : list Universe.Expr.H.(Hashcons.S.t)) (c : Constraint.t) : Constraint.t :=
  if check_univ_leq u v then
    c
  else
    enforce_leq u v c.

Definition enforce_leq_level (u : Level.t) (v : Level.t) (c : Constraint.t)
  : Constraint.t :=
  if Level.equal u v then
    c
  else
    Constraint.add (u, Le, v) c.

Definition univ_level_mem (u : Level.t) (v : list (Level.t * Int.t)) : bool :=
  Util.List.(CList.ExtS._exists)
    (fun function_parameter =&gt;
      match function_parameter with
      | (l, n) =&gt; andb (Int.equal n 0) (Level.equal u l)
      end) v.

Definition univ_level_rem
  (u : Level.t) (v : list (Level.t * Z)) (min : list (Level.t * Int.t))
  : list (Level.t * Int.t) :=
  match Universe.level v with
  | Some u' =&gt;
    if Level.equal u u' then
      min
    else
      v
  | None =&gt;
    Util.List.(CList.ExtS.filter)
      (fun function_parameter =&gt;
        match function_parameter with
        | (l, n) =&gt; negb (andb (Int.equal n 0) (Level.equal u l))
        end) v
  end.

Definition universe_level_subst := universe_map universe_level.

Definition universe_subst := universe_map universe.

Module Variance.
  Inductive t : Type :=
  | Irrelevant : t
  | Covariant : t
  | Invariant : t.
  
  Definition sup (x : t) (y : t) : t :=
    match (x, y) with
    | (Irrelevant, s) | (s, Irrelevant) =&gt; s
    | (Invariant, _) | (_, Invariant) =&gt; Invariant
    | (Covariant, Covariant) =&gt; Covariant
    end.
  
  Definition check_subtype (x : t) (y : t) : bool :=
    match (x, y) with
    | (Irrelevant | Covariant | Invariant, Irrelevant) =&gt; true
    | (Irrelevant, Covariant) =&gt; false
    | (Covariant | Invariant, Covariant) =&gt; true
    | (Irrelevant | Covariant, Invariant) =&gt; false
    | (Invariant, Invariant) =&gt; true
    end.
  
  Definition pr (function_parameter : t) : Pp.t :=
    match function_parameter with
    | Irrelevant =&gt; Pp.str &quot;*&quot; % string
    | Covariant =&gt; Pp.str &quot;+&quot; % string
    | Invariant =&gt; Pp.str &quot;=&quot; % string
    end.
  
  Definition leq_constraint
    (csts : Constraint.t) (variance : t) (u : Level.t) (u' : Level.t)
    : Constraint.t :=
    match variance with
    | Irrelevant =&gt; csts
    | Covariant =&gt; enforce_leq_level u u' csts
    | Invariant =&gt; enforce_eq_level u u' csts
    end.
  
  Definition eq_constraint
    (csts : Constraint.t) (variance : t) (u : Level.t) (u' : Level.t)
    : Constraint.t :=
    match variance with
    | Irrelevant =&gt; csts
    | Covariant | Invariant =&gt; enforce_eq_level u u' csts
    end.
  
  Definition leq_constraints
    (variance : array t) (u : array Level.t) (u' : array Level.t)
    (csts : Constraint.t) : Constraint.t :=
    let len := Util.Array.(CArray.ExtS.length) u in
    andb (equiv_decb len (Util.Array.(CArray.ExtS.length) u'))
      (equiv_decb len (Util.Array.(CArray.ExtS.length) variance));
    Util.Array.(CArray.ExtS.fold_left3) leq_constraint csts variance u u'.
  
  Definition eq_constraints
    (variance : array t) (u : array Level.t) (u' : array Level.t)
    (csts : Constraint.t) : Constraint.t :=
    let len := Util.Array.(CArray.ExtS.length) u in
    andb (equiv_decb len (Util.Array.(CArray.ExtS.length) u'))
      (equiv_decb len (Util.Array.(CArray.ExtS.length) variance));
    Util.Array.(CArray.ExtS.fold_left3) eq_constraint csts variance u u'.
End Variance.

Definition enforce_eq_instances (x : Instance.t) (y : Instance.t)
  : Constraint.t -&gt; Constraint.t :=
  let ax : array Level.t :=
    Instance.to_array x
  with ay : array Level.t :=
    Instance.to_array y in
  if
    Stdlib.op_exclamation_eq (Util.Array.(CArray.ExtS.length) ax)
      (Util.Array.(CArray.ExtS.length) ay) then
    CErrors.anomaly None None
      (Pp.op_plus_plus
        (Pp.str &quot;Invalid argument: enforce_eq_instances called with&quot; % string)
        (Pp.str &quot; instances of different lengths.&quot; % string))
  else
    tt;
  CArray.(CArray.ExtS.fold_right2) enforce_eq_level ax ay.

Definition enforce_eq_variance_instances
  : (array Variance.t) -&gt;
    (array Level.t) -&gt; (array Level.t) -&gt; Constraint.t -&gt; Constraint.t :=
  Variance.eq_constraints.

Definition enforce_leq_variance_instances
  : (array Variance.t) -&gt;
    (array Level.t) -&gt; (array Level.t) -&gt; Constraint.t -&gt; Constraint.t :=
  Variance.leq_constraints.

Definition subst_instance_level (s : array Level.t) (l : Level.t) : Level.t :=
  match Level.data l with
  | Level.Var n =&gt; Util.Array.(CArray.ExtS.get) s n
  | _ =&gt; l
  end.

Definition subst_instance_instance (s : array Level.t) (i : array Level.t)
  : array Level.t := Util.Array.Smart.map (fun l =&gt; subst_instance_level s l) i.

Definition subst_instance_universe
  (s : array Level.Self.(Hashcons.HashconsedType.t))
  (u : list (Level.Self.(Hashcons.HashconsedType.t) * Z))
  : list (Level.Self.(Hashcons.HashconsedType.t) * Z) :=
  let f (x : Level.Self.(Hashcons.HashconsedType.t) * Z)
    : Level.Self.(Hashcons.HashconsedType.t) * Z :=
    Universe.Expr.map (fun u =&gt; subst_instance_level s u) x in
  let u' := Universe.smart_map f u in
  if Stdlib.op_eq_eq u u' then
    u
  else
    Universe.sort u'.

Definition subst_instance_constraint {A : Type}
  (s : array Level.t) (function_parameter : Level.t * A * Level.t)
  : Level.t * A * Level.t :=
  match function_parameter with
  | (u, d, v) as c =&gt;
    let u' := subst_instance_level s u in
    let v' := subst_instance_level s v in
    if andb (Stdlib.op_eq_eq u' u) (Stdlib.op_eq_eq v' v) then
      c
    else
      (u', d, v')
  end.

Definition subst_instance_constraints (s : array Level.t) (csts : Constraint.t)
  : Constraint.t :=
  Constraint.fold
    (fun c =&gt; fun csts =&gt; Constraint.add (subst_instance_constraint s c) csts)
    csts Constraint.empty.

Definition puniverses (a : Type) := a * Instance.t.

Definition out_punivs {A B : Type} (function_parameter : A * B) : A :=
  match function_parameter with
  | (x, _y) =&gt; x
  end.

Definition in_punivs {A : Type} (x : A) : A * Instance.t := (x, Instance.empty).

Definition eq_puniverses {A B : Type}
  (f : A -&gt; B -&gt; bool) (function_parameter : A * Instance.t)
  : (B * Instance.t) -&gt; bool :=
  match function_parameter with
  | (x, u) =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | (y, u') =&gt; andb (f x y) (Instance.equal u u')
      end
  end.

Module UContext.
  Definition t := constrained Instance.t.
  
  Definition make {A : Type} (x : A) : A := x.
  
  Definition empty : Instance.t * Constraint.t :=
    (Instance.empty, Constraint.empty).
  
  Definition is_empty (function_parameter : Instance.t * Constraint.t) : bool :=
    match function_parameter with
    | (univs, cst) =&gt; andb (Instance.is_empty univs) (Constraint.is_empty cst)
    end.
  
  Definition pr
    (prl : Level.t -&gt; Pp.t) (variance : option (array Variance.t))
    (function_parameter : Instance.t * Constraint.t) : Pp.t :=
    match function_parameter with
    | (univs, cst) as ctx =&gt;
      if is_empty ctx then
        Pp.mt tt
      else
        Pp.op_plus_plus
          (Pp.h 0
            (Pp.op_plus_plus (Instance.pr prl variance univs)
              (Pp.str &quot; |= &quot; % string)))
          (Pp.h 0 (Pp.v 0 (Constraint.pr prl cst)))
    end.
  
  Definition hcons
    (function_parameter : Instance.t * Hconstraints.(Hashcons.S.t))
    : Instance.t * Hconstraints.(Hashcons.S.t) :=
    match function_parameter with
    | (univs, cst) =&gt; ((Instance.hcons univs), (hcons_constraints cst))
    end.
  
  Definition instance {A B : Type} (function_parameter : A * B) : A :=
    match function_parameter with
    | (univs, _cst) =&gt; univs
    end.
  
  Definition constraints {A B : Type} (function_parameter : A * B) : B :=
    match function_parameter with
    | (_univs, cst) =&gt; cst
    end.
  
  Definition union (function_parameter : Instance.t * Constraint.t)
    : (Instance.t * Constraint.t) -&gt; Instance.t * Constraint.t :=
    match function_parameter with
    | (univs, cst) =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | (univs', cst') =&gt;
          ((Instance.append univs univs'), (Constraint.union cst cst'))
        end
    end.
  
  Definition dest {A : Type} (x : A) : A := x.
  
  Definition size {A : Type} (function_parameter : Instance.t * A) : Z :=
    match function_parameter with
    | (x, _) =&gt; Instance.length x
    end.
End UContext.

Definition universe_context := UContext.t.

Definition hcons_universe_context
  : (Instance.t * Hconstraints.(Hashcons.S.t)) -&gt;
    Instance.t * Hconstraints.(Hashcons.S.t) := UContext.hcons.

Module AUContext.
  Definition t := constrained (array Names.Name.t).
  
  Definition repr {A B : Type} (function_parameter : (array A) * B)
    : (array Level.Self.(Hashcons.HashconsedType.t)) * B :=
    match function_parameter with
    | (inst, cst) =&gt;
      ((Util.Array.(CArray.ExtS.init) (Util.Array.(CArray.ExtS.length) inst)
        (fun i =&gt; Level.var i)), cst)
    end.
  
  Definition pr {A : Type}
    (f : Level.t -&gt; Pp.t) (variance : option (array Variance.t))
    (ctx : (array A) * Constraint.t) : Pp.t := UContext.pr f variance (repr ctx).
  
  Definition instantiate {A : Type}
    (inst : array Level.t) (function_parameter : (array A) * Constraint.t)
    : Constraint.t :=
    match function_parameter with
    | (u, cst) =&gt;
      equiv_decb (Util.Array.(CArray.ExtS.length) u)
        (Util.Array.(CArray.ExtS.length) inst);
      subst_instance_constraints inst cst
    end.
  
  Definition names {A B : Type} (function_parameter : A * B) : A :=
    match function_parameter with
    | (nas, _) =&gt; nas
    end.
  
  Definition hcons
    (function_parameter : (array Names.Name.t) * Hconstraints.(Hashcons.S.t))
    : (array Names.Name.t) * Hconstraints.(Hashcons.S.t) :=
    match function_parameter with
    | (univs, cst) =&gt;
      ((Util.Array.(CArray.ExtS.map) Names.Name.hcons univs),
        (hcons_constraints cst))
    end.
  
  Definition empty {A : Type} : (array A) * Constraint.t :=
    (tt, Constraint.empty).
  
  Definition is_empty {A : Type} (function_parameter : (array A) * Constraint.t)
    : bool :=
    match function_parameter with
    | (nas, cst) =&gt;
      andb (Util.Array.(CArray.ExtS.is_empty) nas) (Constraint.is_empty cst)
    end.
  
  Definition union {A : Type} (function_parameter : (array A) * Constraint.t)
    : ((array A) * Constraint.t) -&gt; (array A) * Constraint.t :=
    match function_parameter with
    | (nas, cst) =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | (nas', cst') =&gt;
          ((Util.Array.(CArray.ExtS.append) nas nas'),
            (Constraint.union cst cst'))
        end
    end.
  
  Definition size {A B : Type} (function_parameter : (array A) * B) : Z :=
    match function_parameter with
    | (nas, _) =&gt; Util.Array.(CArray.ExtS.length) nas
    end.
End AUContext.

Record univ_abstracted {a : Type} := {
  univ_abstracted_value : a;
  univ_abstracted_binder : AUContext.t }.
Arguments univ_abstracted : clear implicits.

Definition map_univ_abstracted {A B : Type}
  (f : A -&gt; B) (function_parameter : univ_abstracted A) : univ_abstracted B :=
  match function_parameter with
  | {|
    univ_abstracted_value := univ_abstracted_value;
      univ_abstracted_binder := univ_abstracted_binder
      |} =&gt;
    let univ_abstracted_value := f univ_abstracted_value in
    {| univ_abstracted_value := univ_abstracted_value;
      univ_abstracted_binder := univ_abstracted_binder |}
  end.

Definition hcons_abstract_universe_context
  : ((array Names.Name.t) * Hconstraints.(Hashcons.S.t)) -&gt;
    (array Names.Name.t) * Hconstraints.(Hashcons.S.t) := AUContext.hcons.

Module ContextSet.
  Definition t := constrained universe_set.
  
  Definition empty : LSet.t * Constraint.t := (LSet.empty, Constraint.empty).
  
  Definition is_empty (function_parameter : LSet.t * Constraint.t) : bool :=
    match function_parameter with
    | (univs, cst) =&gt; andb (LSet.is_empty univs) (Constraint.is_empty cst)
    end.
  
  Definition equal (function_parameter : LSet.t * Constraint.t)
    : (LSet.t * Constraint.t) -&gt; bool :=
    match function_parameter with
    | (univs, cst) as x =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | (univs', cst') as y =&gt;
          orb (Stdlib.op_eq_eq x y)
            (andb (LSet.equal univs univs') (Constraint.equal cst cst'))
        end
    end.
  
  Definition of_set {A : Type} (s : A) : A * Constraint.t :=
    (s, Constraint.empty).
  
  Definition singleton (l : LSet.elt) : LSet.t * Constraint.t :=
    of_set (LSet.singleton l).
  
  Definition of_instance (i : Instance.t) : LSet.t * Constraint.t :=
    of_set (Instance.levels i).
  
  Definition union (function_parameter : LSet.t * Constraint.t)
    : (LSet.t * Constraint.t) -&gt; LSet.t * Constraint.t :=
    match function_parameter with
    | (univs, cst) as x =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | (univs', cst') as y =&gt;
          if Stdlib.op_eq_eq x y then
            x
          else
            ((LSet.union univs univs'), (Constraint.union cst cst'))
        end
    end.
  
  Definition append (function_parameter : LSet.t * Constraint.t)
    : (LSet.t * Constraint.t) -&gt; LSet.t * Constraint.t :=
    match function_parameter with
    | (univs, cst) =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | (univs', cst') =&gt;
          let univs := LSet.fold LSet.add univs univs' in
          let cst := Constraint.fold Constraint.add cst cst' in
          (univs, cst)
        end
    end.
  
  Definition diff (function_parameter : LSet.t * Constraint.t)
    : (LSet.t * Constraint.t) -&gt; LSet.t * Constraint.t :=
    match function_parameter with
    | (univs, cst) =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | (univs', cst') =&gt;
          ((LSet.diff univs univs'), (Constraint.diff cst cst'))
        end
    end.
  
  Definition add_universe {A : Type}
    (u : LSet.elt) (function_parameter : LSet.t * A) : LSet.t * A :=
    match function_parameter with
    | (univs, cst) =&gt; ((LSet.add u univs), cst)
    end.
  
  Definition add_constraints {A : Type}
    (cst' : Constraint.t) (function_parameter : A * Constraint.t)
    : A * Constraint.t :=
    match function_parameter with
    | (univs, cst) =&gt; (univs, (Constraint.union cst cst'))
    end.
  
  Definition add_instance {A : Type}
    (inst : Instance.t) (function_parameter : LSet.t * A) : LSet.t * A :=
    match function_parameter with
    | (univs, cst) =&gt;
      let v := Instance.to_array inst in
      let fold (accu : LSet.t) (u : LSet.elt) : LSet.t :=
        LSet.add u accu in
      let univs := Util.Array.(CArray.ExtS.fold_left) fold univs v in
      (univs, cst)
    end.
  
  Definition sort_levels (a : array Level.t) : array Level.t :=
    Util.Array.(CArray.ExtS.sort) Level.compare a;
    a.
  
  Definition to_context {A : Type} (function_parameter : LSet.t * A)
    : Instance.t * A :=
    match function_parameter with
    | (ctx, cst) =&gt;
      ((Instance.of_array
        (sort_levels (Util.Array.(CArray.ExtS.of_list) (LSet.elements ctx)))),
        cst)
    end.
  
  Definition of_context {A : Type} (function_parameter : Instance.t * A)
    : LSet.t * A :=
    match function_parameter with
    | (ctx, cst) =&gt; ((Instance.levels ctx), cst)
    end.
  
  Definition pr
    (prl : LSet.elt -&gt; Pp.t) (function_parameter : LSet.t * Constraint.t)
    : Pp.t :=
    match function_parameter with
    | (univs, cst) as ctx =&gt;
      if is_empty ctx then
        Pp.mt tt
      else
        Pp.op_plus_plus
          (Pp.h 0 (Pp.op_plus_plus (LSet.pr prl univs) (Pp.str &quot; |= &quot; % string)))
          (Pp.h 0 (Pp.v 0 (Constraint.pr prl cst)))
    end.
  
  Definition constraints {A B : Type} (function_parameter : A * B) : B :=
    match function_parameter with
    | (_univs, cst) =&gt; cst
    end.
  
  Definition levels {A B : Type} (function_parameter : A * B) : A :=
    match function_parameter with
    | (univs, _cst) =&gt; univs
    end.
  
  Definition size {A : Type} (function_parameter : LSet.t * A) : Z :=
    match function_parameter with
    | (univs, _) =&gt; LSet.cardinal univs
    end.
End ContextSet.

Definition universe_context_set := ContextSet.t.

Definition in_universe_context (a : Type) := a * universe_context.

Definition in_universe_context_set (a : Type) := a * universe_context_set.

Definition extend_in_context_set {A : Type}
  (function_parameter : A * (LSet.t * Constraint.t))
  : (LSet.t * Constraint.t) -&gt; A * (LSet.t * Constraint.t) :=
  match function_parameter with
  | (a, ctx) =&gt; fun ctx' =&gt; (a, (ContextSet.union ctx ctx'))
  end.

Definition empty_subst {A : Type} : LMap.t A := LMap.empty.

Definition is_empty_subst {A : Type} : (LMap.t A) -&gt; bool := LMap.is_empty.

Definition empty_level_subst {A : Type} : LMap.t A := LMap.empty.

Definition is_empty_level_subst {A : Type} : (LMap.t A) -&gt; bool := LMap.is_empty.

Definition subst_univs_level_level (subst : LMap.t LMap.key) (l : LMap.key)
  : LMap.key := try.

Definition subst_univs_level_universe
  (subst : LMap.t LMap.key)
  (u : list (Level.Self.(Hashcons.HashconsedType.t) * Z))
  : list (Level.Self.(Hashcons.HashconsedType.t) * Z) :=
  let f (x : Level.Self.(Hashcons.HashconsedType.t) * Z)
    : Level.Self.(Hashcons.HashconsedType.t) * Z :=
    Universe.Expr.map (fun u =&gt; subst_univs_level_level subst u) x in
  let u' := Universe.smart_map f u in
  if Stdlib.op_eq_eq u u' then
    u
  else
    Universe.sort u'.

Definition subst_univs_level_instance (subst : LMap.t LMap.key) (i : Instance.t)
  : Instance.t :=
  let i' := Instance.subst_fn (subst_univs_level_level subst) i in
  if Stdlib.op_eq_eq i i' then
    i
  else
    i'.

Definition subst_univs_level_constraint
  (subst : LMap.t LMap.key)
  (function_parameter : LMap.key * constraint_type * LMap.key)
  : option (LMap.key * constraint_type * LMap.key) :=
  match function_parameter with
  | (u, d, v) =&gt;
    let u' : LMap.key :=
      subst_univs_level_level subst u
    with v' : LMap.key :=
      subst_univs_level_level subst v in
    if andb (Stdlib.op_exclamation_eq d Lt) (Level.equal u' v') then
      None
    else
      Some (u', d, v')
  end.

Definition subst_univs_level_constraints
  (subst : LMap.t LMap.key) (csts : Constraint.t) : Constraint.t :=
  Constraint.fold
    (fun c =&gt;
      Option.fold_right Constraint.add (subst_univs_level_constraint subst c))
    csts Constraint.empty.

Definition subst_univs_level_abstract_universe_context {A : Type}
  (subst : LMap.t LMap.key) (function_parameter : A * Constraint.t)
  : A * Constraint.t :=
  match function_parameter with
  | (inst, csts) =&gt; (inst, (subst_univs_level_constraints subst csts))
  end.

Definition universe_subst_fn := universe_level -&gt; universe.

Definition make_subst {A : Type} (subst : LMap.t A) (l : LMap.key) : A :=
  LMap.find l subst.

Definition subst_univs_expr_opt {A : Type}
  (fn : A -&gt; list (Level.Self.(Hashcons.HashconsedType.t) * Z))
  (function_parameter : A * Z)
  : list (Level.Self.(Hashcons.HashconsedType.t) * Z) :=
  match function_parameter with
  | (l, n) =&gt; Universe.addn n (fn l)
  end.

Definition subst_univs_universe
  (fn :
    Level.Self.(Hashcons.HashconsedType.t) -&gt;
      list (Level.Self.(Hashcons.HashconsedType.t) * Z))
  (ul : list (Level.Self.(Hashcons.HashconsedType.t) * Z))
  : list (Level.Self.(Hashcons.HashconsedType.t) * Z) :=
  match
    Util.List.(CList.ExtS.fold_right)
      (fun u =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | (subst, nosubst) =&gt; try
          end) ul ([], []) with
  | (subst, nosubst) =&gt;
    if CList.is_empty subst then
      ul
    else
      let substs :=
        Util.List.(CList.ExtS.fold_left) Universe.merge_univs Universe.empty
          subst in
      Util.List.(CList.ExtS.fold_left)
        (fun acc =&gt; fun u =&gt; Universe.merge_univs acc (Universe.tip u)) substs
        nosubst
  end.

Definition make_instance_subst (i : Instance.t)
  : LMap.t Level.Self.(Hashcons.HashconsedType.t) :=
  let arr := Instance.to_array i in
  Util.Array.(CArray.ExtS.fold_left_i)
    (fun i =&gt; fun acc =&gt; fun l =&gt; LMap.add l (Level.var i) acc) LMap.empty arr.

Definition make_inverse_instance_subst (i : Instance.t) : LMap.t Level.t :=
  let arr := Instance.to_array i in
  Util.Array.(CArray.ExtS.fold_left_i)
    (fun i =&gt; fun acc =&gt; fun l =&gt; LMap.add (Level.var i) l acc) LMap.empty arr.

Definition make_abstract_instance {A B : Type}
  (function_parameter : (array A) * B)
  : array Level.Self.(Hashcons.HashconsedType.t) :=
  match function_parameter with
  | (ctx, _) =&gt;
    Util.Array.(CArray.ExtS.init) (Util.Array.(CArray.ExtS.length) ctx)
      (fun i =&gt; Level.var i)
  end.

Definition abstract_universes {A : Type}
  (nas : array A) (ctx : Instance.t * Constraint.t)
  : Instance.t * ((array A) * Constraint.t) :=
  let instance := UContext.instance ctx in
  match
    Int.equal (Util.Array.(CArray.ExtS.length) nas) (Instance.length instance)
    with
  | tt =&gt;
    let subst := make_instance_subst instance in
    let cstrs := subst_univs_level_constraints subst (UContext.constraints ctx)
      in
    let ctx := (nas, cstrs) in
    (instance, ctx)
  end.

Fixpoint compact_univ {A : Type}
  (s : LMap.t Level.Self.(Hashcons.HashconsedType.t)) (vars : list Z) (i : Z)
  (u : list (Level.t * A))
  : (LMap.t Level.Self.(Hashcons.HashconsedType.t)) * (list Z) :=
  match u with
  | [] =&gt; (s, (Util.List.(CList.ExtS.rev) vars))
  | cons (lvl, _) u =&gt;
    match Level.var_index lvl with
    | _ =&gt; compact_univ s vars i u
    end
  end.

Definition compact_univ (u : list (Level.Self.(Hashcons.HashconsedType.t) * Z))
  : (list (Level.Self.(Hashcons.HashconsedType.t) * Z)) * (list Z) :=
  match compact_univ LMap.empty [] 0 u with
  | (s, s') =&gt; ((subst_univs_level_universe s u), s')
  end.

Definition pr_constraints (prl : Level.t -&gt; Pp.t) : Constraint.t -&gt; Pp.t :=
  Constraint.pr prl.

Definition pr_universe_context
  : (Level.t -&gt; Pp.t) -&gt;
    (option (array Variance.t)) -&gt; (Instance.t * Constraint.t) -&gt; Pp.t :=
  UContext.pr.

Definition pr_abstract_universe_context {A : Type}
  : (Level.t -&gt; Pp.t) -&gt;
    (option (array Variance.t)) -&gt; ((array A) * Constraint.t) -&gt; Pp.t :=
  AUContext.pr.

Definition pr_universe_context_set
  : (LSet.elt -&gt; Pp.t) -&gt; (LSet.t * Constraint.t) -&gt; Pp.t := ContextSet.pr.

Definition pr_universe_subst : (LMap.t (list (Level.t * Int.t))) -&gt; Pp.t :=
  LMap.pr
    (fun u =&gt;
      Pp.op_plus_plus (Pp.op_plus_plus (Pp.str &quot; := &quot; % string) (Universe.pr u))
        (Pp.spc tt)).

Definition pr_universe_level_subst : (LMap.t Level.t) -&gt; Pp.t :=
  LMap.pr
    (fun u =&gt;
      Pp.op_plus_plus (Pp.op_plus_plus (Pp.str &quot; := &quot; % string) (Level.pr u))
        (Pp.spc tt)).

Definition hcons_universe_set
  : Huniverse_set.(Hashcons.S.t) -&gt; Huniverse_set.(Hashcons.S.t) :=
  Hashcons.simple_hcons Huniverse_set.(Hashcons.S.generate)
    Huniverse_set.(Hashcons.S.hcons) Level.hcons.

Definition hcons_universe_context_set
  (function_parameter :
    Huniverse_set.(Hashcons.S.t) * Hconstraints.(Hashcons.S.t))
  : Huniverse_set.(Hashcons.S.t) * Hconstraints.(Hashcons.S.t) :=
  match function_parameter with
  | (v, c) =&gt; ((hcons_universe_set v), (hcons_constraints c))
  end.

Definition hcons_univ (x : Universe.Huniv.(Hashcons.S.t))
  : Universe.Huniv.(Hashcons.S.t) := Universe.hcons x.

Definition explain_universe_inconsistency
  (prl : Level.t -&gt; Pp.t) (function_parameter : univ_inconsistency) : Pp.t :=
  match function_parameter with
  | (o, u, v, p) =&gt;
    let pr_uni := Universe.pr_with prl in
    let pr_rel (function_parameter : constraint_type) : Pp.t :=
      match function_parameter with
      | Eq =&gt; Pp.str &quot;=&quot; % string
      | Lt =&gt; Pp.str &quot;&lt;&quot; % string
      | Le =&gt; Pp.str &quot;&lt;=&quot; % string
      end in
    let reason :=
      match p with
      | None =&gt; Pp.mt tt
      | Some p =&gt;
        let p := Stdlib.Lazy.force p in
        if equiv_decb p [] then
          Pp.mt tt
        else
          Pp.op_plus_plus
            (Pp.op_plus_plus
              (Pp.op_plus_plus
                (Pp.op_plus_plus (Pp.str &quot; because&quot; % string) (Pp.spc tt))
                (pr_uni v))
              (Pp.prlist
                (fun function_parameter =&gt;
                  match function_parameter with
                  | (r, v) =&gt;
                    Pp.op_plus_plus
                      (Pp.op_plus_plus (Pp.op_plus_plus (Pp.spc tt) (pr_rel r))
                        (Pp.str &quot; &quot; % string)) (prl v)
                  end) p))
            (if
              Universe.equal
                (Universe.make (snd (Util.List.(CList.ExtS.last) p))) u then
              Pp.mt tt
            else
              Pp.op_plus_plus
                (Pp.op_plus_plus (Pp.spc tt) (Pp.str &quot;= &quot; % string)) (pr_uni u))
      end in
    Pp.op_plus_plus
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus
            (Pp.op_plus_plus
              (Pp.op_plus_plus
                (Pp.op_plus_plus (Pp.str &quot;Cannot enforce&quot; % string) (Pp.spc tt))
                (pr_uni u)) (Pp.spc tt)) (pr_rel o)) (Pp.spc tt)) (pr_uni v))
      reason
  end.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="vars" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>vars.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names

module RelDecl = Context.Rel.Declaration

(*********************)
(*     Occurring     *)
(*********************)

exception LocalOccur

(* (closedn n M) raises FreeVar if a variable of height greater than n
   occurs in M, returns () otherwise *)

let closedn n c =
  let rec closed_rec n c = match Constr.kind c with
    | Constr.Rel m -&gt; if m&gt;n then raise LocalOccur
    | _ -&gt; Constr.iter_with_binders succ closed_rec n c
  in
  try closed_rec n c; true with LocalOccur -&gt; false

(* [closed0 M] is true iff [M] is a (de Bruijn) closed term *)

let closed0 c = closedn 0 c

(* (noccurn n M) returns true iff (Rel n) does NOT occur in term M  *)

let noccurn n term =
  let rec occur_rec n c = match Constr.kind c with
    | Constr.Rel m -&gt; if Int.equal m n then raise LocalOccur
    | _ -&gt; Constr.iter_with_binders succ occur_rec n c
  in
  try occur_rec n term; true with LocalOccur -&gt; false

(* (noccur_between n m M) returns true iff (Rel p) does NOT occur in term M
  for n &lt;= p &lt; n+m *)

let noccur_between n m term =
  let rec occur_rec n c = match Constr.kind c with
    | Constr.Rel p -&gt; if n&lt;=p &amp;&amp; p&lt;n+m then raise LocalOccur
    | _        -&gt; Constr.iter_with_binders succ occur_rec n c
  in
  try occur_rec n term; true with LocalOccur -&gt; false

(* Checking function for terms containing existential variables.
 The function [noccur_with_meta] considers the fact that
 each existential variable (as well as each isevar)
 in the term appears applied to its local context,
 which may contain the CoFix variables. These occurrences of CoFix variables
 are not considered *)

let isMeta c = match Constr.kind c with
| Constr.Meta _ -&gt; true
| _ -&gt; false

let noccur_with_meta n m term =
  let rec occur_rec n c = match Constr.kind c with
    | Constr.Rel p -&gt; if n&lt;=p &amp;&amp; p&lt;n+m then raise LocalOccur
    | Constr.App(f,_cl) -&gt;
        (match Constr.kind f with
           | Constr.Cast (c,_,_) when isMeta c -&gt; ()
           | Constr.Meta _ -&gt; ()
           | _ -&gt; Constr.iter_with_binders succ occur_rec n c)
    | Constr.Evar (_, _) -&gt; ()
    | _ -&gt; Constr.iter_with_binders succ occur_rec n c
  in
  try (occur_rec n term; true) with LocalOccur -&gt; false

(*********************)
(*      Lifting      *)
(*********************)

let exliftn = Constr.exliftn
let liftn = Constr.liftn
let lift = Constr.lift

(*********************)
(*   Substituting    *)
(*********************)

(* (subst1 M c) substitutes M for Rel(1) in c
   we generalise it to (substl [M1,...,Mn] c) which substitutes in parallel
   M1,...,Mn for respectively Rel(1),...,Rel(n) in c *)

(* 1st : general case *)

type info = Closed | Open | Unknown
type 'a substituend = { mutable sinfo: info; sit: 'a }

let lift_substituend depth s =
  match s.sinfo with
    | Closed -&gt; s.sit
    | Open -&gt; lift depth s.sit
    | Unknown -&gt;
      let sit = s.sit in
      if closed0 sit then
        let () = s.sinfo &lt;- Closed in
        sit
      else
        let () = s.sinfo &lt;- Open in
        lift depth sit

let make_substituend c = { sinfo=Unknown; sit=c }

let substn_many lamv n c =
  let lv = Array.length lamv in
  if Int.equal lv 0 then c
  else
    let rec substrec depth c = match Constr.kind c with
      | Constr.Rel k     -&gt;
          if k&lt;=depth then c
          else if k-depth &lt;= lv then lift_substituend depth (Array.unsafe_get lamv (k-depth-1))
          else Constr.mkRel (k-lv)
      | _ -&gt; Constr.map_with_binders succ substrec depth c in
    substrec n c

(*
let substkey = CProfile.declare_profile &quot;substn_many&quot;;;
let substn_many lamv n c = CProfile.profile3 substkey substn_many lamv n c;;
*)

let make_subst = function
| [] -&gt; [||]
| hd :: tl -&gt;
  let len = List.length tl in
  let subst = Array.make (1 + len) (make_substituend hd) in
  let s = ref tl in
  for i = 1 to len do
    match !s with
    | [] -&gt; assert false
    | x :: tl -&gt;
      Array.unsafe_set subst i (make_substituend x);
      s := tl
  done;
  subst

(* The type of substitutions, with term substituting most recent
    binder at the head *)

type substl = Constr.t list

let substnl laml n c = substn_many (make_subst laml) n c
let substl laml c = substn_many (make_subst laml) 0 c
let subst1 lam c = substn_many [|make_substituend lam|] 0 c

let substnl_decl laml k r = RelDecl.map_constr (fun c -&gt; substnl laml k c) r
let substl_decl laml r = RelDecl.map_constr (fun c -&gt; substnl laml 0 c) r
let subst1_decl lam r = RelDecl.map_constr (fun c -&gt; subst1 lam c) r

(* Build a substitution from an instance, inserting missing let-ins *)

let subst_of_rel_context_instance sign l =
  let rec aux subst sign l =
    let open RelDecl in
    match sign, l with
    | LocalAssum _ :: sign', a::args' -&gt; aux (a::subst) sign' args'
    | LocalDef (_,c,_)::sign', args' -&gt;
	aux (substl subst c :: subst) sign' args'
    | [], [] -&gt; subst
    | _ -&gt; CErrors.anomaly (Pp.str &quot;Instance and signature do not match.&quot;)
  in aux [] (List.rev sign) l

let adjust_subst_to_rel_context sign l =
  List.rev (subst_of_rel_context_instance sign l)

let adjust_rel_to_rel_context sign n =
  let rec aux sign =
    let open RelDecl in
    match sign with
    | LocalAssum _ :: sign' -&gt; let (n',p) = aux sign' in (n'+1,p)
    | LocalDef (_,_c,_)::sign' -&gt; let (n',p) = aux sign' in (n'+1,if n'&lt;n then p+1 else p)
    | [] -&gt; (0,n)
  in snd (aux sign)

(* (thin_val sigma) removes identity substitutions from sigma *)

let rec thin_val = function
  | [] -&gt; []
  | (id, c) :: tl -&gt;
    match Constr.kind c with
    | Constr.Var v -&gt;
      if Id.equal id v then thin_val tl
      else (id, make_substituend c) :: (thin_val tl)
    | _ -&gt; (id, make_substituend c) :: (thin_val tl)

let rec find_var id = function
| [] -&gt; raise Not_found
| (idc, c) :: subst -&gt;
  if Id.equal id idc then c
  else find_var id subst

(* (replace_vars sigma M) applies substitution sigma to term M *)
let replace_vars var_alist x =
  let var_alist = thin_val var_alist in
  match var_alist with
  | [] -&gt; x
  | _ -&gt;
    let rec substrec n c = match Constr.kind c with
    | Constr.Var x -&gt;
      (try lift_substituend n (find_var x var_alist)
      with Not_found -&gt; c)
    | _ -&gt; Constr.map_with_binders succ substrec n c
    in
    substrec 0 x

(* (subst_var str t) substitute (Var str) by (Rel 1) in t *)
let subst_var str t = replace_vars [(str, Constr.mkRel 1)] t

(* (subst_vars [id1;...;idn] t) substitute (Var idj) by (Rel j) in t *)
let substn_vars p vars c =
  let _,subst =
    List.fold_left (fun (n,l) var -&gt; ((n+1),(var,Constr.mkRel n)::l)) (p,[]) vars
  in replace_vars (List.rev subst) c

let subst_vars subst c = substn_vars 1 subst c

(** Universe substitutions *)
open Constr

let subst_univs_level_constr subst c =
  if Univ.is_empty_level_subst subst then c
  else 
    let f = Univ.Instance.subst_fn (Univ.subst_univs_level_level subst) in
    let changed = ref false in
    let rec aux t = 
      match kind t with
      | Const (c, u) -&gt; 
	if Univ.Instance.is_empty u then t
	else 
          let u' = f u in 
	    if u' == u then t
	    else (changed := true; mkConstU (c, u'))
      | Ind (i, u) -&gt;
	if Univ.Instance.is_empty u then t
	else 
	  let u' = f u in 
	    if u' == u then t
	    else (changed := true; mkIndU (i, u'))
      | Construct (c, u) -&gt;
	if Univ.Instance.is_empty u then t
	else 
          let u' = f u in 
	    if u' == u then t
	    else (changed := true; mkConstructU (c, u'))
      | Sort (Sorts.Type u) -&gt; 
         let u' = Univ.subst_univs_level_universe subst u in
	   if u' == u then t else 
	     (changed := true; mkSort (Sorts.sort_of_univ u'))
      | _ -&gt; Constr.map aux t
    in
    let c' = aux c in
      if !changed then c' else c

let subst_univs_level_context s = 
  Context.Rel.map (subst_univs_level_constr s)
      
let subst_instance_constr subst c =
  if Univ.Instance.is_empty subst then c
  else
    let f u = Univ.subst_instance_instance subst u in
    let rec aux t =
      match kind t with
      | Const (c, u) -&gt;
       if Univ.Instance.is_empty u then t
       else
          let u' = f u in
           if u' == u then t
           else (mkConstU (c, u'))
      | Ind (i, u) -&gt;
       if Univ.Instance.is_empty u then t
       else
         let u' = f u in
           if u' == u then t
           else (mkIndU (i, u'))
      | Construct (c, u) -&gt;
       if Univ.Instance.is_empty u then t
       else
          let u' = f u in
           if u' == u then t
           else (mkConstructU (c, u'))
      | Sort (Sorts.Type u) -&gt;
         let u' = Univ.subst_instance_universe subst u in
          if u' == u then t else
            (mkSort (Sorts.sort_of_univ u'))
      | _ -&gt; Constr.map aux t
    in
    aux c

let univ_instantiate_constr u c =
  let open Univ in
  assert (Int.equal (Instance.length u) (AUContext.size c.univ_abstracted_binder));
  subst_instance_constr u c.univ_abstracted_value

(* let substkey = CProfile.declare_profile &quot;subst_instance_constr&quot;;; *)
(* let subst_instance_constr inst c = CProfile.profile2 substkey subst_instance_constr inst c;; *)

let subst_instance_context s ctx = 
  if Univ.Instance.is_empty s then ctx
  else Context.Rel.map (fun x -&gt; subst_instance_constr s x) ctx

let universes_of_constr c =
  let open Univ in
  let rec aux s c =
    match kind c with
    | Const (_c, u) -&gt;
       LSet.fold LSet.add (Instance.levels u) s
    | Ind ((_mind,_), u) | Construct (((_mind,_),_), u) -&gt;
       LSet.fold LSet.add (Instance.levels u) s
    | Sort u when not (Sorts.is_small u) -&gt;
      let u = Sorts.univ_of_sort u in
      LSet.fold LSet.add (Universe.levels u) s
    | _ -&gt; Constr.fold aux s c
  in aux LSet.empty c
</pre>
          </div>
          <div class="col-md-6">
            <code>vars.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Names.

Definition closedn (n : Z) (c : Constr.constr) : bool :=
  let fix closed_rec (n : Z) (c : Constr.constr) : unit :=
    match Constr.kind c with
    | Constr.Rel m =&gt;
      if OCaml.Stdlib.gt m n then
        Stdlib.raise LocalOccur
      else
        tt
    | _ =&gt; Constr.iter_with_binders Z.succ closed_rec n c
    end in
  try.

Definition closed0 (c : Constr.constr) : bool := closedn 0 c.

Definition noccurn (n : Int.t) (term : Constr.constr) : bool :=
  let fix occur_rec (n : Int.t) (c : Constr.constr) : unit :=
    match Constr.kind c with
    | Constr.Rel m =&gt;
      if Int.equal m n then
        Stdlib.raise LocalOccur
      else
        tt
    | _ =&gt; Constr.iter_with_binders Z.succ occur_rec n c
    end in
  try.

Definition noccur_between (n : Z) (m : Z) (term : Constr.constr) : bool :=
  let fix occur_rec (n : Z) (c : Constr.constr) : unit :=
    match Constr.kind c with
    | Constr.Rel p =&gt;
      if andb (OCaml.Stdlib.le n p) (OCaml.Stdlib.lt p (Z.add n m)) then
        Stdlib.raise LocalOccur
      else
        tt
    | _ =&gt; Constr.iter_with_binders Z.succ occur_rec n c
    end in
  try.

Definition isMeta (c : Constr.constr) : bool :=
  match Constr.kind c with
  | Constr.Meta _ =&gt; true
  | _ =&gt; false
  end.

Definition noccur_with_meta (n : Z) (m : Z) (term : Constr.constr) : bool :=
  let fix occur_rec (n : Z) (c : Constr.constr) : unit :=
    match Constr.kind c with
    | Constr.Rel p =&gt;
      if andb (OCaml.Stdlib.le n p) (OCaml.Stdlib.lt p (Z.add n m)) then
        Stdlib.raise LocalOccur
      else
        tt
    | Constr.App f _cl =&gt;
      match Constr.kind f with
      | Constr.Meta _ =&gt; tt
      | _ =&gt; Constr.iter_with_binders Z.succ occur_rec n c
      end
    | Constr.Evar (_, _) =&gt; tt
    | _ =&gt; Constr.iter_with_binders Z.succ occur_rec n c
    end in
  try.

Definition exliftn : Esubst.lift -&gt; Constr.constr -&gt; Constr.constr :=
  Constr.exliftn.

Definition liftn : Z -&gt; Z -&gt; Constr.constr -&gt; Constr.constr := Constr.liftn.

Definition lift : Z -&gt; Constr.constr -&gt; Constr.constr := Constr.lift.

Inductive info : Type :=
| Closed : info
| Open : info
| Unknown : info.

Record substituend {a : Type} := {
  sinfo : info;
  sit : a }.
Arguments substituend : clear implicits.

Definition lift_substituend (depth : Z) (s : substituend Constr.constr)
  : Constr.constr :=
  match sinfo s with
  | Closed =&gt; sit s
  | Open =&gt; lift depth (sit s)
  | Unknown =&gt;
    let sit := sit s in
    if closed0 sit then
      match set_field with
      | tt =&gt; sit
      end
    else
      match set_field with
      | tt =&gt; lift depth sit
      end
  end.

Definition make_substituend {A : Type} (c : A) : substituend A :=
  {| sinfo := Unknown; sit := c |}.

Definition substn_many
  (lamv : array (substituend Constr.constr)) (n : Z) (c : Constr.constr)
  : Constr.constr :=
  let lv := Stdlib.Array.length lamv in
  if Int.equal lv 0 then
    c
  else
    let fix substrec (depth : Z) (c : Constr.constr) : Constr.constr :=
      match Constr.kind c with
      | Constr.Rel k =&gt;
        if OCaml.Stdlib.le k depth then
          c
        else
          if OCaml.Stdlib.le (Z.sub k depth) lv then
            lift_substituend depth
              (Stdlib.Array.unsafe_get lamv (Z.sub (Z.sub k depth) 1))
          else
            Constr.mkRel (Z.sub k lv)
      | _ =&gt; Constr.map_with_binders Z.succ substrec depth c
      end in
    substrec n c.

Definition make_subst {A : Type} (function_parameter : list A)
  : array (substituend A) :=
  match function_parameter with
  | [] =&gt; tt
  | cons hd tl =&gt;
    let len := OCaml.List.length tl in
    let subst := Stdlib.Array.make (Z.add 1 len) (make_substituend hd) in
    let s := Stdlib.ref tl in
    for;
    subst
  end.

Definition substl := list Constr.t.

Definition substnl (laml : list Constr.constr) (n : Z) (c : Constr.constr)
  : Constr.constr := substn_many (make_subst laml) n c.

Definition substl (laml : list Constr.constr) (c : Constr.constr)
  : Constr.constr := substn_many (make_subst laml) 0 c.

Definition subst1 (lam : Constr.constr) (c : Constr.constr) : Constr.constr :=
  substn_many ((make_substituend lam)) 0 c.

Definition substnl_decl
  (laml : list Constr.constr) (k : Z)
  (r : RelDecl.pt Constr.constr Constr.constr)
  : RelDecl.pt Constr.constr Constr.constr :=
  RelDecl.map_constr (fun c =&gt; substnl laml k c) r.

Definition substl_decl
  (laml : list Constr.constr) (r : RelDecl.pt Constr.constr Constr.constr)
  : RelDecl.pt Constr.constr Constr.constr :=
  RelDecl.map_constr (fun c =&gt; substnl laml 0 c) r.

Definition subst1_decl
  (lam : Constr.constr) (r : RelDecl.pt Constr.constr Constr.constr)
  : RelDecl.pt Constr.constr Constr.constr :=
  RelDecl.map_constr (fun c =&gt; subst1 lam c) r.

Definition subst_of_rel_context_instance {A : Type}
  (sign : list (RelDecl.pt Constr.constr A)) (l : list Constr.constr)
  : list Constr.constr :=
  let fix aux {B : Type}
    (subst : list Constr.constr) (sign : list (RelDecl.pt Constr.constr B)) (l :
    list Constr.constr) : list Constr.constr :=
    match (sign, l) with
    | (cons (LocalAssum _ _) sign', cons a args') =&gt;
      aux (cons a subst) sign' args'
    | (cons (LocalDef _ c _) sign', args') =&gt;
      aux (cons (substl subst c) subst) sign' args'
    | ([], []) =&gt; subst
    | _ =&gt;
      CErrors.anomaly None None
        (Pp.str &quot;Instance and signature do not match.&quot; % string)
    end in
  aux [] (List.rev sign) l.

Definition adjust_subst_to_rel_context {A : Type}
  (sign : list (RelDecl.pt Constr.constr A)) (l : list Constr.constr)
  : list Constr.constr := List.rev (subst_of_rel_context_instance sign l).

Definition adjust_rel_to_rel_context {A B : Type}
  (sign : list (RelDecl.pt A B)) (n : Z) : Z :=
  let fix aux {C D : Type} (sign : list (RelDecl.pt C D)) : Z * Z :=
    match sign with
    | cons (LocalAssum _ _) sign' =&gt;
      match aux sign' with
      | (n', p) =&gt; ((Z.add n' 1), p)
      end
    | cons (LocalDef _ _c _) sign' =&gt;
      match aux sign' with
      | (n', p) =&gt;
        ((Z.add n' 1),
          (if OCaml.Stdlib.lt n' n then
            Z.add p 1
          else
            p))
      end
    | [] =&gt; (0, n)
    end in
  snd (aux sign).

Fixpoint thin_val (function_parameter : list (Names.Id.t * Constr.constr))
  : list (Names.Id.t * (substituend Constr.constr)) :=
  match function_parameter with
  | [] =&gt; []
  | cons (id, c) tl =&gt;
    match Constr.kind c with
    | Constr.Var v =&gt;
      if Names.Id.equal id v then
        thin_val tl
      else
        cons (id, (make_substituend c)) (thin_val tl)
    | _ =&gt; cons (id, (make_substituend c)) (thin_val tl)
    end
  end.

Fixpoint find_var {A : Type}
  (id : Names.Id.t) (function_parameter : list (Names.Id.t * A)) : A :=
  match function_parameter with
  | [] =&gt; Stdlib.raise OCaml.Not_found
  | cons (idc, c) subst =&gt;
    if Names.Id.equal id idc then
      c
    else
      find_var id subst
  end.

Definition replace_vars
  (var_alist : list (Names.Id.t * Constr.constr)) (x : Constr.constr)
  : Constr.constr :=
  let var_alist := thin_val var_alist in
  match var_alist with
  | [] =&gt; x
  | _ =&gt;
    let fix substrec (n : Z) (c : Constr.constr) : Constr.constr :=
      match Constr.kind c with
      | Constr.Var x =&gt; try
      | _ =&gt; Constr.map_with_binders Z.succ substrec n c
      end in
    substrec 0 x
  end.

Definition subst_var (str : Names.Id.t) (t : Constr.constr) : Constr.constr :=
  replace_vars (cons (str, (Constr.mkRel 1)) []) t.

Definition substn_vars (p : Z) (vars : list Names.Id.t) (c : Constr.constr)
  : Constr.constr :=
  match
    Stdlib.List.fold_left
      (fun function_parameter =&gt;
        match function_parameter with
        | (n, l) =&gt; fun var =&gt; ((Z.add n 1), (cons (var, (Constr.mkRel n)) l))
        end) (p, []) vars with
  | (_, subst) =&gt; replace_vars (List.rev subst) c
  end.

Definition subst_vars (subst : list Names.Id.t) (c : Constr.constr)
  : Constr.constr := substn_vars 1 subst c.

Import Constr.

Definition subst_univs_level_constr
  (subst : Univ.universe_level_subst) (c : Constr.constr) : Constr.constr :=
  if Univ.is_empty_level_subst subst then
    c
  else
    let f := Univ.Instance.subst_fn (Univ.subst_univs_level_level subst) in
    let changed := Stdlib.ref false in
    let fix aux (t : Constr.constr) : Constr.constr :=
      match Constr.kind t with
      | Const (c, u) =&gt;
        if Univ.Instance.is_empty u then
          t
        else
          let u' := f u in
          if Stdlib.op_eq_eq u' u then
            t
          else
            Stdlib.op_colon_eq changed true;
            Constr.mkConstU (c, u')
      | Ind (i, u) =&gt;
        if Univ.Instance.is_empty u then
          t
        else
          let u' := f u in
          if Stdlib.op_eq_eq u' u then
            t
          else
            Stdlib.op_colon_eq changed true;
            Constr.mkIndU (i, u')
      | Construct (c, u) =&gt;
        if Univ.Instance.is_empty u then
          t
        else
          let u' := f u in
          if Stdlib.op_eq_eq u' u then
            t
          else
            Stdlib.op_colon_eq changed true;
            Constr.mkConstructU (c, u')
      | Sort (Sorts.Type u) =&gt;
        let u' := Univ.subst_univs_level_universe subst u in
        if Stdlib.op_eq_eq u' u then
          t
        else
          Stdlib.op_colon_eq changed true;
          Constr.mkSort (Sorts.sort_of_univ u')
      | _ =&gt; Constr.map aux t
      end in
    let c' := aux c in
    if Stdlib.op_exclamation changed then
      c'
    else
      c.

Definition subst_univs_level_context (s : Univ.universe_level_subst)
  : (Context.Rel.pt Constr.constr Constr.constr) -&gt;
    Context.Rel.pt Constr.constr Constr.constr :=
  Context.Rel.map (subst_univs_level_constr s).

Definition subst_instance_constr (subst : Univ.Instance.t) (c : Constr.constr)
  : Constr.constr :=
  if Univ.Instance.is_empty subst then
    c
  else
    let f (u : Univ.Instance.t) : Univ.Instance.t :=
      Univ.subst_instance_instance subst u in
    let fix aux (t : Constr.constr) : Constr.constr :=
      match Constr.kind t with
      | Const (c, u) =&gt;
        if Univ.Instance.is_empty u then
          t
        else
          let u' := f u in
          if Stdlib.op_eq_eq u' u then
            t
          else
            Constr.mkConstU (c, u')
      | Ind (i, u) =&gt;
        if Univ.Instance.is_empty u then
          t
        else
          let u' := f u in
          if Stdlib.op_eq_eq u' u then
            t
          else
            Constr.mkIndU (i, u')
      | Construct (c, u) =&gt;
        if Univ.Instance.is_empty u then
          t
        else
          let u' := f u in
          if Stdlib.op_eq_eq u' u then
            t
          else
            Constr.mkConstructU (c, u')
      | Sort (Sorts.Type u) =&gt;
        let u' := Univ.subst_instance_universe subst u in
        if Stdlib.op_eq_eq u' u then
          t
        else
          Constr.mkSort (Sorts.sort_of_univ u')
      | _ =&gt; Constr.map aux t
      end in
    aux c.

Definition univ_instantiate_constr
  (u : Univ.Instance.t) (c : Univ.univ_abstracted Constr.constr)
  : Constr.constr :=
  Int.equal (Univ.Instance.length u)
    (Univ.AUContext.size (univ_abstracted_binder c));
  subst_instance_constr u (univ_abstracted_value c).

Definition subst_instance_context
  (s : Univ.Instance.t) (ctx : Context.Rel.pt Constr.constr Constr.constr)
  : Context.Rel.pt Constr.constr Constr.constr :=
  if Univ.Instance.is_empty s then
    ctx
  else
    Context.Rel.map (fun x =&gt; subst_instance_constr s x) ctx.

Definition universes_of_constr (c : Constr.constr) : Univ.LSet.t :=
  let fix aux (s : Univ.LSet.t) (c : Constr.constr) : Univ.LSet.t :=
    match Constr.kind c with
    | Const (_c, u) =&gt; Univ.LSet.fold Univ.LSet.add (Univ.Instance.levels u) s
    | Ind ((_mind, _), u) | Construct (((_mind, _), _), u) =&gt;
      Univ.LSet.fold Univ.LSet.add (Univ.Instance.levels u) s
    | _ =&gt; Constr.fold aux s c
    end in
  aux Univ.LSet.empty c.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="vconv" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>vconv.ml</code>
            <pre>open Util
open Names
open Environ
open Reduction
open Vm
open Vmvalues
open Csymtable

(* Test la structure des piles *)

let compare_zipper z1 z2 =
  match z1, z2 with
  | Zapp args1, Zapp args2 -&gt; Int.equal (nargs args1) (nargs args2)
  | Zfix(_f1,args1), Zfix(_f2,args2) -&gt;  Int.equal (nargs args1) (nargs args2)
  | Zswitch _, Zswitch _ | Zproj _, Zproj _ -&gt; true
  | Zapp _ , _ | Zfix _, _ | Zswitch _, _ | Zproj _, _ -&gt; false

let rec compare_stack stk1 stk2 =
  match stk1, stk2 with
  | [], [] -&gt; true
  | z1::stk1, z2::stk2 -&gt;
      if compare_zipper z1 z2 then compare_stack stk1 stk2
      else false
  | _, _ -&gt; false

(* Conversion *)
let conv_vect fconv vect1 vect2 cu =
  let n = Array.length vect1 in
  if Int.equal n (Array.length vect2) then
    let rcu = ref cu in
    for i = 0 to n - 1 do
      rcu := fconv vect1.(i) vect2.(i) !rcu
    done;
    !rcu
  else raise NotConvertible

let rec conv_val env pb k v1 v2 cu =
  if v1 == v2 then cu
  else conv_whd env pb k (whd_val v1) (whd_val v2) cu

and conv_whd env pb k whd1 whd2 cu =
(*  Pp.(msg_debug (str &quot;conv_whd(&quot; ++ pr_whd whd1 ++ str &quot;, &quot; ++ pr_whd whd2 ++ str &quot;)&quot;)) ; *)
  match whd1, whd2 with
  | Vuniv_level _ , _
  | _ , Vuniv_level _ -&gt;
    (** Both of these are invalid since universes are handled via
     ** special cases in the code.
     **)
    assert false
  | Vprod p1, Vprod p2 -&gt;
      let cu = conv_val env CONV k (dom p1) (dom p2) cu in
      conv_fun env pb k (codom p1) (codom p2) cu
  | Vfun f1, Vfun f2 -&gt; conv_fun env CONV k f1 f2 cu
  | Vfix (f1,None), Vfix (f2,None) -&gt; conv_fix env k f1 f2 cu
  | Vfix (f1,Some args1), Vfix(f2,Some args2) -&gt;
      if nargs args1 &lt;&gt; nargs args2 then raise NotConvertible
      else conv_arguments env k args1 args2 (conv_fix env k f1 f2 cu)
  | Vcofix (cf1,_,None), Vcofix (cf2,_,None) -&gt; conv_cofix env k cf1 cf2 cu
  | Vcofix (cf1,_,Some args1), Vcofix (cf2,_,Some args2) -&gt;
      if nargs args1 &lt;&gt; nargs args2 then raise NotConvertible
      else conv_arguments env k args1 args2 (conv_cofix env k cf1 cf2 cu)
  | Vconstr_const i1, Vconstr_const i2 -&gt;
      if Int.equal i1 i2 then cu else raise NotConvertible
  | Vconstr_block b1, Vconstr_block b2 -&gt;
      let tag1 = btag b1 and tag2 = btag b2 in
      let sz = bsize b1 in
      if Int.equal tag1 tag2 &amp;&amp; Int.equal sz (bsize b2) then
	let rcu = ref cu in
	for i = 0 to sz - 1 do
	  rcu := conv_val env CONV k (bfield b1 i) (bfield b2 i) !rcu
	done;
	!rcu
      else raise NotConvertible
  | Vint64 i1, Vint64 i2 -&gt;
    if Int64.equal i1 i2 then cu else raise NotConvertible
  | Vatom_stk(a1,stk1), Vatom_stk(a2,stk2) -&gt;
      conv_atom env pb k a1 stk1 a2 stk2 cu
  | Vfun _, _ | _, Vfun _ -&gt;
     (* on the fly eta expansion *)
      conv_val env CONV (k+1) (apply_whd k whd1) (apply_whd k whd2) cu

  | Vprod _, _ | Vfix _, _ | Vcofix _, _  | Vconstr_const _, _ | Vint64 _, _
  | Vconstr_block _, _ | Vatom_stk _, _ -&gt; raise NotConvertible


and conv_atom env pb k a1 stk1 a2 stk2 cu =
(*  Pp.(msg_debug (str &quot;conv_atom(&quot; ++ pr_atom a1 ++ str &quot;, &quot; ++ pr_atom a2 ++ str &quot;)&quot;)) ; *)
  match a1, a2 with
  | Aind ((mi,_i) as ind1) , Aind ind2 -&gt;
    if eq_ind ind1 ind2 &amp;&amp; compare_stack stk1 stk2 then
      let ulen = Univ.AUContext.size (Environ.mind_context env mi) in
      if ulen = 0 then
        conv_stack env k stk1 stk2 cu
      else
        match stk1 , stk2 with
        | Zapp args1 :: stk1' , Zapp args2 :: stk2' -&gt;
          assert (ulen &lt;= nargs args1);
          assert (ulen &lt;= nargs args2);
          let u1 = Array.init ulen (fun i -&gt; uni_lvl_val (arg args1 i)) in
          let u2 = Array.init ulen (fun i -&gt; uni_lvl_val (arg args2 i)) in
          let u1 = Univ.Instance.of_array u1 in
          let u2 = Univ.Instance.of_array u2 in
          let cu = convert_instances ~flex:false u1 u2 cu in
          conv_arguments env ~from:ulen k args1 args2
	    (conv_stack env k stk1' stk2' cu)
        | _, _ -&gt; assert false (* Should not happen if problem is well typed *)
    else raise NotConvertible
  | Aid ik1, Aid ik2 -&gt;
    if Vmvalues.eq_id_key ik1 ik2 &amp;&amp; compare_stack stk1 stk2 then
	conv_stack env k stk1 stk2 cu
      else raise NotConvertible
  | Asort s1, Asort s2 -&gt;
    sort_cmp_universes env pb s1 s2 cu
  | Asort _ , _ | Aind _, _ | Aid _, _ -&gt; raise NotConvertible

and conv_stack env k stk1 stk2 cu =
  match stk1, stk2 with
  | [], [] -&gt; cu
  | Zapp args1 :: stk1, Zapp args2 :: stk2 -&gt;
      conv_stack env k stk1 stk2 (conv_arguments env k args1 args2 cu)
  | Zfix(f1,args1) :: stk1, Zfix(f2,args2) :: stk2 -&gt;
      conv_stack env k stk1 stk2
	(conv_arguments env k args1 args2 (conv_fix env k f1 f2 cu))
  | Zswitch sw1 :: stk1, Zswitch sw2 :: stk2 -&gt;
      if check_switch sw1 sw2 then
	let vt1,vt2 = type_of_switch sw1, type_of_switch sw2 in
	let rcu = ref (conv_val env CONV k vt1 vt2 cu) in
	let b1, b2 = branch_of_switch k sw1, branch_of_switch k sw2 in
	for i = 0 to Array.length b1 - 1 do
	  rcu :=
	    conv_val env CONV (k + fst b1.(i)) (snd b1.(i)) (snd b2.(i)) !rcu
	done;
	conv_stack env k stk1 stk2 !rcu
      else raise NotConvertible
  | Zproj p1 :: stk1, Zproj p2 :: stk2 -&gt;
    if Projection.Repr.equal p1 p2 then conv_stack env k stk1 stk2 cu
    else raise NotConvertible
  | [], _ | Zapp _ :: _, _ | Zfix _ :: _, _ | Zswitch _ :: _, _
  | Zproj _ :: _, _ -&gt; raise NotConvertible

and conv_fun env pb k f1 f2 cu =
  if f1 == f2 then cu
  else
    let arity,b1,b2 = decompose_vfun2 k f1 f2 in
    conv_val env pb (k+arity) b1 b2 cu

and conv_fix env k f1 f2 cu =
  if f1 == f2 then cu
  else
    if check_fix f1 f2 then
      let bf1, tf1 = reduce_fix k f1 in
      let bf2, tf2 = reduce_fix k f2 in
      let cu = conv_vect (conv_val env CONV k) tf1 tf2 cu in
      conv_vect (conv_fun env CONV (k + Array.length tf1)) bf1 bf2 cu
    else raise NotConvertible

and conv_cofix env k cf1 cf2 cu =
  if cf1 == cf2 then cu
  else
    if check_cofix cf1 cf2 then
      let bcf1, tcf1 = reduce_cofix k cf1 in
      let bcf2, tcf2 = reduce_cofix k cf2 in
      let cu = conv_vect (conv_val env CONV k) tcf1 tcf2 cu in
      conv_vect (conv_val env CONV (k + Array.length tcf1)) bcf1 bcf2 cu
    else raise NotConvertible

and conv_arguments env ?from:(from=0) k args1 args2 cu =
  if args1 == args2 then cu
  else
    let n = nargs args1 in
    if Int.equal n (nargs args2) then
      let rcu = ref cu in
      for i = from to n - 1 do
	rcu := conv_val env CONV k (arg args1 i) (arg args2 i) !rcu
      done;
      !rcu
    else raise NotConvertible

let warn_bytecode_compiler_failed =
  let open Pp in
  CWarnings.create ~name:&quot;bytecode-compiler-failed&quot; ~category:&quot;bytecode-compiler&quot;
         (fun () -&gt; strbrk &quot;Bytecode compiler failed, &quot; ++
                      strbrk &quot;falling back to standard conversion&quot;)

let vm_conv_gen cv_pb env univs t1 t2 =
  if not (typing_flags env).Declarations.enable_VM then
    Reduction.generic_conv cv_pb ~l2r:false (fun _ -&gt; None)
      TransparentState.full env univs t1 t2
  else
  try
    let v1 = val_of_constr env t1 in
    let v2 = val_of_constr env t2 in
    fst (conv_val env cv_pb (nb_rel env) v1 v2 univs)
  with Not_found | Invalid_argument _ -&gt;
    warn_bytecode_compiler_failed ();
    Reduction.generic_conv cv_pb ~l2r:false (fun _ -&gt; None)
      TransparentState.full env univs t1 t2

let vm_conv cv_pb env t1 t2 =
  let univs = Environ.universes env in
  let b =
    if cv_pb = CUMUL then Constr.leq_constr_univs univs t1 t2
    else Constr.eq_constr_univs univs t1 t2
  in
  if not b then
    let univs = (univs, checked_universes) in
    let _ = vm_conv_gen cv_pb env univs t1 t2 in ()
</pre>
          </div>
          <div class="col-md-6">
            <code>vconv.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Util.

Import Names.

Import Environ.

Import Reduction.

Import Vm.

Import Vmvalues.

Import Csymtable.

Definition compare_zipper (z1 : Vmvalues.zipper) (z2 : Vmvalues.zipper)
  : bool :=
  match (z1, z2) with
  | (Zapp args1, Zapp args2) =&gt;
    Int.equal (Vmvalues.nargs args1) (Vmvalues.nargs args2)
  | (Zfix _f1 args1, Zfix _f2 args2) =&gt;
    Int.equal (Vmvalues.nargs args1) (Vmvalues.nargs args2)
  | (Zswitch _, Zswitch _) | (Zproj _, Zproj _) =&gt; true
  | (Zapp _, _) | (Zfix _ _, _) | (Zswitch _, _) | (Zproj _, _) =&gt; false
  end.

Fixpoint compare_stack
  (stk1 : list Vmvalues.zipper) (stk2 : list Vmvalues.zipper) : bool :=
  match (stk1, stk2) with
  | ([], []) =&gt; true
  | (cons z1 stk1, cons z2 stk2) =&gt;
    if compare_zipper z1 z2 then
      compare_stack stk1 stk2
    else
      false
  | (_, _) =&gt; false
  end.

Definition conv_vect {A B C : Type}
  (fconv : A -&gt; B -&gt; C -&gt; C) (vect1 : array A) (vect2 : array B) (cu : C) : C :=
  let n := Util.Array.(CArray.ExtS.length) vect1 in
  if Int.equal n (Util.Array.(CArray.ExtS.length) vect2) then
    let rcu := Stdlib.ref cu in
    for;
    Util.op_exclamation rcu
  else
    Stdlib.raise NotConvertible.

Fixpoint conv_val {A : Type}
  (env : Environ.env) (pb : Reduction.conv_pb) (k : Z) (v1 : Vmvalues.values)
  (v2 : Vmvalues.values) (cu : A * (Reduction.universe_compare A))
  : A * (Reduction.universe_compare A) :=
  if Stdlib.op_eq_eq v1 v2 then
    cu
  else
    conv_whd env pb k (Vmvalues.whd_val v1) (Vmvalues.whd_val v2) cu

with conv_whd {A : Type}
  (env : Environ.env) (pb : Reduction.conv_pb) (k : Z) (whd1 : Vmvalues.whd)
  (whd2 : Vmvalues.whd) (cu : A * (Reduction.universe_compare A))
  : A * (Reduction.universe_compare A) :=
  match (whd1, whd2) with
  | (Vuniv_level _, _) | (_, Vuniv_level _) =&gt; false
  | (Vprod p1, Vprod p2) =&gt;
    let cu := conv_val env CONV k (Vmvalues.dom p1) (Vmvalues.dom p2) cu in
    conv_fun env pb k (Vmvalues.codom p1) (Vmvalues.codom p2) cu
  | (Vfun f1, Vfun f2) =&gt; conv_fun env CONV k f1 f2 cu
  | (Vfix f1 None, Vfix f2 None) =&gt; conv_fix env k f1 f2 cu
  | (Vfix f1 (Some args1), Vfix f2 (Some args2)) =&gt;
    if nequiv_decb (Vmvalues.nargs args1) (Vmvalues.nargs args2) then
      Stdlib.raise NotConvertible
    else
      conv_arguments env None k args1 args2 (conv_fix env k f1 f2 cu)
  | (Vcofix cf1 _ None, Vcofix cf2 _ None) =&gt; conv_cofix env k cf1 cf2 cu
  | (Vcofix cf1 _ (Some args1), Vcofix cf2 _ (Some args2)) =&gt;
    if nequiv_decb (Vmvalues.nargs args1) (Vmvalues.nargs args2) then
      Stdlib.raise NotConvertible
    else
      conv_arguments env None k args1 args2 (conv_cofix env k cf1 cf2 cu)
  | (Vconstr_const i1, Vconstr_const i2) =&gt;
    if Int.equal i1 i2 then
      cu
    else
      Stdlib.raise NotConvertible
  | (Vconstr_block b1, Vconstr_block b2) =&gt;
    let tag1 : Z :=
      Vmvalues.btag b1
    with tag2 : Z :=
      Vmvalues.btag b2 in
    let sz := Vmvalues.bsize b1 in
    if andb (Int.equal tag1 tag2) (Int.equal sz (Vmvalues.bsize b2)) then
      let rcu := Stdlib.ref cu in
      for;
      Util.op_exclamation rcu
    else
      Stdlib.raise NotConvertible
  | (Vint64 i1, Vint64 i2) =&gt;
    if Stdlib.Int64.equal i1 i2 then
      cu
    else
      Stdlib.raise NotConvertible
  | (Vatom_stk a1 stk1, Vatom_stk a2 stk2) =&gt;
    conv_atom env pb k a1 stk1 a2 stk2 cu
  | (Vfun _, _) | (_, Vfun _) =&gt;
    conv_val env CONV (Util.op_plus k 1) (Vm.apply_whd k whd1)
      (Vm.apply_whd k whd2) cu
  |
    (Vprod _, _) | (Vfix _ _, _) | (Vcofix _ _ _, _) | (Vconstr_const _, _) |
      (Vint64 _, _) | (Vconstr_block _, _) | (Vatom_stk _ _, _) =&gt;
    Stdlib.raise NotConvertible
  end

with conv_atom {A : Type}
  (env : Environ.env) (pb : Reduction.conv_pb) (k : Z) (a1 : Vmvalues.atom)
  (stk1 : Vmvalues.stack) (a2 : Vmvalues.atom) (stk2 : Vmvalues.stack)
  (cu : A * (Reduction.universe_compare A))
  : A * (Reduction.universe_compare A) :=
  match (a1, a2) with
  | (Aind ((mi, _i) as ind1), Aind ind2) =&gt;
    if andb (Names.eq_ind ind1 ind2) (compare_stack stk1 stk2) then
      let ulen := Univ.AUContext.size (Environ.mind_context env mi) in
      if equiv_decb ulen 0 then
        conv_stack env k stk1 stk2 cu
      else
        match (stk1, stk2) with
        | (cons (Zapp args1) stk1', cons (Zapp args2) stk2') =&gt;
          OCaml.Stdlib.le ulen (Vmvalues.nargs args1);
          OCaml.Stdlib.le ulen (Vmvalues.nargs args2);
          let u1 :=
            Util.Array.(CArray.ExtS.init) ulen
              (fun i =&gt; Vmvalues.uni_lvl_val (Vmvalues.arg args1 i)) in
          let u2 :=
            Util.Array.(CArray.ExtS.init) ulen
              (fun i =&gt; Vmvalues.uni_lvl_val (Vmvalues.arg args2 i)) in
          let u1 := Univ.Instance.of_array u1 in
          let u2 := Univ.Instance.of_array u2 in
          let cu := Reduction.convert_instances false u1 u2 cu in
          conv_arguments env (Some ulen) k args1 args2
            (conv_stack env k stk1' stk2' cu)
        | (_, _) =&gt; false
        end
    else
      Stdlib.raise NotConvertible
  | (Aid ik1, Aid ik2) =&gt;
    if andb (Vmvalues.eq_id_key ik1 ik2) (compare_stack stk1 stk2) then
      conv_stack env k stk1 stk2 cu
    else
      Stdlib.raise NotConvertible
  | (Asort s1, Asort s2) =&gt; Reduction.sort_cmp_universes env pb s1 s2 cu
  | (Asort _, _) | (Aind _, _) | (Aid _, _) =&gt; Stdlib.raise NotConvertible
  end

with conv_stack {A : Type}
  (env : Environ.env) (k : Z) (stk1 : Vmvalues.stack) (stk2 : Vmvalues.stack)
  (cu : A * (Reduction.universe_compare A))
  : A * (Reduction.universe_compare A) :=
  match (stk1, stk2) with
  | ([], []) =&gt; cu
  | (cons (Zapp args1) stk1, cons (Zapp args2) stk2) =&gt;
    conv_stack env k stk1 stk2 (conv_arguments env None k args1 args2 cu)
  | (cons (Zfix f1 args1) stk1, cons (Zfix f2 args2) stk2) =&gt;
    conv_stack env k stk1 stk2
      (conv_arguments env None k args1 args2 (conv_fix env k f1 f2 cu))
  | (cons (Zswitch sw1) stk1, cons (Zswitch sw2) stk2) =&gt;
    if Vmvalues.check_switch sw1 sw2 then
      match ((Vm.type_of_switch sw1), (Vm.type_of_switch sw2)) with
      | (vt1, vt2) =&gt;
        let rcu := Stdlib.ref (conv_val env CONV k vt1 vt2 cu) in
        match ((Vm.branch_of_switch k sw1), (Vm.branch_of_switch k sw2)) with
        | (b1, b2) =&gt;
          for;
          conv_stack env k stk1 stk2 (Util.op_exclamation rcu)
        end
      end
    else
      Stdlib.raise NotConvertible
  | (cons (Zproj p1) stk1, cons (Zproj p2) stk2) =&gt;
    if Names.Projection.Repr.equal p1 p2 then
      conv_stack env k stk1 stk2 cu
    else
      Stdlib.raise NotConvertible
  |
    ([], _) | (cons (Zapp _) _, _) | (cons (Zfix _ _) _, _) |
      (cons (Zswitch _) _, _) | (cons (Zproj _) _, _) =&gt;
    Stdlib.raise NotConvertible
  end

with conv_fun {A : Type}
  (env : Environ.env) (pb : Reduction.conv_pb) (k : Z) (f1 : Vmvalues.vfun)
  (f2 : Vmvalues.vfun) (cu : A * (Reduction.universe_compare A))
  : A * (Reduction.universe_compare A) :=
  if Stdlib.op_eq_eq f1 f2 then
    cu
  else
    match Vm.decompose_vfun2 k f1 f2 with
    | (arity, b1, b2) =&gt; conv_val env pb (Util.op_plus k arity) b1 b2 cu
    end

with conv_fix {A : Type}
  (env : Environ.env) (k : Z) (f1 : Vmvalues.vfix) (f2 : Vmvalues.vfix)
  (cu : A * (Reduction.universe_compare A))
  : A * (Reduction.universe_compare A) :=
  if Stdlib.op_eq_eq f1 f2 then
    cu
  else
    if Vmvalues.check_fix f1 f2 then
      match Vm.reduce_fix k f1 with
      | (bf1, tf1) =&gt;
        match Vm.reduce_fix k f2 with
        | (bf2, tf2) =&gt;
          let cu := conv_vect (conv_val env CONV k) tf1 tf2 cu in
          conv_vect
            (conv_fun env CONV
              (Util.op_plus k (Util.Array.(CArray.ExtS.length) tf1))) bf1 bf2 cu
        end
      end
    else
      Stdlib.raise NotConvertible

with conv_cofix {A : Type}
  (env : Environ.env) (k : Z) (cf1 : Vmvalues.vcofix) (cf2 : Vmvalues.vcofix)
  (cu : A * (Reduction.universe_compare A))
  : A * (Reduction.universe_compare A) :=
  if Stdlib.op_eq_eq cf1 cf2 then
    cu
  else
    if Vmvalues.check_cofix cf1 cf2 then
      match Vm.reduce_cofix k cf1 with
      | (bcf1, tcf1) =&gt;
        match Vm.reduce_cofix k cf2 with
        | (bcf2, tcf2) =&gt;
          let cu := conv_vect (conv_val env CONV k) tcf1 tcf2 cu in
          conv_vect
            (conv_val env CONV
              (Util.op_plus k (Util.Array.(CArray.ExtS.length) tcf1))) bcf1 bcf2
            cu
        end
      end
    else
      Stdlib.raise NotConvertible

with conv_arguments {A : Type}
  (env : Environ.env) (op_star_o_p_t_star : option Z)
  : Z -&gt;
    Vmvalues.arguments -&gt;
      Vmvalues.arguments -&gt;
        (A * (Reduction.universe_compare A)) -&gt;
          A * (Reduction.universe_compare A) :=
  let from :=
    match op_star_o_p_t_star with
    | Some op_star_s_t_h_star =&gt; op_star_s_t_h_star
    | None =&gt; 0
    end in
  fun k =&gt;
    fun args1 =&gt;
      fun args2 =&gt;
        fun cu =&gt;
          if Stdlib.op_eq_eq args1 args2 then
            cu
          else
            let n := Vmvalues.nargs args1 in
            if Int.equal n (Vmvalues.nargs args2) then
              let rcu := Stdlib.ref cu in
              for;
              Util.op_exclamation rcu
            else
              Stdlib.raise NotConvertible.

Definition warn_bytecode_compiler_failed : (option Loc.t) -&gt; unit -&gt; unit :=
  CWarnings.create &quot;bytecode-compiler-failed&quot; % string
    &quot;bytecode-compiler&quot; % string None
    (fun function_parameter =&gt;
      match function_parameter with
      | tt =&gt;
        Pp.op_plus_plus (Pp.strbrk &quot;Bytecode compiler failed, &quot; % string)
          (Pp.strbrk &quot;falling back to standard conversion&quot; % string)
      end).

Definition vm_conv_gen {A : Type}
  (cv_pb : Reduction.conv_pb) (env : Environ.env)
  (univs : Reduction.universe_state A) (t1 : Constr.constr) (t2 : Constr.constr)
  : A :=
  if negb (Declarations.enable_VM (Environ.typing_flags env)) then
    Reduction.generic_conv cv_pb false
      (fun function_parameter =&gt;
        match function_parameter with
        | _ =&gt; None
        end) TransparentState.full env univs t1 t2
  else
    try.

Definition vm_conv
  (cv_pb : Reduction.conv_pb) (env : Environ.env) (t1 : Constr.constr)
  (t2 : Constr.constr) : unit :=
  let univs := Environ.universes env in
  let b :=
    if equiv_decb cv_pb CUMUL then
      Constr.leq_constr_univs univs t1 t2
    else
      Constr.eq_constr_univs univs t1 t2 in
  if negb b then
    let univs := (univs, Reduction.checked_universes) in
    match vm_conv_gen cv_pb env univs t1 t2 with
    | _ =&gt; tt
    end
  else
    tt.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="vm" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>vm.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)
open Vmvalues

external set_drawinstr : unit -&gt; unit = &quot;coq_set_drawinstr&quot;

external mkPopStopCode : int -&gt; tcode = &quot;coq_pushpop&quot;

let popstop_tbl =  ref (Array.init 30 mkPopStopCode)

let popstop_code i =
  let len = Array.length !popstop_tbl in
  if i &lt; len then !popstop_tbl.(i)
  else
    begin
      popstop_tbl :=
	Array.init (i+10)
	  (fun j -&gt; if j &lt; len then !popstop_tbl.(j) else mkPopStopCode j);
      !popstop_tbl.(i)
    end

let stop = popstop_code 0

(************************************************)
(* Abstract machine *****************************)
(************************************************)

(* gestion de la pile *)
external push_ra : tcode -&gt; unit = &quot;coq_push_ra&quot;
external push_val : values -&gt; unit = &quot;coq_push_val&quot;
external push_arguments : arguments -&gt; unit = &quot;coq_push_arguments&quot;
external push_vstack : vstack -&gt; int -&gt; unit = &quot;coq_push_vstack&quot;


(* interpreteur *)
external coq_interprete : tcode -&gt; values -&gt; atom array -&gt; vm_global -&gt; vm_env -&gt; int -&gt; values =
  &quot;coq_interprete_byte&quot; &quot;coq_interprete_ml&quot;

let interprete code v env k =
  coq_interprete code v (get_atom_rel ()) (Csymtable.get_global_data ()) env k

(* Functions over arguments *)

(* Apply a value to arguments contained in [vargs] *)
let apply_arguments vf vargs =
  let n = nargs vargs in
  if Int.equal n 0 then fun_val vf
  else
   begin
     push_ra stop;
     push_arguments vargs;
     interprete (fun_code vf) (fun_val vf) (fun_env vf) (n - 1)
   end

(* Apply value [vf] to an array of argument values [varray] *)
let apply_varray vf varray =
  let n = Array.length varray in
  if Int.equal n 0 then fun_val vf
  else
    begin
      push_ra stop;
      (* The fun code of [vf] will make sure we have enough stack, so we put 0
         here. *)
      push_vstack varray 0;
      interprete (fun_code vf) (fun_val vf) (fun_env vf) (n - 1)
    end

let mkrel_vstack k arity =
  let max = k + arity - 1 in
  Array.init arity (fun i -&gt; val_of_rel (max - i))

let reduce_fun k vf =
  let vargs = mkrel_vstack k 1 in
  apply_varray vf vargs

let decompose_vfun2 k vf1 vf2 =
  let arity = min (closure_arity vf1) (closure_arity vf2) in
  assert (0 &lt; arity &amp;&amp; arity &lt; Sys.max_array_length);
  let vargs = mkrel_vstack k arity in
  let v1 = apply_varray vf1 vargs in
  let v2 = apply_varray vf2 vargs in
  arity, v1, v2

(* Functions over vfix *)

let reduce_fix k vf =
  let fb = first_fix vf in
  (* computing types *)
  let fc_typ = fix_types fb in
  let ndef = Array.length fc_typ in
  let et = offset_closure_fix fb (2*(ndef - 1)) in
  let ftyp =
    Array.map
      (fun c -&gt; interprete c crazy_val et 0) fc_typ in
  (* Construction of the environment of fix bodies *)
  (mk_fix_body k ndef fb, ftyp)

let reduce_cofix k vcf =
  let fc_typ = cofix_types vcf in
  let ndef = Array.length fc_typ in
  let ftyp =
    (* Evaluate types *)
    Array.map (fun c -&gt; interprete c crazy_val (cofix_env vcf) 0) fc_typ in

  (* Construction of the environment of cofix bodies *)
  (mk_cofix_body apply_varray k ndef vcf, ftyp)

let type_of_switch sw =
  (* The fun code of types will make sure we have enough stack, so we put 0
  here. *)
  push_vstack sw.sw_stk 0;
  interprete sw.sw_type_code crazy_val sw.sw_env 0

let apply_switch sw arg =
  let tc = sw.sw_annot.tailcall in
  if tc then
    (push_ra stop;push_vstack sw.sw_stk sw.sw_annot.max_stack_size)
  else
    (push_vstack sw.sw_stk sw.sw_annot.max_stack_size;
     push_ra (popstop_code (Array.length sw.sw_stk)));
  interprete sw.sw_code arg sw.sw_env 0

let branch_of_switch k sw =
  let eval_branch (_,arity as ta) =
    let arg = branch_arg k ta in
    let v = apply_switch sw arg in
    (arity, v)
  in
  Array.map eval_branch sw.sw_annot.rtbl

(* Apply the term represented by a under stack stk to argument v *)
(* t = a stk --&gt; t v *)
let rec apply_stack a stk v =
  match stk with
  | [] -&gt; apply_varray (fun_of_val a) [|v|]
  | Zapp args :: stk -&gt; apply_stack (apply_arguments (fun_of_val a) args) stk v
  | Zproj kn :: stk -&gt; apply_stack (val_of_proj kn a) stk v
  | Zfix(f,args) :: stk -&gt;
      let a,stk = 
	match stk with
	| Zapp args' :: stk -&gt;
	    push_ra stop;
	    push_arguments args';
	    push_val a;
	    push_arguments args;
	    let a =
              interprete (fix_code f) (fix_val f) (fix_env f)
		(nargs args+ nargs args') in
	    a, stk
	| _ -&gt; 
	    push_ra stop;
	    push_val a;
	    push_arguments args;
	    let a =
              interprete (fix_code f) (fix_val f) (fix_env f)
		(nargs args) in
	    a, stk in
      apply_stack a stk v
  | Zswitch sw :: stk -&gt;
      apply_stack (apply_switch sw a) stk v

let apply_whd k whd =
  let v = val_of_rel k in
  match whd with
  | Vprod _ | Vconstr_const _ | Vconstr_block _ | Vint64 _ -&gt; assert false
  | Vfun f -&gt; reduce_fun k f
  | Vfix(f, None) -&gt; 
      push_ra stop;
      push_val v;
      interprete (fix_code f) (fix_val f) (fix_env f) 0
  | Vfix(f, Some args) -&gt;
      push_ra stop;
      push_val v;
      push_arguments args;
      interprete (fix_code f) (fix_val f) (fix_env f) (nargs args)
  | Vcofix(_,to_up,_) -&gt;
      push_ra stop;
      push_val v;
      interprete (cofix_upd_code to_up) (cofix_upd_val to_up) (cofix_upd_env to_up) 0
  | Vatom_stk(a,stk) -&gt;
      apply_stack (val_of_atom a) stk v
  | Vuniv_level _lvl -&gt; assert false

</pre>
          </div>
          <div class="col-md-6">
            <code>vm.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Vmvalues.

Definition popstop_tbl : Stdlib.ref (array Vmvalues.tcode) :=
  Stdlib.ref (Stdlib.Array.init 30 mkPopStopCode).

Definition popstop_code (i : Z) : Vmvalues.tcode :=
  let len := Stdlib.Array.length (Stdlib.op_exclamation popstop_tbl) in
  if OCaml.Stdlib.lt i len then
    Stdlib.Array.get (Stdlib.op_exclamation popstop_tbl) i
  else
    Stdlib.op_colon_eq popstop_tbl
      (Stdlib.Array.init (Z.add i 10)
        (fun j =&gt;
          if OCaml.Stdlib.lt j len then
            Stdlib.Array.get (Stdlib.op_exclamation popstop_tbl) j
          else
            mkPopStopCode j));
    Stdlib.Array.get (Stdlib.op_exclamation popstop_tbl) i.

Definition stop : Vmvalues.tcode := popstop_code 0.

Definition interprete
  (code : Vmvalues.tcode) (v : Vmvalues.values) (env : Vmvalues.vm_env) (k : Z)
  : Vmvalues.values :=
  coq_interprete code v (Vmvalues.get_atom_rel tt)
    (Csymtable.get_global_data tt) env k.

Definition apply_arguments (vf : Vmvalues.vfun) (vargs : Vmvalues.arguments)
  : Vmvalues.values :=
  let n := Vmvalues.nargs vargs in
  if Int.equal n 0 then
    Vmvalues.fun_val vf
  else
    push_ra stop;
    push_arguments vargs;
    interprete (Vmvalues.fun_code vf) (Vmvalues.fun_val vf)
      (Vmvalues.fun_env vf) (Z.sub n 1).

Definition apply_varray (vf : Vmvalues.vfun) (varray : Vmvalues.vstack)
  : Vmvalues.values :=
  let n := Stdlib.Array.length varray in
  if Int.equal n 0 then
    Vmvalues.fun_val vf
  else
    push_ra stop;
    push_vstack varray 0;
    interprete (Vmvalues.fun_code vf) (Vmvalues.fun_val vf)
      (Vmvalues.fun_env vf) (Z.sub n 1).

Definition mkrel_vstack (k : Z) (arity : Z) : array Vmvalues.values :=
  let max := Z.sub (Z.add k arity) 1 in
  Stdlib.Array.init arity (fun i =&gt; Vmvalues.val_of_rel (Z.sub max i)).

Definition reduce_fun (k : Z) (vf : Vmvalues.vfun) : Vmvalues.values :=
  let vargs := mkrel_vstack k 1 in
  apply_varray vf vargs.

Definition decompose_vfun2 (k : Z) (vf1 : Vmvalues.vfun) (vf2 : Vmvalues.vfun)
  : Z * Vmvalues.values * Vmvalues.values :=
  let arity :=
    OCaml.Stdlib.min (Vmvalues.closure_arity vf1) (Vmvalues.closure_arity vf2)
    in
  andb (OCaml.Stdlib.lt 0 arity)
    (OCaml.Stdlib.lt arity Stdlib.Sys.max_array_length);
  let vargs := mkrel_vstack k arity in
  let v1 := apply_varray vf1 vargs in
  let v2 := apply_varray vf2 vargs in
  (arity, v1, v2).

Definition reduce_fix (k : Z) (vf : Vmvalues.vfix)
  : (array Vmvalues.vfun) * (array Vmvalues.values) :=
  let fb := Vmvalues.first_fix vf in
  let fc_typ := Vmvalues.fix_types fb in
  let ndef := Stdlib.Array.length fc_typ in
  let et := Vmvalues.offset_closure_fix fb (Z.mul 2 (Z.sub ndef 1)) in
  let ftyp :=
    Stdlib.Array.map (fun c =&gt; interprete c Vmvalues.crazy_val et 0) fc_typ in
  ((Vmvalues.mk_fix_body k ndef fb), ftyp).

Definition reduce_cofix (k : Z) (vcf : Vmvalues.vcofix)
  : (array Vmvalues.values) * (array Vmvalues.values) :=
  let fc_typ := Vmvalues.cofix_types vcf in
  let ndef := Stdlib.Array.length fc_typ in
  let ftyp :=
    Stdlib.Array.map
      (fun c =&gt; interprete c Vmvalues.crazy_val (Vmvalues.cofix_env vcf) 0)
      fc_typ in
  ((Vmvalues.mk_cofix_body apply_varray k ndef vcf), ftyp).

Definition type_of_switch (sw : Vmvalues.vswitch) : Vmvalues.values :=
  push_vstack (sw_stk sw) 0;
  interprete (sw_type_code sw) Vmvalues.crazy_val (sw_env sw) 0.

Definition apply_switch (sw : Vmvalues.vswitch) (arg : Vmvalues.values)
  : Vmvalues.values :=
  let tc := tailcall (sw_annot sw) in
  if tc then
    push_ra stop;
    push_vstack (sw_stk sw) (max_stack_size (sw_annot sw))
  else
    push_vstack (sw_stk sw) (max_stack_size (sw_annot sw));
    push_ra (popstop_code (Stdlib.Array.length (sw_stk sw)));
  interprete (sw_code sw) arg (sw_env sw) 0.

Definition branch_of_switch (k : Z) (sw : Vmvalues.vswitch)
  : array (Z * Vmvalues.values) :=
  let eval_branch (function_parameter : Vmvalues.tag * Z)
    : Z * Vmvalues.values :=
    match function_parameter with
    | (_, arity) as ta =&gt;
      let arg := Vmvalues.branch_arg k ta in
      let v := apply_switch sw arg in
      (arity, v)
    end in
  Stdlib.Array.map eval_branch (rtbl (sw_annot sw)).

Fixpoint apply_stack
  (a : Vmvalues.values) (stk : list Vmvalues.zipper) (v : Vmvalues.values)
  : Vmvalues.values :=
  match stk with
  | [] =&gt; apply_varray (Vmvalues.fun_of_val a) (v)
  | cons (Zapp args) stk =&gt;
    apply_stack (apply_arguments (Vmvalues.fun_of_val a) args) stk v
  | cons (Zproj kn) stk =&gt; apply_stack (Vmvalues.val_of_proj kn a) stk v
  | cons (Zfix f args) stk =&gt;
    match
      match stk with
      | cons (Zapp args') stk =&gt;
        push_ra stop;
        push_arguments args';
        push_val a;
        push_arguments args;
        let a :=
          interprete (Vmvalues.fix_code f) (Vmvalues.fix_val f)
            (Vmvalues.fix_env f)
            (Z.add (Vmvalues.nargs args) (Vmvalues.nargs args')) in
        (a, stk)
      | _ =&gt;
        push_ra stop;
        push_val a;
        push_arguments args;
        let a :=
          interprete (Vmvalues.fix_code f) (Vmvalues.fix_val f)
            (Vmvalues.fix_env f) (Vmvalues.nargs args) in
        (a, stk)
      end with
    | (a, stk) =&gt; apply_stack a stk v
    end
  | cons (Zswitch sw) stk =&gt; apply_stack (apply_switch sw a) stk v
  end.

Definition apply_whd (k : Z) (whd : Vmvalues.whd) : Vmvalues.values :=
  let v := Vmvalues.val_of_rel k in
  match whd with
  | Vprod _ | Vconstr_const _ | Vconstr_block _ | Vint64 _ =&gt; false
  | Vfun f =&gt; reduce_fun k f
  | Vfix f None =&gt;
    push_ra stop;
    push_val v;
    interprete (Vmvalues.fix_code f) (Vmvalues.fix_val f) (Vmvalues.fix_env f) 0
  | Vfix f (Some args) =&gt;
    push_ra stop;
    push_val v;
    push_arguments args;
    interprete (Vmvalues.fix_code f) (Vmvalues.fix_val f) (Vmvalues.fix_env f)
      (Vmvalues.nargs args)
  | Vcofix _ to_up _ =&gt;
    push_ra stop;
    push_val v;
    interprete (Vmvalues.cofix_upd_code to_up) (Vmvalues.cofix_upd_val to_up)
      (Vmvalues.cofix_upd_env to_up) 0
  | Vatom_stk a stk =&gt; apply_stack (Vmvalues.val_of_atom a) stk v
  | Vuniv_level _lvl =&gt; false
  end.</pre>
          </div>
        </div>
        
        <hr />
        <div class="row" id="vmvalues" style="padding-bottom: 20px; padding-top: 20px;">
          <div class="col-md-6">
            <code>vmvalues.ml</code>
            <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2019       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)
open Names
open Univ
open Constr

(********************************************)
(* Initialization of the abstract machine ***)
(* Necessary for [relaccu_tbl]              *)
(********************************************)

external init_vm : unit -&gt; unit = &quot;init_coq_vm&quot;

let _ = init_vm ()

(******************************************************)
(* Abstract data types and utility functions **********)
(******************************************************)

(* The representation of values relies on this assertion *)
let _ = assert (Int.equal Obj.first_non_constant_constructor_tag 0)

(* Values of the abstract machine *)
type values
type structured_values = values
let val_of_obj v = ((Obj.obj v):values)
let crazy_val = (val_of_obj (Obj.repr 0))

type tag = int

let accu_tag = 0

let type_atom_tag = 2
let max_atom_tag = 2
let proj_tag = 3
let fix_app_tag = 4
let switch_tag = 5
let cofix_tag = 6
let cofix_evaluated_tag = 7

(** Structured constants are constants whose construction is done once. Their
occurrences share the same value modulo kernel name substitutions (for functor
application). Structured values have the additional property that no
substitution will need to be performed, so their runtime value can directly be
shared without reallocating a more structured representation. *)
type structured_constant =
  | Const_sort of Sorts.t
  | Const_ind of inductive
  | Const_b0 of tag
  | Const_univ_level of Univ.Level.t
  | Const_val of structured_values
  | Const_uint of Uint63.t

type reloc_table = (tag * int) array

type annot_switch =
   {ci : case_info; rtbl : reloc_table; tailcall : bool; max_stack_size : int}

let rec eq_structured_values v1 v2 =
  v1 == v2 ||
  let o1 = Obj.repr v1 in
  let o2 = Obj.repr v2 in
  if Obj.is_int o1 &amp;&amp; Obj.is_int o2 then o1 == o2
  else
    let t1 = Obj.tag o1 in
    let t2 = Obj.tag o2 in
    if Int.equal t1 t2 &amp;&amp;
       Int.equal (Obj.size o1) (Obj.size o2)
    then if Int.equal t1 Obj.custom_tag
      then Int64.equal (Obj.magic v1 : int64) (Obj.magic v2 : int64)
    else begin
      assert (t1 &lt;= Obj.last_non_constant_constructor_tag &amp;&amp;
              t2 &lt;= Obj.last_non_constant_constructor_tag);
      let i = ref 0 in
      while (!i &lt; Obj.size o1 &amp;&amp; eq_structured_values
               (Obj.magic (Obj.field o1 !i) : structured_values)
               (Obj.magic (Obj.field o2 !i) : structured_values)) do
        incr i
      done;
      !i &gt;= Obj.size o1
    end
    else false

let hash_structured_values (v : structured_values) =
  (* We may want a better hash function here *)
  Hashtbl.hash v

let eq_structured_constant c1 c2 = match c1, c2 with
| Const_sort s1, Const_sort s2 -&gt; Sorts.equal s1 s2
| Const_sort _, _ -&gt; false
| Const_ind i1, Const_ind i2 -&gt; eq_ind i1 i2
| Const_ind _, _ -&gt; false
| Const_b0 t1, Const_b0 t2 -&gt; Int.equal t1 t2
| Const_b0 _, _ -&gt; false
| Const_univ_level l1 , Const_univ_level l2 -&gt; Univ.Level.equal l1 l2
| Const_univ_level _ , _ -&gt; false
| Const_val v1, Const_val v2 -&gt; eq_structured_values v1 v2
| Const_val _, _ -&gt; false
| Const_uint i1, Const_uint i2 -&gt; Uint63.equal i1 i2
| Const_uint _, _ -&gt; false

let hash_structured_constant c =
  let open Hashset.Combine in
  match c with
  | Const_sort s -&gt; combinesmall 1 (Sorts.hash s)
  | Const_ind i -&gt; combinesmall 2 (ind_hash i)
  | Const_b0 t -&gt; combinesmall 3 (Int.hash t)
  | Const_univ_level l -&gt; combinesmall 4 (Univ.Level.hash l)
  | Const_val v -&gt; combinesmall 5 (hash_structured_values v)
  | Const_uint i -&gt; combinesmall 6 (Uint63.hash i)

let eq_annot_switch asw1 asw2 =
  let eq_ci ci1 ci2 =
    eq_ind ci1.ci_ind ci2.ci_ind &amp;&amp;
    Int.equal ci1.ci_npar ci2.ci_npar &amp;&amp;
    CArray.equal Int.equal ci1.ci_cstr_ndecls ci2.ci_cstr_ndecls
  in
  let eq_rlc (i1, j1) (i2, j2) = Int.equal i1 i2 &amp;&amp; Int.equal j1 j2 in
  eq_ci asw1.ci asw2.ci &amp;&amp;
  CArray.equal eq_rlc asw1.rtbl asw2.rtbl &amp;&amp;
  (asw1.tailcall : bool) == asw2.tailcall

let hash_annot_switch asw =
  let open Hashset.Combine in
  let h1 = Constr.case_info_hash asw.ci in
  let h2 = Array.fold_left (fun h (t, i) -&gt; combine3 h t i) 0 asw.rtbl in
  let h3 = if asw.tailcall then 1 else 0 in
  combine3 h1 h2 h3

let pp_sort s =
  let open Sorts in
  match s with
  | SProp -&gt; Pp.str &quot;SProp&quot;
  | Prop -&gt; Pp.str &quot;Prop&quot;
  | Set -&gt; Pp.str &quot;Set&quot;
  | Type u -&gt; Pp.(str &quot;Type@{&quot; ++ Univ.pr_uni u ++ str &quot;}&quot;)

let pp_struct_const = function
  | Const_sort s -&gt; pp_sort s
  | Const_ind (mind, i) -&gt; Pp.(MutInd.print mind ++ str&quot;#&quot; ++ int i)
  | Const_b0 i -&gt; Pp.int i
  | Const_univ_level l -&gt; Univ.Level.pr l
  | Const_val _ -&gt; Pp.str &quot;(value)&quot;
  | Const_uint i -&gt; Pp.str (Uint63.to_string i)

(* Abstract data *)
type vprod
type vfun
type vfix
type vcofix
type vblock
type arguments

let fun_val v = (Obj.magic v : values)
let fix_val v = (Obj.magic v : values)
let cofix_upd_val v = (Obj.magic v : values)

type vm_env
type vm_global
let fun_env v = (Obj.magic v : vm_env)
let fix_env v = (Obj.magic v : vm_env)
let cofix_env v = (Obj.magic v : vm_env)
let cofix_upd_env v = (Obj.magic v : vm_env)
type vstack = values array

let fun_of_val v = (Obj.magic v : vfun)

let vm_global (v : values array) = (Obj.magic v : vm_global)

(*******************************************)
(* Machine code *** ************************)
(*******************************************)

type tcode
(** A block whose first field is a C-allocated VM bytecode, encoded as char*.
    This is compatible with the representation of the Coq VM closures. *)

type tcode_array

external mkAccuCode : int -&gt; tcode = &quot;coq_makeaccu&quot;
external offset_tcode : tcode -&gt; int -&gt; tcode = &quot;coq_offset_tcode&quot;

let fun_code v = (Obj.magic v : tcode)
let fix_code = fun_code
let cofix_upd_code = fun_code


type vswitch = {
    sw_type_code : tcode;
    sw_code : tcode;
    sw_annot : annot_switch;
    sw_stk : vstack;
    sw_env : vm_env
  }

(* Representation of values *)
(* + Products : *)
(*   -   vprod = 0_[ dom | codom]                                         *)
(*             dom : values, codom : vfun                                 *)
(*                                                                        *)
(* + Functions have two representations :                                 *)
(*   - unapplied fun :  vf = Ct_[ C | fv1 | ... | fvn]                    *)
(*                                       C:tcode, fvi : values            *)
(*     Remark : a function and its environment is the same value.         *)
(*   - partially applied fun : Ct_[Restart:C| vf | arg1 | ... argn]       *)
(*                                                                        *)
(* + Fixpoints :                                                          *)
(*   -        Ct_[C1|Infix_t|C2|...|Infix_t|Cn|fv1|...|fvn]               *)
(*     One single block to represent all of the fixpoints, each fixpoint  *)
(*     is the pointer to the field holding the pointer to its code, and   *)
(*     the infix tag is used to know where the block starts.              *)
(*   - Partial application follows the scheme of partially applied        *)
(*     functions. Note: only fixpoints not having been applied to its     *)
(*     recursive argument are coded this way. When the rec. arg. is       *)
(*     applied, either it's a constructor and the fix reduces, or it's    *)
(*     and the fix is coded as an accumulator.                            *)
(*                                                                        *)
(* + Cofixpoints : see cbytegen.ml                                        *)
(*                                                                        *)
(* + vblock's encode (non constant) constructors as in Ocaml, but         *)
(*   starting from 0 up. tag 0 ( = accu_tag) is reserved for              *)
(*   accumulators.                                                        *)
(*                                                                        *)
(* + vm_env is the type of the machine environments (i.e. a function or   *)
(*   a fixpoint)                                                          *)
(*                                                                        *)
(* + Accumulators : At_[accumulate| accu | arg1 | ... | argn ]            *)
(*   - representation of [accu] : tag_[....]                              *)
(*     -- tag &lt;= 3 : encoding atom type (sorts, free vars, etc.)          *)
(*     -- 10_[accu|proj name] : a projection blocked by an accu           *)
(*     -- 11_[accu|fix_app] : a fixpoint blocked by an accu               *)
(*     -- 12_[accu|vswitch] : a match blocked by an accu                  *)
(*     -- 13_[fcofix]       : a cofix function                            *)
(*     -- 14_[fcofix|val]   : a cofix function, val represent the value   *)
(*        of the function applied to arg1 ... argn                        *)
(* The [arguments] type, which is abstracted as an array, represents :    *)
(*          tag[ _ | _ |v1|... | vn]                                      *)
(* Generally the first field is a code pointer.                           *)

(* Do not edit this type without editing C code, especially &quot;coq_values.h&quot; *)

type id_key =
| ConstKey of Constant.t
| VarKey of Id.t
| RelKey of Int.t
| EvarKey of Evar.t

let eq_id_key (k1 : id_key) (k2 : id_key) = match k1, k2 with
| ConstKey c1, ConstKey c2 -&gt; Constant.equal c1 c2
| VarKey id1, VarKey id2 -&gt; Id.equal id1 id2
| RelKey n1, RelKey n2 -&gt; Int.equal n1 n2
| EvarKey evk1, EvarKey evk2 -&gt; Evar.equal evk1 evk2
| _ -&gt; false

type atom =
  | Aid of id_key
  | Aind of inductive
  | Asort of Sorts.t

(* Zippers *)

type zipper =
  | Zapp of arguments
  | Zfix of vfix*arguments  (* Possibly empty *)
  | Zswitch of vswitch
  | Zproj of Projection.Repr.t (* name of the projection *)

type stack = zipper list

type to_update = values

type whd =
  | Vprod of vprod
  | Vfun of vfun
  | Vfix of vfix * arguments option
  | Vcofix of vcofix * to_update * arguments option
  | Vconstr_const of int
  | Vconstr_block of vblock
  | Vint64 of int64
  | Vatom_stk of atom * stack
  | Vuniv_level of Univ.Level.t

(* Functions over arguments *)
let nargs : arguments -&gt; int = fun args -&gt; (Obj.size (Obj.repr args)) - 2
let arg args i =
  if  0 &lt;= i &amp;&amp; i &lt; (nargs args) then
    val_of_obj (Obj.field (Obj.repr args) (i+2))
  else invalid_arg
                (&quot;Vm.arg size = &quot;^(string_of_int (nargs args))^
                 &quot; acces &quot;^(string_of_int i))

(*************************************************)
(* Destructors ***********************************)
(*************************************************)

let uni_lvl_val (v : values) : Univ.Level.t =
    let whd = Obj.magic v in
    match whd with
    | Vuniv_level lvl -&gt; lvl
    | _ -&gt;
      let pr =
        let open Pp in
        match whd with
        | Vprod _ -&gt; str &quot;Vprod&quot;
        | Vfun _ -&gt; str &quot;Vfun&quot;
        | Vfix _ -&gt; str &quot;Vfix&quot;
        | Vcofix _ -&gt; str &quot;Vcofix&quot;
        | Vconstr_const _i -&gt; str &quot;Vconstr_const&quot;
        | Vconstr_block _b -&gt; str &quot;Vconstr_block&quot;
        | Vint64 _ -&gt; str &quot;Vint64&quot;
        | Vatom_stk (_a,_stk) -&gt; str &quot;Vatom_stk&quot;
        | Vuniv_level _ -&gt; assert false
      in
      CErrors.anomaly
        Pp.(   strbrk &quot;Parsing virtual machine value expected universe level, got &quot;
            ++ pr ++ str &quot;.&quot;)

let rec whd_accu a stk =
  let stk =
    if Int.equal (Obj.size a) 2 then stk
    else Zapp (Obj.obj a) :: stk in
  let at = Obj.field a 1 in
  match Obj.tag at with
  | i when Int.equal i type_atom_tag -&gt;
     begin match stk with
     | [] -&gt; Vatom_stk(Obj.magic at, stk)
     | [Zapp args] -&gt;
        let args = Array.init (nargs args) (arg args) in
        let s = Obj.obj (Obj.field at 0) in
        begin match s with
        | Sorts.Type u -&gt;
          let inst = Instance.of_array (Array.map uni_lvl_val args) in
          let u = Univ.subst_instance_universe inst u in
          Vatom_stk (Asort (Sorts.sort_of_univ u), [])
        | _ -&gt; assert false
        end
     | _ -&gt; assert false
     end
  | i when i &lt;= max_atom_tag -&gt;
      Vatom_stk(Obj.magic at, stk)
  | i when Int.equal i proj_tag -&gt;
     let zproj = Zproj (Obj.obj (Obj.field at 0)) in
     whd_accu (Obj.field at 1) (zproj :: stk)
  | i when Int.equal i fix_app_tag -&gt;
      let fa = Obj.field at 1 in
      let zfix  =
        Zfix (Obj.obj (Obj.field fa 1), Obj.obj fa) in
      whd_accu (Obj.field at 0) (zfix :: stk)
  | i when Int.equal i switch_tag -&gt;
      let zswitch = Zswitch (Obj.obj (Obj.field at 1)) in
      whd_accu (Obj.field at 0) (zswitch :: stk)
  | i when Int.equal i cofix_tag -&gt;
      let vcfx = Obj.obj (Obj.field at 0) in
      let to_up = Obj.obj a in
      begin match stk with
      | []          -&gt; Vcofix(vcfx, to_up, None)
      | [Zapp args] -&gt; Vcofix(vcfx, to_up, Some args)
      | _           -&gt; assert false
      end
  | i when Int.equal i cofix_evaluated_tag -&gt;
      let vcofix = Obj.obj (Obj.field at 0) in
      let res = Obj.obj a in
      begin match stk with
      | []          -&gt; Vcofix(vcofix, res, None)
      | [Zapp args] -&gt; Vcofix(vcofix, res, Some args)
      | _           -&gt; assert false
      end
  | i when Int.equal i Obj.custom_tag -&gt;
    Vint64 (Obj.magic i)
  | tg -&gt;
    CErrors.anomaly
      Pp.(strbrk &quot;Failed to parse VM value. Tag = &quot; ++ int tg ++ str &quot;.&quot;)

external kind_of_closure : Obj.t -&gt; int = &quot;coq_kind_of_closure&quot;
external is_accumulate : tcode -&gt; bool = &quot;coq_is_accumulate_code&quot;
external int_tcode : tcode -&gt; int -&gt; int = &quot;coq_int_tcode&quot;
external accumulate : unit -&gt; tcode = &quot;accumulate_code&quot;
external set_bytecode_field : Obj.t -&gt; int -&gt; tcode -&gt; unit = &quot;coq_set_bytecode_field&quot;
let accumulate = accumulate ()

let whd_val : values -&gt; whd =
  fun v -&gt;
    let o = Obj.repr v in
    if Obj.is_int o then Vconstr_const (Obj.obj o)
    else
      let tag = Obj.tag o in
      if tag = accu_tag then
        if is_accumulate (fun_code o) then whd_accu o []
        else Vprod(Obj.obj o)
      else
        if tag = Obj.closure_tag || tag = Obj.infix_tag then
          (match kind_of_closure o with
           | 0 -&gt; Vfun(Obj.obj o)
           | 1 -&gt; Vfix(Obj.obj o, None)
           | 2 -&gt; Vfix(Obj.obj (Obj.field o 1), Some (Obj.obj o))
           | 3 -&gt; Vatom_stk(Aid(RelKey(int_tcode (fun_code o) 1)), [])
           | _ -&gt; CErrors.anomaly ~label:&quot;Vm.whd &quot; (Pp.str &quot;kind_of_closure does not work.&quot;))
        else if Int.equal tag Obj.custom_tag then Vint64 (Obj.magic v)
        else
           Vconstr_block(Obj.obj o)

(**********************************************)
(* Constructors *******************************)
(**********************************************)

let obj_of_atom : atom -&gt; Obj.t =
  fun a -&gt;
    let res = Obj.new_block accu_tag 2 in
    set_bytecode_field res 0 accumulate;
    Obj.set_field res 1 (Obj.repr a);
    res

(* obj_of_str_const : structured_constant -&gt; Obj.t *)
let obj_of_str_const str =
  match str with
  | Const_sort s -&gt; obj_of_atom (Asort s)
  | Const_ind ind -&gt; obj_of_atom (Aind ind)
  | Const_b0 tag -&gt; Obj.repr tag
  | Const_univ_level l -&gt; Obj.repr (Vuniv_level l)
  | Const_val v -&gt; Obj.repr v
  | Const_uint i -&gt; Obj.repr i

let val_of_block tag (args : structured_values array) =
  let nargs = Array.length args in
  let r = Obj.new_block tag nargs in
  for i = 0 to nargs - 1 do
    Obj.set_field r i (Obj.repr args.(i))
  done;
  (Obj.magic r : structured_values)

let val_of_obj o = ((Obj.obj o) : values)

let val_of_str_const str = val_of_obj (obj_of_str_const str)

let val_of_atom a = val_of_obj (obj_of_atom a)

let val_of_int i = (Obj.magic i : values)

let val_of_uint i = (Obj.magic i : values)

let atom_of_proj kn v =
  let r = Obj.new_block proj_tag 2 in
  Obj.set_field r 0 (Obj.repr kn);
  Obj.set_field r 1 (Obj.repr v);
  ((Obj.obj r) : atom)

let val_of_proj kn v =
  val_of_atom (atom_of_proj kn v)

module IdKeyHash =
struct
  type t = id_key
  let equal = eq_id_key
  open Hashset.Combine
  let hash : t -&gt; tag = function
  | ConstKey c -&gt; combinesmall 1 (Constant.hash c)
  | VarKey id -&gt; combinesmall 2 (Id.hash id)
  | RelKey i -&gt; combinesmall 3 (Int.hash i)
  | EvarKey evk -&gt; combinesmall 4 (Evar.hash evk)
end

module KeyTable = Hashtbl.Make(IdKeyHash)

let idkey_tbl = KeyTable.create 31

let val_of_idkey key =
  try KeyTable.find idkey_tbl key
  with Not_found -&gt;
    let v = val_of_atom (Aid key) in
    KeyTable.add idkey_tbl key v;
    v

let val_of_rel k = val_of_idkey (RelKey k)

let val_of_named id = val_of_idkey (VarKey id)

let val_of_constant c = val_of_idkey (ConstKey c)

let val_of_evar evk = val_of_idkey (EvarKey evk)

external val_of_annot_switch : annot_switch -&gt; values = &quot;%identity&quot;
external val_of_proj_name : Projection.Repr.t -&gt; values = &quot;%identity&quot;

(*************************************************)
(** Operations manipulating data types ***********)
(*************************************************)

(* Functions over products *)

let dom : vprod -&gt; values = fun p -&gt; val_of_obj (Obj.field (Obj.repr p) 0)
let codom : vprod -&gt; vfun = fun p -&gt; (Obj.obj (Obj.field (Obj.repr p) 1))

(* Functions over vfun *)

external closure_arity : vfun -&gt; int = &quot;coq_closure_arity&quot;

(* Functions over fixpoint *)

external offset : Obj.t -&gt; int = &quot;coq_offset&quot;
external offset_closure : Obj.t -&gt; int -&gt; Obj.t = &quot;coq_offset_closure&quot;
external offset_closure_fix : vfix -&gt; int -&gt; vm_env = &quot;coq_offset_closure&quot;
external tcode_array : tcode_array -&gt; tcode array = &quot;coq_tcode_array&quot;

let first o = (offset_closure o (offset o))
let first_fix (v:vfix) = (Obj.magic (first (Obj.repr v)) : vfix)

let last o = (Obj.field o (Obj.size o - 1))
let fix_types (v:vfix) = tcode_array (Obj.magic (last (Obj.repr v)) : tcode_array)
let cofix_types (v:vcofix) = tcode_array (Obj.magic (last (Obj.repr v)) : tcode_array)

let current_fix vf = - (offset (Obj.repr vf) / 2)

let unsafe_fb_code fb i =
  let off = (2 * i) * (Sys.word_size / 8) in
  Obj.obj (Obj.add_offset (Obj.repr fb) (Int32.of_int off))

let unsafe_rec_arg fb i = int_tcode (unsafe_fb_code fb i) 1

let rec_args vf =
  let fb = first (Obj.repr vf) in
  let size = Obj.size (last fb) in
  Array.init size (unsafe_rec_arg fb)

exception FALSE

let check_fix f1 f2 =
  let i1, i2 = current_fix f1, current_fix f2 in
  (* Checking starting point *)
  if i1 = i2 then
    let fb1,fb2 = first (Obj.repr f1), first (Obj.repr f2) in
    let n = Obj.size (last fb1) in
    (* Checking number of definitions *)
    if n = Obj.size (last fb2) then
      (* Checking recursive arguments *)
      try
        for i = 0 to n - 1 do
          if unsafe_rec_arg fb1 i &lt;&gt; unsafe_rec_arg fb2 i
          then raise FALSE
        done;
        true
      with FALSE -&gt; false
    else false
  else false

let atom_rel : atom array ref =
  let init i = Aid (RelKey i) in
  ref (Array.init 40 init)

let get_atom_rel () = !atom_rel

let realloc_atom_rel n =
  let n = min (2 * n + 0x100) Sys.max_array_length in
  let init i = Aid (RelKey i) in
  let ans = Array.init n init in
  atom_rel := ans

let relaccu_tbl =
  let len = Array.length !atom_rel in
  ref (Array.init len mkAccuCode)

let relaccu_code i =
  let len = Array.length !relaccu_tbl in
  if i &lt; len then !relaccu_tbl.(i)
  else
    begin
      realloc_atom_rel i;
      let nl = Array.length !atom_rel in
      relaccu_tbl :=
        Array.init nl
          (fun j -&gt; if j &lt; len then !relaccu_tbl.(j) else mkAccuCode j);
      !relaccu_tbl.(i)
    end

let mk_fix_body k ndef fb =
  let e = Obj.dup (Obj.repr fb) in
  for i = 0 to ndef - 1 do
    set_bytecode_field e (2 * i) (relaccu_code (k + i))
  done;
  let fix_body i =
    let c = offset_tcode (unsafe_fb_code fb i) 2 in
    let res = Obj.new_block Obj.closure_tag 2 in
    set_bytecode_field res 0 c;
    Obj.set_field res 1 (offset_closure e (2*i));
    ((Obj.obj res) : vfun)  in
  Array.init ndef fix_body

(* Functions over vcofix *)

let get_fcofix vcf i =
  match whd_val (Obj.obj (Obj.field (Obj.repr vcf) (i+1))) with
  | Vcofix(vcfi, _, _) -&gt; vcfi
  | _ -&gt; assert false

let current_cofix vcf =
  let ndef = Obj.size (last (Obj.repr vcf)) in
  let rec find_cofix pos =
    if pos &lt; ndef then
      if get_fcofix vcf pos == vcf then pos
      else find_cofix (pos+1)
    else raise Not_found in
  try find_cofix 0
  with Not_found -&gt; assert false

let check_cofix vcf1 vcf2 =
  (current_cofix vcf1 = current_cofix vcf2) &amp;&amp;
  (Obj.size (last (Obj.repr vcf1)) = Obj.size (last (Obj.repr vcf2)))

let mk_cofix_body apply_varray k ndef vcf =
  let e = Obj.dup (Obj.repr vcf) in
  for i = 0 to ndef - 1 do
    Obj.set_field e (i+1) (Obj.repr (val_of_rel (k+i)))
  done;

  let cofix_body i =
    let vcfi = get_fcofix vcf i in
    let c = Obj.field (Obj.repr vcfi) 0 in
    Obj.set_field e 0 c;
    let atom = Obj.new_block cofix_tag 1 in
    let self = Obj.new_block accu_tag 2 in
    set_bytecode_field self 0 accumulate;
    Obj.set_field self 1 (Obj.repr atom);
    apply_varray (Obj.obj e) [|Obj.obj self|] in
  Array.init ndef cofix_body

(* Functions over vblock *)

let btag : vblock -&gt; int = fun b -&gt; Obj.tag (Obj.repr b)
let bsize : vblock -&gt; int = fun b -&gt; Obj.size (Obj.repr b)
let bfield b i =
  if 0 &lt;= i &amp;&amp; i &lt; (bsize b) then val_of_obj (Obj.field (Obj.repr b) i)
  else invalid_arg &quot;Vm.bfield&quot;


(* Functions over vswitch *)

let check_switch sw1 sw2 = sw1.sw_annot.rtbl = sw2.sw_annot.rtbl

let branch_arg k (tag,arity) =
  if Int.equal arity 0 then  ((Obj.magic tag):values)
  else
    let b, ofs =
      if tag &lt; Obj.last_non_constant_constructor_tag then Obj.new_block tag arity, 0
      else
        let b = Obj.new_block Obj.last_non_constant_constructor_tag (arity+1) in
        Obj.set_field b 0 (Obj.repr (tag-Obj.last_non_constant_constructor_tag));
        b,1 in
    for i = ofs to ofs + arity - 1 do
      Obj.set_field b i (Obj.repr (val_of_rel (k+i)))
    done;
    val_of_obj b

(* Printing *)

let rec pr_atom a =
  Pp.(match a with
  | Aid c -&gt; str &quot;Aid(&quot; ++ (match c with
                            | ConstKey c -&gt; Constant.print c
                            | RelKey i -&gt; str &quot;#&quot; ++ int i
                            | _ -&gt; str &quot;...&quot;) ++ str &quot;)&quot;
  | Aind (mi,i) -&gt; str &quot;Aind(&quot; ++ MutInd.print mi ++ str &quot;#&quot; ++ int i ++ str &quot;)&quot;
  | Asort _ -&gt; str &quot;Asort(&quot;)
and pr_whd w =
  Pp.(match w with
  | Vprod _ -&gt; str &quot;Vprod&quot;
  | Vfun _ -&gt; str &quot;Vfun&quot;
  | Vfix _ -&gt; str &quot;Vfix&quot;
  | Vcofix _ -&gt; str &quot;Vcofix&quot;
  | Vconstr_const i -&gt; str &quot;Vconstr_const(&quot; ++ int i ++ str &quot;)&quot;
  | Vconstr_block _b -&gt; str &quot;Vconstr_block&quot;
  | Vint64 i -&gt; i |&gt; Format.sprintf &quot;Vint64(%LiL)&quot; |&gt; str
  | Vatom_stk (a,stk) -&gt; str &quot;Vatom_stk(&quot; ++ pr_atom a ++ str &quot;, &quot; ++ pr_stack stk ++ str &quot;)&quot;
  | Vuniv_level _ -&gt; assert false)
and pr_stack stk =
  Pp.(match stk with
      | [] -&gt; str &quot;[]&quot;
      | s :: stk -&gt; pr_zipper s ++ str &quot; :: &quot; ++ pr_stack stk)
and pr_zipper z =
  Pp.(match z with
  | Zapp args -&gt; str &quot;Zapp(len = &quot; ++ int (nargs args) ++ str &quot;)&quot;
  | Zfix (_f,args) -&gt; str &quot;Zfix(..., len=&quot; ++ int (nargs args) ++ str &quot;)&quot;
  | Zswitch _s -&gt; str &quot;Zswitch(...)&quot;
  | Zproj c -&gt; str &quot;Zproj(&quot; ++ Projection.Repr.print c ++ str &quot;)&quot;)
</pre>
          </div>
          <div class="col-md-6">
            <code>vmvalues.v</code>
            <pre>Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Import Names.

Import Univ.

Import Constr.

Parameter values : Type.

Definition structured_values := values.

Definition val_of_obj (v : Stdlib.Obj.t) : values := Stdlib.Obj.obj v.

Definition crazy_val : values := val_of_obj (Stdlib.Obj.repr 0).

Definition tag := Z.

Definition accu_tag : Z := 0.

Definition type_atom_tag : Z := 2.

Definition max_atom_tag : Z := 2.

Definition proj_tag : Z := 3.

Definition fix_app_tag : Z := 4.

Definition switch_tag : Z := 5.

Definition cofix_tag : Z := 6.

Definition cofix_evaluated_tag : Z := 7.

Inductive structured_constant : Type :=
| Const_sort : Sorts.t -&gt; structured_constant
| Const_ind : Names.inductive -&gt; structured_constant
| Const_b0 : tag -&gt; structured_constant
| Const_univ_level : Univ.Level.t -&gt; structured_constant
| Const_val : structured_values -&gt; structured_constant
| Const_uint : Uint63.t -&gt; structured_constant.

Definition reloc_table := array (tag * Z).

Record annot_switch := {
  ci : Constr.case_info;
  rtbl : reloc_table;
  tailcall : bool;
  max_stack_size : Z }.

Fixpoint eq_structured_values (v1 : structured_values) (v2 : structured_values)
  : bool :=
  orb (Stdlib.op_eq_eq v1 v2)
    (let o1 := Stdlib.Obj.repr v1 in
    let o2 := Stdlib.Obj.repr v2 in
    if andb (Stdlib.Obj.is_int o1) (Stdlib.Obj.is_int o2) then
      Stdlib.op_eq_eq o1 o2
    else
      let t1 := Stdlib.Obj.tag o1 in
      let t2 := Stdlib.Obj.tag o2 in
      if
        andb (Int.equal t1 t2)
          (Int.equal (Stdlib.Obj.size o1) (Stdlib.Obj.size o2)) then
        if Int.equal t1 Stdlib.Obj.custom_tag then
          Stdlib.Int64.equal (Stdlib.Obj.magic v1) (Stdlib.Obj.magic v2)
        else
          andb (OCaml.Stdlib.le t1 Stdlib.Obj.last_non_constant_constructor_tag)
            (OCaml.Stdlib.le t2 Stdlib.Obj.last_non_constant_constructor_tag);
          let i := Stdlib.ref 0 in
          while;
          OCaml.Stdlib.ge (Stdlib.op_exclamation i) (Stdlib.Obj.size o1)
      else
        false).

Definition hash_structured_values (v : structured_values) : Z :=
  Stdlib.Hashtbl.hash v.

Definition eq_structured_constant
  (c1 : structured_constant) (c2 : structured_constant) : bool :=
  match (c1, c2) with
  | (Const_sort s1, Const_sort s2) =&gt; Sorts.equal s1 s2
  | (Const_sort _, _) =&gt; false
  | (Const_ind i1, Const_ind i2) =&gt; Names.eq_ind i1 i2
  | (Const_ind _, _) =&gt; false
  | (Const_b0 t1, Const_b0 t2) =&gt; Int.equal t1 t2
  | (Const_b0 _, _) =&gt; false
  | (Const_univ_level l1, Const_univ_level l2) =&gt; Univ.Level.equal l1 l2
  | (Const_univ_level _, _) =&gt; false
  | (Const_val v1, Const_val v2) =&gt; eq_structured_values v1 v2
  | (Const_val _, _) =&gt; false
  | (Const_uint i1, Const_uint i2) =&gt; Uint63.equal i1 i2
  | (Const_uint _, _) =&gt; false
  end.

Definition hash_structured_constant (c : structured_constant) : Z :=
  match c with
  | Const_sort s =&gt; Hashset.Combine.combinesmall 1 (Sorts.hash s)
  | Const_ind i =&gt; Hashset.Combine.combinesmall 2 (Names.ind_hash i)
  | Const_b0 t =&gt; Hashset.Combine.combinesmall 3 (Int.hash t)
  | Const_univ_level l =&gt; Hashset.Combine.combinesmall 4 (Univ.Level.hash l)
  | Const_val v =&gt; Hashset.Combine.combinesmall 5 (hash_structured_values v)
  | Const_uint i =&gt; Hashset.Combine.combinesmall 6 (Uint63.hash i)
  end.

Definition eq_annot_switch (asw1 : annot_switch) (asw2 : annot_switch) : bool :=
  let eq_ci (ci1 : Constr.case_info) (ci2 : Constr.case_info) : bool :=
    andb (Names.eq_ind (ci_ind ci1) (ci_ind ci2))
      (andb (Int.equal (ci_npar ci1) (ci_npar ci2))
        (CArray.(CArray.ExtS.equal) Int.equal (ci_cstr_ndecls ci1)
          (ci_cstr_ndecls ci2))) in
  let eq_rlc (function_parameter : Int.t * Int.t) : (Int.t * Int.t) -&gt; bool :=
    match function_parameter with
    | (i1, j1) =&gt;
      fun function_parameter =&gt;
        match function_parameter with
        | (i2, j2) =&gt; andb (Int.equal i1 i2) (Int.equal j1 j2)
        end
    end in
  andb (eq_ci (ci asw1) (ci asw2))
    (andb (CArray.(CArray.ExtS.equal) eq_rlc (rtbl asw1) (rtbl asw2))
      (Stdlib.op_eq_eq (tailcall asw1) (tailcall asw2))).

Definition hash_annot_switch (asw : annot_switch) : Z :=
  let h1 := Constr.case_info_hash (ci asw) in
  let h2 :=
    Stdlib.Array.fold_left
      (fun h =&gt;
        fun function_parameter =&gt;
          match function_parameter with
          | (t, i) =&gt; Hashset.Combine.combine3 h t i
          end) 0 (rtbl asw) in
  let h3 :=
    if tailcall asw then
      1
    else
      0 in
  Hashset.Combine.combine3 h1 h2 h3.

Definition pp_sort (s : Sorts.t) : Pp.t :=
  match s with
  | SProp =&gt; Pp.str &quot;SProp&quot; % string
  | Prop =&gt; Pp.str &quot;Prop&quot; % string
  | Set =&gt; Pp.str &quot;Set&quot; % string
  | Type u =&gt;
    Pp.op_plus_plus (Pp.op_plus_plus (Pp.str &quot;Type@{&quot; % string) (Univ.pr_uni u))
      (Pp.str &quot;}&quot; % string)
  end.

Definition pp_struct_const (function_parameter : structured_constant) : Pp.t :=
  match function_parameter with
  | Const_sort s =&gt; pp_sort s
  | Const_ind (mind, i) =&gt;
    Pp.op_plus_plus
      (Pp.op_plus_plus (Names.MutInd.print mind) (Pp.str &quot;#&quot; % string))
      (Pp.int i)
  | Const_b0 i =&gt; Pp.int i
  | Const_univ_level l =&gt; Univ.Level.pr l
  | Const_val _ =&gt; Pp.str &quot;(value)&quot; % string
  | Const_uint i =&gt; Pp.str (Uint63.to_string i)
  end.

Parameter vprod : Type.

Parameter vfun : Type.

Parameter vfix : Type.

Parameter vcofix : Type.

Parameter vblock : Type.

Parameter arguments : Type.

Definition fun_val {A : Type} (v : A) : values := Stdlib.Obj.magic v.

Definition fix_val {A : Type} (v : A) : values := Stdlib.Obj.magic v.

Definition cofix_upd_val {A : Type} (v : A) : values := Stdlib.Obj.magic v.

Parameter vm_env : Type.

Parameter vm_global : Type.

Definition fun_env {A : Type} (v : A) : vm_env := Stdlib.Obj.magic v.

Definition fix_env {A : Type} (v : A) : vm_env := Stdlib.Obj.magic v.

Definition cofix_env {A : Type} (v : A) : vm_env := Stdlib.Obj.magic v.

Definition cofix_upd_env {A : Type} (v : A) : vm_env := Stdlib.Obj.magic v.

Definition vstack := array values.

Definition fun_of_val {A : Type} (v : A) : vfun := Stdlib.Obj.magic v.

Definition vm_global (v : array values) : vm_global := Stdlib.Obj.magic v.

Parameter tcode : Type.

Parameter tcode_array : Type.

Definition fun_code {A : Type} (v : A) : tcode := Stdlib.Obj.magic v.

Definition fix_code {A : Type} : A -&gt; tcode := fun_code.

Definition cofix_upd_code {A : Type} : A -&gt; tcode := fun_code.

Record vswitch := {
  sw_type_code : tcode;
  sw_code : tcode;
  sw_annot : annot_switch;
  sw_stk : vstack;
  sw_env : vm_env }.

Inductive id_key : Type :=
| ConstKey : Names.Constant.t -&gt; id_key
| VarKey : Names.Id.t -&gt; id_key
| RelKey : Int.t -&gt; id_key
| EvarKey : Evar.t -&gt; id_key.

Definition eq_id_key (k1 : id_key) (k2 : id_key) : bool :=
  match (k1, k2) with
  | (ConstKey c1, ConstKey c2) =&gt; Names.Constant.equal c1 c2
  | (VarKey id1, VarKey id2) =&gt; Names.Id.equal id1 id2
  | (RelKey n1, RelKey n2) =&gt; Int.equal n1 n2
  | (EvarKey evk1, EvarKey evk2) =&gt; Evar.equal evk1 evk2
  | _ =&gt; false
  end.

Inductive atom : Type :=
| Aid : id_key -&gt; atom
| Aind : Names.inductive -&gt; atom
| Asort : Sorts.t -&gt; atom.

Inductive zipper : Type :=
| Zapp : arguments -&gt; zipper
| Zfix : vfix -&gt; arguments -&gt; zipper
| Zswitch : vswitch -&gt; zipper
| Zproj : Names.Projection.Repr.t -&gt; zipper.

Definition stack := list zipper.

Definition to_update := values.

Inductive whd : Type :=
| Vprod : vprod -&gt; whd
| Vfun : vfun -&gt; whd
| Vfix : vfix -&gt; (option arguments) -&gt; whd
| Vcofix : vcofix -&gt; to_update -&gt; (option arguments) -&gt; whd
| Vconstr_const : Z -&gt; whd
| Vconstr_block : vblock -&gt; whd
| Vint64 : int64 -&gt; whd
| Vatom_stk : atom -&gt; stack -&gt; whd
| Vuniv_level : Univ.Level.t -&gt; whd.

Definition nargs (args : arguments) : Z :=
  Z.sub (Stdlib.Obj.size (Stdlib.Obj.repr args)) 2.

Definition arg (args : arguments) (i : Z) : values :=
  if andb (OCaml.Stdlib.le 0 i) (OCaml.Stdlib.lt i (nargs args)) then
    val_of_obj (Stdlib.Obj.field (Stdlib.Obj.repr args) (Z.add i 2))
  else
    OCaml.Stdlib.invalid_arg
      (String.append &quot;Vm.arg size = &quot; % string
        (String.append (OCaml.Stdlib.string_of_int (nargs args))
          (String.append &quot; acces &quot; % string (OCaml.Stdlib.string_of_int i)))).

Definition uni_lvl_val (v : values) : Univ.Level.t :=
  let whd := Stdlib.Obj.magic v in
  match whd with
  | Vuniv_level lvl =&gt; lvl
  | _ =&gt;
    let pr :=
      match whd with
      | Vprod _ =&gt; Pp.str &quot;Vprod&quot; % string
      | Vfun _ =&gt; Pp.str &quot;Vfun&quot; % string
      | Vfix _ _ =&gt; Pp.str &quot;Vfix&quot; % string
      | Vcofix _ _ _ =&gt; Pp.str &quot;Vcofix&quot; % string
      | Vconstr_const _i =&gt; Pp.str &quot;Vconstr_const&quot; % string
      | Vconstr_block _b =&gt; Pp.str &quot;Vconstr_block&quot; % string
      | Vint64 _ =&gt; Pp.str &quot;Vint64&quot; % string
      | Vatom_stk _a _stk =&gt; Pp.str &quot;Vatom_stk&quot; % string
      | Vuniv_level _ =&gt; false
      end in
    CErrors.anomaly None None
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.strbrk
            &quot;Parsing virtual machine value expected universe level, got &quot; %
              string) pr) (Pp.str &quot;.&quot; % string))
  end.

Fixpoint whd_accu (a : Stdlib.Obj.t) (stk : stack) : whd :=
  let stk :=
    if Int.equal (Stdlib.Obj.size a) 2 then
      stk
    else
      cons (Zapp (Stdlib.Obj.obj a)) stk in
  let at := Stdlib.Obj.field a 1 in
  match Stdlib.Obj.tag at with
  | tg =&gt;
    CErrors.anomaly None None
      (Pp.op_plus_plus
        (Pp.op_plus_plus (Pp.strbrk &quot;Failed to parse VM value. Tag = &quot; % string)
          (Pp.int tg)) (Pp.str &quot;.&quot; % string))
  end.

Definition accumulate : tcode := accumulate tt.

Definition whd_val (v : values) : whd :=
  let o := Stdlib.Obj.repr v in
  if Stdlib.Obj.is_int o then
    Vconstr_const (Stdlib.Obj.obj o)
  else
    let tag := Stdlib.Obj.tag o in
    if equiv_decb tag accu_tag then
      if is_accumulate (fun_code o) then
        whd_accu o []
      else
        Vprod (Stdlib.Obj.obj o)
    else
      if
        orb (equiv_decb tag Stdlib.Obj.closure_tag)
          (equiv_decb tag Stdlib.Obj.infix_tag) then
        match kind_of_closure o with
        | 0 =&gt; Vfun (Stdlib.Obj.obj o)
        | 1 =&gt; Vfix (Stdlib.Obj.obj o) None
        | 2 =&gt;
          Vfix (Stdlib.Obj.obj (Stdlib.Obj.field o 1)) (Some (Stdlib.Obj.obj o))
        | 3 =&gt; Vatom_stk (Aid (RelKey (int_tcode (fun_code o) 1))) []
        | _ =&gt;
          CErrors.anomaly None (Some &quot;Vm.whd &quot; % string)
            (Pp.str &quot;kind_of_closure does not work.&quot; % string)
        end
      else
        if Int.equal tag Stdlib.Obj.custom_tag then
          Vint64 (Stdlib.Obj.magic v)
        else
          Vconstr_block (Stdlib.Obj.obj o).

Definition obj_of_atom (a : atom) : Stdlib.Obj.t :=
  let res := Stdlib.Obj.new_block accu_tag 2 in
  set_bytecode_field res 0 accumulate;
  Stdlib.Obj.set_field res 1 (Stdlib.Obj.repr a);
  res.

Definition obj_of_str_const (str : structured_constant) : Stdlib.Obj.t :=
  match str with
  | Const_sort s =&gt; obj_of_atom (Asort s)
  | Const_ind ind =&gt; obj_of_atom (Aind ind)
  | Const_b0 tag =&gt; Stdlib.Obj.repr tag
  | Const_univ_level l =&gt; Stdlib.Obj.repr (Vuniv_level l)
  | Const_val v =&gt; Stdlib.Obj.repr v
  | Const_uint i =&gt; Stdlib.Obj.repr i
  end.

Definition val_of_block (tag : Z) (args : array structured_values)
  : structured_values :=
  let nargs := Stdlib.Array.length args in
  let r := Stdlib.Obj.new_block tag nargs in
  for;
  Stdlib.Obj.magic r.

Definition val_of_obj (o : Stdlib.Obj.t) : values := Stdlib.Obj.obj o.

Definition val_of_str_const (str : structured_constant) : values :=
  val_of_obj (obj_of_str_const str).

Definition val_of_atom (a : atom) : values := val_of_obj (obj_of_atom a).

Definition val_of_int {A : Type} (i : A) : values := Stdlib.Obj.magic i.

Definition val_of_uint {A : Type} (i : A) : values := Stdlib.Obj.magic i.

Definition atom_of_proj {A B : Type} (kn : A) (v : B) : atom :=
  let r := Stdlib.Obj.new_block proj_tag 2 in
  Stdlib.Obj.set_field r 0 (Stdlib.Obj.repr kn);
  Stdlib.Obj.set_field r 1 (Stdlib.Obj.repr v);
  Stdlib.Obj.obj r.

Definition val_of_proj {A B : Type} (kn : A) (v : B) : values :=
  val_of_atom (atom_of_proj kn v).

Module IdKeyHash.
  Definition t := id_key.
  
  Definition equal : id_key -&gt; id_key -&gt; bool := eq_id_key.
  
  Import Hashset.Combine.
  
  Definition hash (function_parameter : t) : tag :=
    match function_parameter with
    | ConstKey c =&gt; Hashset.Combine.combinesmall 1 (Names.Constant.hash c)
    | VarKey id =&gt; Hashset.Combine.combinesmall 2 (Names.Id.hash id)
    | RelKey i =&gt; Hashset.Combine.combinesmall 3 (Int.hash i)
    | EvarKey evk =&gt; Hashset.Combine.combinesmall 4 (Evar.hash evk)
    end.
End IdKeyHash.

Definition idkey_tbl : KeyTable.t values := KeyTable.create 31.

Definition val_of_idkey (key : KeyTable.key) : values := try.

Definition val_of_rel (k : Int.t) : values := val_of_idkey (RelKey k).

Definition val_of_named (id : Names.Id.t) : values := val_of_idkey (VarKey id).

Definition val_of_constant (c : Names.Constant.t) : values :=
  val_of_idkey (ConstKey c).

Definition val_of_evar (evk : Evar.t) : values := val_of_idkey (EvarKey evk).

Definition dom (p : vprod) : values :=
  val_of_obj (Stdlib.Obj.field (Stdlib.Obj.repr p) 0).

Definition codom (p : vprod) : vfun :=
  Stdlib.Obj.obj (Stdlib.Obj.field (Stdlib.Obj.repr p) 1).

Definition first (o : Stdlib.Obj.t) : Stdlib.Obj.t :=
  offset_closure o (offset o).

Definition first_fix (v : vfix) : vfix :=
  Stdlib.Obj.magic (first (Stdlib.Obj.repr v)).

Definition last (o : Stdlib.Obj.t) : Stdlib.Obj.t :=
  Stdlib.Obj.field o (Z.sub (Stdlib.Obj.size o) 1).

Definition fix_types (v : vfix) : array tcode :=
  tcode_array (Stdlib.Obj.magic (last (Stdlib.Obj.repr v))).

Definition cofix_types (v : vcofix) : array tcode :=
  tcode_array (Stdlib.Obj.magic (last (Stdlib.Obj.repr v))).

Definition current_fix {A : Type} (vf : A) : Z :=
  Z.opp (Z.div (offset (Stdlib.Obj.repr vf)) 2).

Definition unsafe_fb_code {A B : Type} (fb : A) (i : Z) : B :=
  let off := Z.mul (Z.mul 2 i) (Z.div Stdlib.Sys.word_size 8) in
  Stdlib.Obj.obj
    (Stdlib.Obj.add_offset (Stdlib.Obj.repr fb) (Stdlib.Int32.of_int off)).

Definition unsafe_rec_arg {A : Type} (fb : A) (i : Z) : Z :=
  int_tcode (unsafe_fb_code fb i) 1.

Definition rec_args {A : Type} (vf : A) : array Z :=
  let fb := first (Stdlib.Obj.repr vf) in
  let size := Stdlib.Obj.size (last fb) in
  Stdlib.Array.init size (unsafe_rec_arg fb).

Definition check_fix {A B : Type} (f1 : A) (f2 : B) : bool :=
  match ((current_fix f1), (current_fix f2)) with
  | (i1, i2) =&gt;
    if equiv_decb i1 i2 then
      match ((first (Stdlib.Obj.repr f1)), (first (Stdlib.Obj.repr f2))) with
      | (fb1, fb2) =&gt;
        let n := Stdlib.Obj.size (last fb1) in
        if equiv_decb n (Stdlib.Obj.size (last fb2)) then
          try
        else
          false
      end
    else
      false
  end.

Definition atom_rel : Stdlib.ref (array atom) :=
  let init (i : Int.t) : atom :=
    Aid (RelKey i) in
  Stdlib.ref (Stdlib.Array.init 40 init).

Definition get_atom_rel (function_parameter : unit) : array atom :=
  match function_parameter with
  | tt =&gt; Stdlib.op_exclamation atom_rel
  end.

Definition realloc_atom_rel (n : Z) : unit :=
  let n := OCaml.Stdlib.min (Z.add (Z.mul 2 n) 256) Stdlib.Sys.max_array_length
    in
  let init (i : Int.t) : atom :=
    Aid (RelKey i) in
  let ans := Stdlib.Array.init n init in
  Stdlib.op_colon_eq atom_rel ans.

Definition relaccu_tbl : Stdlib.ref (array tcode) :=
  let len := Stdlib.Array.length (Stdlib.op_exclamation atom_rel) in
  Stdlib.ref (Stdlib.Array.init len mkAccuCode).

Definition relaccu_code (i : Z) : tcode :=
  let len := Stdlib.Array.length (Stdlib.op_exclamation relaccu_tbl) in
  if OCaml.Stdlib.lt i len then
    Stdlib.Array.get (Stdlib.op_exclamation relaccu_tbl) i
  else
    realloc_atom_rel i;
    let nl := Stdlib.Array.length (Stdlib.op_exclamation atom_rel) in
    Stdlib.op_colon_eq relaccu_tbl
      (Stdlib.Array.init nl
        (fun j =&gt;
          if OCaml.Stdlib.lt j len then
            Stdlib.Array.get (Stdlib.op_exclamation relaccu_tbl) j
          else
            mkAccuCode j));
    Stdlib.Array.get (Stdlib.op_exclamation relaccu_tbl) i.

Definition mk_fix_body {A : Type} (k : Z) (ndef : Z) (fb : A) : array vfun :=
  let e := Stdlib.Obj.dup (Stdlib.Obj.repr fb) in
  for;
  let fix_body (i : Z) : vfun :=
    let c := offset_tcode (unsafe_fb_code fb i) 2 in
    let res := Stdlib.Obj.new_block Stdlib.Obj.closure_tag 2 in
    set_bytecode_field res 0 c;
    Stdlib.Obj.set_field res 1 (offset_closure e (Z.mul 2 i));
    Stdlib.Obj.obj res in
  Stdlib.Array.init ndef fix_body.

Definition get_fcofix {A : Type} (vcf : A) (i : Z) : vcofix :=
  match
    whd_val
      (Stdlib.Obj.obj (Stdlib.Obj.field (Stdlib.Obj.repr vcf) (Z.add i 1))) with
  | Vcofix vcfi _ _ =&gt; vcfi
  | _ =&gt; false
  end.

Definition current_cofix (vcf : vcofix) : Z :=
  let ndef := Stdlib.Obj.size (last (Stdlib.Obj.repr vcf)) in
  let fix find_cofix (pos : Z) : Z :=
    if OCaml.Stdlib.lt pos ndef then
      if Stdlib.op_eq_eq (get_fcofix vcf pos) vcf then
        pos
      else
        find_cofix (Z.add pos 1)
    else
      Stdlib.raise OCaml.Not_found in
  try.

Definition check_cofix (vcf1 : vcofix) (vcf2 : vcofix) : bool :=
  andb (equiv_decb (current_cofix vcf1) (current_cofix vcf2))
    (equiv_decb (Stdlib.Obj.size (last (Stdlib.Obj.repr vcf1)))
      (Stdlib.Obj.size (last (Stdlib.Obj.repr vcf2)))).

Definition mk_cofix_body {A B C D : Type}
  (apply_varray : A -&gt; (array B) -&gt; C) (k : Z) (ndef : Z) (vcf : D) : array C :=
  let e := Stdlib.Obj.dup (Stdlib.Obj.repr vcf) in
  for;
  let cofix_body (i : Z) : C :=
    let vcfi := get_fcofix vcf i in
    let c := Stdlib.Obj.field (Stdlib.Obj.repr vcfi) 0 in
    Stdlib.Obj.set_field e 0 c;
    let atom := Stdlib.Obj.new_block cofix_tag 1 in
    let self := Stdlib.Obj.new_block accu_tag 2 in
    set_bytecode_field self 0 accumulate;
    Stdlib.Obj.set_field self 1 (Stdlib.Obj.repr atom);
    apply_varray (Stdlib.Obj.obj e) ((Stdlib.Obj.obj self)) in
  Stdlib.Array.init ndef cofix_body.

Definition btag (b : vblock) : Z := Stdlib.Obj.tag (Stdlib.Obj.repr b).

Definition bsize (b : vblock) : Z := Stdlib.Obj.size (Stdlib.Obj.repr b).

Definition bfield (b : vblock) (i : Z) : values :=
  if andb (OCaml.Stdlib.le 0 i) (OCaml.Stdlib.lt i (bsize b)) then
    val_of_obj (Stdlib.Obj.field (Stdlib.Obj.repr b) i)
  else
    OCaml.Stdlib.invalid_arg &quot;Vm.bfield&quot; % string.

Definition check_switch (sw1 : vswitch) (sw2 : vswitch) : bool :=
  equiv_decb (rtbl (sw_annot sw1)) (rtbl (sw_annot sw2)).

Definition branch_arg (k : Z) (function_parameter : Z * Int.t) : values :=
  match function_parameter with
  | (tag, arity) =&gt;
    if Int.equal arity 0 then
      Stdlib.Obj.magic tag
    else
      match
        if OCaml.Stdlib.lt tag Stdlib.Obj.last_non_constant_constructor_tag then
          ((Stdlib.Obj.new_block tag arity), 0)
        else
          let b :=
            Stdlib.Obj.new_block Stdlib.Obj.last_non_constant_constructor_tag
              (Z.add arity 1) in
          Stdlib.Obj.set_field b 0
            (Stdlib.Obj.repr
              (Z.sub tag Stdlib.Obj.last_non_constant_constructor_tag));
          (b, 1) with
      | (b, ofs) =&gt;
        for;
        val_of_obj b
      end
  end.

Fixpoint pr_atom (a : atom) : Pp.t :=
  match a with
  | Aid c =&gt;
    Pp.op_plus_plus
      (Pp.op_plus_plus (Pp.str &quot;Aid(&quot; % string)
        match c with
        | ConstKey c =&gt; Names.Constant.print c
        | RelKey i =&gt; Pp.op_plus_plus (Pp.str &quot;#&quot; % string) (Pp.int i)
        | _ =&gt; Pp.str &quot;...&quot; % string
        end) (Pp.str &quot;)&quot; % string)
  | Aind (mi, i) =&gt;
    Pp.op_plus_plus
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus (Pp.str &quot;Aind(&quot; % string) (Names.MutInd.print mi))
          (Pp.str &quot;#&quot; % string)) (Pp.int i)) (Pp.str &quot;)&quot; % string)
  | Asort _ =&gt; Pp.str &quot;Asort(&quot; % string
  end

with pr_whd (w : whd) : Pp.t :=
  match w with
  | Vprod _ =&gt; Pp.str &quot;Vprod&quot; % string
  | Vfun _ =&gt; Pp.str &quot;Vfun&quot; % string
  | Vfix _ _ =&gt; Pp.str &quot;Vfix&quot; % string
  | Vcofix _ _ _ =&gt; Pp.str &quot;Vcofix&quot; % string
  | Vconstr_const i =&gt;
    Pp.op_plus_plus
      (Pp.op_plus_plus (Pp.str &quot;Vconstr_const(&quot; % string) (Pp.int i))
      (Pp.str &quot;)&quot; % string)
  | Vconstr_block _b =&gt; Pp.str &quot;Vconstr_block&quot; % string
  | Vint64 i =&gt;
    OCaml.Stdlib.reverse_apply
      (OCaml.Stdlib.reverse_apply i
        (Stdlib.Format.sprintf
          (CamlinternalFormatBasics.Format
            (CamlinternalFormatBasics.String_literal &quot;Vint64(&quot; % string
              (CamlinternalFormatBasics.Int64 CamlinternalFormatBasics.Int_i
                CamlinternalFormatBasics.No_padding
                CamlinternalFormatBasics.No_precision
                (CamlinternalFormatBasics.String_literal &quot;L)&quot; % string
                  CamlinternalFormatBasics.End_of_format)))
            &quot;Vint64(%LiL)&quot; % string))) Pp.str
  | Vatom_stk a stk =&gt;
    Pp.op_plus_plus
      (Pp.op_plus_plus
        (Pp.op_plus_plus
          (Pp.op_plus_plus (Pp.str &quot;Vatom_stk(&quot; % string) (pr_atom a))
          (Pp.str &quot;, &quot; % string)) (pr_stack stk)) (Pp.str &quot;)&quot; % string)
  | Vuniv_level _ =&gt; false
  end

with pr_stack (stk : stack) : Pp.t :=
  match stk with
  | [] =&gt; Pp.str &quot;[]&quot; % string
  | cons s stk =&gt;
    Pp.op_plus_plus (Pp.op_plus_plus (pr_zipper s) (Pp.str &quot; :: &quot; % string))
      (pr_stack stk)
  end

with pr_zipper (z : zipper) : Pp.t :=
  match z with
  | Zapp args =&gt;
    Pp.op_plus_plus
      (Pp.op_plus_plus (Pp.str &quot;Zapp(len = &quot; % string) (Pp.int (nargs args)))
      (Pp.str &quot;)&quot; % string)
  | Zfix _f args =&gt;
    Pp.op_plus_plus
      (Pp.op_plus_plus (Pp.str &quot;Zfix(..., len=&quot; % string) (Pp.int (nargs args)))
      (Pp.str &quot;)&quot; % string)
  | Zswitch _s =&gt; Pp.str &quot;Zswitch(...)&quot; % string
  | Zproj c =&gt;
    Pp.op_plus_plus
      (Pp.op_plus_plus (Pp.str &quot;Zproj(&quot; % string)
        (Names.Projection.Repr.print c)) (Pp.str &quot;)&quot; % string)
  end.</pre>
          </div>
        </div>
        
      </div>
      <hr/>
      <div class="footer">
        <p class="text-center">
          <small>Sources are on <a href="https://github.com/clarus/coq-of-ocaml">GitHub</a>. ¬© Guillaume Claret.</small>
        </p>
      </div>
    </div>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script src="bootstrap.min.js"></script>
  </body>
</html>
