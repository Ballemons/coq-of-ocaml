---
id: introduction
title: What is coq-of-ocaml
---

coq-of-ocaml is a compiler from the [OCaml](https://ocaml.org/) programming language to the [Coq](https://coq.inria.fr/) proof language. It aims generate *idiomatic* and *human readable* OCaml code doing a *shallow embedding*.

We can use coq-of-ocaml to:
* do formal proofs on OCaml programs;
* port OCaml projects to Coq. 

Starting from the following OCaml program:
```ocaml
type 'a tree =
  | Leaf of 'a
  | Node of 'a tree * 'a tree

let rec sum tree =
  match tree with
  | Leaf n -> n
  | Node (tree1, tree2) -> sum tree1 + sum tree2
```
we get the Coq program:
```coq
(* Generated by coq-of-ocaml *)
Inductive tree (a : Set) : Set :=
| Leaf : a -> tree a
| Node : (tree a) -> (tree a) -> tree a.

Arguments Leaf {_}.
Arguments Node {_}.

Fixpoint sum (tree : tree Z) : Z :=
  match tree with
  | Leaf n => n
  | Node tree1 tree2 => Z.add (sum tree1) (sum tree2)
  end.
```

## Concepts
We import the purely functional part of OCaml to Coq. The side-effects are kept as axioms. The semantics of the source code may not be completely preserved. One should do manual reviews to assert that the generated Coq is a reasonable formalization of the sources. We generate a dummy Coq term and an explicit error message in case of error, so that we always generate something.

We compile OCaml projects by pluging into [Merlin](https://github.com/ocaml/merlin). This means that if you are using Merlin then you can run `coq-of-ocaml` with no additional configurations.

We do not do special treatments for the termination of fixpoints. We disable termination checks by using the package [coq-typing-flags](https://github.com/SimonBoulier/TypingFlags) from [Simon Boulier](http://perso.eleves.ens-rennes.fr/people/Simon.Boulier/) (should be included in the upcoming Coq 8.11). We erase the type parameters for the [GADTs](https://caml.inria.fr/pub/docs/manual-ocaml/manual033.html). This makes sure that the type definitions are accepted, but can make the pattern matchings incomplete. We did not find a way to represent GADTs in Coq yet. We think that this is hard because the dependent pattern matching works well on type indicies which are values, but not so well with types.

We support modules, module types, functors and first-class modules. We generate either Coq modules or dependent records depending on the use case. We generate axioms for `.mli` files to help formalizations, but importing `.mli` files should be optional. The generation of the `Require` primitives between Coq files is custom.

## Status
coq-of-ocaml is under active development at [Nomadic Labs](https://www.nomadic-labs.com/) to get a [Coq formalization](https://clarus.github.io/coq-of-ocaml/examples/tezos/) of the [Tezos](https://tezos.com/) crypto-currency. To get the latest features use the development version from the `master` branch. Do not hesitate to ask questions on our Gitter [chat room](https://gitter.im/clarus/coq-of-ocaml).

## Workflow
coq-of-ocaml works by compiling files one by one. Thanks to Merlin we get access to the variable environment of each file, so names referencing external modules are properly interpreted.

In a typical project, we may want to translate some of the `.ml` and keep the rest as axioms (libraries, non-critical files, ...). For the files kept as axioms, we can use coq-of-ocaml on the `.mli` files so that the interfaces are automatically generated. We do not generate the `Require` directives, so we need to add them by hand. Depending on the extend of what we want to formalize, we can either require the other imported `.ml` files, the interface files of axioms from the `.mli` or custom files.

When something is not properly handled, coq-of-ocaml generates an error message. These errors do not necessarily need to be fixed. However there are good warnings to help having a more extensive and reliable Coq formalization.

The generated Coq for a project will generally not compile as it. This can be due to unsupported features, or various small errors such as name collisions. We recommend to modify the OCaml source as needed, and use post-processing scripts to fix these small errors. If the conversion to Coq has to be done only once, we can even fix the errors by hand. For a large project, maintaining a fork of coq-of-ocaml with custom edits may also be reasonable.

## Related
In the OCaml community:
* [CFML](http://chargueraud.org/softs/cfml/) (import OCaml to Coq using characteristic formulae)
* [coq-of-ocaml-mrmr1993](https://github.com/mrmr1993/coq-of-ocaml) (fork of coq-of-ocaml including side-effects, focusing on the compilation of the OCaml's stdlib)

In the JavaScript community:
* [coq-of-js](https://github.com/clarus/coq-of-js) (under heavy development, contributors needed! sister project; *currently on halt to support coq-of-ocaml*)

In the Haskell community:
* [hs-to-coq](https://github.com/antalsz/hs-to-coq) (import Haskell to Coq)
* [hs-to-gallina](https://github.com/gdijkstra/hs-to-gallina) (2012, by Gabe Dijkstra, first known project to do shallow embedding of a functional language to Coq)

## Credits
The coq-of-ocaml project started as part of a PhD directed by [Yann Regis-Gianas](http://yann.regis-gianas.org/) and [Hugo Herbelin
](http://pauillac.inria.fr/~herbelin/) as the university of [Paris 7](https://u-paris.fr/). Originally, the idea was to formalize real OCaml programs in Coq to study side-effects inference and proof techniques on functional programs. The project is now financed by [Nomadic Labs](https://www.nomadic-labs.com/) to formalize the implementation of the crypto-currency [Tezos](https://tezos.com/).
