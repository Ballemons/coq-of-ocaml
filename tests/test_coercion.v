(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Inductive bar_tags : Type :=
| bar_int_tag : bar_tags
| bar_string_tag : bar_tags
| bar_Var_tag : forall (t0 : Set), bar_tags.

Fixpoint decode_bar_tags (tag : bar_tags) : Set :=
  match tag with
  | bar_Var_tag t0 => t0
  | bar_string_tag => string
  | bar_int_tag => int
  end.

Inductive bar : bar_tags -> Type :=
| BarC : int -> bar bar_int_tag
| BarC2 : string -> bar bar_string_tag.

Inductive foo_tags : Type :=
| foo_bool_tag : foo_tags
| foo_int_tag : foo_tags
| foo_Var_tag : forall (t0 : Set), foo_tags.

Fixpoint decode_foo_tags (tag : foo_tags) : Set :=
  match tag with
  | foo_Var_tag t0 => t0
  | foo_int_tag => int
  | foo_bool_tag => bool
  end.

Definition bar_tags_to_foo_tags (tag: bar_tags) : foo_tags :=
  match tag with
  | bar_Var_tag t0 => foo_Var_tag t0
  | bar_int_tag => foo_int_tag
  | bar_string_tag => foo_Var_tag string
  end.

Coercion bar_tags_to_foo_tags : bar_tags >-> foo_tags.


Inductive foo : foo_tags -> Type :=
| FooC : int -> foo foo_int_tag
| FooC2 : bool -> foo foo_bool_tag.

Inductive term_tags : Type :=
| term_Tuple_tag : forall (t0 t1 : term_tags), term_tags
| term_Arrow_tag : forall (t0 t1 : term_tags), term_tags
| term_Var_tag : forall (t0 : Set), term_tags.

Definition bar_tags_to_term_tags (tag: bar_tags) : term_tags :=
  match tag with
  | bar_Var_tag t0 => term_Var_tag t0
  | bar_int_tag => term_Var_tag int
  | bar_string_tag => term_Var_tag string
  end.

Coercion bar_tags_to_term_tags : bar_tags >-> term_tags.

Fixpoint foo_tags_to_term_tags (tag : foo_tags) : term_tags :=
  match tag with
  | foo_Var_tag t0 => term_Var_tag t0
  | foo_int_tag => term_Var_tag int
  | foo_bool_tag => term_Var_tag bool
  end.

Coercion foo_tags_to_term_tags : foo_tags >-> term_tags.

Fixpoint decode_term_tags (tag : term_tags) : Set :=
  match tag with
  | term_Var_tag t0 => t0
  | term_Arrow_tag t0 t1 => decode_term_tags t0 -> decode_term_tags t1
  | term_Tuple_tag t0 t1 => decode_term_tags t0 * decode_term_tags t1
  end.

Inductive term : term_tags -> Type :=
| Pair : forall {a b c : term_tags},
  term a -> term (term_Arrow_tag c b) -> term c -> term (term_Tuple_tag a b)
| Lam : forall {a b : term_tags},
  string -> term a -> term b -> term (term_Arrow_tag a b)
| Foo : forall {a : bar_tags}, bar a -> foo a -> term (term_Tuple_tag a a).

Definition evalFoo {a : foo_tags} (function_parameter : foo a) : decode_foo_tags a :=
  match function_parameter with
  | FooC n => n
  | FooC2 b => b
  end.

Definition evalBar {a : bar_tags} (function_parameter : bar a) : decode_bar_tags a :=
  match function_parameter with
  | BarC2 s => s
  | BarC n => n
  end.


Lemma decodes_bar_term_eq : forall a, (decode_bar_tags a) = (decode_term_tags a) :> Type.
Proof.
  destruct a; simpl; auto.
Qed.

Lemma decodes_bar_foo_eq : forall a, (decode_bar_tags a) = (decode_foo_tags a) :> Type.
Proof.
  destruct a; simpl; auto.
Qed.

Import EqNotations.

Fixpoint eval {a : term_tags} (function_parameter : term a) : decode_term_tags a :=
  match function_parameter with
  | Lam x ty t => fun x => eval t
  | Pair a f b => ((eval a), ((eval f) (eval b)))
  | @Foo a' f b =>
    let cast_foo x := rew [fun S => S] (eq_sym (decodes_bar_foo_eq a')) in (evalFoo x) in
        rew [fun S => S * S ] (decodes_bar_term_eq a') in (evalBar f, cast_foo b)
  end.

(* Translation of get_int  *)

Inductive term : term_tags -> Type :=
| Pair : forall {a b c : term_tags},
  term a -> term (term_Arrow_tag c b) -> term c -> term (term_Tuple_tag a b)
| Int : int -> term term_int_tag
| Bool : bool -> term term_bool_tag
| Lam : forall {a b : term_tags},
  string -> term a -> term b -> term (term_Arrow_tag a b)
| App : forall {a b : term_tags}, term (term_Arrow_tag a b) -> term a -> term b
| Arrow : forall {u v : term_tags},
  (decode_term u -> decode_term v) -> term (term_Arrow_tag u v)
.

Import EqNotations.

Definition get_int (function_parameter : term term_int_tag) : int :=
  match function_parameter in term T return T = term_int_tag -> int with
  | Int n => fun _ => n
  | App t1 t2 => fun eq => rew eq in (eval t1) (eval t2)
  | _ => fun _ => ltac:(discriminate)
  end eq_refl .
