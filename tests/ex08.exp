Inductive t1:
  ([ ], [ (C1, [ Type (Z/1) ]); (C2, [ Type (bool/1); Type (Z/1) ]); (C3, [ ]) ])

((),
  Value (non_rec, n, [ ], [ ], Some Type (t1/0)) =
    Constructor (8, C2/0, Constructor (8, false/1), Constant (8, Int(3))))

((),
  Value (non_rec, m, [ ], [ ], Some Type (bool/1)) =
    Match
      (10, Variable (10, n/0),
        [
          (Constructor (C2/0, b, Any), Variable (11, b/0));
          (Any, Constructor (12, true/1))
        ]))

Inductive t2:
  ([ a ], [ (D1, [ ]); (D2, [ a; Type (t2/0, a) ]) ])

((),
  Value (rec, of_list, [ A ], [ (l, Type (list/1, A)) ], Some Type (t2/0, A)) =
    Match
      (19, Variable (19, l/0),
        [
          (Constructor ([]/1), Constructor (20, D1/0));
          (Constructor (cons/1, x, xs),
            Constructor
              (21, D2/0, Variable (21, x/0),
                Apply
                  (21, Variable (21, of_list/0),
                    Variable (21, xs/0))))
        ]))

((),
  Value (rec, sum, [ ], [ (l, Type (t2/0, Type (Z/1))) ], Some Type (Z/1)) =
    Match
      (24, Variable (24, l/0),
        [
          (Constructor (D1/0), Constant (25, Int(0)));
          (Constructor (D2/0, x, xs),
            Apply
              (?,
                Apply
                  (26, Variable (26, Z.add/1),
                    Variable (26, x/0)),
                Apply
                  (26, Variable (26, sum/0),
                    Variable (26, xs/0))))
        ]))

((),
  Value (non_rec, s, [ ], [ ], Some Type (Z/1)) =
    Apply
      (28, Variable (28, sum/0),
        Apply
          (28, Variable (28, of_list/0),
            Constructor
              (28, cons/1, Constant (28, Int(5)),
                Constructor
                  (28, cons/1, Constant (28, Int(7)),
                    Constructor
                      (28, cons/1, Constant (28, Int(3)), Constructor (28, []/1)))))))
