(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

(* type 'a expr = *)
  (* | Int : 'a -> 'a expr *)
  (* | Int : int -> int expr *)
  (* | Sum : int expr * int expr -> int expr *)
  (* | Expr : 'a expr -> 'a expr expr *)
  (* | Var : 'a -> 'a expr  *)
  (* | Arr : 'a expr -> ('a -> 'b -> 'c -> 'd) expr *)
  (* | Tup : 'a expr -> ('a * 'b * 'c * 'd) expr *)

(* Inductive expr : Type -> Type := *)
(* | Int : nat -> expr nat *)
(* | Sum : expr nat -> expr nat -> expr nat *)
(* | Var : forall a, a -> expr a *)
(* | Arr : forall a b, expr a -> expr (a -> b) *)

(* | Expr : forall a, expr a -> expr (expr a) *)
(*                                    ^^^^^^  *)
(* . *)

(* Error: Universe inconsistency. *)

Polymorphic Inductive pre_expr : Type :=
| Int : int -> pre_expr
| Sum : pre_expr * pre_expr -> pre_expr
| Var : forall X, X -> pre_expr
(* | Expr : pre_expr -> pre_expr *)
| Arr : pre_expr -> pre_expr.
(* We cannot express expr_wf for Expr because
we have to build constr_tag with an expr_wf, this leads to a universe inconsistency *)

Set Printing Universes.
Import EqNotations.
Fixpoint expr_wf (t : pre_expr) (tag : vtag) : Type :=
  match t with
         | Int _ => tag = int_tag
         | Sum (lhs, rhs) =>
           (tag = int_tag) * expr_wf lhs int_tag * expr_wf rhs int_tag
         | Var ty x => ty = decode_vtag tag
         | Arr y => sigT (fun '(a, b) => (expr_wf y a) * (tag = arrow_tag a b))
  end.

Definition expr (t : vtag) := { f &  expr_wf f t }.
Opaque expr.

Fixpoint get_Int (e : pre_expr) (wf_e : expr_wf e int_tag) {struct e } : decode_vtag int_tag.
  refine (match e as t0 return expr_wf t0 int_tag -> int with
         | Int n => fun _ => n
         | Sum (lhs, rhs) => fun '(p1, p2, p3) =>
                              Z.add (get_Int lhs p2) (get_Int rhs p3)
         | Arr x => fun '(existT _ t eq) =>
                ltac:(destruct t; destruct eq as [eq]; discriminate)
         | Var ty x => fun eq => rew eq in x
  end wf_e).
Defined.

Definition get_int (e : expr int_tag) : int :=
  let '(existT _ e wf_e) := e in
  get_Int e wf_e.

Inductive expr2 : vtag -> Set :=
| Int2 : int -> expr2 int_tag
| Sum2 : expr2 int_tag * expr2 int_tag -> expr2 int_tag
| Arr2 : forall a b, expr2 a -> expr2 (arrow_tag a b)
| Var2 : forall a, decode_vtag a -> expr2 a
(* | Expr2 : forall a, expr2 a -> expr2 (constr_tag "expr_var" (expr2 a)) *)
.
(* Error: Non strictly positive occurrence of "expr2" in *)
(*  "forall a : vtag, *)
(*   expr2 a -> expr2 (constr_tag "expr_var" (expr2 a))". *)

Fixpoint get_int2 (e : expr2 int_tag) : int :=
    match e in (expr2 T) return T = int_tag -> int with
           | Int2 n => fun _ => n
           | Sum2 (n1, n2) => fun eq => Z.add (get_int2 n1) (get_int2 n2)
           | Arr2 _ _ _ => fun eq => ltac:(discriminate)
           | Var2 A a => fun eq => rew eq in a
    end eq_refl.
