(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Inductive term_tag : Type :=
| term_Var_tag : forall (a : Set), term_tag
| term_int_tag : term_tag
| term_bool_tag : term_tag
| term_option_tag : forall (a : term_tag), term_tag
| term_List_tag : forall (a : term_tag), term_tag
| term_Pair_tag : forall (a b : term_tag), term_tag
| term_Arrow_tag : forall (a b : term_tag), term_tag.

Inductive term : term_tag -> Type :=
| Int : int -> term term_int_tag
| Bool : bool -> term term_bool_tag
| Lam : forall {a b : term_tag} ,
  string ->
  term a ->
  term b ->
  term (term_Arrow_tag a b)
| App : forall {a b : term_tag},
  term (term_Arrow_tag a b) ->
  term a ->
  term b
| OptApp : forall {a b : term_tag},
  term (term_Arrow_tag (term_option_tag a) b) ->
  term a ->
  term b
| List: forall {a : term_tag},
  list (term a) ->
  term  (term_List_tag a)
| Pair: forall {a b : term_tag},
  term a ->
  term b ->
  term  (term_Pair_tag a b).

Arguments Pair { _ _ } _ _.
Arguments App { _ _ } _ _.
Arguments List { _ } _.

Fixpoint dec_term_tags (tag : term_tag) : Set :=
  match tag with
  | term_Var_tag a => a
  | term_int_tag => int
  | term_bool_tag => bool
  | term_option_tag a => option (dec_term_tags a)
  | term_List_tag a => list (dec_term_tags a)
  | term_Arrow_tag a b => (dec_term_tags a) -> (dec_term_tags b)
  | term_Pair_tag a b => (dec_term_tags a) * (dec_term_tags b)
  end.

Require Import List.
Import ListNotations.

Fixpoint eval {a} (t : term a) {struct t}: dec_term_tags a :=
  match t in term T return dec_term_tags T with
  | Int n => n
  | Bool b => b
  | Lam x ty t => fun _ => eval t
  | App t1 t2 => (eval t1) (eval t2)
  | OptApp t1 t2 => (eval t1) (Some (eval t2))
  | List l => let fix f l := match l with
                            | nil => nil
                            | l :: ls => eval l :: f ls
                            end in f l
  | Pair ta tb => (eval ta, eval tb)
  end.

Definition bogus (t : term (term_Var_tag unit)) : {a & term a}.
  inversion t; simpl in *; subst;
  exists a; assumption.
Defined.

Definition bogus2 (t : term (term_Var_tag unit)) : {a & term a} :=
  match
    t in (term t0)
    return (t0 = term_Var_tag unit -> {a : term_tag & term a})
  with
  | Int H =>
    ltac:(discriminate)
  | Bool H =>
    ltac:(discriminate)
  | @Lam a b H X X0 =>
    ltac:(discriminate)
  | @App a b X X0 =>
      fun H : b = term_Var_tag unit =>
      (fun H0 : b = term_Var_tag unit =>
       let H1 : b = term_Var_tag unit := H0 in
       eq_rect_r
         (fun t0 : term_tag =>
          term (term_Arrow_tag a t0) ->
          term a -> {a0 : term_tag & term a0})
         (fun (_ : term (term_Arrow_tag a (term_Var_tag unit)))
            (X2 : term a) =>
          existT (fun a0 : term_tag => term a0) a X2) H1) H X X0
  | @OptApp a b X X0 =>
      fun H : b = term_Var_tag unit =>
      (fun H0 : b = term_Var_tag unit =>
       let H1 : b = term_Var_tag unit := H0 in
       eq_rect_r
         (fun t0 : term_tag =>
          term (term_Arrow_tag (term_option_tag a) t0) ->
          term a -> {a0 : term_tag & term a0})
         (fun
            (_ : term
                   (term_Arrow_tag (term_option_tag a)
                      (term_Var_tag unit)))
            (X2 : term a) =>
          existT (fun a0 : term_tag => term a0) a X2) H1) H X X0
  | @List a X =>
    ltac:(discriminate)
  | @Pair a b X X0 =>
    ltac:(discriminate)
  (*     fun H : term_Pair_tag a b = term_Var_tag unit => *)
  (*     (fun H0 : term_Pair_tag a b = term_Var_tag unit => *)
  (*      let H1 : False := *)
  (*        eq_ind (term_Pair_tag a b) *)
  (*          (fun e : term_tag => *)
  (*           match e with *)
  (*           | term_Pair_tag _ _ => True *)
  (*           | _ => False *)
  (*           end) I (term_Var_tag unit) H0 in *)
  (*      False_rect (term a -> term b -> {a0 : term_tag & term a0}) *)
  (*        H1) H X X0 *)
  end
eq_refl.
