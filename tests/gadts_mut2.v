(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.


(* type _ foo = *)
(*   | Foo_int : int -> int foo *)
(*   | Foo_Bar_string : string bar -> (string bar) foo *)
(* and _ bar = *)
(*   | Bar_string : string -> string bar *)
(*   | Bar_bool : bool -> bool bar *)

Inductive pre_foo : Type :=
  | C1 : int -> pre_foo
  | C2 : pre_bar -> pre_foo

with pre_bar : Type :=
  | Cs : string -> pre_bar
  | C3 : bool -> pre_bar
     (* | C4 : pre_foo -> pre_bar. *)
     .

Notation bar_tag := (constr_tag "pre_bar" pre_bar).
Notation foo_tag := (constr_tag "pre_foo" pre_foo).

(* Unset Guard Checking. *)
Fixpoint foo_wf (t : pre_foo) (tag: vtag) : Type :=
  match t with
  | C1 x => tag = int_tag
  | C2 b => (tag = constr_tag "bar_string" (sigT (fun f => bar_wf f string_tag)))
           * (bar_wf b string_tag)
  end

with bar_wf (t : pre_bar) (tag: vtag) : Type :=
match t with
| Cs s => tag = string_tag
| C3 b => tag = bool_tag
end.

Definition foo t := sigT (fun '(f, n) => foo_wf f t (S n) ).
Definition bar t := sigT (fun '(b, n) => bar_wf b t (S n) ).

Import EqNotations.

Ltac crush :=
  match goal with
  | [ H : False  |- _ ] => apply (False_rect _ H)
  | [ H : bar_wf _ _ ?n |- _ ] => destruct n; simpl in *; crush
  | [ H : _ * _ |- _ ] => destruct H; crush
  | [ H : constr_tag _ _ = constr_tag _ _ |- _ ] => try solve [inversion H]
  | _ => idtac
  end.

Definition eval {tag : vtag} (x : foo tag) : decode_vtag tag.
  refine (let '(existT _ (x, n) wf_x) := x in

          match x as x0 return foo_wf x0 tag (S n) -> decode_vtag tag with
          | C1 n => fun eq => rew <- eq in n
          | C2 b => fun '(eq, b_wf) =>
                match b as b0 return bar_wf b0 string_tag n -> decode_vtag tag with
                | Cs s => fun H => rew <- eq in existT _ (Cs s) H
                | C3 b => fun eq => ltac:(crush)
                | C4 f => fun f => ltac:(crush)
                end b_wf
          end wf_x).
Defined.


Program Definition f (x : foo (constr_tag "bar_bool" (bar bool)) : int + bool :=
  let '(existT _ p wf_p) := x in
  match p return foo_wf p bar_tag -> int + bool with
  | C1 x => fun F => ltac:(simpl in F; discriminate)
  | C2 b => fun '(conj _ wf_b) =>
             match b return bar_wf b bool_tag -> int + bool with
             | C3 b' => fun _ => inr b'
             | C4 _ => fun F' => ltac:(destruct F'; discriminate)
             end wf_b
  end wf_p.

Definition f2 (x : foo bar_tag) : int + bool.
  refine (let '(existT _ p wf_p) := x in
  match p return foo_wf p bar_tag -> int + bool with
  | C1 x => fun _ => _
  | C2 b => fun F => _
             (* fun F => ltac:(simpl in F; intuition; congruence) *)
  end wf_p).
  simpl in f.
  discriminate.
  destruct F.
  refine (match b return bar_wf b bool_tag -> int + bool with
          | C3 b' => fun _ => inr b'
          | C4 _ => fun F' => _
         end H0).
  destruct F'.
  discriminate.
Defined.
