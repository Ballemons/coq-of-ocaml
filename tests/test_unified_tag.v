(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Inductive tags : Type :=
| constr_tag : string -> Type -> tags
| tuple_tag : tags -> tags -> tags
| var_tag : forall (t0 : Set), tags.

Goal (constr_tag "int" int <> constr_tag "string" string).
  intro.
  inversion H.
Qed.

Fixpoint decode_tag (tag : tags) : Type :=
  match tag with
  | var_tag t0 => t0
  | tuple_tag t0 t1 => decode_tag t0 * decode_tag t1
  | constr_tag _ t => t
  end.

Inductive bar : tags -> Type :=
| BarC : int -> bar (constr_tag "int" int)
| BarC2 : string -> bar (constr_tag "string" string)
| BarC4 : forall a, bar (var_tag a).


Inductive foo : tags -> Type :=
| FooC : int -> foo (constr_tag "int" int)
| FooC2 : bool -> foo (constr_tag "bool" bool).

Inductive term : tags -> Type :=
| Int : int -> term (constr_tag "int" int)
| Bool : bool -> term (constr_tag "bool" bool)
| Foo : forall {b : tags} {a : tags},
  bar a -> foo b -> term (tuple_tag a b).

Definition evalFoo {a : tags} (function_parameter : foo a)
  : decode_tag a :=
  match function_parameter with
  | FooC n => n
  | FooC2 b => b
  end.

Definition evalBar {a : tags} (function_parameter : bar a)
  : decode_tag a :=
  match function_parameter with
  | BarC2 s => s
  | BarC n => n
  end.

Fixpoint eval {a : tags} (function_parameter : term a)
  : decode_tag a :=
  match function_parameter with
  | Int n => n
  | Bool b => b
  | Foo f b => ((evalBar f), (evalFoo b))
  end.

(* let get_int : int term -> int = function
 *   | Int n -> n
 *   | App (t1, t2) -> (eval t1) (eval t2) *)

Definition get_int (t: term (constr_tag "int" int)) : int :=
  match t with
  | Int n => n
  end.
