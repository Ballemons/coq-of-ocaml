(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Inductive t1 : Set :=
| C1 : int -> t1
| C2 : bool -> int -> t1
| C3 : t1.

Definition n : t1 := C2 false 3.

Definition m : bool :=
  match n with
  | C2 b _ => b
  | _ => true
  end.

Inductive t2 : vtag -> Set :=
| D1 : forall {a : vtag}, t2 a
| D2 : forall {a : vtag}, decode_vtag a -> t2 a -> t2 a.

Fixpoint of_list {A : vtag} (l : list (decode_vtag A)) : t2 A :=
  match l with
  | [] => D1
  | cons x xs => D2 x (of_list xs)
  end.

Fixpoint sum (l : t2 int_tag) : int :=
  let sum (l : t2 int_tag) : int := sum l in
  match l in t2 t0 return t0 = int_tag -> int with
  | D1 => fun eq0 => ltac:(subst; exact 0)
  | D2 x xs => fun eq0 => ltac:(subst; exact (Z.add x (sum xs)))
  end eq_refl.

Definition s {A : Set} (function_parameter : A) : int :=
  sum (@of_list int_tag [ 5; 7; 3 ]).

Parameter t3 : Set.

Parameter t4 : forall (a : Set), Set.

Inductive t5 : Set :=
| C : t5.

Inductive single_string : Set :=
| Single : string -> single_string.

Definition get_string (s : single_string) : string :=
  let 'Single s := s in
  s.
