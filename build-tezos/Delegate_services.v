(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Unset Positivity Checking.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Baking_mli. Module Baking := Baking_mli.
Require Tezos.Contract_repr.
Require Tezos.Misc.
Require Tezos.Services_registration.

Import Alpha_context.

Module info.
  Record record : Set := Build {
    balance : Alpha_context.Tez.t;
    frozen_balance : Alpha_context.Tez.t;
    frozen_balance_by_cycle :
      (|Alpha_context.Cycle.Map|).(S.MAP.t)
        Alpha_context.Delegate.frozen_balance;
    staking_balance : Alpha_context.Tez.t;
    delegated_contracts : list Contract_repr.t;
    delegated_balance : Alpha_context.Tez.t;
    deactivated : bool;
    grace_period : Alpha_context.Cycle.t }.
  Definition with_balance balance (r : record) :=
    Build balance r.(frozen_balance) r.(frozen_balance_by_cycle)
      r.(staking_balance) r.(delegated_contracts) r.(delegated_balance)
      r.(deactivated) r.(grace_period).
  Definition with_frozen_balance frozen_balance (r : record) :=
    Build r.(balance) frozen_balance r.(frozen_balance_by_cycle)
      r.(staking_balance) r.(delegated_contracts) r.(delegated_balance)
      r.(deactivated) r.(grace_period).
  Definition with_frozen_balance_by_cycle frozen_balance_by_cycle
    (r : record) :=
    Build r.(balance) r.(frozen_balance) frozen_balance_by_cycle
      r.(staking_balance) r.(delegated_contracts) r.(delegated_balance)
      r.(deactivated) r.(grace_period).
  Definition with_staking_balance staking_balance (r : record) :=
    Build r.(balance) r.(frozen_balance) r.(frozen_balance_by_cycle)
      staking_balance r.(delegated_contracts) r.(delegated_balance)
      r.(deactivated) r.(grace_period).
  Definition with_delegated_contracts delegated_contracts (r : record) :=
    Build r.(balance) r.(frozen_balance) r.(frozen_balance_by_cycle)
      r.(staking_balance) delegated_contracts r.(delegated_balance)
      r.(deactivated) r.(grace_period).
  Definition with_delegated_balance delegated_balance (r : record) :=
    Build r.(balance) r.(frozen_balance) r.(frozen_balance_by_cycle)
      r.(staking_balance) r.(delegated_contracts) delegated_balance
      r.(deactivated) r.(grace_period).
  Definition with_deactivated deactivated (r : record) :=
    Build r.(balance) r.(frozen_balance) r.(frozen_balance_by_cycle)
      r.(staking_balance) r.(delegated_contracts) r.(delegated_balance)
      deactivated r.(grace_period).
  Definition with_grace_period grace_period (r : record) :=
    Build r.(balance) r.(frozen_balance) r.(frozen_balance_by_cycle)
      r.(staking_balance) r.(delegated_contracts) r.(delegated_balance)
      r.(deactivated) grace_period.
End info.
Definition info := info.record.

Definition info_encoding : Data_encoding.encoding info :=
  Data_encoding.conv
    (fun function_parameter =>
      let '{|
        info.balance := balance;
          info.frozen_balance := __frozen_balance_value;
          info.frozen_balance_by_cycle := frozen_balance_by_cycle;
          info.staking_balance := staking_balance;
          info.delegated_contracts := delegated_contracts;
          info.delegated_balance := delegated_balance;
          info.deactivated := deactivated;
          info.grace_period := grace_period
          |} := function_parameter in
      (balance, __frozen_balance_value, frozen_balance_by_cycle,
        staking_balance, delegated_contracts, delegated_balance, deactivated,
        grace_period))
    (fun function_parameter =>
      let
        '(balance, __frozen_balance_value, frozen_balance_by_cycle,
          staking_balance, delegated_contracts, delegated_balance, deactivated,
          grace_period) := function_parameter in
      {| info.balance := balance; info.frozen_balance := __frozen_balance_value;
        info.frozen_balance_by_cycle := frozen_balance_by_cycle;
        info.staking_balance := staking_balance;
        info.delegated_contracts := delegated_contracts;
        info.delegated_balance := delegated_balance;
        info.deactivated := deactivated; info.grace_period := grace_period |})
    None
    (Data_encoding.obj8
      (Data_encoding.req None None "balance" Alpha_context.Tez.encoding)
      (Data_encoding.req None None "frozen_balance" Alpha_context.Tez.encoding)
      (Data_encoding.req None None "frozen_balance_by_cycle"
        Alpha_context.Delegate.frozen_balance_by_cycle_encoding)
      (Data_encoding.req None None "staking_balance" Alpha_context.Tez.encoding)
      (Data_encoding.req None None "delegated_contracts"
        (Data_encoding.__list_value None Contract_repr.encoding))
      (Data_encoding.req None None "delegated_balance"
        Alpha_context.Tez.encoding)
      (Data_encoding.req None None "deactivated" Data_encoding.__bool_value)
      (Data_encoding.req None None "grace_period" Alpha_context.Cycle.encoding)).

Module S.
  Definition raw_path : RPC_path.path Updater.rpc_context Updater.rpc_context :=
    RPC_path.op_div (RPC_path.op_div RPC_path.open_root "context") "delegates".
  
  Import Data_encoding.
  
  Module list_query.
    Record record : Set := Build {
      active : bool;
      inactive : bool }.
    Definition with_active active (r : record) :=
      Build active r.(inactive).
    Definition with_inactive inactive (r : record) :=
      Build r.(active) inactive.
  End list_query.
  Definition list_query := list_query.record.
  
  Definition __list_query_value : RPC_query.t list_query :=
    RPC_query.seal
      (RPC_query.op_pipeplus
        (RPC_query.op_pipeplus
          (RPC_query.__query_value
            (fun active =>
              fun inactive =>
                {| list_query.active := active; list_query.inactive := inactive
                  |}))
          (RPC_query.flag None "active"
            (fun __t_value => __t_value.(list_query.active))))
        (RPC_query.flag None "inactive"
          (fun __t_value => __t_value.(list_query.inactive)))).
  
  Definition list_delegate
    : RPC_service.service Updater.rpc_context Updater.rpc_context list_query
      unit (list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) :=
    RPC_service.get_service (Some "Lists all registered delegates.")
      __list_query_value
      (Data_encoding.__list_value None
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding)) raw_path.
  
  Definition path
    : RPC_path.path Updater.rpc_context
      (Updater.rpc_context *
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) :=
    RPC_path.op_divcolon raw_path
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.rpc_arg).
  
  Definition __info_value
    : RPC_service.service Updater.rpc_context
      (Updater.rpc_context *
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) unit unit info :=
    RPC_service.get_service (Some "Everything about a delegate.")
      RPC_query.empty info_encoding path.
  
  Definition balance
    : RPC_service.service Updater.rpc_context
      (Updater.rpc_context *
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) unit unit
      Alpha_context.Tez.t :=
    RPC_service.get_service
      (Some
        "Returns the full balance of a given delegate, including the frozen balances.")
      RPC_query.empty Alpha_context.Tez.encoding
      (RPC_path.op_div path "balance").
  
  Definition __frozen_balance_value
    : RPC_service.service Updater.rpc_context
      (Updater.rpc_context *
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) unit unit
      Alpha_context.Tez.t :=
    RPC_service.get_service
      (Some
        "Returns the total frozen balances of a given delegate, this includes the frozen deposits, rewards and fees.")
      RPC_query.empty Alpha_context.Tez.encoding
      (RPC_path.op_div path "frozen_balance").
  
  Definition frozen_balance_by_cycle
    : RPC_service.service Updater.rpc_context
      (Updater.rpc_context *
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) unit unit
      ((|Alpha_context.Cycle.Map|).(S.MAP.t)
        Alpha_context.Delegate.frozen_balance) :=
    RPC_service.get_service
      (Some
        "Returns the frozen balances of a given delegate, indexed by the cycle by which it will be unfrozen")
      RPC_query.empty Alpha_context.Delegate.frozen_balance_by_cycle_encoding
      (RPC_path.op_div path "frozen_balance_by_cycle").
  
  Definition staking_balance
    : RPC_service.service Updater.rpc_context
      (Updater.rpc_context *
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) unit unit
      Alpha_context.Tez.t :=
    RPC_service.get_service
      (Some
        "Returns the total amount of tokens delegated to a given delegate. This includes the balances of all the contracts that delegate to it, but also the balance of the delegate itself and its frozen fees and deposits. The rewards do not count in the delegated balance until they are unfrozen.")
      RPC_query.empty Alpha_context.Tez.encoding
      (RPC_path.op_div path "staking_balance").
  
  Definition delegated_contracts
    : RPC_service.service Updater.rpc_context
      (Updater.rpc_context *
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) unit unit
      (list Contract_repr.contract) :=
    RPC_service.get_service
      (Some "Returns the list of contracts that delegate to a given delegate.")
      RPC_query.empty (Data_encoding.__list_value None Contract_repr.encoding)
      (RPC_path.op_div path "delegated_contracts").
  
  Definition delegated_balance
    : RPC_service.service Updater.rpc_context
      (Updater.rpc_context *
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) unit unit
      Alpha_context.Tez.t :=
    RPC_service.get_service
      (Some
        "Returns the balances of all the contracts that delegate to a given delegate. This excludes the delegate's own balance and its frozen balances.")
      RPC_query.empty Alpha_context.Tez.encoding
      (RPC_path.op_div path "delegated_balance").
  
  Definition deactivated
    : RPC_service.service Updater.rpc_context
      (Updater.rpc_context *
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) unit unit bool :=
    RPC_service.get_service
      (Some
        "Tells whether the delegate is currently tagged as deactivated or not.")
      RPC_query.empty Data_encoding.__bool_value
      (RPC_path.op_div path "deactivated").
  
  Definition grace_period
    : RPC_service.service Updater.rpc_context
      (Updater.rpc_context *
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) unit unit
      Alpha_context.Cycle.t :=
    RPC_service.get_service
      (Some
        "Returns the cycle by the end of which the delegate might be deactivated if she fails to execute any delegate action. A deactivated delegate might be reactivated (without loosing any rolls) by simply re-registering as a delegate. For deactivated delegates, this value contains the cycle by which they were deactivated.")
      RPC_query.empty Alpha_context.Cycle.encoding
      (RPC_path.op_div path "grace_period").
End S.

Definition register (function_parameter : unit) : unit :=
  let '_ := function_parameter in
  (* ❌ Sequences of instructions are ignored (operator ";") *)
  (* ❌ instruction_sequence ";" *)
  (* ❌ Sequences of instructions are ignored (operator ";") *)
  (* ❌ instruction_sequence ";" *)
  (* ❌ Sequences of instructions are ignored (operator ";") *)
  (* ❌ instruction_sequence ";" *)
  (* ❌ Sequences of instructions are ignored (operator ";") *)
  (* ❌ instruction_sequence ";" *)
  (* ❌ Sequences of instructions are ignored (operator ";") *)
  (* ❌ instruction_sequence ";" *)
  (* ❌ Sequences of instructions are ignored (operator ";") *)
  (* ❌ instruction_sequence ";" *)
  (* ❌ Sequences of instructions are ignored (operator ";") *)
  (* ❌ instruction_sequence ";" *)
  (* ❌ Sequences of instructions are ignored (operator ";") *)
  (* ❌ instruction_sequence ";" *)
  (* ❌ Sequences of instructions are ignored (operator ";") *)
  (* ❌ instruction_sequence ";" *)
  Services_registration.register1 S.grace_period
    (fun ctxt =>
      fun pkh =>
        fun function_parameter =>
          let '_ := function_parameter in
          fun function_parameter =>
            let '_ := function_parameter in
            Alpha_context.Delegate.grace_period ctxt pkh).

Definition __list_value {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t RPC_context.t RPC_context.t q i o -> D -> q -> i ->
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t RPC_context.t (RPC_context.t * a) q i o -> D -> a -> q ->
      i -> Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
        (((RPC_service.t RPC_context.t ((RPC_context.t * a) * b) q i o -> D ->
        a -> b -> q -> i -> Lwt.t (Error_monad.shell_tzresult o)) *
          (I * a * b * q * i * o)) *
          (((RPC_service.t RPC_context.t (((RPC_context.t * a) * b) * c) q i o
          -> D -> a -> b -> c -> q -> i -> Lwt.t (Error_monad.shell_tzresult o))
            * (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (op_staroptstar : option bool)
  : option bool -> unit ->
  Lwt.t
    (Error_monad.shell_tzresult
      (list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))) :=
  let active :=
    match op_staroptstar with
    | Some op_starsthstar => op_starsthstar
    | None => true
    end in
  fun op_staroptstar =>
    let inactive :=
      match op_staroptstar with
      | Some op_starsthstar => op_starsthstar
      | None => false
      end in
    fun function_parameter =>
      let '_ := function_parameter in
      RPC_context.make_call0 S.list_delegate ctxt block
        {| S.list_query.active := active; S.list_query.inactive := inactive |}
        tt.

Definition __info_value {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t RPC_context.t RPC_context.t q i o -> D -> q -> i ->
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t RPC_context.t (RPC_context.t * a) q i o -> D -> a -> q ->
      i -> Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
        (((RPC_service.t RPC_context.t ((RPC_context.t * a) * b) q i o -> D ->
        a -> b -> q -> i -> Lwt.t (Error_monad.shell_tzresult o)) *
          (I * a * b * q * i * o)) *
          (((RPC_service.t RPC_context.t (((RPC_context.t * a) * b) * c) q i o
          -> D -> a -> b -> c -> q -> i -> Lwt.t (Error_monad.shell_tzresult o))
            * (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (pkh : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.shell_tzresult info) :=
  RPC_context.make_call1 S.__info_value ctxt block pkh tt tt.

Definition balance {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t RPC_context.t RPC_context.t q i o -> D -> q -> i ->
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t RPC_context.t (RPC_context.t * a) q i o -> D -> a -> q ->
      i -> Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
        (((RPC_service.t RPC_context.t ((RPC_context.t * a) * b) q i o -> D ->
        a -> b -> q -> i -> Lwt.t (Error_monad.shell_tzresult o)) *
          (I * a * b * q * i * o)) *
          (((RPC_service.t RPC_context.t (((RPC_context.t * a) * b) * c) q i o
          -> D -> a -> b -> c -> q -> i -> Lwt.t (Error_monad.shell_tzresult o))
            * (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (pkh : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t) :=
  RPC_context.make_call1 S.balance ctxt block pkh tt tt.

Definition __frozen_balance_value {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t RPC_context.t RPC_context.t q i o -> D -> q -> i ->
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t RPC_context.t (RPC_context.t * a) q i o -> D -> a -> q ->
      i -> Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
        (((RPC_service.t RPC_context.t ((RPC_context.t * a) * b) q i o -> D ->
        a -> b -> q -> i -> Lwt.t (Error_monad.shell_tzresult o)) *
          (I * a * b * q * i * o)) *
          (((RPC_service.t RPC_context.t (((RPC_context.t * a) * b) * c) q i o
          -> D -> a -> b -> c -> q -> i -> Lwt.t (Error_monad.shell_tzresult o))
            * (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (pkh : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t) :=
  RPC_context.make_call1 S.__frozen_balance_value ctxt block pkh tt tt.

Definition frozen_balance_by_cycle {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t RPC_context.t RPC_context.t q i o -> D -> q -> i ->
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t RPC_context.t (RPC_context.t * a) q i o -> D -> a -> q ->
      i -> Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
        (((RPC_service.t RPC_context.t ((RPC_context.t * a) * b) q i o -> D ->
        a -> b -> q -> i -> Lwt.t (Error_monad.shell_tzresult o)) *
          (I * a * b * q * i * o)) *
          (((RPC_service.t RPC_context.t (((RPC_context.t * a) * b) * c) q i o
          -> D -> a -> b -> c -> q -> i -> Lwt.t (Error_monad.shell_tzresult o))
            * (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (pkh : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t
    (Error_monad.shell_tzresult
      ((|Alpha_context.Cycle.Map|).(S.MAP.t)
        Alpha_context.Delegate.frozen_balance)) :=
  RPC_context.make_call1 S.frozen_balance_by_cycle ctxt block pkh tt tt.

Definition staking_balance {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t RPC_context.t RPC_context.t q i o -> D -> q -> i ->
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t RPC_context.t (RPC_context.t * a) q i o -> D -> a -> q ->
      i -> Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
        (((RPC_service.t RPC_context.t ((RPC_context.t * a) * b) q i o -> D ->
        a -> b -> q -> i -> Lwt.t (Error_monad.shell_tzresult o)) *
          (I * a * b * q * i * o)) *
          (((RPC_service.t RPC_context.t (((RPC_context.t * a) * b) * c) q i o
          -> D -> a -> b -> c -> q -> i -> Lwt.t (Error_monad.shell_tzresult o))
            * (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (pkh : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t) :=
  RPC_context.make_call1 S.staking_balance ctxt block pkh tt tt.

Definition delegated_contracts {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t RPC_context.t RPC_context.t q i o -> D -> q -> i ->
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t RPC_context.t (RPC_context.t * a) q i o -> D -> a -> q ->
      i -> Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
        (((RPC_service.t RPC_context.t ((RPC_context.t * a) * b) q i o -> D ->
        a -> b -> q -> i -> Lwt.t (Error_monad.shell_tzresult o)) *
          (I * a * b * q * i * o)) *
          (((RPC_service.t RPC_context.t (((RPC_context.t * a) * b) * c) q i o
          -> D -> a -> b -> c -> q -> i -> Lwt.t (Error_monad.shell_tzresult o))
            * (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (pkh : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.shell_tzresult (list Contract_repr.contract)) :=
  RPC_context.make_call1 S.delegated_contracts ctxt block pkh tt tt.

Definition delegated_balance {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t RPC_context.t RPC_context.t q i o -> D -> q -> i ->
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t RPC_context.t (RPC_context.t * a) q i o -> D -> a -> q ->
      i -> Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
        (((RPC_service.t RPC_context.t ((RPC_context.t * a) * b) q i o -> D ->
        a -> b -> q -> i -> Lwt.t (Error_monad.shell_tzresult o)) *
          (I * a * b * q * i * o)) *
          (((RPC_service.t RPC_context.t (((RPC_context.t * a) * b) * c) q i o
          -> D -> a -> b -> c -> q -> i -> Lwt.t (Error_monad.shell_tzresult o))
            * (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (pkh : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t) :=
  RPC_context.make_call1 S.delegated_balance ctxt block pkh tt tt.

Definition deactivated {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t RPC_context.t RPC_context.t q i o -> D -> q -> i ->
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t RPC_context.t (RPC_context.t * a) q i o -> D -> a -> q ->
      i -> Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
        (((RPC_service.t RPC_context.t ((RPC_context.t * a) * b) q i o -> D ->
        a -> b -> q -> i -> Lwt.t (Error_monad.shell_tzresult o)) *
          (I * a * b * q * i * o)) *
          (((RPC_service.t RPC_context.t (((RPC_context.t * a) * b) * c) q i o
          -> D -> a -> b -> c -> q -> i -> Lwt.t (Error_monad.shell_tzresult o))
            * (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (pkh : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.shell_tzresult bool) :=
  RPC_context.make_call1 S.deactivated ctxt block pkh tt tt.

Definition grace_period {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t RPC_context.t RPC_context.t q i o -> D -> q -> i ->
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t RPC_context.t (RPC_context.t * a) q i o -> D -> a -> q ->
      i -> Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
        (((RPC_service.t RPC_context.t ((RPC_context.t * a) * b) q i o -> D ->
        a -> b -> q -> i -> Lwt.t (Error_monad.shell_tzresult o)) *
          (I * a * b * q * i * o)) *
          (((RPC_service.t RPC_context.t (((RPC_context.t * a) * b) * c) q i o
          -> D -> a -> b -> c -> q -> i -> Lwt.t (Error_monad.shell_tzresult o))
            * (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (pkh : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Cycle.t) :=
  RPC_context.make_call1 S.grace_period ctxt block pkh tt tt.

Definition requested_levels
  (default : Alpha_context.Level.t * option Alpha_context.Timestamp.t)
  (ctxt : Alpha_context.context) (cycles : list Alpha_context.Cycle.t)
  (levels : list Alpha_context.Raw_level.t)
  : Lwt.t
    (Error_monad.tzresult
      (list (Alpha_context.Level.t * option Alpha_context.Timestamp.t))) :=
  match (levels, cycles) with
  | ([], []) => Error_monad.__return [ default ]
  | (levels, cycles) =>
    let levels :=
      List.sort_uniq Alpha_context.Level.compare
        (List.concat
          (cons
            (List.map
              (let arg := Alpha_context.Level.from_raw ctxt in
              fun eta => arg None eta) levels)
            (List.map (Alpha_context.Level.levels_in_cycle ctxt) cycles))) in
    Error_monad.map_s
      (fun level =>
        let current_level := Alpha_context.Level.current ctxt in
        if Alpha_context.Level.op_lteq level current_level then
          Error_monad.__return (level, None)
        else
          let=? timestamp := Baking.earlier_predecessor_timestamp ctxt level in
          Error_monad.__return (level, (Some timestamp))) levels
  end.

Module Baking_rights.
  Module t.
    Record record : Set := Build {
      level : Alpha_context.Raw_level.t;
      delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t);
      priority : int;
      timestamp : option Alpha_context.Timestamp.t }.
    Definition with_level level (r : record) :=
      Build level r.(delegate) r.(priority) r.(timestamp).
    Definition with_delegate delegate (r : record) :=
      Build r.(level) delegate r.(priority) r.(timestamp).
    Definition with_priority priority (r : record) :=
      Build r.(level) r.(delegate) priority r.(timestamp).
    Definition with_timestamp timestamp (r : record) :=
      Build r.(level) r.(delegate) r.(priority) timestamp.
  End t.
  Definition t := t.record.
  
  Definition encoding : Data_encoding.encoding t :=
    Data_encoding.conv
      (fun function_parameter =>
        let '{|
          t.level := level;
            t.delegate := delegate;
            t.priority := priority;
            t.timestamp := timestamp
            |} := function_parameter in
        (level, delegate, priority, timestamp))
      (fun function_parameter =>
        let '(level, delegate, priority, timestamp) := function_parameter in
        {| t.level := level; t.delegate := delegate; t.priority := priority;
          t.timestamp := timestamp |}) None
      (Data_encoding.obj4
        (Data_encoding.req None None "level" Alpha_context.Raw_level.encoding)
        (Data_encoding.req None None "delegate"
          (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
        (Data_encoding.req None None "priority" Data_encoding.uint16)
        (Data_encoding.opt None None "estimated_time"
          Alpha_context.Timestamp.encoding)).
  
  Module S.
    Import Data_encoding.
    
    Definition custom_root
      : RPC_path.path Updater.rpc_context Updater.rpc_context :=
      RPC_path.op_div (RPC_path.op_div RPC_path.open_root "helpers")
        "baking_rights".
    
    Module baking_rights_query.
      Record record : Set := Build {
        levels : list Alpha_context.Raw_level.t;
        cycles : list Alpha_context.Cycle.t;
        delegates : list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t);
        max_priority : option int;
        all : bool }.
      Definition with_levels levels (r : record) :=
        Build levels r.(cycles) r.(delegates) r.(max_priority) r.(all).
      Definition with_cycles cycles (r : record) :=
        Build r.(levels) cycles r.(delegates) r.(max_priority) r.(all).
      Definition with_delegates delegates (r : record) :=
        Build r.(levels) r.(cycles) delegates r.(max_priority) r.(all).
      Definition with_max_priority max_priority (r : record) :=
        Build r.(levels) r.(cycles) r.(delegates) max_priority r.(all).
      Definition with_all all (r : record) :=
        Build r.(levels) r.(cycles) r.(delegates) r.(max_priority) all.
    End baking_rights_query.
    Definition baking_rights_query := baking_rights_query.record.
    
    Definition baking_rights_query : RPC_query.t baking_rights_query :=
      RPC_query.seal
        (RPC_query.op_pipeplus
          (RPC_query.op_pipeplus
            (RPC_query.op_pipeplus
              (RPC_query.op_pipeplus
                (RPC_query.op_pipeplus
                  (RPC_query.__query_value
                    (fun levels =>
                      fun cycles =>
                        fun delegates =>
                          fun max_priority =>
                            fun all =>
                              {| baking_rights_query.levels := levels;
                                baking_rights_query.cycles := cycles;
                                baking_rights_query.delegates := delegates;
                                baking_rights_query.max_priority := max_priority;
                                baking_rights_query.all := all |}))
                  (RPC_query.multi_field None "level"
                    Alpha_context.Raw_level.rpc_arg
                    (fun __t_value => __t_value.(baking_rights_query.levels))))
                (RPC_query.multi_field None "cycle" Alpha_context.Cycle.rpc_arg
                  (fun __t_value => __t_value.(baking_rights_query.cycles))))
              (RPC_query.multi_field None "delegate"
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.rpc_arg)
                (fun __t_value => __t_value.(baking_rights_query.delegates))))
            (RPC_query.opt_field None "max_priority" RPC_arg.__int_value
              (fun __t_value => __t_value.(baking_rights_query.max_priority))))
          (RPC_query.flag None "all"
            (fun __t_value => __t_value.(baking_rights_query.all)))).
    
    Definition baking_rights
      : RPC_service.service Updater.rpc_context Updater.rpc_context
        baking_rights_query unit (list t) :=
      RPC_service.get_service
        (Some
          "Retrieves the list of delegates allowed to bake a block.\nBy default, it gives the best baking priorities for bakers that have at least one opportunity below the 64th priority for the next block.\nParameters `level` and `cycle` can be used to specify the (valid) level(s) in the past or future at which the baking rights have to be returned. Parameter `delegate` can be used to restrict the results to the given delegates. If parameter `all` is set, all the baking opportunities for each baker at each level are returned, instead of just the first one.\nReturns the list of baking slots. Also returns the minimal timestamps that correspond to these slots. The timestamps are omitted for levels in the past, and are only estimates for levels later that the next block, based on the hypothesis that all predecessor blocks were baked at the first priority.")
        baking_rights_query (Data_encoding.__list_value None encoding)
        custom_root.
  End S.
  
  Definition baking_priorities
    (ctxt : Alpha_context.context) (max_prio : (|Compare.Int|).(Compare.S.t))
    (function_parameter : Alpha_context.Level.t * option Time.t)
    : Lwt.t (Error_monad.tzresult (list t)) :=
    let '(level, pred_timestamp) := function_parameter in
    let=? contract_list := Baking.baking_priorities ctxt level in
    let fix loop
      (l : Misc.lazy_list_t (|Signature.Public_key|).(S.SPublic_key.t))
      (acc : list t) (priority : (|Compare.Int|).(Compare.S.t)) {struct l}
      : Lwt.t (Error_monad.tzresult (list t)) :=
      if (|Compare.Int|).(Compare.S.op_gteq) priority max_prio then
        Error_monad.__return (List.rev acc)
      else
        let 'Misc.LCons pk next := l in
        let delegate := (|Signature.Public_key|).(S.SPublic_key.__hash_value) pk
          in
        let=? timestamp :=
          match pred_timestamp with
          | None => Error_monad.return_none
          | Some pred_timestamp =>
            let=? __t_value := Baking.minimal_time ctxt priority pred_timestamp
              in
            Error_monad.return_some __t_value
          end in
        let acc :=
          cons
            {| t.level := level.(Alpha_context.Level.t.level);
              t.delegate := delegate; t.priority := priority;
              t.timestamp := timestamp |} acc in
        let=? l := next tt in
        loop l acc (Pervasives.op_plus priority 1) in
    loop contract_list nil 0.
  
  Definition remove_duplicated_delegates (rights : list t) : list t :=
    List.rev
      (Pervasives.fst
        (List.fold_left
          (fun function_parameter =>
            let '(acc, previous) := function_parameter in
            fun __r_value =>
              if
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.__Set).(S.INDEXES_Set.mem)
                  __r_value.(t.delegate) previous then
                (acc, previous)
              else
                ((cons __r_value acc),
                  ((|Signature.Public_key_hash|).(S.SPublic_key_hash.__Set).(S.INDEXES_Set.add)
                    __r_value.(t.delegate) previous)))
          (nil,
            (|Signature.Public_key_hash|).(S.SPublic_key_hash.__Set).(S.INDEXES_Set.empty))
          rights)).
  
  Definition register (function_parameter : unit) : unit :=
    let '_ := function_parameter in
    Services_registration.register0 S.baking_rights
      (fun ctxt =>
        fun q =>
          fun function_parameter =>
            let '_ := function_parameter in
            let=? levels :=
              requested_levels
                ((Alpha_context.Level.succ ctxt
                  (Alpha_context.Level.current ctxt)),
                  (Some (Alpha_context.Timestamp.current ctxt))) ctxt
                q.(S.baking_rights_query.cycles)
                q.(S.baking_rights_query.levels) in
            let max_priority :=
              match q.(S.baking_rights_query.max_priority) with
              | None => 64
              | Some max => max
              end in
            let=? rights :=
              Error_monad.map_s (baking_priorities ctxt max_priority) levels in
            let rights :=
              if q.(S.baking_rights_query.all) then
                rights
              else
                List.map remove_duplicated_delegates rights in
            let rights := List.concat rights in
            match q.(S.baking_rights_query.delegates) with
            | [] => Error_monad.__return rights
            | (cons _ _) as delegates =>
              let is_requested (__p_value : t) : bool :=
                List.__exists
                  ((|Signature.Public_key_hash|).(S.SPublic_key_hash.equal)
                    __p_value.(t.delegate)) delegates in
              Error_monad.__return (List.filter is_requested rights)
            end).
  
  Definition get {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t RPC_context.t RPC_context.t q i o -> D -> q -> i ->
      Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
        (((RPC_service.t RPC_context.t (RPC_context.t * a) q i o -> D -> a ->
        q -> i -> Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t RPC_context.t ((RPC_context.t * a) * b) q i o -> D ->
          a -> b -> q -> i -> Lwt.t (Error_monad.shell_tzresult o)) *
            (I * a * b * q * i * o)) *
            (((RPC_service.t RPC_context.t (((RPC_context.t * a) * b) * c) q i o
            -> D -> a -> b -> c -> q -> i ->
            Lwt.t (Error_monad.shell_tzresult o)) * (K * a * b * c * q * i * o))
              * L)))) * L * D)
    (op_staroptstar : option (list Alpha_context.Raw_level.t))
    : option (list Alpha_context.Cycle.t) ->
    option (list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) ->
    option bool -> option int -> D ->
    Lwt.t (Error_monad.shell_tzresult (list t)) :=
    let levels :=
      match op_staroptstar with
      | Some op_starsthstar => op_starsthstar
      | None => nil
      end in
    fun op_staroptstar =>
      let cycles :=
        match op_staroptstar with
        | Some op_starsthstar => op_starsthstar
        | None => nil
        end in
      fun op_staroptstar =>
        let delegates :=
          match op_staroptstar with
          | Some op_starsthstar => op_starsthstar
          | None => nil
          end in
        fun op_staroptstar =>
          let all :=
            match op_staroptstar with
            | Some op_starsthstar => op_starsthstar
            | None => false
            end in
          fun max_priority =>
            fun block =>
              RPC_context.make_call0 S.baking_rights ctxt block
                {| S.baking_rights_query.levels := levels;
                  S.baking_rights_query.cycles := cycles;
                  S.baking_rights_query.delegates := delegates;
                  S.baking_rights_query.max_priority := max_priority;
                  S.baking_rights_query.all := all |} tt.
End Baking_rights.

Module Endorsing_rights.
  Module t.
    Record record : Set := Build {
      level : Alpha_context.Raw_level.t;
      delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t);
      slots : list int;
      estimated_time : option Time.t }.
    Definition with_level level (r : record) :=
      Build level r.(delegate) r.(slots) r.(estimated_time).
    Definition with_delegate delegate (r : record) :=
      Build r.(level) delegate r.(slots) r.(estimated_time).
    Definition with_slots slots (r : record) :=
      Build r.(level) r.(delegate) slots r.(estimated_time).
    Definition with_estimated_time estimated_time (r : record) :=
      Build r.(level) r.(delegate) r.(slots) estimated_time.
  End t.
  Definition t := t.record.
  
  Definition encoding : Data_encoding.encoding t :=
    Data_encoding.conv
      (fun function_parameter =>
        let '{|
          t.level := level;
            t.delegate := delegate;
            t.slots := slots;
            t.estimated_time := estimated_time
            |} := function_parameter in
        (level, delegate, slots, estimated_time))
      (fun function_parameter =>
        let '(level, delegate, slots, estimated_time) := function_parameter in
        {| t.level := level; t.delegate := delegate; t.slots := slots;
          t.estimated_time := estimated_time |}) None
      (Data_encoding.obj4
        (Data_encoding.req None None "level" Alpha_context.Raw_level.encoding)
        (Data_encoding.req None None "delegate"
          (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
        (Data_encoding.req None None "slots"
          (Data_encoding.__list_value None Data_encoding.uint16))
        (Data_encoding.opt None None "estimated_time"
          Alpha_context.Timestamp.encoding)).
  
  Module S.
    Import Data_encoding.
    
    Definition custom_root
      : RPC_path.path Updater.rpc_context Updater.rpc_context :=
      RPC_path.op_div (RPC_path.op_div RPC_path.open_root "helpers")
        "endorsing_rights".
    
    Module endorsing_rights_query.
      Record record : Set := Build {
        levels : list Alpha_context.Raw_level.t;
        cycles : list Alpha_context.Cycle.t;
        delegates : list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) }.
      Definition with_levels levels (r : record) :=
        Build levels r.(cycles) r.(delegates).
      Definition with_cycles cycles (r : record) :=
        Build r.(levels) cycles r.(delegates).
      Definition with_delegates delegates (r : record) :=
        Build r.(levels) r.(cycles) delegates.
    End endorsing_rights_query.
    Definition endorsing_rights_query := endorsing_rights_query.record.
    
    Definition endorsing_rights_query : RPC_query.t endorsing_rights_query :=
      RPC_query.seal
        (RPC_query.op_pipeplus
          (RPC_query.op_pipeplus
            (RPC_query.op_pipeplus
              (RPC_query.__query_value
                (fun levels =>
                  fun cycles =>
                    fun delegates =>
                      {| endorsing_rights_query.levels := levels;
                        endorsing_rights_query.cycles := cycles;
                        endorsing_rights_query.delegates := delegates |}))
              (RPC_query.multi_field None "level"
                Alpha_context.Raw_level.rpc_arg
                (fun __t_value => __t_value.(endorsing_rights_query.levels))))
            (RPC_query.multi_field None "cycle" Alpha_context.Cycle.rpc_arg
              (fun __t_value => __t_value.(endorsing_rights_query.cycles))))
          (RPC_query.multi_field None "delegate"
            (|Signature.Public_key_hash|).(S.SPublic_key_hash.rpc_arg)
            (fun __t_value => __t_value.(endorsing_rights_query.delegates)))).
    
    Definition endorsing_rights
      : RPC_service.service Updater.rpc_context Updater.rpc_context
        endorsing_rights_query unit (list t) :=
      RPC_service.get_service
        (Some
          "Retrieves the delegates allowed to endorse a block.\nBy default, it gives the endorsement slots for delegates that have at least one in the next block.\nParameters `level` and `cycle` can be used to specify the (valid) level(s) in the past or future at which the endorsement rights have to be returned. Parameter `delegate` can be used to restrict the results to the given delegates.\nReturns the list of endorsement slots. Also returns the minimal timestamps that correspond to these slots. The timestamps are omitted for levels in the past, and are only estimates for levels later that the next block, based on the hypothesis that all predecessor blocks were baked at the first priority.")
        endorsing_rights_query (Data_encoding.__list_value None encoding)
        custom_root.
  End S.
  
  Definition endorsement_slots
    (ctxt : Alpha_context.context)
    (function_parameter : Alpha_context.Level.t * option Time.t)
    : Lwt.t (Error_monad.tzresult (list t)) :=
    let '(level, estimated_time) := function_parameter in
    let=? rights := Baking.endorsement_rights ctxt level in
    Error_monad.__return
      ((|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.fold)
        (fun delegate =>
          fun function_parameter =>
            let '(_, slots, _) := function_parameter in
            fun acc =>
              cons
                {| t.level := level.(Alpha_context.Level.t.level);
                  t.delegate := delegate; t.slots := slots;
                  t.estimated_time := estimated_time |} acc) rights nil).
  
  Definition register (function_parameter : unit) : unit :=
    let '_ := function_parameter in
    Services_registration.register0 S.endorsing_rights
      (fun ctxt =>
        fun q =>
          fun function_parameter =>
            let '_ := function_parameter in
            let=? levels :=
              requested_levels
                ((Alpha_context.Level.current ctxt),
                  (Some (Alpha_context.Timestamp.current ctxt))) ctxt
                q.(S.endorsing_rights_query.cycles)
                q.(S.endorsing_rights_query.levels) in
            let=? rights := Error_monad.map_s (endorsement_slots ctxt) levels in
            let rights := List.concat rights in
            match q.(S.endorsing_rights_query.delegates) with
            | [] => Error_monad.__return rights
            | (cons _ _) as delegates =>
              let is_requested (__p_value : t) : bool :=
                List.__exists
                  ((|Signature.Public_key_hash|).(S.SPublic_key_hash.equal)
                    __p_value.(t.delegate)) delegates in
              Error_monad.__return (List.filter is_requested rights)
            end).
  
  Definition get {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t RPC_context.t RPC_context.t q i o -> D -> q -> i ->
      Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
        (((RPC_service.t RPC_context.t (RPC_context.t * a) q i o -> D -> a ->
        q -> i -> Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t RPC_context.t ((RPC_context.t * a) * b) q i o -> D ->
          a -> b -> q -> i -> Lwt.t (Error_monad.shell_tzresult o)) *
            (I * a * b * q * i * o)) *
            (((RPC_service.t RPC_context.t (((RPC_context.t * a) * b) * c) q i o
            -> D -> a -> b -> c -> q -> i ->
            Lwt.t (Error_monad.shell_tzresult o)) * (K * a * b * c * q * i * o))
              * L)))) * L * D)
    (op_staroptstar : option (list Alpha_context.Raw_level.t))
    : option (list Alpha_context.Cycle.t) ->
    option (list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) -> D ->
    Lwt.t (Error_monad.shell_tzresult (list t)) :=
    let levels :=
      match op_staroptstar with
      | Some op_starsthstar => op_starsthstar
      | None => nil
      end in
    fun op_staroptstar =>
      let cycles :=
        match op_staroptstar with
        | Some op_starsthstar => op_starsthstar
        | None => nil
        end in
      fun op_staroptstar =>
        let delegates :=
          match op_staroptstar with
          | Some op_starsthstar => op_starsthstar
          | None => nil
          end in
        fun block =>
          RPC_context.make_call0 S.endorsing_rights ctxt block
            {| S.endorsing_rights_query.levels := levels;
              S.endorsing_rights_query.cycles := cycles;
              S.endorsing_rights_query.delegates := delegates |} tt.
End Endorsing_rights.

Module Endorsing_power.
  Definition endorsing_power
    (ctxt : Alpha_context.context)
    (function_parameter :
      Alpha_context.packed_operation * (|Chain_id|).(S.HASH.t))
    : Lwt.t (Error_monad.tzresult int) :=
    let '(operation, chain_id) := function_parameter in
    let 'Alpha_context.Operation_data data :=
      operation.(Alpha_context.packed_operation.protocol_data) in
    match data.(Alpha_context.protocol_data.contents) with
    | Alpha_context.Single (Alpha_context.Endorsement _) =>
      let=? '(_, slots, _) :=
        Baking.check_endorsement_rights ctxt chain_id
          {|
            Alpha_context.operation.shell :=
              operation.(Alpha_context.packed_operation.shell);
            Alpha_context.operation.protocol_data := data |} in
      Error_monad.__return (List.length slots)
    | _ => Pervasives.failwith "Operation is not an endorsement"
    end.
  
  Module S.
    Definition endorsing_power
      : RPC_service.service Updater.rpc_context Updater.rpc_context unit
        (Alpha_context.Operation.packed * (|Chain_id|).(S.HASH.t)) int :=
      RPC_service.post_service
        (Some
          "Get the endorsing power of an endorsement, that is, the number of slots that the endorser has")
        RPC_query.empty
        (Data_encoding.obj2
          (Data_encoding.req None None "endorsement_operation"
            Alpha_context.Operation.encoding)
          (Data_encoding.req None None "chain_id" (|Chain_id|).(S.HASH.encoding)))
        Data_encoding.int31
        (RPC_path.op_div RPC_path.open_root "endorsing_power").
  End S.
  
  Definition register (function_parameter : unit) : unit :=
    let '_ := function_parameter in
    Services_registration.register0 S.endorsing_power
      (fun ctxt =>
        fun function_parameter =>
          let '_ := function_parameter in
          fun function_parameter =>
            let '(op, chain_id) := function_parameter in
            endorsing_power ctxt (op, chain_id)).
  
  Definition get {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t RPC_context.t RPC_context.t q i o -> D -> q -> i ->
      Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
        (((RPC_service.t RPC_context.t (RPC_context.t * a) q i o -> D -> a ->
        q -> i -> Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t RPC_context.t ((RPC_context.t * a) * b) q i o -> D ->
          a -> b -> q -> i -> Lwt.t (Error_monad.shell_tzresult o)) *
            (I * a * b * q * i * o)) *
            (((RPC_service.t RPC_context.t (((RPC_context.t * a) * b) * c) q i o
            -> D -> a -> b -> c -> q -> i ->
            Lwt.t (Error_monad.shell_tzresult o)) * (K * a * b * c * q * i * o))
              * L)))) * L * D) (block : D) (op : Alpha_context.Operation.packed)
    (chain_id : (|Chain_id|).(S.HASH.t))
    : Lwt.t (Error_monad.shell_tzresult int) :=
    RPC_context.make_call0 S.endorsing_power ctxt block tt (op, chain_id).
End Endorsing_power.

Module Required_endorsements.
  Definition required_endorsements
    (ctxt : Alpha_context.context) (block_delay : Alpha_context.Period.t)
    : Lwt.t (Error_monad.tzresult int) :=
    Error_monad.__return (Baking.minimum_allowed_endorsements ctxt block_delay).
  
  Module S.
    Module t.
      Record record : Set := Build {
        block_delay : Alpha_context.Period.t }.
      Definition with_block_delay block_delay (r : record) :=
        Build block_delay.
    End t.
    Definition t := t.record.
    
    Definition required_endorsements_query : RPC_query.t t :=
      RPC_query.seal
        (RPC_query.op_pipeplus
          (RPC_query.__query_value
            (fun block_delay => {| t.block_delay := block_delay |}))
          (RPC_query.__field_value None "block_delay"
            Alpha_context.Period.rpc_arg Alpha_context.Period.zero
            (fun __t_value => __t_value.(t.block_delay)))).
    
    Definition required_endorsements
      : RPC_service.service Updater.rpc_context Updater.rpc_context t unit int :=
      RPC_service.get_service
        (Some
          "Minimum number of endorsements for a block to be valid, given a delay of the block's timestamp with respect to the minimum time to bake at the block's priority")
        required_endorsements_query Data_encoding.int31
        (RPC_path.op_div RPC_path.open_root "required_endorsements").
  End S.
  
  Definition register (function_parameter : unit) : unit :=
    let '_ := function_parameter in
    Services_registration.register0 S.required_endorsements
      (fun ctxt =>
        fun function_parameter =>
          let '{| S.t.block_delay := block_delay |} := function_parameter in
          fun function_parameter =>
            let '_ := function_parameter in
            required_endorsements ctxt block_delay).
  
  Definition get {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t RPC_context.t RPC_context.t q i o -> D -> q -> i ->
      Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
        (((RPC_service.t RPC_context.t (RPC_context.t * a) q i o -> D -> a ->
        q -> i -> Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t RPC_context.t ((RPC_context.t * a) * b) q i o -> D ->
          a -> b -> q -> i -> Lwt.t (Error_monad.shell_tzresult o)) *
            (I * a * b * q * i * o)) *
            (((RPC_service.t RPC_context.t (((RPC_context.t * a) * b) * c) q i o
            -> D -> a -> b -> c -> q -> i ->
            Lwt.t (Error_monad.shell_tzresult o)) * (K * a * b * c * q * i * o))
              * L)))) * L * D) (block : D)
    (block_delay : Alpha_context.Period.t)
    : Lwt.t (Error_monad.shell_tzresult int) :=
    RPC_context.make_call0 S.required_endorsements ctxt block
      {| S.t.block_delay := block_delay |} tt.
End Required_endorsements.

Module Minimal_valid_time.
  Definition minimal_valid_time
    (ctxt : Alpha_context.context) (priority : int) (endorsing_power : int)
    : Lwt.t (Error_monad.tzresult Time.t) :=
    Baking.minimal_valid_time ctxt priority endorsing_power.
  
  Module S.
    Module t.
      Record record : Set := Build {
        priority : int;
        endorsing_power : int }.
      Definition with_priority priority (r : record) :=
        Build priority r.(endorsing_power).
      Definition with_endorsing_power endorsing_power (r : record) :=
        Build r.(priority) endorsing_power.
    End t.
    Definition t := t.record.
    
    Definition minimal_valid_time_query : RPC_query.t t :=
      RPC_query.seal
        (RPC_query.op_pipeplus
          (RPC_query.op_pipeplus
            (RPC_query.__query_value
              (fun priority =>
                fun endorsing_power =>
                  {| t.priority := priority;
                    t.endorsing_power := endorsing_power |}))
            (RPC_query.__field_value None "priority" RPC_arg.__int_value 0
              (fun __t_value => __t_value.(t.priority))))
          (RPC_query.__field_value None "endorsing_power" RPC_arg.__int_value 0
            (fun __t_value => __t_value.(t.endorsing_power)))).
    
    Definition minimal_valid_time
      : RPC_service.service Updater.rpc_context Updater.rpc_context t unit
        Time.t :=
      RPC_service.get_service
        (Some
          "Minimal valid time for a block given a priority and an endorsing power.")
        minimal_valid_time_query Time.encoding
        (RPC_path.op_div RPC_path.open_root "minimal_valid_time").
  End S.
  
  Definition register (function_parameter : unit) : unit :=
    let '_ := function_parameter in
    Services_registration.register0 S.minimal_valid_time
      (fun ctxt =>
        fun function_parameter =>
          let '{|
            S.t.priority := priority;
              S.t.endorsing_power := endorsing_power
              |} := function_parameter in
          fun function_parameter =>
            let '_ := function_parameter in
            minimal_valid_time ctxt priority endorsing_power).
  
  Definition get {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t RPC_context.t RPC_context.t q i o -> D -> q -> i ->
      Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
        (((RPC_service.t RPC_context.t (RPC_context.t * a) q i o -> D -> a ->
        q -> i -> Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t RPC_context.t ((RPC_context.t * a) * b) q i o -> D ->
          a -> b -> q -> i -> Lwt.t (Error_monad.shell_tzresult o)) *
            (I * a * b * q * i * o)) *
            (((RPC_service.t RPC_context.t (((RPC_context.t * a) * b) * c) q i o
            -> D -> a -> b -> c -> q -> i ->
            Lwt.t (Error_monad.shell_tzresult o)) * (K * a * b * c * q * i * o))
              * L)))) * L * D) (block : D) (priority : int)
    (endorsing_power : int) : Lwt.t (Error_monad.shell_tzresult Time.t) :=
    RPC_context.make_call0 S.minimal_valid_time ctxt block
      {| S.t.priority := priority; S.t.endorsing_power := endorsing_power |} tt.
End Minimal_valid_time.

Definition register (function_parameter : unit) : unit :=
  let '_ := function_parameter in
  (* ❌ Sequences of instructions are ignored (operator ";") *)
  (* ❌ instruction_sequence ";" *)
  (* ❌ Sequences of instructions are ignored (operator ";") *)
  (* ❌ instruction_sequence ";" *)
  (* ❌ Sequences of instructions are ignored (operator ";") *)
  (* ❌ instruction_sequence ";" *)
  (* ❌ Sequences of instructions are ignored (operator ";") *)
  (* ❌ instruction_sequence ";" *)
  (* ❌ Sequences of instructions are ignored (operator ";") *)
  (* ❌ instruction_sequence ";" *)
  Minimal_valid_time.register tt.

Definition endorsement_rights
  (ctxt : Alpha_context.context) (level : Alpha_context.Level.t)
  : Lwt.t
    (Error_monad.tzresult
      (list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))) :=
  let=? l := Endorsing_rights.endorsement_slots ctxt (level, None) in
  Error_monad.__return
    (List.map
      (fun function_parameter =>
        let '{| Endorsing_rights.t.delegate := delegate |} := function_parameter
          in
        delegate) l).

Definition baking_rights
  (ctxt : Alpha_context.context)
  (max_priority : option (|Compare.Int|).(Compare.S.t))
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.Raw_level.t *
        list
          ((|Signature.Public_key_hash|).(S.SPublic_key_hash.t) *
            option Alpha_context.Timestamp.t))) :=
  let max :=
    match max_priority with
    | None => 64
    | Some m => m
    end in
  let level := Alpha_context.Level.current ctxt in
  let=? l := Baking_rights.baking_priorities ctxt max (level, None) in
  Error_monad.__return
    (level.(Alpha_context.Level.t.level),
      (List.map
        (fun function_parameter =>
          let '{|
            Baking_rights.t.delegate := delegate;
              Baking_rights.t.timestamp := timestamp
              |} := function_parameter in
          (delegate, timestamp)) l)).

Definition endorsing_power
  (ctxt : Alpha_context.context)
  (operation : Alpha_context.packed_operation * (|Chain_id|).(S.HASH.t))
  : Lwt.t (Error_monad.tzresult int) :=
  Endorsing_power.endorsing_power ctxt operation.

Definition required_endorsements
  (ctxt : Alpha_context.context) (delay : Alpha_context.Period.t)
  : Lwt.t (Error_monad.tzresult int) :=
  Required_endorsements.required_endorsements ctxt delay.

Definition minimal_valid_time
  (ctxt : Alpha_context.context) (priority : int) (endorsing_power : int)
  : Lwt.t (Error_monad.tzresult Time.t) :=
  Minimal_valid_time.minimal_valid_time ctxt priority endorsing_power.
