(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Unset Positivity Checking.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Constants_repr.
Require Tezos.Contract_repr.
Require Tezos.Fitness_repr.
Require Tezos.Gas_limit_repr.
Require Tezos.Level_repr.
Require Tezos.Parameters_repr.
Require Tezos.Raw_level_repr.
Require Tezos.Storage_description.
Require Tezos.Tez_repr.

Definition Int_set :=
  __Set.Make
    (existT (A := Set) _ _
      {|
        Compare.COMPARABLE.compare := (|Compare.Int|).(Compare.S.compare)
      |}).

Module t.
  Record record := Build {
    context : Context.t;
    constants : Constants_repr.parametric;
    first_level : Raw_level_repr.t;
    level : Level_repr.t;
    predecessor_timestamp : Time.t;
    timestamp : Time.t;
    fitness : Int64.t;
    deposits :
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
        Tez_repr.t;
    included_endorsements : Z;
    allowed_endorsements :
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
        ((|Signature.Public_key|).(S.SPublic_key.t) * list Z * bool);
    fees : Tez_repr.t;
    rewards : Tez_repr.t;
    block_gas : Z.t;
    operation_gas : Gas_limit_repr.t;
    internal_gas : Gas_limit_repr.internal_gas;
    storage_space_to_pay : option Z.t;
    allocated_contracts : option Z;
    origination_nonce : option Contract_repr.origination_nonce;
    temporary_big_map : Z.t;
    internal_nonce : Z;
    internal_nonces_used : (|Int_set|).(S.SET.t) }.
  Definition with_context context (r : record) :=
    Build context r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_constants constants (r : record) :=
    Build r.(context) constants r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_first_level first_level (r : record) :=
    Build r.(context) r.(constants) first_level r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_level level (r : record) :=
    Build r.(context) r.(constants) r.(first_level) level
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_predecessor_timestamp predecessor_timestamp (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      predecessor_timestamp r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_timestamp timestamp (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) timestamp r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_fitness fitness (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) fitness r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_deposits deposits (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) deposits
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_included_endorsements included_endorsements (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      included_endorsements r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_allowed_endorsements allowed_endorsements (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) allowed_endorsements r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_fees fees (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) fees r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_rewards rewards (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) rewards
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_block_gas block_gas (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      block_gas r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_operation_gas operation_gas (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) operation_gas r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_internal_gas internal_gas (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) internal_gas r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_storage_space_to_pay storage_space_to_pay (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) storage_space_to_pay
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_allocated_contracts allocated_contracts (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      allocated_contracts r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_origination_nonce origination_nonce (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) origination_nonce r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_temporary_big_map temporary_big_map (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) temporary_big_map
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_internal_nonce internal_nonce (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      internal_nonce r.(internal_nonces_used).
  Definition with_internal_nonces_used internal_nonces_used (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) internal_nonces_used.
End t.
Definition t := t.record.

Definition context := t.

Definition root_context := t.

Definition current_level (ctxt : t) : Level_repr.t := ctxt.(t.level).

Definition predecessor_timestamp (ctxt : t) : Time.t :=
  ctxt.(t.predecessor_timestamp).

Definition current_timestamp (ctxt : t) : Time.t := ctxt.(t.timestamp).

Definition current_fitness (ctxt : t) : Int64.t := ctxt.(t.fitness).

Definition first_level (ctxt : t) : Raw_level_repr.t := ctxt.(t.first_level).

Definition constants (ctxt : t) : Constants_repr.parametric :=
  ctxt.(t.constants).

Definition recover (ctxt : t) : Context.t := ctxt.(t.context).

Definition record_endorsement
  (ctxt : t)
  (k :
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.key))
  : t :=
  match
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.find_opt)
      k ctxt.(t.allowed_endorsements) with
  | None =>
    (* ❌ Assert instruction is not handled. *)
    assert false
  | Some (_, _, true) =>
    (* ❌ Assert instruction is not handled. *)
    assert false
  | Some (d, s, false) =>
    t.with_allowed_endorsements
      ((|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.add)
        k (d, s, true) ctxt.(t.allowed_endorsements))
      (t.with_included_endorsements
        (Pervasives.op_plus ctxt.(t.included_endorsements) (List.length s)) ctxt)
  end.

Definition init_endorsements
  (ctxt : t)
  (allowed_endorsements :
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
      ((|Signature.Public_key|).(S.SPublic_key.t) * list Z * bool)) : t :=
  if
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.is_empty)
      allowed_endorsements then
    (* ❌ Assert instruction is not handled. *)
    assert false
  else
    if
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.is_empty)
        ctxt.(t.allowed_endorsements) then
      t.with_allowed_endorsements allowed_endorsements ctxt
    else
      (* ❌ Assert instruction is not handled. *)
      assert false.

Definition allowed_endorsements (ctxt : t)
  : (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
    ((|Signature.Public_key|).(S.SPublic_key.t) * list Z * bool) :=
  ctxt.(t.allowed_endorsements).

Definition included_endorsements (ctxt : t) : Z :=
  ctxt.(t.included_endorsements).

(* ❌ Structure item `typext` not handled. *)
(* type_extension *)

(* ❌ Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition fresh_internal_nonce (ctxt : t) : Error_monad.tzresult (t * Z) :=
  if (|Compare.Int|).(Compare.S.op_gteq) ctxt.(t.internal_nonce) 65535 then
    Error_monad.__error_value extensible_type_value
  else
    Error_monad.ok
      ((t.with_internal_nonce (Pervasives.op_plus ctxt.(t.internal_nonce) 1)
        ctxt), ctxt.(t.internal_nonce)).

Definition reset_internal_nonce (ctxt : t) : t :=
  t.with_internal_nonces_used (|Int_set|).(S.SET.empty)
    (t.with_internal_nonce 0 ctxt).

Definition record_internal_nonce (ctxt : t) (k : (|Int_set|).(S.SET.elt)) : t :=
  t.with_internal_nonces_used
    ((|Int_set|).(S.SET.add) k ctxt.(t.internal_nonces_used)) ctxt.

Definition internal_nonce_already_recorded
  (ctxt : t) (k : (|Int_set|).(S.SET.elt)) : bool :=
  (|Int_set|).(S.SET.mem) k ctxt.(t.internal_nonces_used).

Definition set_current_fitness (ctxt : t) (fitness : Int64.t) : t :=
  t.with_fitness fitness ctxt.

Definition add_fees (ctxt : t) (fees : Tez_repr.t)
  : Lwt.t (Error_monad.tzresult t) :=
  Error_monad.op_gtgteqquestion
    (Lwt.__return (Tez_repr.op_plusquestion ctxt.(t.fees) fees))
    (fun fees => Error_monad.__return (t.with_fees fees ctxt)).

Definition add_rewards (ctxt : t) (rewards : Tez_repr.t)
  : Lwt.t (Error_monad.tzresult t) :=
  Error_monad.op_gtgteqquestion
    (Lwt.__return (Tez_repr.op_plusquestion ctxt.(t.rewards) rewards))
    (fun rewards => Error_monad.__return (t.with_rewards rewards ctxt)).

Definition add_deposit
  (ctxt : t)
  (delegate :
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.key))
  (deposit : Tez_repr.t) : Lwt.t (Error_monad.tzresult t) :=
  let previous :=
    match
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.find_opt)
        delegate ctxt.(t.deposits) with
    | Some tz => tz
    | None => Tez_repr.zero
    end in
  Error_monad.op_gtgteqquestion
    (Lwt.__return (Tez_repr.op_plusquestion previous deposit))
    (fun deposit =>
      let deposits :=
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.add)
          delegate deposit ctxt.(t.deposits) in
      Error_monad.__return (t.with_deposits deposits ctxt)).

Definition get_deposits (ctxt : t)
  : (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
    Tez_repr.t := ctxt.(t.deposits).

Definition get_rewards (ctxt : t) : Tez_repr.t := ctxt.(t.rewards).

Definition get_fees (ctxt : t) : Tez_repr.t := ctxt.(t.fees).

(* ❌ Structure item `typext` not handled. *)
(* type_extension *)

(* ❌ Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition init_origination_nonce
  (ctxt : t) (operation_hash : (|Operation_hash|).(S.HASH.t)) : t :=
  let origination_nonce :=
    Some (Contract_repr.initial_origination_nonce operation_hash) in
  t.with_origination_nonce origination_nonce ctxt.

Definition origination_nonce (ctxt : t)
  : Error_monad.tzresult Contract_repr.origination_nonce :=
  match ctxt.(t.origination_nonce) with
  | None => Error_monad.__error_value extensible_type_value
  | Some origination_nonce => Error_monad.ok origination_nonce
  end.

Definition increment_origination_nonce (ctxt : t)
  : Error_monad.tzresult (t * Contract_repr.origination_nonce) :=
  match ctxt.(t.origination_nonce) with
  | None => Error_monad.__error_value extensible_type_value
  | Some cur_origination_nonce =>
    let origination_nonce :=
      Some (Contract_repr.incr_origination_nonce cur_origination_nonce) in
    Error_monad.ok
      ((t.with_origination_nonce origination_nonce ctxt), cur_origination_nonce)
  end.

Definition unset_origination_nonce (ctxt : t) : t :=
  t.with_origination_nonce None ctxt.

(* ❌ Structure item `typext` not handled. *)
(* type_extension *)

(* ❌ Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition check_gas_limit (ctxt : t) (remaining : (|Compare.Z|).(Compare.S.t))
  : Error_monad.tzresult unit :=
  if
    Pervasives.op_pipepipe
      ((|Compare.Z|).(Compare.S.op_gt) remaining
        ctxt.(t.constants).(Constants_repr.parametric.hard_gas_limit_per_operation))
      ((|Compare.Z|).(Compare.S.op_lt) remaining Z.zero) then
    Error_monad.__error_value extensible_type_value
  else
    Error_monad.ok tt.

Definition set_gas_limit (ctxt : t) (remaining : Z.t) : t :=
  t.with_internal_gas Gas_limit_repr.internal_gas_zero
    (t.with_operation_gas
      (Gas_limit_repr.Limited
        {| Gas_limit_repr.t.Limited.remaining := remaining |}) ctxt).

Definition set_gas_unlimited (ctxt : t) : t :=
  t.with_operation_gas Gas_limit_repr.Unaccounted ctxt.

Definition consume_gas (ctxt : t) (cost : Gas_limit_repr.cost)
  : Error_monad.tzresult t :=
  Error_monad.op_gtgtquestion
    (Gas_limit_repr.consume ctxt.(t.block_gas) ctxt.(t.operation_gas)
      ctxt.(t.internal_gas) cost)
    (fun function_parameter =>
      let '(block_gas, operation_gas, __internal_gas_value) :=
        function_parameter in
      Error_monad.ok
        (t.with_internal_gas __internal_gas_value
          (t.with_operation_gas operation_gas (t.with_block_gas block_gas ctxt)))).

Definition check_enough_gas (ctxt : t) (cost : Gas_limit_repr.cost)
  : Error_monad.tzresult unit :=
  Gas_limit_repr.check_enough ctxt.(t.block_gas) ctxt.(t.operation_gas)
    ctxt.(t.internal_gas) cost.

Definition gas_level (ctxt : t) : Gas_limit_repr.t := ctxt.(t.operation_gas).

Definition block_gas_level (ctxt : t) : Z.t := ctxt.(t.block_gas).

Definition gas_consumed (since : t) (until : t) : Z.t :=
  match ((gas_level since), (gas_level until)) with
  |
    (Gas_limit_repr.Limited {| Gas_limit_repr.t.Limited.remaining := before |},
      Gas_limit_repr.Limited {| Gas_limit_repr.t.Limited.remaining := after |})
    => Z.sub before after
  | (_, _) => Z.zero
  end.

Definition init_storage_space_to_pay (ctxt : t) : t :=
  match ctxt.(t.storage_space_to_pay) with
  | Some _ =>
    (* ❌ Assert instruction is not handled. *)
    assert false
  | None =>
    t.with_allocated_contracts (Some 0)
      (t.with_storage_space_to_pay (Some Z.zero) ctxt)
  end.

Definition update_storage_space_to_pay (ctxt : t) (n : Z.t) : t :=
  match ctxt.(t.storage_space_to_pay) with
  | None =>
    (* ❌ Assert instruction is not handled. *)
    assert false
  | Some storage_space_to_pay =>
    t.with_storage_space_to_pay (Some (Z.add n storage_space_to_pay)) ctxt
  end.

Definition update_allocated_contracts_count (ctxt : t) : t :=
  match ctxt.(t.allocated_contracts) with
  | None =>
    (* ❌ Assert instruction is not handled. *)
    assert false
  | Some allocated_contracts =>
    t.with_allocated_contracts (Some (Pervasives.succ allocated_contracts)) ctxt
  end.

Definition clear_storage_space_to_pay (ctxt : t) : t * Z.t * Z :=
  match (ctxt.(t.storage_space_to_pay), ctxt.(t.allocated_contracts)) with
  | ((None, _) | (_, None)) =>
    (* ❌ Assert instruction is not handled. *)
    assert false
  | (Some storage_space_to_pay, Some allocated_contracts) =>
    ((t.with_allocated_contracts None (t.with_storage_space_to_pay None ctxt)),
      storage_space_to_pay, allocated_contracts)
  end.

Inductive missing_key_kind : Set :=
| Del : missing_key_kind
| Copy : missing_key_kind
| Get : missing_key_kind
| __Set : missing_key_kind.

Inductive storage_error : Set :=
| Incompatible_protocol_version : string -> storage_error
| Missing_key : list string -> missing_key_kind -> storage_error
| Existing_key : list string -> storage_error
| Corrupted_data : list string -> storage_error.

Definition storage_error_encoding : Data_encoding.encoding storage_error :=
  Data_encoding.union None
    [
      Data_encoding.__case_value "Incompatible_protocol_version" None
        (Data_encoding.Tag 0)
        (Data_encoding.obj1
          (Data_encoding.req None None "incompatible_protocol_version"
            Data_encoding.__string_value))
        (fun function_parameter =>
          match function_parameter with
          | Incompatible_protocol_version arg => Some arg
          | _ => None
          end) (fun arg => Incompatible_protocol_version arg);
      Data_encoding.__case_value "Missing_key" None (Data_encoding.Tag 1)
        (Data_encoding.obj2
          (Data_encoding.req None None "missing_key"
            (Data_encoding.__list_value None Data_encoding.__string_value))
          (Data_encoding.req None None "function"
            (Data_encoding.string_enum
              [
                ("get", Get);
                ("set", __Set);
                ("del", Del);
                ("copy", Copy)
              ])))
        (fun function_parameter =>
          match function_parameter with
          | Missing_key key f => Some (key, f)
          | _ => None
          end)
        (fun function_parameter =>
          let '(key, f) := function_parameter in
          Missing_key key f);
      Data_encoding.__case_value "Existing_key" None (Data_encoding.Tag 2)
        (Data_encoding.obj1
          (Data_encoding.req None None "existing_key"
            (Data_encoding.__list_value None Data_encoding.__string_value)))
        (fun function_parameter =>
          match function_parameter with
          | Existing_key key => Some key
          | _ => None
          end) (fun key => Existing_key key);
      Data_encoding.__case_value "Corrupted_data" None (Data_encoding.Tag 3)
        (Data_encoding.obj1
          (Data_encoding.req None None "corrupted_data"
            (Data_encoding.__list_value None Data_encoding.__string_value)))
        (fun function_parameter =>
          match function_parameter with
          | Corrupted_data key => Some key
          | _ => None
          end) (fun key => Corrupted_data key)
    ].

Definition pp_storage_error
  (ppf : Format.formatter) (function_parameter : storage_error) : unit :=
  match function_parameter with
  | Incompatible_protocol_version version =>
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal
          "Found a context with an unexpected version '"
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal "'."
              CamlinternalFormatBasics.End_of_format)))
        "Found a context with an unexpected version '%s'.") version
  | Missing_key key Get =>
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal "Missing key '"
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal "'."
              CamlinternalFormatBasics.End_of_format))) "Missing key '%s'.")
      (String.concat "/" key)
  | Missing_key key __Set =>
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal "Cannot set undefined key '"
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal "'."
              CamlinternalFormatBasics.End_of_format)))
        "Cannot set undefined key '%s'.") (String.concat "/" key)
  | Missing_key key Del =>
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal "Cannot delete undefined key '"
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal "'."
              CamlinternalFormatBasics.End_of_format)))
        "Cannot delete undefined key '%s'.") (String.concat "/" key)
  | Missing_key key Copy =>
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal "Cannot copy undefined key '"
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal "'."
              CamlinternalFormatBasics.End_of_format)))
        "Cannot copy undefined key '%s'.") (String.concat "/" key)
  | Existing_key key =>
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal
          "Cannot initialize defined key '"
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal "'."
              CamlinternalFormatBasics.End_of_format)))
        "Cannot initialize defined key '%s'.") (String.concat "/" key)
  | Corrupted_data key =>
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal "Failed to parse the data at '"
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal "'."
              CamlinternalFormatBasics.End_of_format)))
        "Failed to parse the data at '%s'.") (String.concat "/" key)
  end.

(* ❌ Structure item `typext` not handled. *)
(* type_extension *)

(* ❌ Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition __storage_error_value {A : Set} (err : storage_error)
  : Lwt.t (Error_monad.tzresult A) := Error_monad.fail extensible_type_value.

Definition version_key : list string := [ "version" ].

Definition version_value : string := "alpha_current".

Definition version : string := "v1".

Definition first_level_key : list string := [ version; "first_level" ].

Definition constants_key : list string := [ version; "constants" ].

Definition protocol_param_key : list string := [ "protocol_parameters" ].

Definition get_first_level (ctxt : Context.t)
  : Lwt.t (Error_monad.tzresult Raw_level_repr.raw_level) :=
  Error_monad.op_gtgteq (Context.get ctxt first_level_key)
    (fun function_parameter =>
      match function_parameter with
      | None => __storage_error_value (Missing_key first_level_key Get)
      | Some __bytes_value =>
        match
          Data_encoding.Binary.of_bytes Raw_level_repr.encoding __bytes_value
          with
        | None => __storage_error_value (Corrupted_data first_level_key)
        | Some level => Error_monad.__return level
        end
      end).

Definition set_first_level (ctxt : Context.t) (level : Raw_level_repr.raw_level)
  : Lwt.t (Error_monad.tzresult Context.t) :=
  let __bytes_value :=
    Data_encoding.Binary.to_bytes_exn Raw_level_repr.encoding level in
  Error_monad.op_gtgteq (Context.set ctxt first_level_key __bytes_value)
    (fun ctxt => Error_monad.__return ctxt).

(* ❌ Structure item `typext` not handled. *)
(* type_extension *)

(* ❌ Structure item `typext` not handled. *)
(* type_extension *)

(* ❌ Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition get_proto_param (ctxt : Context.t)
  : Lwt.t (Error_monad.tzresult (Parameters_repr.t * Context.t)) :=
  Error_monad.op_gtgteq (Context.get ctxt protocol_param_key)
    (fun function_parameter =>
      match function_parameter with
      | None => Pervasives.failwith "Missing protocol parameters."
      | Some __bytes_value =>
        match
          Data_encoding.Binary.of_bytes Data_encoding.__json_value __bytes_value
          with
        | None => Error_monad.fail extensible_type_value
        | Some __json_value =>
          Error_monad.op_gtgteq (Context.del ctxt protocol_param_key)
            (fun ctxt =>
              let 'param :=
                Data_encoding.Json.destruct Parameters_repr.encoding
                  __json_value in
              Error_monad.__return (param, ctxt))
        end
      end).

Definition set_constants
  (ctxt : Context.t) (constants : Constants_repr.parametric)
  : Lwt.t Context.t :=
  let __bytes_value :=
    Data_encoding.Binary.to_bytes_exn Constants_repr.parametric_encoding
      constants in
  Context.set ctxt constants_key __bytes_value.

Definition get_constants (ctxt : Context.t)
  : Lwt.t (Error_monad.tzresult Constants_repr.parametric) :=
  Error_monad.op_gtgteq (Context.get ctxt constants_key)
    (fun function_parameter =>
      match function_parameter with
      | None =>
        Pervasives.failwith "Internal error: cannot read constants in context."
      | Some __bytes_value =>
        match
          Data_encoding.Binary.of_bytes Constants_repr.parametric_encoding
            __bytes_value with
        | None =>
          Pervasives.failwith
            "Internal error: cannot parse constants in context."
        | Some constants => Error_monad.__return constants
        end
      end).

Definition patch_constants
  (ctxt : t) (f : Constants_repr.parametric -> Constants_repr.parametric)
  : Lwt.t t :=
  let constants := f ctxt.(t.constants) in
  Error_monad.op_gtgteq (set_constants ctxt.(t.context) constants)
    (fun context =>
      Lwt.__return (t.with_constants constants (t.with_context context ctxt))).

Definition check_inited (ctxt : Context.t)
  : Lwt.t (Error_monad.tzresult unit) :=
  Error_monad.op_gtgteq (Context.get ctxt version_key)
    (fun function_parameter =>
      match function_parameter with
      | None => Pervasives.failwith "Internal error: un-initialized context."
      | Some __bytes_value =>
        let s := MBytes.to_string __bytes_value in
        if (|Compare.String|).(Compare.S.op_eq) s version_value then
          Error_monad.return_unit
        else
          __storage_error_value (Incompatible_protocol_version s)
      end).

Definition prepare
  (level : int32) (predecessor_timestamp : Time.t) (timestamp : Time.t)
  (fitness : list MBytes.t) (ctxt : Context.t)
  : Lwt.t (Error_monad.tzresult t) :=
  Error_monad.op_gtgteqquestion (Lwt.__return (Raw_level_repr.of_int32 level))
    (fun level =>
      Error_monad.op_gtgteqquestion
        (Lwt.__return (Fitness_repr.to_int64 fitness))
        (fun fitness =>
          Error_monad.op_gtgteqquestion (check_inited ctxt)
            (fun function_parameter =>
              let '_ := function_parameter in
              Error_monad.op_gtgteqquestion (get_constants ctxt)
                (fun constants =>
                  Error_monad.op_gtgteqquestion (get_first_level ctxt)
                    (fun first_level =>
                      let level :=
                        Level_repr.from_raw first_level
                          constants.(Constants_repr.parametric.blocks_per_cycle)
                          constants.(Constants_repr.parametric.blocks_per_voting_period)
                          constants.(Constants_repr.parametric.blocks_per_commitment)
                          level in
                      Error_monad.__return
                        {| t.context := ctxt; t.constants := constants;
                          t.first_level := first_level; t.level := level;
                          t.predecessor_timestamp := predecessor_timestamp;
                          t.timestamp := timestamp; t.fitness := fitness;
                          t.deposits :=
                            (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.empty);
                          t.included_endorsements := 0;
                          t.allowed_endorsements :=
                            (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.empty);
                          t.fees := Tez_repr.zero; t.rewards := Tez_repr.zero;
                          t.block_gas :=
                            constants.(Constants_repr.parametric.hard_gas_limit_per_block);
                          t.operation_gas := Gas_limit_repr.Unaccounted;
                          t.internal_gas := Gas_limit_repr.internal_gas_zero;
                          t.storage_space_to_pay := None;
                          t.allocated_contracts := None;
                          t.origination_nonce := None;
                          t.temporary_big_map := Z.sub Z.zero Z.one;
                          t.internal_nonce := 0;
                          t.internal_nonces_used := (|Int_set|).(S.SET.empty) |}))))).

Inductive previous_protocol : Set :=
| Genesis : Parameters_repr.t -> previous_protocol
| Alpha_previous : previous_protocol.

Definition check_and_update_protocol_version (ctxt : Context.t)
  : Lwt.t (Error_monad.tzresult (previous_protocol * Context.t)) :=
  Error_monad.op_gtgteqquestion
    (Error_monad.op_gtgteq (Context.get ctxt version_key)
      (fun function_parameter =>
        match function_parameter with
        | None =>
          Pervasives.failwith
            "Internal error: un-initialized context in check_first_block."
        | Some __bytes_value =>
          let s := MBytes.to_string __bytes_value in
          if (|Compare.String|).(Compare.S.op_eq) s version_value then
            Pervasives.failwith
              "Internal error: previously initialized context."
          else
            if (|Compare.String|).(Compare.S.op_eq) s "genesis" then
              Error_monad.op_gtgteqquestion (get_proto_param ctxt)
                (fun function_parameter =>
                  let '(param, ctxt) := function_parameter in
                  Error_monad.__return ((Genesis param), ctxt))
            else
              if (|Compare.String|).(Compare.S.op_eq) s "alpha_previous" then
                Error_monad.__return (Alpha_previous, ctxt)
              else
                __storage_error_value (Incompatible_protocol_version s)
        end))
    (fun function_parameter =>
      let '(previous_proto, ctxt) := function_parameter in
      Error_monad.op_gtgteq
        (Context.set ctxt version_key (MBytes.of_string version_value))
        (fun ctxt => Error_monad.__return (previous_proto, ctxt))).

Definition prepare_first_block
  (level : int32) (timestamp : Time.t) (fitness : list MBytes.t)
  (ctxt : Context.t) : Lwt.t (Error_monad.tzresult (previous_protocol * t)) :=
  Error_monad.op_gtgteqquestion (check_and_update_protocol_version ctxt)
    (fun function_parameter =>
      let '(previous_proto, ctxt) := function_parameter in
      Error_monad.op_gtgteqquestion
        match previous_proto with
        | Genesis param =>
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Raw_level_repr.of_int32 level))
            (fun first_level =>
              Error_monad.op_gtgteqquestion (set_first_level ctxt first_level)
                (fun ctxt =>
                  Error_monad.op_gtgteq
                    (set_constants ctxt param.(Parameters_repr.t.constants))
                    (fun ctxt => Error_monad.__return ctxt)))
        | Alpha_previous => Error_monad.__return ctxt
        end
        (fun ctxt =>
          Error_monad.op_gtgteqquestion
            (prepare level timestamp timestamp fitness ctxt)
            (fun ctxt => Error_monad.__return (previous_proto, ctxt)))).

Definition activate (function_parameter : t)
  : (|Protocol_hash|).(S.HASH.t) -> Lwt.t t :=
  let '{| t.context := c |} as s := function_parameter in
  fun h =>
    Error_monad.op_gtgteq (Updater.activate c h)
      (fun c => Lwt.__return (t.with_context c s)).

Definition fork_test_chain (function_parameter : t)
  : (|Protocol_hash|).(S.HASH.t) -> Time.t -> Lwt.t t :=
  let '{| t.context := c |} as s := function_parameter in
  fun protocol =>
    fun expiration =>
      Error_monad.op_gtgteq (Updater.fork_test_chain c protocol expiration)
        (fun c => Lwt.__return (t.with_context c s)).

Definition key := list string.

Definition value := MBytes.t.

Module T.
  Record signature {t : Set} := {
    t := t;
    context := t;
    mem : context -> key -> Lwt.t bool;
    dir_mem : context -> key -> Lwt.t bool;
    get : context -> key -> Lwt.t (Error_monad.tzresult value);
    get_option : context -> key -> Lwt.t (option value);
    init : context -> key -> value -> Lwt.t (Error_monad.tzresult context);
    set : context -> key -> value -> Lwt.t (Error_monad.tzresult context);
    init_set : context -> key -> value -> Lwt.t context;
    set_option : context -> key -> option value -> Lwt.t context;
    delete : context -> key -> Lwt.t (Error_monad.tzresult context);
    remove : context -> key -> Lwt.t context;
    remove_rec : context -> key -> Lwt.t context;
    copy : context -> key -> key -> Lwt.t (Error_monad.tzresult context);
    fold : forall {a : Set},
      context -> key -> a -> (Context.dir_or_key -> a -> Lwt.t a) -> Lwt.t a;
    keys : context -> key -> Lwt.t (list key);
    fold_keys : forall {a : Set},
      context -> key -> a -> (key -> a -> Lwt.t a) -> Lwt.t a;
    project : context -> root_context;
    absolute_key : context -> key -> key;
    consume_gas :
      context -> Gas_limit_repr.cost -> Error_monad.tzresult context;
    check_enough_gas :
      context -> Gas_limit_repr.cost -> Error_monad.tzresult unit;
    description : Storage_description.t context;
  }.
  Arguments signature : clear implicits.
End T.

Definition mem (ctxt : t) (k : Context.key) : Lwt.t bool :=
  Context.mem ctxt.(t.context) k.

Definition dir_mem (ctxt : t) (k : Context.key) : Lwt.t bool :=
  Context.dir_mem ctxt.(t.context) k.

Definition get (ctxt : t) (k : Context.key)
  : Lwt.t (Error_monad.tzresult Context.value) :=
  Error_monad.op_gtgteq (Context.get ctxt.(t.context) k)
    (fun function_parameter =>
      match function_parameter with
      | None => __storage_error_value (Missing_key k Get)
      | Some v => Error_monad.__return v
      end).

Definition get_option (ctxt : t) (k : Context.key)
  : Lwt.t (option Context.value) := Context.get ctxt.(t.context) k.

Definition set (ctxt : t) (k : Context.key) (v : Context.value)
  : Lwt.t (Error_monad.tzresult t) :=
  Error_monad.op_gtgteq (Context.mem ctxt.(t.context) k)
    (fun function_parameter =>
      match function_parameter with
      | false => __storage_error_value (Missing_key k __Set)
      | true =>
        Error_monad.op_gtgteq (Context.set ctxt.(t.context) k v)
          (fun context => Error_monad.__return (t.with_context context ctxt))
      end).

Definition init (ctxt : t) (k : Context.key) (v : Context.value)
  : Lwt.t (Error_monad.tzresult t) :=
  Error_monad.op_gtgteq (Context.mem ctxt.(t.context) k)
    (fun function_parameter =>
      match function_parameter with
      | true => __storage_error_value (Existing_key k)
      | false =>
        Error_monad.op_gtgteq (Context.set ctxt.(t.context) k v)
          (fun context => Error_monad.__return (t.with_context context ctxt))
      end).

Definition init_set (ctxt : t) (k : Context.key) (v : Context.value)
  : Lwt.t t :=
  Error_monad.op_gtgteq (Context.set ctxt.(t.context) k v)
    (fun context => Lwt.__return (t.with_context context ctxt)).

Definition delete (ctxt : t) (k : Context.key)
  : Lwt.t (Error_monad.tzresult t) :=
  Error_monad.op_gtgteq (Context.mem ctxt.(t.context) k)
    (fun function_parameter =>
      match function_parameter with
      | false => __storage_error_value (Missing_key k Del)
      | true =>
        Error_monad.op_gtgteq (Context.del ctxt.(t.context) k)
          (fun context => Error_monad.__return (t.with_context context ctxt))
      end).

Definition remove (ctxt : t) (k : Context.key) : Lwt.t t :=
  Error_monad.op_gtgteq (Context.del ctxt.(t.context) k)
    (fun context => Lwt.__return (t.with_context context ctxt)).

Definition set_option
  (ctxt : t) (k : Context.key) (function_parameter : option Context.value)
  : Lwt.t t :=
  match function_parameter with
  | None => remove ctxt k
  | Some v => init_set ctxt k v
  end.

Definition remove_rec (ctxt : t) (k : Context.key) : Lwt.t t :=
  Error_monad.op_gtgteq (Context.remove_rec ctxt.(t.context) k)
    (fun context => Lwt.__return (t.with_context context ctxt)).

Definition copy (ctxt : t) (from : Context.key) (to_ : Context.key)
  : Lwt.t (Error_monad.tzresult t) :=
  Error_monad.op_gtgteq (Context.copy ctxt.(t.context) from to_)
    (fun function_parameter =>
      match function_parameter with
      | None => __storage_error_value (Missing_key from Copy)
      | Some context => Error_monad.__return (t.with_context context ctxt)
      end).

Definition fold {A : Set}
  (ctxt : t) (k : Context.key) (init : A)
  (f : Context.dir_or_key -> A -> Lwt.t A) : Lwt.t A :=
  Context.fold ctxt.(t.context) k init f.

Definition keys (ctxt : t) (k : Context.key) : Lwt.t (list Context.key) :=
  Context.keys ctxt.(t.context) k.

Definition fold_keys {A : Set}
  (ctxt : t) (k : Context.key) (init : A) (f : Context.key -> A -> Lwt.t A)
  : Lwt.t A := Context.fold_keys ctxt.(t.context) k init f.

Definition project {A : Set} (x : A) : A := x.

Definition absolute_key {A B : Set} (function_parameter : A) : B -> B :=
  let '_ := function_parameter in
  fun k => k.

Definition description {A : Set} : Storage_description.t A := axiom.

Definition fresh_temporary_big_map (ctxt : t) : t * Z.t :=
  ((t.with_temporary_big_map (Z.sub ctxt.(t.temporary_big_map) Z.one) ctxt),
    ctxt.(t.temporary_big_map)).

Definition reset_temporary_big_map (ctxt : t) : t :=
  t.with_temporary_big_map (Z.sub Z.zero Z.one) ctxt.

Definition temporary_big_maps {A : Set}
  (ctxt : t) (f : A -> Z.t -> Lwt.t A) (acc : A) : Lwt.t A :=
  let fix iter (acc : A) (id : Z.t) {struct acc} : Lwt.t A :=
    if Z.equal id ctxt.(t.temporary_big_map) then
      Lwt.__return acc
    else
      Error_monad.op_gtgteq (f acc id) (fun acc => iter acc (Z.sub id Z.one)) in
  iter acc (Z.sub Z.zero Z.one).
