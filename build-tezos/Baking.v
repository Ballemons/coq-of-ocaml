(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Unset Positivity Checking.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Notations.
Require Tezos.Alpha_context.
Require Tezos.Misc.

Import Alpha_context.

Import Misc.

(* ❌ Structure item `typext` not handled. *)
(* type_extension *)

(* ❌ Structure item `typext` not handled. *)
(* type_extension *)

(* ❌ Structure item `typext` not handled. *)
(* type_extension *)

(* ❌ Structure item `typext` not handled. *)
(* type_extension *)

(* ❌ Structure item `typext` not handled. *)
(* type_extension *)

(* ❌ Structure item `typext` not handled. *)
(* type_extension *)

(* ❌ Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition minimal_time
  (c : Alpha_context.context) (priority : Z)
  (pred_timestamp : Alpha_context.Timestamp.time)
  : Lwt.t (Error_monad.tzresult Alpha_context.Timestamp.time) :=
  let priority := Int32.of_int priority in
  let fix cumsum_time_between_blocks
    (acc : Alpha_context.Timestamp.time)
    (durations : list Alpha_context.Period.period)
    (__p_value : (|Compare.Int32|).(Compare.S.t)) {struct acc}
    : Error_monad.tzresult Alpha_context.Timestamp.time :=
    if
      (|Compare.Int32|).(Compare.S.op_lteq) __p_value
        (* ❌ Constant of type int32 is converted to int *)
        0 then
      Error_monad.ok acc
    else
      match durations with
      | [] =>
        cumsum_time_between_blocks acc [ Alpha_context.Period.one_minute ]
          __p_value
      | cons last [] =>
        Error_monad.op_gtgtquestion (Alpha_context.Period.mult __p_value last)
          (fun period => Alpha_context.Timestamp.op_plusquestion acc period)
      | cons first durations =>
        Error_monad.op_gtgtquestion
          (Alpha_context.Timestamp.op_plusquestion acc first)
          (fun acc =>
            let __p_value := Int32.pred __p_value in
            cumsum_time_between_blocks acc durations __p_value)
      end in
  Lwt.__return
    (cumsum_time_between_blocks pred_timestamp
      (Alpha_context.Constants.time_between_blocks c) (Int32.succ priority)).

Definition earlier_predecessor_timestamp
  (ctxt : Alpha_context.context) (level : Alpha_context.Level.level)
  : Lwt.t (Error_monad.tzresult Alpha_context.Timestamp.time) :=
  let current := Alpha_context.Level.current ctxt in
  let current_timestamp := Alpha_context.Timestamp.current ctxt in
  let gap := Alpha_context.Level.diff level current in
  let step := List.hd (Alpha_context.Constants.time_between_blocks ctxt) in
  if
    (|Compare.Int32|).(Compare.S.op_lt) gap
      (* ❌ Constant of type int32 is converted to int *)
      1 then
    Pervasives.failwith "Baking.earlier_block_timestamp: past block."
  else
    let!? delay :=
      Lwt.__return (Alpha_context.Period.mult (Int32.pred gap) step) in
    let!? __result_value :=
      Lwt.__return
        (Alpha_context.Timestamp.op_plusquestion current_timestamp delay) in
    Error_monad.__return __result_value.

Definition check_timestamp
  (c : Alpha_context.context) (priority : Z)
  (pred_timestamp : Alpha_context.Timestamp.time)
  : Lwt.t (Error_monad.tzresult Alpha_context.Period.t) :=
  let!? minimal_time := minimal_time c priority pred_timestamp in
  let timestamp := Alpha_context.Timestamp.current c in
  Lwt.__return
    (Error_monad.record_trace extensible_type_value
      (Alpha_context.Timestamp.op_minusquestion timestamp minimal_time)).

Definition check_baking_rights
  (c : Alpha_context.context)
  (function_parameter : Alpha_context.Block_header.contents)
  : Alpha_context.Timestamp.time ->
  Lwt.t
    (Error_monad.tzresult (Alpha_context.public_key * Alpha_context.Period.t)) :=
  let '{| Alpha_context.Block_header.contents.priority := priority |} :=
    function_parameter in
  fun pred_timestamp =>
    let level := Alpha_context.Level.current c in
    let!? delegate := Alpha_context.Roll.baking_rights_owner c level priority in
    let!? block_delay := check_timestamp c priority pred_timestamp in
    Error_monad.__return (delegate, block_delay).

(* ❌ Structure item `typext` not handled. *)
(* type_extension *)

(* ❌ Structure item `typext` not handled. *)
(* type_extension *)

(* ❌ Top-level evaluations are ignored *)
(* top_level_evaluation *)

(* ❌ Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition baking_reward
  (ctxt : Alpha_context.context) (prio : (|Compare.Int|).(Compare.S.t))
  (num_endo : (|Compare.Int|).(Compare.S.t))
  : Lwt.t (Error_monad.tzresult Alpha_context.Tez.tez) :=
  let!? '_ :=
    Error_monad.fail_unless ((|Compare.Int|).(Compare.S.op_gteq) prio 0)
      extensible_type_value in
  let max_endorsements := Alpha_context.Constants.endorsers_per_block ctxt in
  let!? '_ :=
    Error_monad.fail_unless
      (Pervasives.op_andand ((|Compare.Int|).(Compare.S.op_gteq) num_endo 0)
        ((|Compare.Int|).(Compare.S.op_lteq) num_endo max_endorsements))
      extensible_type_value in
  let prio_factor_denominator := Int64.succ (Int64.of_int prio) in
  let endo_factor_numerator :=
    Int64.of_int
      (Pervasives.op_plus 8
        (Pervasives.op_div (Pervasives.op_star 2 num_endo) max_endorsements)) in
  let endo_factor_denominator :=
    (* ❌ Constant of type int64 is converted to int *)
    10 in
  Lwt.__return
    (Error_monad.op_gtgtquestion
      (Alpha_context.Tez.op_starquestion
        (Alpha_context.Constants.block_reward ctxt) endo_factor_numerator)
      (fun val1 =>
        Error_monad.op_gtgtquestion
          (Alpha_context.Tez.op_divquestion val1 endo_factor_denominator)
          (fun val2 =>
            Alpha_context.Tez.op_divquestion val2 prio_factor_denominator))).

Definition endorsing_reward
  (ctxt : Alpha_context.context) (prio : (|Compare.Int|).(Compare.S.t)) (n : Z)
  : Lwt.t (Error_monad.tzresult Alpha_context.Tez.tez) :=
  if (|Compare.Int|).(Compare.S.op_gteq) prio 0 then
    let!? tez :=
      Lwt.__return
        (Alpha_context.Tez.op_divquestion
          (Alpha_context.Constants.endorsement_reward ctxt)
          (Int64.succ (Int64.of_int prio))) in
    Lwt.__return (Alpha_context.Tez.op_starquestion tez (Int64.of_int n))
  else
    Error_monad.fail extensible_type_value.

Definition baking_priorities
  (c : Alpha_context.context) (level : Alpha_context.Level.t)
  : Lwt.t (Error_monad.tzresult (Misc.lazy_list_t Alpha_context.public_key)) :=
  let fix f (priority : Z) {struct priority}
    : Lwt.t (Error_monad.tzresult (Misc.lazy_list_t Alpha_context.public_key)) :=
    let!? delegate := Alpha_context.Roll.baking_rights_owner c level priority in
    Error_monad.__return
      (Misc.LCons delegate
        (fun function_parameter =>
          let '_ := function_parameter in
          f (Pervasives.succ priority))) in
  f 0.

Definition endorsement_rights
  (c : Alpha_context.context) (level : Alpha_context.Level.t)
  : Lwt.t
    (Error_monad.tzresult
      ((|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
        (Alpha_context.public_key * list Z * bool))) :=
  Error_monad.fold_left_s
    (fun acc =>
      fun slot =>
        let!? pk := Alpha_context.Roll.endorsement_rights_owner c level slot in
        let pkh := (|Signature.Public_key|).(S.SPublic_key.__hash_value) pk in
        let __right :=
          match
            (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.find_opt)
              pkh acc with
          | None => (pk, [ slot ], false)
          | Some (pk, slots, used) => (pk, (cons slot slots), used)
          end in
        Error_monad.__return
          ((|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.add)
            pkh __right acc))
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.empty)
    (Misc.op_minusminusgt 0
      (Pervasives.op_minus (Alpha_context.Constants.endorsers_per_block c) 1)).

Definition check_endorsement_rights
  (ctxt : Alpha_context.context) (chain_id : (|Chain_id|).(S.HASH.t))
  (op : Alpha_context.Operation.t Alpha_context.Kind.endorsement)
  : Lwt.t
    (Error_monad.tzresult
      ((|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.key)
        * list Z * bool)) :=
  let current_level := Alpha_context.Level.current ctxt in
  let
    'Alpha_context.Single
      (Alpha_context.Endorsement {|
        Alpha_context.contents.Endorsement.level := level |}) :=
    op.(Alpha_context.operation.protocol_data).(Alpha_context.protocol_data.contents)
    in
  let!? endorsements :=
    if
      Alpha_context.Raw_level.op_eq (Alpha_context.Raw_level.succ level)
        current_level.(Alpha_context.Level.t.level) then
      Error_monad.__return (Alpha_context.allowed_endorsements ctxt)
    else
      endorsement_rights ctxt (Alpha_context.Level.from_raw ctxt None level) in
  match
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.fold)
      (fun pkh =>
        fun function_parameter =>
          let '(pk, slots, used) := function_parameter in
          fun acc =>
            match Alpha_context.Operation.check_signature_sync pk chain_id op
              with
            | Pervasives.Error _ => acc
            | Pervasives.Ok _ => Some (pkh, slots, used)
            end) endorsements None with
  | None => Error_monad.fail extensible_type_value
  | Some v => Error_monad.__return v
  end.

Definition select_delegate
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  (delegate_list : Misc.lazy_list_t (|Signature.Public_key|).(S.SPublic_key.t))
  (max_priority : (|Compare.Int|).(Compare.S.t))
  : Lwt.t (Error_monad.tzresult (list (|Compare.Int|).(Compare.S.t))) :=
  let fix loop
    (acc : list (|Compare.Int|).(Compare.S.t))
    (l : Misc.lazy_list_t (|Signature.Public_key|).(S.SPublic_key.t))
    (n : (|Compare.Int|).(Compare.S.t)) {struct acc}
    : Lwt.t (Error_monad.tzresult (list (|Compare.Int|).(Compare.S.t))) :=
    if (|Compare.Int|).(Compare.S.op_gteq) n max_priority then
      Error_monad.__return (List.rev acc)
    else
      let 'Misc.LCons pk __t_value := l in
      let acc :=
        if
          (|Signature.Public_key_hash|).(S.SPublic_key_hash.equal) delegate
            ((|Signature.Public_key|).(S.SPublic_key.__hash_value) pk) then
          cons n acc
        else
          acc in
      let!? __t_value := __t_value tt in
      loop acc __t_value (Pervasives.succ n) in
  loop nil delegate_list 0.

Definition first_baking_priorities
  (ctxt : Alpha_context.context)
  (op_staroptstar : option (|Compare.Int|).(Compare.S.t))
  : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
  Alpha_context.Level.t ->
  Lwt.t (Error_monad.tzresult (list (|Compare.Int|).(Compare.S.t))) :=
  let max_priority :=
    match op_staroptstar with
    | Some op_starsthstar => op_starsthstar
    | None => 32
    end in
  fun delegate =>
    fun level =>
      let!? delegate_list := baking_priorities ctxt level in
      select_delegate delegate delegate_list max_priority.

Definition check_hash
  (__hash_value : (|Block_hash|).(S.HASH.t))
  (stamp_threshold : (|Compare.Uint64|).(Compare.S.t)) : bool :=
  let __bytes_value := (|Block_hash|).(S.HASH.to_bytes) __hash_value in
  let word := MBytes.get_int64 __bytes_value 0 in
  (|Compare.Uint64|).(Compare.S.op_lteq) word stamp_threshold.

Definition check_header_proof_of_work_stamp
  (shell : Block_header.shell_header)
  (contents : Alpha_context.Block_header.contents)
  (stamp_threshold : (|Compare.Uint64|).(Compare.S.t)) : bool :=
  let __hash_value :=
    Alpha_context.Block_header.__hash_value
      {| Alpha_context.Block_header.t.shell := shell;
        Alpha_context.Block_header.t.protocol_data :=
          {| Alpha_context.Block_header.protocol_data.contents := contents;
            Alpha_context.Block_header.protocol_data.signature := Signature.zero
            |} |} in
  check_hash __hash_value stamp_threshold.

Definition check_proof_of_work_stamp
  (ctxt : Alpha_context.context) (block : Alpha_context.Block_header.t)
  : Lwt.t (Error_monad.tzresult unit) :=
  let proof_of_work_threshold :=
    Alpha_context.Constants.proof_of_work_threshold ctxt in
  if
    check_header_proof_of_work_stamp block.(Alpha_context.Block_header.t.shell)
      block.(Alpha_context.Block_header.t.protocol_data).(Alpha_context.Block_header.protocol_data.contents)
      proof_of_work_threshold then
    Error_monad.return_unit
  else
    Error_monad.fail extensible_type_value.

Definition check_signature
  (block : Alpha_context.Block_header.t) (chain_id : (|Chain_id|).(S.HASH.t))
  (__key_value : (|Signature.Public_key|).(S.SPublic_key.t))
  : Lwt.t (Error_monad.tzresult unit) :=
  let check_signature
    (__key_value : (|Signature.Public_key|).(S.SPublic_key.t))
    (function_parameter : Alpha_context.Block_header.t) : bool :=
    let '{|
      Alpha_context.Block_header.t.shell := shell;
        Alpha_context.Block_header.t.protocol_data := {|
          Alpha_context.Block_header.protocol_data.contents := contents;
            Alpha_context.Block_header.protocol_data.signature :=
              signature
            |}
        |} := function_parameter in
    let unsigned_header :=
      Data_encoding.Binary.to_bytes_exn
        Alpha_context.Block_header.unsigned_encoding (shell, contents) in
    Signature.check (Some (Signature.Block_header chain_id)) __key_value
      signature unsigned_header in
  if check_signature __key_value block then
    Error_monad.return_unit
  else
    Error_monad.fail extensible_type_value.

Definition max_fitness_gap {A : Set} (_ctxt : A) : int64 :=
  (* ❌ Constant of type int64 is converted to int *)
  1.

Definition check_fitness_gap
  (ctxt : Alpha_context.context) (block : Alpha_context.Block_header.t)
  : Lwt.t (Error_monad.tzresult unit) :=
  let current_fitness := Alpha_context.Fitness.current ctxt in
  let!? announced_fitness :=
    Lwt.__return
      (Alpha_context.Fitness.to_int64
        block.(Alpha_context.Block_header.t.shell).(Block_header.shell_header.fitness))
    in
  let gap := Int64.sub announced_fitness current_fitness in
  if
    Pervasives.op_pipepipe
      ((|Compare.Int64|).(Compare.S.op_lteq) gap
        (* ❌ Constant of type int64 is converted to int *)
        0) ((|Compare.Int64|).(Compare.S.op_lt) (max_fitness_gap ctxt) gap) then
    Error_monad.fail extensible_type_value
  else
    Error_monad.return_unit.

Definition last_of_a_cycle
  (ctxt : Alpha_context.context) (l : Alpha_context.Level.t) : bool :=
  (|Compare.Int32|).(Compare.S.op_eq)
    (Int32.succ l.(Alpha_context.Level.t.cycle_position))
    (Alpha_context.Constants.blocks_per_cycle ctxt).

Definition dawn_of_a_new_cycle (ctxt : Alpha_context.context)
  : Lwt.t (Error_monad.tzresult (option Alpha_context.Cycle.t)) :=
  let level := Alpha_context.Level.current ctxt in
  if last_of_a_cycle ctxt level then
    Error_monad.return_some level.(Alpha_context.Level.t.cycle)
  else
    Error_monad.return_none.

Definition minimum_allowed_endorsements
  (ctxt : Alpha_context.context) (block_delay : Alpha_context.Period.period)
  : (|Compare.Int|).(Compare.S.t) :=
  let minimum := Alpha_context.Constants.initial_endorsers ctxt in
  let delay_per_missing_endorsement :=
    Int64.to_int
      (Alpha_context.Period.to_seconds
        (Alpha_context.Constants.delay_per_missing_endorsement ctxt)) in
  let reduced_time_constraint :=
    let delay := Int64.to_int (Alpha_context.Period.to_seconds block_delay) in
    if (|Compare.Int|).(Compare.S.op_eq) delay_per_missing_endorsement 0 then
      delay
    else
      Pervasives.op_div delay delay_per_missing_endorsement in
  (|Compare.Int|).(Compare.S.max) 0
    (Pervasives.op_minus minimum reduced_time_constraint).

Definition minimal_valid_time
  (ctxt : Alpha_context.context) (priority : Z) (endorsing_power : Z)
  : Lwt.t (Error_monad.tzresult Time.t) :=
  let predecessor_timestamp := Alpha_context.Timestamp.current ctxt in
  let!? minimal_time := minimal_time ctxt priority predecessor_timestamp in
  let minimal_required_endorsements :=
    Alpha_context.Constants.initial_endorsers ctxt in
  let delay_per_missing_endorsement :=
    Alpha_context.Constants.delay_per_missing_endorsement ctxt in
  let missing_endorsements :=
    (|Compare.Int|).(Compare.S.max) 0
      (Pervasives.op_minus minimal_required_endorsements endorsing_power) in
  match
    Alpha_context.Period.mult (Int32.of_int missing_endorsements)
      delay_per_missing_endorsement with
  | Pervasives.Ok delay =>
    Error_monad.__return
      (Time.add minimal_time (Alpha_context.Period.to_seconds delay))
  | (Pervasives.Error _) as err => Lwt.__return err
  end.
