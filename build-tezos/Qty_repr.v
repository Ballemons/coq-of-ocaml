(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.

Module QTY.
  Record signature : Set := {
    id : string;
  }.
End QTY.

Module S.
  Record signature {qty : Set} : Set := {
    qty := qty;
    (* extensible_type error *)
    id : string;
    zero : qty;
    one_mutez : qty;
    one_cent : qty;
    fifty_cents : qty;
    one : qty;
    op_minusquestion : qty -> qty -> Error_monad.tzresult qty;
    op_plusquestion : qty -> qty -> Error_monad.tzresult qty;
    op_starquestion : qty -> int64 -> Error_monad.tzresult qty;
    op_divquestion : qty -> int64 -> Error_monad.tzresult qty;
    to_mutez : qty -> int64;
    of_mutez : int64 -> option qty;
    of_mutez_exn : int64 -> qty;
    add_exn : qty -> qty -> qty;
    mul_exn : qty -> int -> qty;
    qty_encoding : Data_encoding.t qty;
    to_int64 : qty -> int64;
    op_eq : qty -> qty -> bool;
    op_ltgt : qty -> qty -> bool;
    op_lt : qty -> qty -> bool;
    op_lteq : qty -> qty -> bool;
    op_gteq : qty -> qty -> bool;
    op_gt : qty -> qty -> bool;
    compare : qty -> qty -> int;
    equal : qty -> qty -> bool;
    max : qty -> qty -> qty;
    min : qty -> qty -> qty;
    pp : Format.formatter -> qty -> unit;
    of_string : string -> option qty;
    to_string : qty -> string;
  }.
End S.

Definition Make :=
  fun (T : {_ : unit & QTY.signature}) =>
    ((let qty : Set := int64 in
    (* ❌ type_extension *)
    let t := (|Compare.Int64|).(Compare.S.t) in
    let op_eq := (|Compare.Int64|).(Compare.S.op_eq) in
    let op_ltgt := (|Compare.Int64|).(Compare.S.op_ltgt) in
    let op_lt := (|Compare.Int64|).(Compare.S.op_lt) in
    let op_lteq := (|Compare.Int64|).(Compare.S.op_lteq) in
    let op_gteq := (|Compare.Int64|).(Compare.S.op_gteq) in
    let op_gt := (|Compare.Int64|).(Compare.S.op_gt) in
    let compare := (|Compare.Int64|).(Compare.S.compare) in
    let equal := (|Compare.Int64|).(Compare.S.equal) in
    let max := (|Compare.Int64|).(Compare.S.max) in
    let min := (|Compare.Int64|).(Compare.S.min) in
    let zero :=
      (* ❌ Constant of type int64 is converted to int *)
      0 in
    let one_mutez :=
      (* ❌ Constant of type int64 is converted to int *)
      1 in
    let one_cent :=
      Int64.mul one_mutez
        (* ❌ Constant of type int64 is converted to int *)
        10000 in
    let fifty_cents :=
      Int64.mul one_cent
        (* ❌ Constant of type int64 is converted to int *)
        50 in
    let one :=
      Int64.mul one_cent
        (* ❌ Constant of type int64 is converted to int *)
        100 in
    let id := (|T|).(QTY.id) in
    let of_string (s : string) : option int64 :=
      let triplets (function_parameter : list string) : bool :=
        match function_parameter with
        | cons hd tl =>
          let len := String.length hd in
          Pervasives.op_andand ((|Compare.Int|).(Compare.S.op_lteq) len 3)
            (Pervasives.op_andand ((|Compare.Int|).(Compare.S.op_gt) len 0)
              (List.for_all
                (fun s => (|Compare.Int|).(Compare.S.op_eq) (String.length s) 3)
                tl))
        | [] => false
        end in
      let integers (s : string) : bool :=
        triplets (String.split_on_char "," % char s) in
      let decimals (s : string) : bool :=
        let l := String.split_on_char "," % char s in
        if (|Compare.Int|).(Compare.S.op_gt) (List.length l) 2 then
          false
        else
          triplets (List.rev l) in
      let parse (__left : string) (__right : string) : option int64 :=
        let remove_commas (s : string) : string :=
          String.concat "" (String.split_on_char "," % char s) in
        let pad_to_six (s : string) : string :=
          let len := String.length s in
          String.init 6
            (fun i =>
              if (|Compare.Int|).(Compare.S.op_lt) i len then
                String.get s i
              else
                "0" % char) in
        (* ❌ Try-with are not handled *)
        try
          (Some
            (Int64.of_string
              (Pervasives.op_caret (remove_commas __left)
                (pad_to_six (remove_commas __right))))) in
      match String.split_on_char "." % char s with
      | cons __left (cons __right []) =>
        if String.contains s "," % char then
          if Pervasives.op_andand (integers __left) (decimals __right) then
            parse __left __right
          else
            None
        else
          if
            Pervasives.op_andand
              ((|Compare.Int|).(Compare.S.op_gt) (String.length __right) 0)
              ((|Compare.Int|).(Compare.S.op_lteq) (String.length __right) 6)
            then
            parse __left __right
          else
            None
      | cons __left [] =>
        if
          Pervasives.op_pipepipe (Pervasives.not (String.contains s "," % char))
            (integers __left) then
          parse __left ""
        else
          None
      | _ => None
      end in
    let pp (ppf : Format.formatter) (amount : int64) : unit :=
      let mult_int :=
        (* ❌ Constant of type int64 is converted to int *)
        1000000 in
      let fix __left (ppf : Format.formatter) (amount : int64) {struct ppf}
        : unit :=
        let '(d, __r_value) :=
          ((Int64.div amount
            (* ❌ Constant of type int64 is converted to int *)
            1000),
            (Int64.rem amount
              (* ❌ Constant of type int64 is converted to int *)
              1000)) in
        if
          op_gt d
            (* ❌ Constant of type int64 is converted to int *)
            0 then
          Format.fprintf ppf
            (CamlinternalFormatBasics.Format
              (CamlinternalFormatBasics.Alpha
                (CamlinternalFormatBasics.Int64 CamlinternalFormatBasics.Int_d
                  (CamlinternalFormatBasics.Lit_padding
                    CamlinternalFormatBasics.Zeros 3)
                  CamlinternalFormatBasics.No_precision
                  CamlinternalFormatBasics.End_of_format)) "%a%03Ld") __left d
            __r_value
        else
          Format.fprintf ppf
            (CamlinternalFormatBasics.Format
              (CamlinternalFormatBasics.Int64 CamlinternalFormatBasics.Int_d
                CamlinternalFormatBasics.No_padding
                CamlinternalFormatBasics.No_precision
                CamlinternalFormatBasics.End_of_format) "%Ld") __r_value in
      let __right (ppf : Format.formatter) (amount : int) : unit :=
        let triplet (ppf : Format.formatter) (v : int) : unit :=
          if (|Compare.Int|).(Compare.S.op_gt) (Pervasives.__mod v 10) 0 then
            Format.fprintf ppf
              (CamlinternalFormatBasics.Format
                (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_d
                  (CamlinternalFormatBasics.Lit_padding
                    CamlinternalFormatBasics.Zeros 3)
                  CamlinternalFormatBasics.No_precision
                  CamlinternalFormatBasics.End_of_format) "%03d") v
          else
            if (|Compare.Int|).(Compare.S.op_gt) (Pervasives.__mod v 100) 0 then
              Format.fprintf ppf
                (CamlinternalFormatBasics.Format
                  (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_d
                    (CamlinternalFormatBasics.Lit_padding
                      CamlinternalFormatBasics.Zeros 2)
                    CamlinternalFormatBasics.No_precision
                    CamlinternalFormatBasics.End_of_format) "%02d")
                (Pervasives.op_div v 10)
            else
              Format.fprintf ppf
                (CamlinternalFormatBasics.Format
                  (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_d
                    CamlinternalFormatBasics.No_padding
                    CamlinternalFormatBasics.No_precision
                    CamlinternalFormatBasics.End_of_format) "%d")
                (Pervasives.op_div v 100) in
        let '(hi, lo) :=
          ((Pervasives.op_div amount 1000), (Pervasives.__mod amount 1000)) in
        if (|Compare.Int|).(Compare.S.op_eq) lo 0 then
          Format.fprintf ppf
            (CamlinternalFormatBasics.Format
              (CamlinternalFormatBasics.Alpha
                CamlinternalFormatBasics.End_of_format) "%a") triplet hi
        else
          Format.fprintf ppf
            (CamlinternalFormatBasics.Format
              (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_d
                (CamlinternalFormatBasics.Lit_padding
                  CamlinternalFormatBasics.Zeros 3)
                CamlinternalFormatBasics.No_precision
                (CamlinternalFormatBasics.Alpha
                  CamlinternalFormatBasics.End_of_format)) "%03d%a") hi triplet
            lo in
      let '(ints, decs) :=
        ((Int64.div amount mult_int), (Int64.to_int (Int64.rem amount mult_int)))
        in
      (* ❌ Sequences of instructions are ignored (operator ";") *)
      (* ❌ instruction_sequence ";" *)
      if (|Compare.Int|).(Compare.S.op_gt) decs 0 then
        Format.fprintf ppf
          (CamlinternalFormatBasics.Format
            (CamlinternalFormatBasics.Char_literal "." % char
              (CamlinternalFormatBasics.Alpha
                CamlinternalFormatBasics.End_of_format)) ".%a") __right decs
      else
        tt in
    let to_string (__t_value : int64) : string :=
      Format.asprintf
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Alpha CamlinternalFormatBasics.End_of_format)
          "%a") pp __t_value in
    let op_minus (t1 : t) (t2 : t) : option int64 :=
      if op_lteq t2 t1 then
        Some (Int64.sub t1 t2)
      else
        None in
    let op_minusquestion (t1 : t) (t2 : t) : Error_monad.tzresult int64 :=
      match op_minus t1 t2 with
      | None => Error_monad.__error_value extensible_type_value
      | Some v => Error_monad.ok v
      end in
    let op_plusquestion (t1 : t) (t2 : qty) : Error_monad.tzresult int64 :=
      let __t_value := Int64.add t1 t2 in
      if op_lt __t_value t1 then
        Error_monad.__error_value extensible_type_value
      else
        Error_monad.ok __t_value in
    let op_starquestion (__t_value : qty) (m : (|Compare.Int64|).(Compare.S.t))
      : Error_monad.tzresult t :=
      let fix step (cur : (|Compare.Int64|).(Compare.S.t)) (pow : t) (acc : t)
        {struct cur} : Error_monad.tzresult t :=
        if
          (|Compare.Int64|).(Compare.S.op_eq) cur
            (* ❌ Constant of type int64 is converted to int *)
            0 then
          Error_monad.ok acc
        else
          let? npow := op_plusquestion pow pow in
          if
            (|Compare.Int64|).(Compare.S.op_eq)
              (Int64.logand cur
                (* ❌ Constant of type int64 is converted to int *)
                1)
              (* ❌ Constant of type int64 is converted to int *)
              1 then
            let? nacc := op_plusquestion acc pow in
            step (Int64.shift_right_logical cur 1) npow nacc
          else
            step (Int64.shift_right_logical cur 1) npow acc in
      if
        (|Compare.Int64|).(Compare.S.op_lt) m
          (* ❌ Constant of type int64 is converted to int *)
          0 then
        Error_monad.__error_value extensible_type_value
      else
        match
          step m __t_value
            (* ❌ Constant of type int64 is converted to int *)
            0 with
        | Pervasives.Ok res => Pervasives.Ok res
        | Pervasives.Error errs => Pervasives.Error errs
        end in
    let op_divquestion (__t_value : qty) (d : t) : Error_monad.tzresult int64 :=
      if
        op_lteq d
          (* ❌ Constant of type int64 is converted to int *)
          0 then
        Error_monad.__error_value extensible_type_value
      else
        Error_monad.ok (Int64.div __t_value d) in
    let add_exn (t1 : int64) (t2 : int64) : int64 :=
      let __t_value := Int64.add t1 t2 in
      if
        op_lteq __t_value
          (* ❌ Constant of type int64 is converted to int *)
          0 then
        Pervasives.invalid_arg "add_exn"
      else
        __t_value in
    let mul_exn (__t_value : qty) (m : int) : t :=
      match op_starquestion __t_value (Int64.of_int m) with
      | Pervasives.Ok v => v
      | Pervasives.Error _ => Pervasives.invalid_arg "mul_exn"
      end in
    let of_mutez (__t_value : t) : option t :=
      if
        op_lt __t_value
          (* ❌ Constant of type int64 is converted to int *)
          0 then
        None
      else
        Some __t_value in
    let of_mutez_exn (x : t) : t :=
      match of_mutez x with
      | None => Pervasives.invalid_arg "Qty.of_mutez"
      | Some v => v
      end in
    let to_int64 {A : Set} (__t_value : A) : A :=
      __t_value in
    let to_mutez {A : Set} (__t_value : A) : A :=
      __t_value in
    let qty_encoding :=
      Data_encoding.check_size 10
        (Data_encoding.conv Z.of_int64
          (Data_encoding.Json.wrap_error Z.to_int64) None Data_encoding.n) in
    (* ❌ top_level_evaluation *)
    existT (A := Set) _ _
      {|
        S.id := id;
        S.zero := zero;
        S.one_mutez := one_mutez;
        S.one_cent := one_cent;
        S.fifty_cents := fifty_cents;
        S.one := one;
        S.op_minusquestion := op_minusquestion;
        S.op_plusquestion := op_plusquestion;
        S.op_starquestion := op_starquestion;
        S.op_divquestion := op_divquestion;
        S.to_mutez := to_mutez;
        S.of_mutez := of_mutez;
        S.of_mutez_exn := of_mutez_exn;
        S.add_exn := add_exn;
        S.mul_exn := mul_exn;
        S.qty_encoding := qty_encoding;
        S.to_int64 := to_int64;
        S.op_eq := op_eq;
        S.op_ltgt := op_ltgt;
        S.op_lt := op_lt;
        S.op_lteq := op_lteq;
        S.op_gteq := op_gteq;
        S.op_gt := op_gt;
        S.compare := compare;
        S.equal := equal;
        S.max := max;
        S.min := min;
        S.pp := pp;
        S.of_string := of_string;
        S.to_string := to_string
      |}) : {qty : Set & S.signature (qty := qty)}).
