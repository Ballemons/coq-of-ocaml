(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Nonce_hash.

Import Alpha_context.

Import Data_encoding.

Definition error_encoding : Data_encoding.encoding Error_monad.__error := axiom.

Module ConstructorRecordNotations_successful_manager_operation_result.
  Module successful_manager_operation_result.
    Module Reveal_result.
      Record record {consumed_gas : Set} : Set := {
        consumed_gas : consumed_gas }.
      Arguments record : clear implicits.
    End Reveal_result.
    Definition Reveal_result_skeleton := Reveal_result.record.
    
    Module Transaction_result.
      Record record {storage big_map_diff balance_updates originated_contracts
        consumed_gas storage_size paid_storage_size_diff
        allocated_destination_contract : Set} : Set := {
        storage : storage;
        big_map_diff : big_map_diff;
        balance_updates : balance_updates;
        originated_contracts : originated_contracts;
        consumed_gas : consumed_gas;
        storage_size : storage_size;
        paid_storage_size_diff : paid_storage_size_diff;
        allocated_destination_contract : allocated_destination_contract }.
      Arguments record : clear implicits.
    End Transaction_result.
    Definition Transaction_result_skeleton := Transaction_result.record.
    
    Module Origination_result.
      Record record {big_map_diff balance_updates originated_contracts
        consumed_gas storage_size paid_storage_size_diff : Set} : Set := {
        big_map_diff : big_map_diff;
        balance_updates : balance_updates;
        originated_contracts : originated_contracts;
        consumed_gas : consumed_gas;
        storage_size : storage_size;
        paid_storage_size_diff : paid_storage_size_diff }.
      Arguments record : clear implicits.
    End Origination_result.
    Definition Origination_result_skeleton := Origination_result.record.
    
    Module Delegation_result.
      Record record {consumed_gas : Set} : Set := {
        consumed_gas : consumed_gas }.
      Arguments record : clear implicits.
    End Delegation_result.
    Definition Delegation_result_skeleton := Delegation_result.record.
  End successful_manager_operation_result.
End ConstructorRecordNotations_successful_manager_operation_result.
Import ConstructorRecordNotations_successful_manager_operation_result.

Reserved Notation "'successful_manager_operation_result.Reveal_result".
Reserved Notation "'successful_manager_operation_result.Transaction_result".
Reserved Notation "'successful_manager_operation_result.Origination_result".
Reserved Notation "'successful_manager_operation_result.Delegation_result".

Inductive successful_manager_operation_result : Set :=
| Reveal_result :
  'successful_manager_operation_result.Reveal_result ->
  successful_manager_operation_result
| Transaction_result :
  'successful_manager_operation_result.Transaction_result ->
  successful_manager_operation_result
| Origination_result :
  'successful_manager_operation_result.Origination_result ->
  successful_manager_operation_result
| Delegation_result :
  'successful_manager_operation_result.Delegation_result ->
  successful_manager_operation_result

where "'successful_manager_operation_result.Reveal_result" :=
  (successful_manager_operation_result.Reveal_result_skeleton Z.t)
and "'successful_manager_operation_result.Transaction_result" :=
  (successful_manager_operation_result.Transaction_result_skeleton
    (option Alpha_context.Script.expr)
    (option Alpha_context.Contract.big_map_diff)
    Alpha_context.Delegate.balance_updates (list Alpha_context.Contract.t) Z.t
    Z.t Z.t bool)
and "'successful_manager_operation_result.Origination_result" :=
  (successful_manager_operation_result.Origination_result_skeleton
    (option Alpha_context.Contract.big_map_diff)
    Alpha_context.Delegate.balance_updates (list Alpha_context.Contract.t) Z.t
    Z.t Z.t)
and "'successful_manager_operation_result.Delegation_result" :=
  (successful_manager_operation_result.Delegation_result_skeleton Z.t).

Module successful_manager_operation_result.
  Include ConstructorRecordNotations_successful_manager_operation_result.successful_manager_operation_result.
  Definition Reveal_result :=
    'successful_manager_operation_result.Reveal_result.
  Definition Transaction_result :=
    'successful_manager_operation_result.Transaction_result.
  Definition Origination_result :=
    'successful_manager_operation_result.Origination_result.
  Definition Delegation_result :=
    'successful_manager_operation_result.Delegation_result.
End successful_manager_operation_result.

Inductive packed_successful_manager_operation_result : Set :=
| Successful_manager_result :
  successful_manager_operation_result ->
  packed_successful_manager_operation_result.

Inductive manager_operation_result (kind : Set) : Set :=
| Applied : successful_manager_operation_result -> manager_operation_result kind
| Backtracked :
  successful_manager_operation_result -> option (list Error_monad.__error) ->
  manager_operation_result kind
| Failed :
  Alpha_context.Kind.manager -> list Error_monad.__error ->
  manager_operation_result kind
| Skipped : Alpha_context.Kind.manager -> manager_operation_result kind.

Arguments Applied {_}.
Arguments Backtracked {_}.
Arguments Failed {_}.
Arguments Skipped {_}.

Inductive packed_internal_operation_result : Set :=
| Internal_operation_result : forall {kind : Set},
  Alpha_context.internal_operation -> manager_operation_result kind ->
  packed_internal_operation_result.

Module Manager_result.
  Module ConstructorRecordNotations_case.
    Module case.
      Module MCase.
        Record record {op_case encoding kind iselect select proj inj t : Set} :
          Set := {
          op_case : op_case;
          encoding : encoding;
          kind : kind;
          iselect : iselect;
          select : select;
          proj : proj;
          inj : inj;
          t : t }.
        Arguments record : clear implicits.
      End MCase.
      Definition MCase_skeleton := MCase.record.
    End case.
  End ConstructorRecordNotations_case.
  Import ConstructorRecordNotations_case.
  
  Reserved Notation "'case.MCase".
  
  Inductive case (kind : Set) : Set :=
  | MCase : forall {a : Set}, 'case.MCase a kind -> case kind
  
  where "'case.MCase" := (fun (t_a t_kind : Set) =>
    case.MCase_skeleton Alpha_context.Operation.Encoding.Manager_operations.case
      (Data_encoding.t t_a) Alpha_context.Kind.manager
      (packed_internal_operation_result ->
      option
        (Alpha_context.internal_operation * manager_operation_result t_kind))
      (packed_successful_manager_operation_result ->
      option successful_manager_operation_result)
      (successful_manager_operation_result -> t_a)
      (t_a -> successful_manager_operation_result)
      (Data_encoding.t (manager_operation_result t_kind))).
  
  Module case.
    Include ConstructorRecordNotations_case.case.
    Definition MCase := 'case.MCase.
  End case.
  
  Arguments MCase {_ _}.
  
  Definition make {A B : Set}
    (op_case : Alpha_context.Operation.Encoding.Manager_operations.case)
    (encoding : Data_encoding.encoding A) (kind : Alpha_context.Kind.manager)
    (iselect :
      packed_internal_operation_result ->
      option (Alpha_context.internal_operation * manager_operation_result B))
    (select :
      packed_successful_manager_operation_result ->
      option successful_manager_operation_result)
    (proj : successful_manager_operation_result -> A)
    (inj : A -> successful_manager_operation_result) : case B :=
    let
      'Alpha_context.Operation.Encoding.Manager_operations.MCase {|
        Alpha_context.Operation.Encoding.Manager_operations.case.MCase.name := name
          |} := op_case in
    let __t_value :=
      (let arg :=
        Data_encoding.def
          (Format.asprintf
            (CamlinternalFormatBasics.Format
              (CamlinternalFormatBasics.String_literal
                "operation.alpha.operation_result."
                (CamlinternalFormatBasics.String
                  CamlinternalFormatBasics.No_padding
                  CamlinternalFormatBasics.End_of_format))
              "operation.alpha.operation_result.%s") name) in
      fun eta => arg None None eta)
        (Data_encoding.union (Some Data_encoding.Uint8)
          [
            Data_encoding.__case_value "Applied" None (Data_encoding.Tag 0)
              (Data_encoding.merge_objs
                (Data_encoding.obj1
                  (Data_encoding.req None None "status"
                    (Data_encoding.constant
                      "applied")))
                encoding)
              (fun o =>
                match o with
                | (Skipped _ | Failed _ _ | Backtracked _ _) =>
                  None
                | Applied o =>
                  match
                    select
                      (Successful_manager_result
                        o) with
                  | None => None
                  | Some o => Some (tt, (proj o))
                  end
                end)
              (fun function_parameter =>
                let '(_, x) := function_parameter in
                Applied (inj x));
            Data_encoding.__case_value "Failed" None (Data_encoding.Tag 1)
              (Data_encoding.obj2
                (Data_encoding.req None None "status"
                  (Data_encoding.constant "failed"))
                (Data_encoding.req None None "errors"
                  (Data_encoding.__list_value None
                    error_encoding)))
              (fun function_parameter =>
                match function_parameter with
                | Failed _ errs => Some (tt, errs)
                | _ => None
                end)
              (fun function_parameter =>
                let '(_, errs) := function_parameter in
                Failed kind errs);
            Data_encoding.__case_value "Skipped" None (Data_encoding.Tag 2)
              (Data_encoding.obj1
                (Data_encoding.req None None "status"
                  (Data_encoding.constant "skipped")))
              (fun function_parameter =>
                match function_parameter with
                | Skipped _ => Some tt
                | _ => None
                end)
              (fun function_parameter =>
                let '_ := function_parameter in
                Skipped kind);
            Data_encoding.__case_value "Backtracked" None (Data_encoding.Tag 3)
              (Data_encoding.merge_objs
                (Data_encoding.obj2
                  (Data_encoding.req None None "status"
                    (Data_encoding.constant
                      "backtracked"))
                  (Data_encoding.opt None None "errors"
                    (Data_encoding.__list_value
                      None
                      error_encoding)))
                encoding)
              (fun o =>
                match o with
                | (Skipped _ | Failed _ _ | Applied _) => None
                | Backtracked o errs =>
                  match
                    select
                      (Successful_manager_result
                        o) with
                  | None => None
                  | Some o =>
                    Some ((tt, errs), (proj o))
                  end
                end)
              (fun function_parameter =>
                let '((_, errs), x) := function_parameter in
                Backtracked (inj x) errs)
          ]) in
    MCase
      {| case.MCase.op_case := op_case; case.MCase.encoding := encoding;
        case.MCase.kind := kind; case.MCase.iselect := iselect;
        case.MCase.select := select; case.MCase.proj := proj;
        case.MCase.inj := inj; case.MCase.t := __t_value |}.
  
  Definition reveal_case : case Alpha_context.Kind.reveal :=
    make Alpha_context.Operation.Encoding.Manager_operations.reveal_case
      (Data_encoding.obj1
        (Data_encoding.dft None None "consumed_gas" Data_encoding.z Z.zero))
      Alpha_context.Kind.Reveal_manager_kind
      (fun function_parameter =>
        match function_parameter with
        |
          Internal_operation_result
            ({|
              Alpha_context.internal_operation.operation := Alpha_context.Reveal _
                |} as op) res =>
          let 'existT _ __Internal_operation_result_'kind [op, res] :=
            existT (A := Set)
              (fun __Internal_operation_result_'kind =>
                [Alpha_context.internal_operation **
                  manager_operation_result __Internal_operation_result_'kind]) _
              [op, res] in
          Some (op, res)
        | _ => None
        end)
      (fun function_parameter =>
        match function_parameter with
        | Successful_manager_result ((Reveal_result _) as op) => Some op
        | _ => None
        end)
      (fun function_parameter =>
        let
          'Reveal_result {|
            successful_manager_operation_result.Reveal_result.consumed_gas := consumed_gas
              |} := function_parameter in
        consumed_gas)
      (fun consumed_gas =>
        Reveal_result
          {|
            successful_manager_operation_result.Reveal_result.consumed_gas :=
              consumed_gas |}).
  
  Definition transaction_case : case Alpha_context.Kind.transaction :=
    make Alpha_context.Operation.Encoding.Manager_operations.transaction_case
      (Data_encoding.obj8
        (Data_encoding.opt None None "storage"
          Alpha_context.Script.expr_encoding)
        (Data_encoding.opt None None "big_map_diff"
          Alpha_context.Contract.big_map_diff_encoding)
        (Data_encoding.dft None None "balance_updates"
          Alpha_context.Delegate.balance_updates_encoding nil)
        (Data_encoding.dft None None "originated_contracts"
          (Data_encoding.__list_value None Alpha_context.Contract.encoding) nil)
        (Data_encoding.dft None None "consumed_gas" Data_encoding.z Z.zero)
        (Data_encoding.dft None None "storage_size" Data_encoding.z Z.zero)
        (Data_encoding.dft None None "paid_storage_size_diff" Data_encoding.z
          Z.zero)
        (Data_encoding.dft None None "allocated_destination_contract"
          Data_encoding.__bool_value false))
      Alpha_context.Kind.Transaction_manager_kind
      (fun function_parameter =>
        match function_parameter with
        |
          Internal_operation_result
            ({|
              Alpha_context.internal_operation.operation := Alpha_context.Transaction _
                |} as op) res =>
          let 'existT _ __Internal_operation_result_'kind [op, res] :=
            existT (A := Set)
              (fun __Internal_operation_result_'kind =>
                [Alpha_context.internal_operation **
                  manager_operation_result __Internal_operation_result_'kind]) _
              [op, res] in
          Some (op, res)
        | _ => None
        end)
      (fun function_parameter =>
        match function_parameter with
        | Successful_manager_result ((Transaction_result _) as op) => Some op
        | _ => None
        end)
      (fun function_parameter =>
        let
          'Transaction_result {|
            successful_manager_operation_result.Transaction_result.storage := storage;
              successful_manager_operation_result.Transaction_result.big_map_diff
                := big_map_diff;
              successful_manager_operation_result.Transaction_result.balance_updates
                := balance_updates;
              successful_manager_operation_result.Transaction_result.originated_contracts
                := originated_contracts;
              successful_manager_operation_result.Transaction_result.consumed_gas
                := consumed_gas;
              successful_manager_operation_result.Transaction_result.storage_size
                := storage_size;
              successful_manager_operation_result.Transaction_result.paid_storage_size_diff
                := paid_storage_size_diff;
              successful_manager_operation_result.Transaction_result.allocated_destination_contract
                := allocated_destination_contract
              |} := function_parameter in
        (storage, big_map_diff, balance_updates, originated_contracts,
          consumed_gas, storage_size, paid_storage_size_diff,
          allocated_destination_contract))
      (fun function_parameter =>
        let
          '(storage, big_map_diff, balance_updates, originated_contracts,
            consumed_gas, storage_size, paid_storage_size_diff,
            allocated_destination_contract) := function_parameter in
        Transaction_result
          {|
            successful_manager_operation_result.Transaction_result.storage :=
              storage;
            successful_manager_operation_result.Transaction_result.big_map_diff :=
              big_map_diff;
            successful_manager_operation_result.Transaction_result.balance_updates :=
              balance_updates;
            successful_manager_operation_result.Transaction_result.originated_contracts :=
              originated_contracts;
            successful_manager_operation_result.Transaction_result.consumed_gas :=
              consumed_gas;
            successful_manager_operation_result.Transaction_result.storage_size :=
              storage_size;
            successful_manager_operation_result.Transaction_result.paid_storage_size_diff :=
              paid_storage_size_diff;
            successful_manager_operation_result.Transaction_result.allocated_destination_contract :=
              allocated_destination_contract |}).
  
  Definition origination_case : case Alpha_context.Kind.origination :=
    make Alpha_context.Operation.Encoding.Manager_operations.origination_case
      (Data_encoding.obj6
        (Data_encoding.opt None None "big_map_diff"
          Alpha_context.Contract.big_map_diff_encoding)
        (Data_encoding.dft None None "balance_updates"
          Alpha_context.Delegate.balance_updates_encoding nil)
        (Data_encoding.dft None None "originated_contracts"
          (Data_encoding.__list_value None Alpha_context.Contract.encoding) nil)
        (Data_encoding.dft None None "consumed_gas" Data_encoding.z Z.zero)
        (Data_encoding.dft None None "storage_size" Data_encoding.z Z.zero)
        (Data_encoding.dft None None "paid_storage_size_diff" Data_encoding.z
          Z.zero)) Alpha_context.Kind.Origination_manager_kind
      (fun function_parameter =>
        match function_parameter with
        |
          Internal_operation_result
            ({|
              Alpha_context.internal_operation.operation := Alpha_context.Origination _
                |} as op) res =>
          let 'existT _ __Internal_operation_result_'kind [op, res] :=
            existT (A := Set)
              (fun __Internal_operation_result_'kind =>
                [Alpha_context.internal_operation **
                  manager_operation_result __Internal_operation_result_'kind]) _
              [op, res] in
          Some (op, res)
        | _ => None
        end)
      (fun function_parameter =>
        match function_parameter with
        | Successful_manager_result ((Origination_result _) as op) => Some op
        | _ => None
        end)
      (fun function_parameter =>
        let
          'Origination_result {|
            successful_manager_operation_result.Origination_result.big_map_diff :=
              big_map_diff;
              successful_manager_operation_result.Origination_result.balance_updates
                := balance_updates;
              successful_manager_operation_result.Origination_result.originated_contracts
                := originated_contracts;
              successful_manager_operation_result.Origination_result.consumed_gas
                := consumed_gas;
              successful_manager_operation_result.Origination_result.storage_size
                := storage_size;
              successful_manager_operation_result.Origination_result.paid_storage_size_diff
                := paid_storage_size_diff
              |} := function_parameter in
        (big_map_diff, balance_updates, originated_contracts, consumed_gas,
          storage_size, paid_storage_size_diff))
      (fun function_parameter =>
        let
          '(big_map_diff, balance_updates, originated_contracts, consumed_gas,
            storage_size, paid_storage_size_diff) := function_parameter in
        Origination_result
          {|
            successful_manager_operation_result.Origination_result.big_map_diff :=
              big_map_diff;
            successful_manager_operation_result.Origination_result.balance_updates :=
              balance_updates;
            successful_manager_operation_result.Origination_result.originated_contracts :=
              originated_contracts;
            successful_manager_operation_result.Origination_result.consumed_gas :=
              consumed_gas;
            successful_manager_operation_result.Origination_result.storage_size :=
              storage_size;
            successful_manager_operation_result.Origination_result.paid_storage_size_diff :=
              paid_storage_size_diff |}).
  
  Definition delegation_case : case Alpha_context.Kind.delegation :=
    make Alpha_context.Operation.Encoding.Manager_operations.delegation_case
      (Data_encoding.obj1
        (Data_encoding.dft None None "consumed_gas" Data_encoding.z Z.zero))
      Alpha_context.Kind.Delegation_manager_kind
      (fun function_parameter =>
        match function_parameter with
        |
          Internal_operation_result
            ({|
              Alpha_context.internal_operation.operation := Alpha_context.Delegation _
                |} as op) res =>
          let 'existT _ __Internal_operation_result_'kind [op, res] :=
            existT (A := Set)
              (fun __Internal_operation_result_'kind =>
                [Alpha_context.internal_operation **
                  manager_operation_result __Internal_operation_result_'kind]) _
              [op, res] in
          Some (op, res)
        | _ => None
        end)
      (fun function_parameter =>
        match function_parameter with
        | Successful_manager_result ((Delegation_result _) as op) => Some op
        | _ => None
        end)
      (fun function_parameter =>
        let
          'Delegation_result {|
            successful_manager_operation_result.Delegation_result.consumed_gas :=
              consumed_gas
              |} := function_parameter in
        consumed_gas)
      (fun consumed_gas =>
        Delegation_result
          {|
            successful_manager_operation_result.Delegation_result.consumed_gas :=
              consumed_gas |}).
End Manager_result.

Definition internal_operation_result_encoding
  : Data_encoding.t packed_internal_operation_result :=
  let make {A : Set} (function_parameter : Manager_result.case A)
    : Data_encoding.case packed_internal_operation_result :=
    let 'Manager_result.MCase res_case := function_parameter in
    let 'existT _ __MCase_'a res_case :=
      existT (A := Set)
        (fun __MCase_'a => Manager_result.case.MCase kind __MCase_'a) _ res_case
      in
    let 'Alpha_context.Operation.Encoding.Manager_operations.MCase op_case :=
      res_case.(Manager_result.case.MCase.op_case) in
    let 'existT _ __MCase_'a1 op_case :=
      existT (A := Set)
        (fun __MCase_'a1 =>
          Alpha_context.Operation.Encoding.Manager_operations.case.MCase
            __MCase_'a1) _ op_case in
    Data_encoding.__case_value
      op_case.(Alpha_context.Operation.Encoding.Manager_operations.case.MCase.name)
      None
      (Data_encoding.Tag
        op_case.(Alpha_context.Operation.Encoding.Manager_operations.case.MCase.tag))
      (Data_encoding.merge_objs
        (Data_encoding.obj3
          (Data_encoding.req None None "kind"
            (Data_encoding.constant
              op_case.(Alpha_context.Operation.Encoding.Manager_operations.case.MCase.name)))
          (Data_encoding.req None None "source" Alpha_context.Contract.encoding)
          (Data_encoding.req None None "nonce" Data_encoding.uint16))
        (Data_encoding.merge_objs
          op_case.(Alpha_context.Operation.Encoding.Manager_operations.case.MCase.encoding)
          (Data_encoding.obj1
            (Data_encoding.req None None "result"
              res_case.(Manager_result.case.MCase.t)))))
      (fun op =>
        match res_case.(Manager_result.case.MCase.iselect) op with
        | Some (op, res) =>
          Some
            ((tt, op.(Alpha_context.internal_operation.source),
              op.(Alpha_context.internal_operation.nonce)),
              ((op_case.(Alpha_context.Operation.Encoding.Manager_operations.case.MCase.proj)
                op.(Alpha_context.internal_operation.operation)), res))
        | None => None
        end)
      (fun function_parameter =>
        let '((_, source, __nonce_value), (op, res)) := function_parameter in
        let op :=
          {| Alpha_context.internal_operation.source := source;
            Alpha_context.internal_operation.operation :=
              op_case.(Alpha_context.Operation.Encoding.Manager_operations.case.MCase.inj)
                op; Alpha_context.internal_operation.nonce := __nonce_value |}
          in
        Internal_operation_result op res) in
  (let arg := Data_encoding.def "operation.alpha.internal_operation_result" in
  fun eta => arg None None eta)
    (Data_encoding.union None
      [
        make Manager_result.reveal_case;
        make Manager_result.transaction_case;
        make Manager_result.origination_case;
        make Manager_result.delegation_case
      ]).

Module ConstructorRecordNotations_contents_result.
  Module contents_result.
    Module Endorsement_result.
      Record record {balance_updates delegate slots : Set} : Set := {
        balance_updates : balance_updates;
        delegate : delegate;
        slots : slots }.
      Arguments record : clear implicits.
    End Endorsement_result.
    Definition Endorsement_result_skeleton := Endorsement_result.record.
    
    Module Manager_operation_result.
      Record record {balance_updates operation_result internal_operation_results
        : Set} : Set := {
        balance_updates : balance_updates;
        operation_result : operation_result;
        internal_operation_results : internal_operation_results }.
      Arguments record : clear implicits.
    End Manager_operation_result.
    Definition Manager_operation_result_skeleton :=
      Manager_operation_result.record.
  End contents_result.
End ConstructorRecordNotations_contents_result.
Import ConstructorRecordNotations_contents_result.

Reserved Notation "'contents_result.Endorsement_result".
Reserved Notation "'contents_result.Manager_operation_result".

Inductive contents_result : Set :=
| Endorsement_result : 'contents_result.Endorsement_result -> contents_result
| Seed_nonce_revelation_result :
  Alpha_context.Delegate.balance_updates -> contents_result
| Double_endorsement_evidence_result :
  Alpha_context.Delegate.balance_updates -> contents_result
| Double_baking_evidence_result :
  Alpha_context.Delegate.balance_updates -> contents_result
| Activate_account_result :
  Alpha_context.Delegate.balance_updates -> contents_result
| Proposals_result : contents_result
| Ballot_result : contents_result
| Manager_operation_result : forall {kind : Set},
  'contents_result.Manager_operation_result kind -> contents_result

where "'contents_result.Endorsement_result" :=
  (contents_result.Endorsement_result_skeleton
    Alpha_context.Delegate.balance_updates
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) (list int))
and "'contents_result.Manager_operation_result" := (fun (t_kind : Set) =>
  contents_result.Manager_operation_result_skeleton
    Alpha_context.Delegate.balance_updates (manager_operation_result t_kind)
    (list packed_internal_operation_result)).

Module contents_result.
  Include ConstructorRecordNotations_contents_result.contents_result.
  Definition Endorsement_result := 'contents_result.Endorsement_result.
  Definition Manager_operation_result :=
    'contents_result.Manager_operation_result.
End contents_result.

Inductive packed_contents_result : Set :=
| Contents_result : contents_result -> packed_contents_result.

Inductive packed_contents_and_result : Set :=
| Contents_and_result :
  Alpha_context.Operation.contents -> contents_result ->
  packed_contents_and_result.

Inductive eq : Set :=
| Eq : eq.

Definition equal_manager_kind
  (ka : Alpha_context.Kind.manager) (kb : Alpha_context.Kind.manager)
  : option eq :=
  match (ka, kb) with
  |
    (Alpha_context.Kind.Reveal_manager_kind,
      Alpha_context.Kind.Reveal_manager_kind) => Some Eq
  | (Alpha_context.Kind.Reveal_manager_kind, _) => None
  |
    (Alpha_context.Kind.Transaction_manager_kind,
      Alpha_context.Kind.Transaction_manager_kind) => Some Eq
  | (Alpha_context.Kind.Transaction_manager_kind, _) => None
  |
    (Alpha_context.Kind.Origination_manager_kind,
      Alpha_context.Kind.Origination_manager_kind) => Some Eq
  | (Alpha_context.Kind.Origination_manager_kind, _) => None
  |
    (Alpha_context.Kind.Delegation_manager_kind,
      Alpha_context.Kind.Delegation_manager_kind) => Some Eq
  | (Alpha_context.Kind.Delegation_manager_kind, _) => None
  end.

Module Encoding.
  Module ConstructorRecordNotations_case.
    Module case.
      Module Case.
        Record record {op_case encoding select mselect proj inj : Set} : Set := {
          op_case : op_case;
          encoding : encoding;
          select : select;
          mselect : mselect;
          proj : proj;
          inj : inj }.
        Arguments record : clear implicits.
      End Case.
      Definition Case_skeleton := Case.record.
    End case.
  End ConstructorRecordNotations_case.
  Import ConstructorRecordNotations_case.
  
  Reserved Notation "'case.Case".
  
  Inductive case (kind : Set) : Set :=
  | Case : forall {a : Set}, 'case.Case kind a -> case kind
  
  where "'case.Case" := (fun (t_kind t_a : Set) =>
    case.Case_skeleton (Alpha_context.Operation.Encoding.case t_kind)
      (Data_encoding.t t_a) (packed_contents_result -> option contents_result)
      (packed_contents_and_result ->
      option (Alpha_context.contents * contents_result))
      (contents_result -> t_a) (t_a -> contents_result)).
  
  Module case.
    Include ConstructorRecordNotations_case.case.
    Definition Case := 'case.Case.
  End case.
  
  Arguments Case {_ _}.
  
  Definition tagged_case {A B : Set}
    (tag : Data_encoding.case_tag) (name : string)
    (args : Data_encoding.encoding A) (proj : B -> option A) (inj : A -> B)
    : Data_encoding.case B :=
    Data_encoding.__case_value (String.capitalize_ascii name) None tag
      (Data_encoding.merge_objs
        (Data_encoding.obj1
          (Data_encoding.req None None "kind" (Data_encoding.constant name)))
        args)
      (fun x =>
        match proj x with
        | None => None
        | Some x => Some (tt, x)
        end)
      (fun function_parameter =>
        let '(_, x) := function_parameter in
        inj x).
  
  Definition endorsement_case : case Alpha_context.Kind.endorsement :=
    Case
      {| case.Case.op_case := Alpha_context.Operation.Encoding.endorsement_case;
        case.Case.encoding :=
          Data_encoding.obj3
            (Data_encoding.req None None "balance_updates"
              Alpha_context.Delegate.balance_updates_encoding)
            (Data_encoding.req None None "delegate"
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
            (Data_encoding.req None None "slots"
              (Data_encoding.__list_value None Data_encoding.uint8));
        case.Case.select :=
          fun function_parameter =>
            match function_parameter with
            | Contents_result ((Endorsement_result _) as op) => Some op
            | _ => None
            end;
        case.Case.mselect :=
          fun function_parameter =>
            match function_parameter with
            | Contents_and_result ((Alpha_context.Endorsement _) as op) res =>
              Some (op, res)
            | _ => None
            end;
        case.Case.proj :=
          fun function_parameter =>
            let
              'Endorsement_result {|
                contents_result.Endorsement_result.balance_updates := balance_updates;
                  contents_result.Endorsement_result.delegate := delegate;
                  contents_result.Endorsement_result.slots := slots
                  |} := function_parameter in
            (balance_updates, delegate, slots);
        case.Case.inj :=
          fun function_parameter =>
            let '(balance_updates, delegate, slots) := function_parameter in
            Endorsement_result
              {|
                contents_result.Endorsement_result.balance_updates :=
                  balance_updates;
                contents_result.Endorsement_result.delegate := delegate;
                contents_result.Endorsement_result.slots := slots |} |}.
  
  Definition seed_nonce_revelation_case
    : case Alpha_context.Kind.seed_nonce_revelation :=
    Case
      {|
        case.Case.op_case :=
          Alpha_context.Operation.Encoding.seed_nonce_revelation_case;
        case.Case.encoding :=
          Data_encoding.obj1
            (Data_encoding.req None None "balance_updates"
              Alpha_context.Delegate.balance_updates_encoding);
        case.Case.select :=
          fun function_parameter =>
            match function_parameter with
            | Contents_result ((Seed_nonce_revelation_result _) as op) =>
              Some op
            | _ => None
            end;
        case.Case.mselect :=
          fun function_parameter =>
            match function_parameter with
            |
              Contents_and_result
                ((Alpha_context.Seed_nonce_revelation _) as op) res =>
              Some (op, res)
            | _ => None
            end;
        case.Case.proj :=
          fun function_parameter =>
            let 'Seed_nonce_revelation_result bus := function_parameter in
            bus; case.Case.inj := fun bus => Seed_nonce_revelation_result bus |}.
  
  Definition double_endorsement_evidence_case
    : case Alpha_context.Kind.double_endorsement_evidence :=
    Case
      {|
        case.Case.op_case :=
          Alpha_context.Operation.Encoding.double_endorsement_evidence_case;
        case.Case.encoding :=
          Data_encoding.obj1
            (Data_encoding.req None None "balance_updates"
              Alpha_context.Delegate.balance_updates_encoding);
        case.Case.select :=
          fun function_parameter =>
            match function_parameter with
            | Contents_result ((Double_endorsement_evidence_result _) as op) =>
              Some op
            | _ => None
            end;
        case.Case.mselect :=
          fun function_parameter =>
            match function_parameter with
            |
              Contents_and_result
                ((Alpha_context.Double_endorsement_evidence _) as op) res =>
              Some (op, res)
            | _ => None
            end;
        case.Case.proj :=
          fun function_parameter =>
            let 'Double_endorsement_evidence_result bus := function_parameter in
            bus;
        case.Case.inj := fun bus => Double_endorsement_evidence_result bus |}.
  
  Definition double_baking_evidence_case
    : case Alpha_context.Kind.double_baking_evidence :=
    Case
      {|
        case.Case.op_case :=
          Alpha_context.Operation.Encoding.double_baking_evidence_case;
        case.Case.encoding :=
          Data_encoding.obj1
            (Data_encoding.req None None "balance_updates"
              Alpha_context.Delegate.balance_updates_encoding);
        case.Case.select :=
          fun function_parameter =>
            match function_parameter with
            | Contents_result ((Double_baking_evidence_result _) as op) =>
              Some op
            | _ => None
            end;
        case.Case.mselect :=
          fun function_parameter =>
            match function_parameter with
            |
              Contents_and_result
                ((Alpha_context.Double_baking_evidence _) as op) res =>
              Some (op, res)
            | _ => None
            end;
        case.Case.proj :=
          fun function_parameter =>
            let 'Double_baking_evidence_result bus := function_parameter in
            bus; case.Case.inj := fun bus => Double_baking_evidence_result bus
        |}.
  
  Definition activate_account_case : case Alpha_context.Kind.activate_account :=
    Case
      {|
        case.Case.op_case :=
          Alpha_context.Operation.Encoding.activate_account_case;
        case.Case.encoding :=
          Data_encoding.obj1
            (Data_encoding.req None None "balance_updates"
              Alpha_context.Delegate.balance_updates_encoding);
        case.Case.select :=
          fun function_parameter =>
            match function_parameter with
            | Contents_result ((Activate_account_result _) as op) => Some op
            | _ => None
            end;
        case.Case.mselect :=
          fun function_parameter =>
            match function_parameter with
            | Contents_and_result ((Alpha_context.Activate_account _) as op) res
              => Some (op, res)
            | _ => None
            end;
        case.Case.proj :=
          fun function_parameter =>
            let 'Activate_account_result bus := function_parameter in
            bus; case.Case.inj := fun bus => Activate_account_result bus |}.
  
  Definition proposals_case : case Alpha_context.Kind.proposals :=
    Case
      {| case.Case.op_case := Alpha_context.Operation.Encoding.proposals_case;
        case.Case.encoding := Data_encoding.empty;
        case.Case.select :=
          fun function_parameter =>
            match function_parameter with
            | Contents_result (Proposals_result as op) => Some op
            | _ => None
            end;
        case.Case.mselect :=
          fun function_parameter =>
            match function_parameter with
            | Contents_and_result ((Alpha_context.Proposals _) as op) res =>
              Some (op, res)
            | _ => None
            end;
        case.Case.proj :=
          fun function_parameter =>
            let 'Proposals_result := function_parameter in
            tt;
        case.Case.inj :=
          fun function_parameter =>
            let '_ := function_parameter in
            Proposals_result |}.
  
  Definition ballot_case : case Alpha_context.Kind.ballot :=
    Case
      {| case.Case.op_case := Alpha_context.Operation.Encoding.ballot_case;
        case.Case.encoding := Data_encoding.empty;
        case.Case.select :=
          fun function_parameter =>
            match function_parameter with
            | Contents_result (Ballot_result as op) => Some op
            | _ => None
            end;
        case.Case.mselect :=
          fun function_parameter =>
            match function_parameter with
            | Contents_and_result ((Alpha_context.Ballot _) as op) res =>
              Some (op, res)
            | _ => None
            end;
        case.Case.proj :=
          fun function_parameter =>
            let 'Ballot_result := function_parameter in
            tt;
        case.Case.inj :=
          fun function_parameter =>
            let '_ := function_parameter in
            Ballot_result |}.
  
  Definition make_manager_case {A : Set}
    (function_parameter :
      Alpha_context.Operation.Encoding.case Alpha_context.Kind.manager)
    : Manager_result.case A ->
    (packed_contents_and_result ->
    option (Alpha_context.contents * contents_result)) ->
    case Alpha_context.Kind.manager :=
    let 'Alpha_context.Operation.Encoding.Case op_case := function_parameter in
    let 'existT _ __Case_'a op_case :=
      existT (A := Set)
        (fun __Case_'a => Alpha_context.Operation.Encoding.case.Case __Case_'a)
        _ op_case in
    fun function_parameter =>
      let 'Manager_result.MCase res_case := function_parameter in
      let 'existT _ __MCase_'a res_case :=
        existT (A := Set)
          (fun __MCase_'a => Manager_result.case.MCase kind __MCase_'a) _
          res_case in
      fun mselect =>
        Case
          {| case.Case.op_case := Alpha_context.Operation.Encoding.Case op_case;
            case.Case.encoding :=
              Data_encoding.obj3
                (Data_encoding.req None None "balance_updates"
                  Alpha_context.Delegate.balance_updates_encoding)
                (Data_encoding.req None None "operation_result"
                  res_case.(Manager_result.case.MCase.t))
                (Data_encoding.dft None None "internal_operation_results"
                  (Data_encoding.__list_value None
                    internal_operation_result_encoding) nil);
            case.Case.select :=
              fun function_parameter =>
                match function_parameter with
                |
                  Contents_result
                    (Manager_operation_result
                      ({|
                        contents_result.Manager_operation_result.operation_result := Applied res
                          |} as op)) =>
                  let 'existT _ __0 [res, op] :=
                    existT (A := Set)
                      (fun __0 =>
                        [successful_manager_operation_result **
                          contents_result.Manager_operation_result __0]) _
                      [res, op] in
                  match
                    res_case.(Manager_result.case.MCase.select)
                      (Successful_manager_result res) with
                  | Some res =>
                    Some
                      (Manager_operation_result
                        (contents_result.Manager_operation_result.with_operation_result
                          (Applied res) op))
                  | None => None
                  end
                
                |
                  Contents_result
                    (Manager_operation_result
                      ({|
                        contents_result.Manager_operation_result.operation_result :=
                          Backtracked res errs
                          |} as op)) =>
                  let 'existT _ __1 [res, errs, op] :=
                    existT (A := Set)
                      (fun __1 =>
                        [successful_manager_operation_result **
                          option (list Error_monad.__error) **
                          contents_result.Manager_operation_result __1]) _
                      [res, errs, op] in
                  match
                    res_case.(Manager_result.case.MCase.select)
                      (Successful_manager_result res) with
                  | Some res =>
                    Some
                      (Manager_operation_result
                        (contents_result.Manager_operation_result.with_operation_result
                          (Backtracked res errs) op))
                  | None => None
                  end
                
                |
                  Contents_result
                    (Manager_operation_result
                      ({|
                        contents_result.Manager_operation_result.operation_result := Skipped kind
                          |} as op)) =>
                  let 'existT _ __2 [kind, op] :=
                    existT (A := Set)
                      (fun __2 =>
                        [Alpha_context.Kind.manager **
                          contents_result.Manager_operation_result __2]) _
                      [kind, op] in
                  match
                    equal_manager_kind kind
                      res_case.(Manager_result.case.MCase.kind) with
                  | None => None
                  | Some Eq =>
                    Some
                      (Manager_operation_result
                        (contents_result.Manager_operation_result.with_operation_result
                          (Skipped kind) op))
                  end
                
                |
                  Contents_result
                    (Manager_operation_result
                      ({|
                        contents_result.Manager_operation_result.operation_result := Failed kind errs
                          |} as op)) =>
                  let 'existT _ __3 [kind, errs, op] :=
                    existT (A := Set)
                      (fun __3 =>
                        [Alpha_context.Kind.manager ** list Error_monad.__error
                          ** contents_result.Manager_operation_result __3]) _
                      [kind, errs, op] in
                  match
                    equal_manager_kind kind
                      res_case.(Manager_result.case.MCase.kind) with
                  | None => None
                  | Some Eq =>
                    Some
                      (Manager_operation_result
                        (contents_result.Manager_operation_result.with_operation_result
                          (Failed kind errs) op))
                  end
                
                | Contents_result Ballot_result => None
                
                | Contents_result (Endorsement_result _) => None
                
                | Contents_result (Seed_nonce_revelation_result _) => None
                
                | Contents_result (Double_endorsement_evidence_result _) => None
                
                | Contents_result (Double_baking_evidence_result _) => None
                
                | Contents_result (Activate_account_result _) => None
                
                | Contents_result Proposals_result => None
                end; case.Case.mselect := mselect;
            case.Case.proj :=
              fun function_parameter =>
                let
                  'Manager_operation_result {|
                    contents_result.Manager_operation_result.balance_updates := bus;
                      contents_result.Manager_operation_result.operation_result
                        := __r_value;
                      contents_result.Manager_operation_result.internal_operation_results
                        := rs
                      |} := function_parameter in
                (bus, __r_value, rs);
            case.Case.inj :=
              fun function_parameter =>
                let '(bus, __r_value, rs) := function_parameter in
                Manager_operation_result
                  {|
                    contents_result.Manager_operation_result.balance_updates :=
                      bus;
                    contents_result.Manager_operation_result.operation_result :=
                      __r_value;
                    contents_result.Manager_operation_result.internal_operation_results :=
                      rs |} |}.
  
  Definition reveal_case : case Alpha_context.Kind.manager :=
    make_manager_case Alpha_context.Operation.Encoding.reveal_case
      Manager_result.reveal_case
      (fun function_parameter =>
        match function_parameter with
        |
          Contents_and_result
            ((Alpha_context.Manager_operation {|
              Alpha_context.contents.Manager_operation.operation := Alpha_context.Reveal _
                |}) as op) res => Some (op, res)
        | _ => None
        end).
  
  Definition transaction_case : case Alpha_context.Kind.manager :=
    make_manager_case Alpha_context.Operation.Encoding.transaction_case
      Manager_result.transaction_case
      (fun function_parameter =>
        match function_parameter with
        |
          Contents_and_result
            ((Alpha_context.Manager_operation {|
              Alpha_context.contents.Manager_operation.operation :=
                Alpha_context.Transaction _
                |}) as op) res => Some (op, res)
        | _ => None
        end).
  
  Definition origination_case : case Alpha_context.Kind.manager :=
    make_manager_case Alpha_context.Operation.Encoding.origination_case
      Manager_result.origination_case
      (fun function_parameter =>
        match function_parameter with
        |
          Contents_and_result
            ((Alpha_context.Manager_operation {|
              Alpha_context.contents.Manager_operation.operation :=
                Alpha_context.Origination _
                |}) as op) res => Some (op, res)
        | _ => None
        end).
  
  Definition delegation_case : case Alpha_context.Kind.manager :=
    make_manager_case Alpha_context.Operation.Encoding.delegation_case
      Manager_result.delegation_case
      (fun function_parameter =>
        match function_parameter with
        |
          Contents_and_result
            ((Alpha_context.Manager_operation {|
              Alpha_context.contents.Manager_operation.operation :=
                Alpha_context.Delegation _
                |}) as op) res => Some (op, res)
        | _ => None
        end).
End Encoding.

Definition contents_result_encoding
  : Data_encoding.encoding packed_contents_result :=
  let make {A : Set} (function_parameter : Encoding.case A)
    : Data_encoding.case packed_contents_result :=
    let
      'Encoding.Case {|
        Encoding.case.Case.op_case :=
          Alpha_context.Operation.Encoding.Case {|
            Alpha_context.Operation.Encoding.case.Case.tag := tag;
              Alpha_context.Operation.Encoding.case.Case.name :=
                name
              |};
          Encoding.case.Case.encoding := encoding;
          Encoding.case.Case.select := select;
          Encoding.case.Case.mselect := _;
          Encoding.case.Case.proj := proj;
          Encoding.case.Case.inj := inj
          |} := function_parameter in
    let 'existT _ __Case_'a [tag, name, encoding, select, proj, inj] :=
      existT (A := Set)
        (fun __Case_'a =>
          [int ** string ** Data_encoding.t __Case_'a **
            packed_contents_result -> option contents_result **
            contents_result -> __Case_'a ** __Case_'a -> contents_result]) _
        [tag, name, encoding, select, proj, inj] in
    let proj (x : packed_contents_result) : option __Case_'a :=
      match select x with
      | None => None
      | Some x => Some (proj x)
      end in
    let inj (x : __Case_'a) : packed_contents_result :=
      Contents_result (inj x) in
    tagged_case (Data_encoding.Tag tag) name encoding proj inj in
  (let arg := Data_encoding.def "operation.alpha.contents_result" in
  fun eta => arg None None eta)
    (Data_encoding.union None
      [
        make endorsement_case;
        make seed_nonce_revelation_case;
        make double_endorsement_evidence_case;
        make double_baking_evidence_case;
        make activate_account_case;
        make proposals_case;
        make ballot_case;
        make reveal_case;
        make transaction_case;
        make origination_case;
        make delegation_case
      ]).

Definition contents_and_result_encoding
  : Data_encoding.encoding packed_contents_and_result :=
  let make {A : Set} (function_parameter : Encoding.case A)
    : Data_encoding.case packed_contents_and_result :=
    let
      'Encoding.Case {|
        Encoding.case.Case.op_case :=
          Alpha_context.Operation.Encoding.Case {|
            Alpha_context.Operation.Encoding.case.Case.tag := tag;
              Alpha_context.Operation.Encoding.case.Case.name :=
                name;
              Alpha_context.Operation.Encoding.case.Case.encoding :=
                encoding;
              Alpha_context.Operation.Encoding.case.Case.proj :=
                proj;
              Alpha_context.Operation.Encoding.case.Case.inj := inj
              |};
          Encoding.case.Case.encoding := meta_encoding;
          Encoding.case.Case.mselect := mselect;
          Encoding.case.Case.proj := meta_proj;
          Encoding.case.Case.inj := meta_inj
          |} := function_parameter in
    let 'existT _ [__Case_'a, __Case_'a1]
      [tag, name, encoding, proj, inj, meta_encoding, mselect, meta_proj,
        meta_inj] :=
      existT (A := [Set ** Set])
        (fun '[__Case_'a, __Case_'a1] =>
          [int ** string ** Data_encoding.t __Case_'a1 **
            Alpha_context.Operation.contents -> __Case_'a1 **
            __Case_'a1 -> Alpha_context.Operation.contents **
            Data_encoding.t __Case_'a **
            packed_contents_and_result ->
            option (Alpha_context.contents * contents_result) **
            contents_result -> __Case_'a ** __Case_'a -> contents_result]) [_,
        _]
        [tag, name, encoding, proj, inj, meta_encoding, mselect, meta_proj,
          meta_inj] in
    let proj (c : packed_contents_and_result)
      : option (__Case_'a1 * __Case_'a) :=
      match mselect c with
      | Some (op, res) => Some ((proj op), (meta_proj res))
      | _ => None
      end in
    let inj (function_parameter : __Case_'a1 * __Case_'a)
      : packed_contents_and_result :=
      let '(op, res) := function_parameter in
      Contents_and_result (inj op) (meta_inj res) in
    let encoding :=
      Data_encoding.merge_objs encoding
        (Data_encoding.obj1
          (Data_encoding.req None None "metadata" meta_encoding)) in
    tagged_case (Data_encoding.Tag tag) name encoding proj inj in
  (let arg := Data_encoding.def "operation.alpha.operation_contents_and_result"
    in
  fun eta => arg None None eta)
    (Data_encoding.union None
      [
        make endorsement_case;
        make seed_nonce_revelation_case;
        make double_endorsement_evidence_case;
        make double_baking_evidence_case;
        make activate_account_case;
        make proposals_case;
        make ballot_case;
        make reveal_case;
        make transaction_case;
        make origination_case;
        make delegation_case
      ]).

Inductive contents_result_list : Set :=
| Single_result : contents_result -> contents_result_list
| Cons_result : contents_result -> contents_result_list -> contents_result_list.

Inductive packed_contents_result_list : Set :=
| Contents_result_list : contents_result_list -> packed_contents_result_list.

Definition contents_result_list_encoding
  : Data_encoding.encoding packed_contents_result_list :=
  let fix to_list (function_parameter : packed_contents_result_list)
    : list packed_contents_result :=
    match function_parameter with
    | Contents_result_list (Single_result o) => [ Contents_result o ]
    | Contents_result_list (Cons_result o os) =>
      cons (Contents_result o) (to_list (Contents_result_list os))
    end in
  let fix of_list (function_parameter : list packed_contents_result)
    : packed_contents_result_list :=
    match function_parameter with
    | [] => Pervasives.failwith "cannot decode empty operation result"
    | cons (Contents_result o) [] => Contents_result_list (Single_result o)
    | cons (Contents_result o) os =>
      let 'Contents_result_list os := of_list os in
      match (o, os) with
      | (Manager_operation_result _, Single_result (Manager_operation_result _))
        => Contents_result_list (Cons_result o os)
      | (Manager_operation_result _, Cons_result _ _) =>
        Contents_result_list (Cons_result o os)
      | _ => Pervasives.failwith "cannot decode ill-formed operation result"
      end
    end in
  (let arg := Data_encoding.def "operation.alpha.contents_list_result" in
  fun eta => arg None None eta)
    (Data_encoding.conv to_list of_list None
      (Data_encoding.__list_value None contents_result_encoding)).

Inductive contents_and_result_list : Set :=
| Single_and_result :
  Alpha_context.contents -> contents_result -> contents_and_result_list
| Cons_and_result :
  Alpha_context.contents -> contents_result -> contents_and_result_list ->
  contents_and_result_list.

Inductive packed_contents_and_result_list : Set :=
| Contents_and_result_list :
  contents_and_result_list -> packed_contents_and_result_list.

Definition contents_and_result_list_encoding
  : Data_encoding.encoding packed_contents_and_result_list :=
  let fix to_list (function_parameter : packed_contents_and_result_list)
    : list packed_contents_and_result :=
    match function_parameter with
    | Contents_and_result_list (Single_and_result op res) =>
      [ Contents_and_result op res ]
    | Contents_and_result_list (Cons_and_result op res rest) =>
      cons (Contents_and_result op res)
        (to_list (Contents_and_result_list rest))
    end in
  let fix of_list (function_parameter : list packed_contents_and_result)
    : packed_contents_and_result_list :=
    match function_parameter with
    | [] => Pervasives.failwith "cannot decode empty combined operation result"
    | cons (Contents_and_result op res) [] =>
      Contents_and_result_list (Single_and_result op res)
    | cons (Contents_and_result op res) rest =>
      let 'Contents_and_result_list rest := of_list rest in
      match (op, rest) with
      |
        (Alpha_context.Manager_operation _,
          Single_and_result (Alpha_context.Manager_operation _) _) =>
        Contents_and_result_list (Cons_and_result op res rest)
      | (Alpha_context.Manager_operation _, Cons_and_result _ _ _) =>
        Contents_and_result_list (Cons_and_result op res rest)
      | _ =>
        Pervasives.failwith "cannot decode ill-formed combined operation result"
      end
    end in
  Data_encoding.conv to_list of_list None
    (Data_encoding.__Variable.__list_value None contents_and_result_encoding).

Module operation_metadata.
  Record record : Set := Build {
    contents : contents_result_list }.
  Definition with_contents contents (r : record) :=
    Build contents.
End operation_metadata.
Definition operation_metadata := operation_metadata.record.

Inductive packed_operation_metadata : Set :=
| Operation_metadata : operation_metadata -> packed_operation_metadata
| No_operation_metadata : packed_operation_metadata.

Definition operation_metadata_encoding
  : Data_encoding.encoding packed_operation_metadata :=
  (let arg := Data_encoding.def "operation.alpha.result" in
  fun eta => arg None None eta)
    (Data_encoding.union None
      [
        Data_encoding.__case_value "Operation_metadata" None
          (Data_encoding.Tag 0) contents_result_list_encoding
          (fun function_parameter =>
            match function_parameter with
            |
              Operation_metadata {|
                operation_metadata.contents := contents
                  |} => Some (Contents_result_list contents)
            | _ => None
            end)
          (fun function_parameter =>
            let 'Contents_result_list contents := function_parameter in
            Operation_metadata
              {| operation_metadata.contents := contents |});
        Data_encoding.__case_value "No_operation_metadata" None
          (Data_encoding.Tag 1) Data_encoding.empty
          (fun function_parameter =>
            match function_parameter with
            | No_operation_metadata => Some tt
            | _ => None
            end)
          (fun function_parameter =>
            let '_ := function_parameter in
            No_operation_metadata)
      ]).

Definition kind_equal (op : Alpha_context.contents) (res : contents_result)
  : option eq :=
  match (op, res) with
  | (Alpha_context.Endorsement _, Endorsement_result _) => Some Eq
  | (Alpha_context.Endorsement _, _) => None
  | (Alpha_context.Seed_nonce_revelation _, Seed_nonce_revelation_result _) =>
    Some Eq
  | (Alpha_context.Seed_nonce_revelation _, _) => None
  |
    (Alpha_context.Double_endorsement_evidence _,
      Double_endorsement_evidence_result _) => Some Eq
  | (Alpha_context.Double_endorsement_evidence _, _) => None
  | (Alpha_context.Double_baking_evidence _, Double_baking_evidence_result _) =>
    Some Eq
  | (Alpha_context.Double_baking_evidence _, _) => None
  | (Alpha_context.Activate_account _, Activate_account_result _) => Some Eq
  | (Alpha_context.Activate_account _, _) => None
  | (Alpha_context.Proposals _, Proposals_result) => Some Eq
  | (Alpha_context.Proposals _, _) => None
  | (Alpha_context.Ballot _, Ballot_result) => Some Eq
  | (Alpha_context.Ballot _, _) => None
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation := Alpha_context.Reveal _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Applied (Reveal_result _)
          |}) => Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation := Alpha_context.Reveal _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Backtracked (Reveal_result _) _
          |}) => Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation := Alpha_context.Reveal _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Failed Alpha_context.Kind.Reveal_manager_kind _
          |}) => Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation := Alpha_context.Reveal _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Skipped Alpha_context.Kind.Reveal_manager_kind
          |}) => Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation := Alpha_context.Reveal _
        |}, _) => None
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Transaction _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Applied (Transaction_result _)
          |}) => Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Transaction _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Backtracked (Transaction_result _) _
          |}) => Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Transaction _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Failed Alpha_context.Kind.Transaction_manager_kind _
          |}) => Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Transaction _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Skipped Alpha_context.Kind.Transaction_manager_kind
          |}) => Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Transaction _
        |}, _) => None
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Origination _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Applied (Origination_result _)
          |}) => Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Origination _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Backtracked (Origination_result _) _
          |}) => Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Origination _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Failed Alpha_context.Kind.Origination_manager_kind _
          |}) => Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Origination _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Skipped Alpha_context.Kind.Origination_manager_kind
          |}) => Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Origination _
        |}, _) => None
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Delegation _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Applied (Delegation_result _)
          |}) => Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Delegation _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Backtracked (Delegation_result _) _
          |}) => Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Delegation _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Failed Alpha_context.Kind.Delegation_manager_kind _
          |}) => Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Delegation _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Skipped Alpha_context.Kind.Delegation_manager_kind
          |}) => Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Delegation _
        |}, _) => None
  end.

Fixpoint kind_equal_list
  (contents : Alpha_context.contents_list) (res : contents_result_list)
  : option eq :=
  match (contents, res) with
  | (Alpha_context.Single op, Single_result res) =>
    match kind_equal op res with
    | None => None
    | Some Eq => Some Eq
    end
  | (Alpha_context.Cons op ops, Cons_result res ress) =>
    match kind_equal op res with
    | None => None
    | Some Eq =>
      match kind_equal_list ops ress with
      | None => None
      | Some Eq => Some Eq
      end
    end
  | _ => None
  end.

Fixpoint pack_contents_list
  (contents : Alpha_context.contents_list) (res : contents_result_list)
  : contents_and_result_list :=
  match (contents, res) with
  | (Alpha_context.Single op, Single_result res) => Single_and_result op res
  | (Alpha_context.Cons op ops, Cons_result res ress) =>
    Cons_and_result op res (pack_contents_list ops ress)
  |
    (Alpha_context.Single (Alpha_context.Manager_operation _),
      Cons_result (Manager_operation_result _) (Single_result _)) =>
    (* ❌ Unreachable expressions are not supported *)
    unreachable
  |
    (Alpha_context.Cons _ _,
      Single_result
        (Manager_operation_result {|
          contents_result.Manager_operation_result.operation_result := Failed _ _
            |})) =>
    (* ❌ Unreachable expressions are not supported *)
    unreachable
  |
    (Alpha_context.Cons _ _,
      Single_result
        (Manager_operation_result {|
          contents_result.Manager_operation_result.operation_result := Skipped _
            |})) =>
    (* ❌ Unreachable expressions are not supported *)
    unreachable
  |
    (Alpha_context.Cons _ _,
      Single_result
        (Manager_operation_result {|
          contents_result.Manager_operation_result.operation_result := Applied _
            |})) =>
    (* ❌ Unreachable expressions are not supported *)
    unreachable
  |
    (Alpha_context.Cons _ _,
      Single_result
        (Manager_operation_result {|
          contents_result.Manager_operation_result.operation_result := Backtracked _ _
            |})) =>
    (* ❌ Unreachable expressions are not supported *)
    unreachable
  | (Alpha_context.Single _, Cons_result _ _) =>
    (* ❌ Unreachable expressions are not supported *)
    unreachable
  end.

Fixpoint unpack_contents_list (function_parameter : contents_and_result_list)
  : Alpha_context.contents_list * contents_result_list :=
  match function_parameter with
  | Single_and_result op res => ((Alpha_context.Single op), (Single_result res))
  | Cons_and_result op res rest =>
    let '(ops, ress) := unpack_contents_list rest in
    ((Alpha_context.Cons op ops), (Cons_result res ress))
  end.

Fixpoint to_list (function_parameter : packed_contents_result_list)
  : list packed_contents_result :=
  match function_parameter with
  | Contents_result_list (Single_result o) => [ Contents_result o ]
  | Contents_result_list (Cons_result o os) =>
    cons (Contents_result o) (to_list (Contents_result_list os))
  end.

Fixpoint of_list (function_parameter : list packed_contents_result)
  : packed_contents_result_list :=
  match function_parameter with
  | [] =>
    (* ❌ Assert instruction is not handled. *)
    assert packed_contents_result_list false
  | cons (Contents_result o) [] => Contents_result_list (Single_result o)
  | cons (Contents_result o) os =>
    let 'Contents_result_list os := of_list os in
    match (o, os) with
    | (Manager_operation_result _, Single_result (Manager_operation_result _))
      => Contents_result_list (Cons_result o os)
    | (Manager_operation_result _, Cons_result _ _) =>
      Contents_result_list (Cons_result o os)
    | _ =>
      Pervasives.failwith
        "Operation result list of length > 1 should only contains manager operations result."
    end
  end.

Definition operation_data_and_metadata_encoding
  : Data_encoding.encoding
    (Alpha_context.packed_protocol_data * packed_operation_metadata) :=
  (let arg := Data_encoding.def "operation.alpha.operation_with_metadata" in
  fun eta => arg None None eta)
    (Data_encoding.union None
      [
        Data_encoding.__case_value "Operation_with_metadata" None
          (Data_encoding.Tag 0)
          (Data_encoding.obj2
            (Data_encoding.req None None "contents"
              (Data_encoding.dynamic_size None
                contents_and_result_list_encoding))
            (Data_encoding.opt None None "signature" Signature.encoding))
          (fun function_parameter =>
            match function_parameter with
            | (Alpha_context.Operation_data _, No_operation_metadata) =>
              None
            | (Alpha_context.Operation_data op, Operation_metadata res)
              =>
              match
                kind_equal_list
                  op.(Alpha_context.protocol_data.contents)
                  res.(operation_metadata.contents) with
              | None =>
                Pervasives.failwith
                  "cannot decode inconsistent combined operation result"
              | Some Eq =>
                Some
                  ((Contents_and_result_list
                    (pack_contents_list
                      op.(Alpha_context.protocol_data.contents)
                      res.(operation_metadata.contents))),
                    op.(Alpha_context.protocol_data.signature))
              end
            end)
          (fun function_parameter =>
            let '(Contents_and_result_list contents, signature) :=
              function_parameter in
            let '(op_contents, res_contents) :=
              unpack_contents_list contents in
            ((Alpha_context.Operation_data
              {|
                Alpha_context.protocol_data.contents :=
                  op_contents;
                Alpha_context.protocol_data.signature :=
                  signature |}),
              (Operation_metadata
                {| operation_metadata.contents := res_contents
                  |})));
        Data_encoding.__case_value "Operation_without_metadata" None
          (Data_encoding.Tag 1)
          (Data_encoding.obj2
            (Data_encoding.req None None "contents"
              (Data_encoding.dynamic_size None
                Alpha_context.Operation.contents_list_encoding))
            (Data_encoding.opt None None "signature" Signature.encoding))
          (fun function_parameter =>
            match function_parameter with
            | (Alpha_context.Operation_data op, No_operation_metadata)
              =>
              Some
                ((Alpha_context.Contents_list
                  op.(Alpha_context.protocol_data.contents)),
                  op.(Alpha_context.protocol_data.signature))
            | (Alpha_context.Operation_data _, Operation_metadata _) =>
              None
            end)
          (fun function_parameter =>
            let '(Alpha_context.Contents_list contents, signature) :=
              function_parameter in
            ((Alpha_context.Operation_data
              {| Alpha_context.protocol_data.contents := contents;
                Alpha_context.protocol_data.signature :=
                  signature |}), No_operation_metadata))
      ]).

Module block_metadata.
  Record record : Set := Build {
    baker : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t);
    level : Alpha_context.Level.t;
    voting_period_kind : Alpha_context.Voting_period.kind;
    nonce_hash : option Nonce_hash.t;
    consumed_gas : Z.t;
    deactivated : list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t);
    balance_updates : Alpha_context.Delegate.balance_updates }.
  Definition with_baker baker (r : record) :=
    Build baker r.(level) r.(voting_period_kind) r.(nonce_hash) r.(consumed_gas)
      r.(deactivated) r.(balance_updates).
  Definition with_level level (r : record) :=
    Build r.(baker) level r.(voting_period_kind) r.(nonce_hash) r.(consumed_gas)
      r.(deactivated) r.(balance_updates).
  Definition with_voting_period_kind voting_period_kind (r : record) :=
    Build r.(baker) r.(level) voting_period_kind r.(nonce_hash) r.(consumed_gas)
      r.(deactivated) r.(balance_updates).
  Definition with_nonce_hash nonce_hash (r : record) :=
    Build r.(baker) r.(level) r.(voting_period_kind) nonce_hash r.(consumed_gas)
      r.(deactivated) r.(balance_updates).
  Definition with_consumed_gas consumed_gas (r : record) :=
    Build r.(baker) r.(level) r.(voting_period_kind) r.(nonce_hash) consumed_gas
      r.(deactivated) r.(balance_updates).
  Definition with_deactivated deactivated (r : record) :=
    Build r.(baker) r.(level) r.(voting_period_kind) r.(nonce_hash)
      r.(consumed_gas) deactivated r.(balance_updates).
  Definition with_balance_updates balance_updates (r : record) :=
    Build r.(baker) r.(level) r.(voting_period_kind) r.(nonce_hash)
      r.(consumed_gas) r.(deactivated) balance_updates.
End block_metadata.
Definition block_metadata := block_metadata.record.

Definition block_metadata_encoding : Data_encoding.encoding block_metadata :=
  (let arg := Data_encoding.def "block_header.alpha.metadata" in
  fun eta => arg None None eta)
    (Data_encoding.conv
      (fun function_parameter =>
        let '{|
          block_metadata.baker := baker;
            block_metadata.level := level;
            block_metadata.voting_period_kind := voting_period_kind;
            block_metadata.nonce_hash := nonce_hash;
            block_metadata.consumed_gas := consumed_gas;
            block_metadata.deactivated := deactivated;
            block_metadata.balance_updates := balance_updates
            |} := function_parameter in
        (baker, level, voting_period_kind, nonce_hash, consumed_gas,
          deactivated, balance_updates))
      (fun function_parameter =>
        let
          '(baker, level, voting_period_kind, nonce_hash, consumed_gas,
            deactivated, balance_updates) := function_parameter in
        {| block_metadata.baker := baker; block_metadata.level := level;
          block_metadata.voting_period_kind := voting_period_kind;
          block_metadata.nonce_hash := nonce_hash;
          block_metadata.consumed_gas := consumed_gas;
          block_metadata.deactivated := deactivated;
          block_metadata.balance_updates := balance_updates |}) None
      (Data_encoding.obj7
        (Data_encoding.req None None "baker"
          (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
        (Data_encoding.req None None "level" Alpha_context.Level.encoding)
        (Data_encoding.req None None "voting_period_kind"
          Alpha_context.Voting_period.kind_encoding)
        (Data_encoding.req None None "nonce_hash"
          (Data_encoding.__option_value Nonce_hash.encoding))
        (Data_encoding.req None None "consumed_gas"
          (Data_encoding.check_size 10 Data_encoding.n))
        (Data_encoding.req None None "deactivated"
          (Data_encoding.__list_value None
            (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding)))
        (Data_encoding.req None None "balance_updates"
          Alpha_context.Delegate.balance_updates_encoding))).
