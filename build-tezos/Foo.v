(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Unset Positivity Checking.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Contract_repr.
Require Tezos.Cycle_repr.
Require Tezos.Gas_limit_repr.
Require Tezos.Raw_context.
Require Tezos.Roll_repr.
Require Tezos.Script_repr.
Require Tezos.Storage_description.
Require Tezos.Storage_functors.
Require Tezos.Storage_sigs.
Require Tezos.Tez_repr.

Import Storage_functors.

Definition depends_on_sigs (function_parameter : unit) : unit := axiom.

Definition Int :=
  let t := Z in
  let encoding := Data_encoding.uint16 in
  existT (A := unit) (fun _ => _) tt
    {|
      Storage_sigs.VALUE.encoding := encoding
    |}.

Definition Int32 :=
  let t := Int32.t in
  let encoding := Data_encoding.__int32_value in
  existT (A := unit) (fun _ => _) tt
    {|
      Storage_sigs.VALUE.encoding := encoding
    |}.

Definition Z_value :=
  let t := Z.t in
  let encoding := Data_encoding.z in
  existT (A := unit) (fun _ => _) tt
    {|
      Storage_sigs.VALUE.encoding := encoding
    |}.

Definition Int_index :=
  let t := Z in
  let path_length := 1 in
  let to_path (c : Z) (l : list string) : list string :=
    cons (Pervasives.string_of_int c) l in
  let of_path (function_parameter : list string) : option Z :=
    match function_parameter with
    | [] | cons _ (cons _ _) => None
    | cons c [] => Pervasives.int_of_string_opt c
    end in
  let ipath (a : Set) := a * t in
  let args {A : Set} (function_parameter : unit)
    : Storage_description.args A (|Compare.Int|).(Compare.S.t)
      (A * (|Compare.Int|).(Compare.S.t)) :=
    let '_ := function_parameter in
    Storage_description.One
      {| Storage_description.args.One.rpc_arg := RPC_arg.int;
        Storage_description.args.One.encoding := Data_encoding.int31;
        Storage_description.args.One.compare :=
          (|Compare.Int|).(Compare.S.compare) |} in
  existT (A := unit) (fun _ => _) tt
    {|
      Storage_functors.INDEX.path_length := path_length;
      Storage_functors.INDEX.to_path := to_path;
      Storage_functors.INDEX.of_path := of_path;
      Storage_functors.INDEX.args {_} := args
    |}.

Definition Make_index :=
  fun (H : {t : _ & Storage_description.INDEX.signature t}) =>
    ((let t := (|H|).(Storage_description.INDEX.t) in
    let path_length := (|H|).(Storage_description.INDEX.path_length) in
    let to_path := (|H|).(Storage_description.INDEX.to_path) in
    let of_path := (|H|).(Storage_description.INDEX.of_path) in
    let rpc_arg := (|H|).(Storage_description.INDEX.rpc_arg) in
    let encoding := (|H|).(Storage_description.INDEX.encoding) in
    let compare := (|H|).(Storage_description.INDEX.compare) in
    let ipath (a : Set) := a * t in
    let args {A : Set} (function_parameter : unit)
      : Storage_description.args A t (A * t) :=
      let '_ := function_parameter in
      Storage_description.One
        {| Storage_description.args.One.rpc_arg := rpc_arg;
          Storage_description.args.One.encoding := encoding;
          Storage_description.args.One.compare := compare |} in
    existT (A := unit) (fun _ => _) tt
      {|
        Storage_functors.INDEX.path_length := path_length;
        Storage_functors.INDEX.to_path := to_path;
        Storage_functors.INDEX.of_path := of_path;
        Storage_functors.INDEX.args {_} := args
      |}) :
      {_ : unit &
        INDEX.signature (|H|).(Storage_description.INDEX.t)
          (fun (a : Set) => a * (|H|).(Storage_description.INDEX.t))}).

Definition Block_priority :=
  (((Storage_functors.Make_single_data_storage
    (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
    (existT (A := Set) _ _
      {|
        Raw_context.T.mem := Raw_context.mem;
        Raw_context.T.dir_mem := Raw_context.dir_mem;
        Raw_context.T.get := Raw_context.get;
        Raw_context.T.get_option := Raw_context.get_option;
        Raw_context.T.init := Raw_context.init;
        Raw_context.T.set := Raw_context.set;
        Raw_context.T.init_set := Raw_context.init_set;
        Raw_context.T.set_option := Raw_context.set_option;
        Raw_context.T.delete := Raw_context.delete;
        Raw_context.T.remove := Raw_context.remove;
        Raw_context.T.remove_rec := Raw_context.remove_rec;
        Raw_context.T.copy := Raw_context.copy;
        Raw_context.T.fold {_} := Raw_context.fold;
        Raw_context.T.keys := Raw_context.keys;
        Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
        Raw_context.T.project := Raw_context.project;
        Raw_context.T.absolute_key := Raw_context.absolute_key;
        Raw_context.T.consume_gas := Raw_context.consume_gas;
        Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
        Raw_context.T.description := Raw_context.description
      |}))
    (let name := [ "block_priority" ] in
    existT (A := unit) (fun _ => _) tt
      {|
        Storage_sigs.NAME.name := name
      |})) (existT (A := Set) _ _ (|Int|)).

Module Contract.
  Definition Raw_context :=
    ((Storage_functors.Make_subcontext
      (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _
        {|
          Raw_context.T.mem := Raw_context.mem;
          Raw_context.T.dir_mem := Raw_context.dir_mem;
          Raw_context.T.get := Raw_context.get;
          Raw_context.T.get_option := Raw_context.get_option;
          Raw_context.T.init := Raw_context.init;
          Raw_context.T.set := Raw_context.set;
          Raw_context.T.init_set := Raw_context.init_set;
          Raw_context.T.set_option := Raw_context.set_option;
          Raw_context.T.delete := Raw_context.delete;
          Raw_context.T.remove := Raw_context.remove;
          Raw_context.T.remove_rec := Raw_context.remove_rec;
          Raw_context.T.copy := Raw_context.copy;
          Raw_context.T.fold {_} := Raw_context.fold;
          Raw_context.T.keys := Raw_context.keys;
          Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
          Raw_context.T.project := Raw_context.project;
          Raw_context.T.absolute_key := Raw_context.absolute_key;
          Raw_context.T.consume_gas := Raw_context.consume_gas;
          Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
          Raw_context.T.description := Raw_context.description
        |}))
      (let name := [ "contracts" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}).
  
  Definition Global_counter :=
    (((Storage_functors.Make_single_data_storage
      (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _ (|Raw_context|)))
      (let name := [ "global_counter" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |})) (existT (A := Set) _ _ (|Z_value|)).
  
  Definition Indexed_context :=
    (Storage_functors.Make_indexed_subcontext
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _ (|Raw_context|)))
          (let name := [ "index" ] in
          existT (A := unit) (fun _ => _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index (existT (A := Set) _ _ (|Contract_repr.Index|)) in
      existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)).
  
  Definition fold {A : Set}
    : (|Indexed_context|).(Storage_sigs.Indexed_raw_context.context) -> A ->
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.key) -> A -> Lwt.t A)
    -> Lwt.t A :=
    (|Indexed_context|).(Storage_sigs.Indexed_raw_context.fold_keys).
  
  Definition __list_value
    : (|Indexed_context|).(Storage_sigs.Indexed_raw_context.context) ->
    Lwt.t (list (|Indexed_context|).(Storage_sigs.Indexed_raw_context.key)) :=
    (|Indexed_context|).(Storage_sigs.Indexed_raw_context.keys).
  
  Definition Balance :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "balance" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Tez_repr.encoding
        |}).
  
  Definition Frozen_balance_index :=
    (Storage_functors.Make_indexed_subcontext
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _
            (|Indexed_context|).(Storage_sigs.Indexed_raw_context.Raw_context)))
          (let name := [ "frozen_balance" ] in
          existT (A := unit) (fun _ => _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index (existT (A := Set) _ _ (|Cycle_repr.Index|)) in
      existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)).
  
  Definition Frozen_deposits :=
    ((|Frozen_balance_index|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "deposits" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Tez_repr.encoding
        |}).
  
  Definition Frozen_fees :=
    ((|Frozen_balance_index|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "fees" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Tez_repr.encoding
        |}).
  
  Definition Frozen_rewards :=
    ((|Frozen_balance_index|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "rewards" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Tez_repr.encoding
        |}).
  
  Definition Manager :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "manager" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (let t := (|Manager_repr|).(Storage_sigs.VALUE.t) in
      let encoding := (|Manager_repr|).(Storage_sigs.VALUE.encoding) in
      existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
        |}).
  
  Definition Delegate :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "delegate" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding :=
            (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding)
        |}).
  
  Definition Inactive_delegate :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_set)
      (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
      (let name := [ "inactive_delegate" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}).
  
  Definition Delegate_desactivation :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "delegate_desactivation" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Cycle_repr.encoding
        |}).
  
  Definition Delegated :=
    (Storage_functors.Make_data_set_storage
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _
            (|Indexed_context|).(Storage_sigs.Indexed_raw_context.Raw_context)))
          (let name := [ "delegated" ] in
          existT (A := unit) (fun _ => _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index (existT (A := Set) _ _ (|Contract_repr.Index|)) in
      existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)).
  
  Definition Counter :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "counter" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |})) (existT (A := Set) _ _ (|Z_value|)).
  
  Definition Make_carbonated_map_expr :=
    fun (N : {_ : unit & Storage_sigs.NAME.signature}) =>
      ((let I :=
        ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_carbonated_map)
          (existT (A := unit) (fun _ => _) tt (|N|)))
          (let t := Script_repr.lazy_expr in
          let encoding := Script_repr.lazy_expr_encoding in
          existT (A := Set) _ _
            {|
              Storage_sigs.VALUE.encoding := encoding
            |}) in
      let tag_Non_iterable_indexed_carbonated_data_storage := tt in
      let context :=
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context)
        in
      let key :=
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key) in
      let value :=
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value)
        in
      let mem :=
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.mem) in
      let delete :=
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.delete)
        in
      let remove :=
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.remove)
        in
      let consume_deserialize_gas
        (ctxt : (|Raw_context|).(Raw_context.T.context))
        (value : Script_repr.lazy_expr)
        : Lwt.t (Error_monad.tzresult (|Raw_context|).(Raw_context.T.context)) :=
        Pervasives.op_atat Lwt.__return
          (Error_monad.op_gtgtquestion
            ((|Raw_context|).(Raw_context.T.check_enough_gas) ctxt
              (Script_repr.minimal_deserialize_cost value))
            (fun function_parameter =>
              let '_ := function_parameter in
              Error_monad.op_gtgtquestion (Script_repr.force_decode value)
                (fun function_parameter =>
                  let '(_value, value_cost) := function_parameter in
                  (|Raw_context|).(Raw_context.T.consume_gas) ctxt value_cost)))
        in
      let consume_serialize_gas
        (ctxt : (|Raw_context|).(Raw_context.T.context))
        (value : Script_repr.lazy_expr)
        : Lwt.t (Error_monad.tzresult (|Raw_context|).(Raw_context.T.context)) :=
        Pervasives.op_atat Lwt.__return
          (Error_monad.op_gtgtquestion (Script_repr.force_bytes value)
            (fun function_parameter =>
              let '(_value, value_cost) := function_parameter in
              (|Raw_context|).(Raw_context.T.consume_gas) ctxt value_cost)) in
      let get
        (ctxt :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context))
        (contract :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
        : Lwt.t
          (Error_monad.tzresult
            ((|Raw_context|).(Raw_context.T.context) *
              (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value))) :=
        Error_monad.op_gtgteqquestion
          ((|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get)
            ctxt contract)
          (fun function_parameter =>
            let '(ctxt, value) := function_parameter in
            Error_monad.op_gtgtpipequestion (consume_deserialize_gas ctxt value)
              (fun ctxt => (ctxt, value))) in
      let get_option
        (ctxt :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context))
        (contract :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
        : Lwt.t
          (Error_monad.tzresult
            (Raw_context.t *
              option
                (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value))) :=
        Error_monad.op_gtgteqquestion
          ((|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get_option)
            ctxt contract)
          (fun function_parameter =>
            let '(ctxt, value_opt) := function_parameter in
            match value_opt with
            | None => Error_monad.__return (ctxt, None)
            | Some value =>
              Error_monad.op_gtgtpipequestion
                (consume_deserialize_gas ctxt value)
                (fun ctxt => (ctxt, value_opt))
            end) in
      let set
        (ctxt : (|Raw_context|).(Raw_context.T.context))
        (contract :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
        (value : Script_repr.lazy_expr)
        : Lwt.t (Error_monad.tzresult (Raw_context.t * Z)) :=
        Error_monad.op_gtgteqquestion (consume_serialize_gas ctxt value)
          (fun ctxt =>
            (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set)
              ctxt contract value) in
      let set_option
        (ctxt :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context))
        (contract :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
        (value_opt :
          option
            (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value))
        : Lwt.t (Error_monad.tzresult (Raw_context.t * Z * bool)) :=
        match value_opt with
        | None =>
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set_option)
            ctxt contract None
        | Some value =>
          Error_monad.op_gtgteqquestion (consume_serialize_gas ctxt value)
            (fun ctxt =>
              (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set_option)
                ctxt contract value_opt)
        end in
      let init
        (ctxt : (|Raw_context|).(Raw_context.T.context))
        (contract :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
        (value : Script_repr.lazy_expr)
        : Lwt.t (Error_monad.tzresult (Raw_context.t * Z)) :=
        Error_monad.op_gtgteqquestion (consume_serialize_gas ctxt value)
          (fun ctxt =>
            (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init)
              ctxt contract value) in
      let init_set
        (ctxt : (|Raw_context|).(Raw_context.T.context))
        (contract :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
        (value : Script_repr.lazy_expr)
        : Lwt.t (Error_monad.tzresult (Raw_context.t * Z * bool)) :=
        Error_monad.op_gtgteqquestion (consume_serialize_gas ctxt value)
          (fun ctxt =>
            (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init_set)
              ctxt contract value) in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.tag_Non_iterable_indexed_carbonated_data_storage :=
            tag_Non_iterable_indexed_carbonated_data_storage;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.mem := mem;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get := get;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get_option :=
            get_option;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set := set;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init := init;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init_set :=
            init_set;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set_option :=
            set_option;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.delete :=
            delete;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.remove :=
            remove
        |}) :
        {_ : unit &
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.signature
            (|Raw_context|).(Raw_context.T.t) Contract_repr.t
            Script_repr.lazy_expr}).
  
  Definition Code :=
    Make_carbonated_map_expr
      (let name := [ "code" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}).
  
  Definition Storage :=
    Make_carbonated_map_expr
      (let name := [ "storage" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}).
  
  Definition Paid_storage_space :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "paid_bytes" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |})) (existT (A := Set) _ _ (|Z_value|)).
  
  Definition Used_storage_space :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "used_bytes" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |})) (existT (A := Set) _ _ (|Z_value|)).
  
  Definition Roll_list :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "roll_list" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Roll_repr.encoding
        |}).
  
  Definition Change :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "change" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Tez_repr.encoding
        |}).
End Contract.

Module Big_map.
  Definition Raw_context :=
    ((Storage_functors.Make_subcontext
      (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _
        {|
          Raw_context.T.mem := Raw_context.mem;
          Raw_context.T.dir_mem := Raw_context.dir_mem;
          Raw_context.T.get := Raw_context.get;
          Raw_context.T.get_option := Raw_context.get_option;
          Raw_context.T.init := Raw_context.init;
          Raw_context.T.set := Raw_context.set;
          Raw_context.T.init_set := Raw_context.init_set;
          Raw_context.T.set_option := Raw_context.set_option;
          Raw_context.T.delete := Raw_context.delete;
          Raw_context.T.remove := Raw_context.remove;
          Raw_context.T.remove_rec := Raw_context.remove_rec;
          Raw_context.T.copy := Raw_context.copy;
          Raw_context.T.fold {_} := Raw_context.fold;
          Raw_context.T.keys := Raw_context.keys;
          Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
          Raw_context.T.project := Raw_context.project;
          Raw_context.T.absolute_key := Raw_context.absolute_key;
          Raw_context.T.consume_gas := Raw_context.consume_gas;
          Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
          Raw_context.T.description := Raw_context.description
        |}))
      (let name := [ "big_maps" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}).
  
  Module Next.
    Definition Single_data_storage :=
      (((Storage_functors.Make_single_data_storage
        (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
        (existT (A := Set) _ _ (|Raw_context|)))
        (let name := [ "next" ] in
        existT (A := unit) (fun _ => _) tt
          {|
            Storage_sigs.NAME.name := name
          |})) (existT (A := Set) _ _ (|Z_value|)).
    
    Definition tag_Single_data_storage :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.tag_Single_data_storage).
    
    Definition t := (|Single_data_storage|).(Storage_sigs.Single_data_storage.t).
    
    Definition context :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.context).
    
    Definition value :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.value).
    
    Definition mem :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.mem).
    
    Definition get :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.get).
    
    Definition get_option :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.get_option).
    
    Definition init :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.init).
    
    Definition set :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.set).
    
    Definition init_set :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.init_set).
    
    Definition set_option :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.set_option).
    
    Definition delete :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.delete).
    
    Definition remove :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.remove).
    
    Definition incr (ctxt : context)
      : Lwt.t (Error_monad.tzresult (Raw_context.t * value)) :=
      Error_monad.op_gtgteqquestion (get ctxt)
        (fun i =>
          Error_monad.op_gtgteqquestion (set ctxt (Z.succ i))
            (fun ctxt => Error_monad.__return (ctxt, i))).
    
    Definition init (ctxt : context)
      : Lwt.t (Error_monad.tzresult Raw_context.t) := init ctxt Z.zero.
  End Next.
  
  Definition Index :=
    let t := Z.t in
    let rpc_arg :=
      let construct := Z.to_string in
      let destruct (__hash_value : string) : Pervasives.result Z.t string :=
        let 'id := Z.of_string __hash_value in
        Pervasives.Ok id in
      RPC_arg.make (Some "A big map identifier") "big_map_id" destruct construct
        tt in
    let encoding :=
      Data_encoding.def "big_map_id" (Some "Big map identifier")
        (Some "A big map identifier") (|Z_value|).(Storage_sigs.VALUE.encoding)
      in
    let compare := (|Compare.Z|).(Compare.S.compare) in
    let path_length := 7 in
    let to_path (c : Z.t) (l : list string) : list string :=
      let raw_key := Data_encoding.Binary.to_bytes_exn encoding c in
      let 'MBytes.Hex index_key := MBytes.to_hex (Raw_hashes.blake2b raw_key) in
      cons (String.sub index_key 0 2)
        (cons (String.sub index_key 2 2)
          (cons (String.sub index_key 4 2)
            (cons (String.sub index_key 6 2)
              (cons (String.sub index_key 8 2)
                (cons (String.sub index_key 10 2) (cons (Z.to_string c) l))))))
      in
    let of_path (function_parameter : list (|Compare.String|).(Compare.S.t))
      : option Z.t :=
      match function_parameter with
      |
        [] | cons _ [] | cons _ (cons _ []) | cons _ (cons _ (cons _ [])) |
        cons _ (cons _ (cons _ (cons _ []))) |
        cons _ (cons _ (cons _ (cons _ (cons _ [])))) |
        cons _ (cons _ (cons _ (cons _ (cons _ (cons _ []))))) |
        cons _ (cons _ (cons _ (cons _ (cons _ (cons _ (cons _ (cons _ _)))))))
        => None
      |
        cons index1
          (cons index2
            (cons index3 (cons index4 (cons index5 (cons index6 (cons key []))))))
        =>
        let c := Z.of_string key in
        let raw_key := Data_encoding.Binary.to_bytes_exn encoding c in
        let 'MBytes.Hex index_key := MBytes.to_hex (Raw_hashes.blake2b raw_key)
          in
        (* ❌ Sequences of instructions are ignored (operator ";") *)
        (* ❌ instruction_sequence ";" *)
        (* ❌ Sequences of instructions are ignored (operator ";") *)
        (* ❌ instruction_sequence ";" *)
        (* ❌ Sequences of instructions are ignored (operator ";") *)
        (* ❌ instruction_sequence ";" *)
        (* ❌ Sequences of instructions are ignored (operator ";") *)
        (* ❌ instruction_sequence ";" *)
        (* ❌ Sequences of instructions are ignored (operator ";") *)
        (* ❌ instruction_sequence ";" *)
        (* ❌ Sequences of instructions are ignored (operator ";") *)
        (* ❌ instruction_sequence ";" *)
        Some c
      end in
    existT (A := unit) (fun _ => _) tt
      {|
        Storage_description.INDEX.rpc_arg := rpc_arg;
        Storage_description.INDEX.encoding := encoding;
        Storage_description.INDEX.compare := compare;
        Storage_description.INDEX.path_length := path_length;
        Storage_description.INDEX.to_path := to_path;
        Storage_description.INDEX.of_path := of_path
      |}.
End Big_map.
