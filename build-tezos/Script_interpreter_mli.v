(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Unset Positivity Checking.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Script_ir_translator_mli. Module Script_ir_translator := Script_ir_translator_mli.
Require Tezos.Script_typed_ir.

Import Alpha_context.

Definition execution_trace : Set :=
  list
    (Alpha_context.Script.location * Alpha_context.Gas.t *
      list (Alpha_context.Script.expr * option string)).

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

Module execution_result.
  Record record : Set := Build {
    ctxt : Alpha_context.context;
    storage : Alpha_context.Script.expr;
    big_map_diff : option Alpha_context.Contract.big_map_diff;
    operations : list Alpha_context.packed_internal_operation }.
  Definition with_ctxt ctxt (r : record) :=
    Build ctxt r.(storage) r.(big_map_diff) r.(operations).
  Definition with_storage storage (r : record) :=
    Build r.(ctxt) storage r.(big_map_diff) r.(operations).
  Definition with_big_map_diff big_map_diff (r : record) :=
    Build r.(ctxt) r.(storage) big_map_diff r.(operations).
  Definition with_operations operations (r : record) :=
    Build r.(ctxt) r.(storage) r.(big_map_diff) operations.
End execution_result.
Definition execution_result := execution_result.record.

Module step_constants.
  Record record : Set := Build {
    source : Alpha_context.Contract.t;
    payer : Alpha_context.Contract.t;
    self : Alpha_context.Contract.t;
    amount : Alpha_context.Tez.t;
    chain_id : (|Chain_id|).(S.HASH.t) }.
  Definition with_source source (r : record) :=
    Build source r.(payer) r.(self) r.(amount) r.(chain_id).
  Definition with_payer payer (r : record) :=
    Build r.(source) payer r.(self) r.(amount) r.(chain_id).
  Definition with_self self (r : record) :=
    Build r.(source) r.(payer) self r.(amount) r.(chain_id).
  Definition with_amount amount (r : record) :=
    Build r.(source) r.(payer) r.(self) amount r.(chain_id).
  Definition with_chain_id chain_id (r : record) :=
    Build r.(source) r.(payer) r.(self) r.(amount) chain_id.
End step_constants.
Definition step_constants := step_constants.record.

Reserved Notation "'stack".

Inductive stack_gadt : Set :=
| Item : forall {ty : Set}, ty -> stack_gadt -> stack_gadt
| Empty : stack_gadt

where "'stack" := (fun (_ : Set) => stack_gadt).

Definition stack := 'stack.

Parameter step : forall {aft bef : Set},
  option (Pervasives.ref execution_trace) -> Alpha_context.context ->
  step_constants -> Script_typed_ir.descr bef aft -> stack bef ->
  Lwt.t (Error_monad.tzresult (stack aft * Alpha_context.context)).

Parameter execute_wrapper :
  Alpha_context.t -> Script_ir_translator.unparsing_mode -> step_constants ->
  Alpha_context.Script.t -> string -> Alpha_context.Script.expr ->
  Lwt.t (Error_monad.tzresult execution_result).

Parameter trace :
  Alpha_context.t -> Script_ir_translator.unparsing_mode -> step_constants ->
  Alpha_context.Script.t -> string -> Alpha_context.Script.expr ->
  Lwt.t (Error_monad.tzresult (execution_result * execution_trace)).
