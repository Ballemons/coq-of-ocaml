(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Module Pervasives.
  Parameter raise : forall {a : Set}, extensible_type -> a.
  
  Parameter raise_notrace : forall {a : Set}, extensible_type -> a.
  
  Parameter invalid_arg : forall {a : Set}, string -> a.
  
  Parameter failwith : forall {a : Set}, string -> a.
  
  (* exception Exit *)
  
  Parameter not : bool -> bool.
  
  Parameter op_andand : bool -> bool -> bool.
  
  Parameter op_pipepipe : bool -> bool -> bool.
  
  Parameter __LOC__ : string.
  
  Parameter __FILE__ : string.
  
  Parameter __LINE__ : int.
  
  Parameter __MODULE__ : string.
  
  Parameter __POS__ : string * int * int * int.
  
  Parameter __LOC_OF__ : forall {a : Set}, a -> string * a.
  
  Parameter __LINE_OF__ : forall {a : Set}, a -> int * a.
  
  Parameter __POS_OF__ : forall {a : Set}, a -> (string * int * int * int) * a.
  
  Parameter op_pipegt : forall {a b : Set}, a -> (a -> b) -> b.
  
  Parameter op_atat : forall {a b : Set}, (a -> b) -> a -> b.
  
  Parameter op_tildeminus : int -> int.
  
  Parameter op_tildeplus : int -> int.
  
  Parameter succ : int -> int.
  
  Parameter pred : int -> int.
  
  Parameter op_plus : int -> int -> int.
  
  Parameter op_minus : int -> int -> int.
  
  Parameter op_star : int -> int -> int.
  
  Parameter op_div : int -> int -> int.
  
  Parameter __mod : int -> int -> int.
  
  Parameter abs : int -> int.
  
  Parameter max_int : int.
  
  Parameter min_int : int.
  
  Parameter land : int -> int -> int.
  
  Parameter lor : int -> int -> int.
  
  Parameter lxor : int -> int -> int.
  
  Parameter lnot : int -> int.
  
  Parameter lsl : int -> int -> int.
  
  Parameter lsr : int -> int -> int.
  
  Parameter asr : int -> int -> int.
  
  Parameter op_caret : string -> string -> string.
  
  Parameter int_of_char : ascii -> int.
  
  Parameter char_of_int : int -> ascii.
  
  Parameter ignore : forall {a : Set}, a -> unit.
  
  Parameter string_of_bool : bool -> string.
  
  Parameter bool_of_string_opt : string -> option bool.
  
  Parameter string_of_int : int -> string.
  
  Parameter int_of_string_opt : string -> option int.
  
  Parameter fst : forall {a b : Set}, a * b -> a.
  
  Parameter snd : forall {a b : Set}, a * b -> b.
  
  Parameter op_at : forall {a : Set}, list a -> list a -> list a.
  
  Module ref.
    Record record {a : Set} : Set := Build {
      contents : a }.
    Arguments record : clear implicits.
    Definition with_contents {t_a} contents (r : record t_a) :=
      Build t_a contents.
  End ref.
  Definition ref := ref.record.
  
  Parameter __ref_value : forall {a : Set}, a -> ref a.
  
  Parameter op_exclamation : forall {a : Set}, ref a -> a.
  
  Parameter op_coloneq : forall {a : Set}, ref a -> a -> unit.
  
  Parameter incr : ref int -> unit.
  
  Parameter decr : ref int -> unit.
  
  Inductive result (a b : Set) : Set :=
  | Ok : a -> result a b
  | Error : b -> result a b.
  
  Arguments Ok {_ _}.
  Arguments Error {_ _}.
  
  Definition format6 (a b c d e f : Set) : Set :=
    CamlinternalFormatBasics.format6 a b c d e f.
  
  Definition format4 (a b c d : Set) : Set := format6 a b c c c d.
  
  Definition format (a b c : Set) : Set := format4 a b c c.
  
  Parameter string_of_format : forall {a b c d e f : Set},
    format6 a b c d e f -> string.
  
  Parameter format_of_string : forall {a b c d e f : Set},
    format6 a b c d e f -> format6 a b c d e f.
  
  Parameter op_caretcaret : forall {a b c d e f g h : Set},
    format6 a b c d e f -> format6 f b c e g h -> format6 a b c d g h.
End Pervasives.

Import Pervasives.

Module Type List_type.
  Parameter length : forall {a : Set}, list a -> int.
  
  Parameter compare_lengths : forall {a b : Set}, list a -> list b -> int.
  
  Parameter compare_length_with : forall {a : Set}, list a -> int -> int.
  
  Parameter __cons_value : forall {a : Set}, a -> list a -> list a.
  
  Parameter hd : forall {a : Set}, list a -> a.
  
  Parameter tl : forall {a : Set}, list a -> list a.
  
  Parameter nth_opt : forall {a : Set}, list a -> int -> option a.
  
  Parameter rev : forall {a : Set}, list a -> list a.
  
  Parameter init : forall {a : Set}, int -> (int -> a) -> list a.
  
  Parameter append : forall {a : Set}, list a -> list a -> list a.
  
  Parameter rev_append : forall {a : Set}, list a -> list a -> list a.
  
  Parameter concat : forall {a : Set}, list (list a) -> list a.
  
  Parameter flatten : forall {a : Set}, list (list a) -> list a.
  
  Parameter iter : forall {a : Set}, (a -> unit) -> list a -> unit.
  
  Parameter iteri : forall {a : Set}, (int -> a -> unit) -> list a -> unit.
  
  Parameter map : forall {a b : Set}, (a -> b) -> list a -> list b.
  
  Parameter mapi : forall {a b : Set}, (int -> a -> b) -> list a -> list b.
  
  Parameter rev_map : forall {a b : Set}, (a -> b) -> list a -> list b.
  
  Parameter fold_left : forall {a b : Set}, (a -> b -> a) -> a -> list b -> a.
  
  Parameter fold_right : forall {a b : Set}, (a -> b -> b) -> list a -> b -> b.
  
  Parameter iter2 : forall {a b : Set},
    (a -> b -> unit) -> list a -> list b -> unit.
  
  Parameter map2 : forall {a b c : Set},
    (a -> b -> c) -> list a -> list b -> list c.
  
  Parameter rev_map2 : forall {a b c : Set},
    (a -> b -> c) -> list a -> list b -> list c.
  
  Parameter fold_left2 : forall {a b c : Set},
    (a -> b -> c -> a) -> a -> list b -> list c -> a.
  
  Parameter fold_right2 : forall {a b c : Set},
    (a -> b -> c -> c) -> list a -> list b -> c -> c.
  
  Parameter for_all : forall {a : Set}, (a -> bool) -> list a -> bool.
  
  Parameter __exists : forall {a : Set}, (a -> bool) -> list a -> bool.
  
  Parameter for_all2 : forall {a b : Set},
    (a -> b -> bool) -> list a -> list b -> bool.
  
  Parameter __exists2 : forall {a b : Set},
    (a -> b -> bool) -> list a -> list b -> bool.
  
  Parameter mem : forall {a : Set}, a -> list a -> bool.
  
  Parameter memq : forall {a : Set}, a -> list a -> bool.
  
  Parameter find_opt : forall {a : Set}, (a -> bool) -> list a -> option a.
  
  Parameter filter : forall {a : Set}, (a -> bool) -> list a -> list a.
  
  Parameter find_all : forall {a : Set}, (a -> bool) -> list a -> list a.
  
  Parameter partition : forall {a : Set},
    (a -> bool) -> list a -> list a * list a.
  
  Parameter assoc_opt : forall {a b : Set}, a -> list (a * b) -> option b.
  
  Parameter assq_opt : forall {a b : Set}, a -> list (a * b) -> option b.
  
  Parameter mem_assoc : forall {a b : Set}, a -> list (a * b) -> bool.
  
  Parameter mem_assq : forall {a b : Set}, a -> list (a * b) -> bool.
  
  Parameter remove_assoc : forall {a b : Set},
    a -> list (a * b) -> list (a * b).
  
  Parameter remove_assq : forall {a b : Set}, a -> list (a * b) -> list (a * b).
  
  Parameter split : forall {a b : Set}, list (a * b) -> list a * list b.
  
  Parameter combine : forall {a b : Set}, list a -> list b -> list (a * b).
  
  Parameter sort : forall {a : Set}, (a -> a -> int) -> list a -> list a.
  
  Parameter stable_sort : forall {a : Set}, (a -> a -> int) -> list a -> list a.
  
  Parameter fast_sort : forall {a : Set}, (a -> a -> int) -> list a -> list a.
  
  Parameter sort_uniq : forall {a : Set}, (a -> a -> int) -> list a -> list a.
  
  Parameter merge : forall {a : Set},
    (a -> a -> int) -> list a -> list a -> list a.
End List_type.

Module List.
  Parameter length : forall {a : Set}, list a -> int.
  Parameter compare_lengths : forall {a b : Set}, list a -> list b -> int.
  Parameter compare_length_with : forall {a : Set}, list a -> int -> int.
  Parameter __cons_value : forall {a : Set}, a -> list a -> list a.
  Parameter hd : forall {a : Set}, list a -> a.
  Parameter tl : forall {a : Set}, list a -> list a.
  Parameter nth_opt : forall {a : Set}, list a -> int -> option a.
  Definition rev : forall {a : Set}, list a -> list a :=
    fun {_} => List.rev.
  Parameter init : forall {a : Set}, int -> (int -> a) -> list a.
  Parameter append : forall {a : Set}, list a -> list a -> list a.
  Parameter rev_append : forall {a : Set}, list a -> list a -> list a.
  Parameter concat : forall {a : Set}, list (list a) -> list a.
  Parameter flatten : forall {a : Set}, list (list a) -> list a.
  Parameter iter : forall {a : Set}, (a -> unit) -> list a -> unit.
  Parameter iteri : forall {a : Set}, (int -> a -> unit) -> list a -> unit.
  Definition map : forall {a b : Set}, (a -> b) -> list a -> list b :=
    fun {_ _} => List.map.
  Parameter mapi : forall {a b : Set}, (int -> a -> b) -> list a -> list b.
  Parameter rev_map : forall {a b : Set}, (a -> b) -> list a -> list b.
  Parameter fold_left : forall {a b : Set}, (a -> b -> a) -> a -> list b -> a.
  Parameter fold_right : forall {a b : Set}, (a -> b -> b) -> list a -> b -> b.
  Parameter iter2 : forall {a b : Set}, (a -> b -> unit) -> list a -> list b -> unit.
  Parameter map2 : forall {a b c : Set}, (a -> b -> c) -> list a -> list b -> list c.
  Parameter rev_map2 : forall {a b c : Set}, (a -> b -> c) -> list a -> list b -> list c.
  Parameter fold_left2 : forall {a b c : Set}, (a -> b -> c -> a) -> a -> list b -> list c -> a.
  Parameter fold_right2 : forall {a b c : Set}, (a -> b -> c -> c) -> list a -> list b -> c -> c.
  Parameter for_all : forall {a : Set}, (a -> bool) -> list a -> bool.
  Parameter __exists : forall {a : Set}, (a -> bool) -> list a -> bool.
  Parameter for_all2 : forall {a b : Set}, (a -> b -> bool) -> list a -> list b -> bool.
  Parameter __exists2 : forall {a b : Set}, (a -> b -> bool) -> list a -> list b -> bool.
  Parameter mem : forall {a : Set}, a -> list a -> bool.
  Parameter memq : forall {a : Set}, a -> list a -> bool.
  Parameter find_opt : forall {a : Set}, (a -> bool) -> list a -> option a.
  Parameter filter : forall {a : Set}, (a -> bool) -> list a -> list a.
  Parameter find_all : forall {a : Set}, (a -> bool) -> list a -> list a.
  Parameter partition : forall {a : Set}, (a -> bool) -> list a -> list a * list a.
  Parameter assoc_opt : forall {a b : Set}, a -> list (a * b) -> option b.
  Parameter assq_opt : forall {a b : Set}, a -> list (a * b) -> option b.
  Parameter mem_assoc : forall {a b : Set}, a -> list (a * b) -> bool.
  Parameter mem_assq : forall {a b : Set}, a -> list (a * b) -> bool.
  Parameter remove_assoc : forall {a b : Set}, a -> list (a * b) -> list (a * b).
  Parameter remove_assq : forall {a b : Set}, a -> list (a * b) -> list (a * b).
  Parameter split : forall {a b : Set}, list (a * b) -> list a * list b.
  Parameter combine : forall {a b : Set}, list a -> list b -> list (a * b).
  Parameter sort : forall {a : Set}, (a -> a -> int) -> list a -> list a.
  Parameter stable_sort : forall {a : Set}, (a -> a -> int) -> list a -> list a.
  Parameter fast_sort : forall {a : Set}, (a -> a -> int) -> list a -> list a.
  Parameter sort_uniq : forall {a : Set}, (a -> a -> int) -> list a -> list a.
  Parameter merge : forall {a : Set}, (a -> a -> int) -> list a -> list a -> list a.
End List.

Module List_check : List_type := List.

Module String.
  Parameter length : string -> int.
  
  Parameter get : string -> int -> ascii.
  
  Parameter make : int -> ascii -> string.
  
  Parameter init : int -> (int -> ascii) -> string.
  
  Parameter sub : string -> int -> int -> string.
  
  Parameter blit : string -> int -> bytes -> int -> int -> unit.
  
  Parameter concat : string -> list string -> string.
  
  Parameter iter : (ascii -> unit) -> string -> unit.
  
  Parameter iteri : (int -> ascii -> unit) -> string -> unit.
  
  Parameter map : (ascii -> ascii) -> string -> string.
  
  Parameter mapi : (int -> ascii -> ascii) -> string -> string.
  
  Parameter trim : string -> string.
  
  Parameter escaped : string -> string.
  
  Parameter index_opt : string -> ascii -> option int.
  
  Parameter rindex_opt : string -> ascii -> option int.
  
  Parameter index_from_opt : string -> int -> ascii -> option int.
  
  Parameter rindex_from_opt : string -> int -> ascii -> option int.
  
  Parameter contains : string -> ascii -> bool.
  
  Parameter contains_from : string -> int -> ascii -> bool.
  
  Parameter rcontains_from : string -> int -> ascii -> bool.
  
  Parameter uppercase_ascii : string -> string.
  
  Parameter lowercase_ascii : string -> string.
  
  Parameter capitalize_ascii : string -> string.
  
  Parameter uncapitalize_ascii : string -> string.
  
  Definition t : Set := string.
  
  Parameter compare : t -> t -> int.
  
  Parameter equal : t -> t -> bool.
  
  Parameter split_on_char : ascii -> string -> list string.
  
  Parameter get_char : t -> int -> ascii.
  
  Parameter get_uint8 : t -> int -> int.
  
  Parameter get_int8 : t -> int -> int.
  
  Parameter get_uint16 : t -> int -> int.
  
  Parameter get_int16 : t -> int -> int.
  
  Parameter get_int32 : t -> int -> int32.
  
  Parameter get_int64 : t -> int -> int64.
  
  Module LE.
    Parameter get_uint16 : t -> int -> int.
    
    Parameter get_int16 : t -> int -> int.
    
    Parameter get_int32 : t -> int -> int32.
    
    Parameter get_int64 : t -> int -> int64.
  End LE.
End String.

Module Int32.
  Parameter zero : int32.
  
  Parameter one : int32.
  
  Parameter minus_one : int32.
  
  Parameter neg : int32 -> int32.
  
  Parameter add : int32 -> int32 -> int32.
  
  Parameter sub : int32 -> int32 -> int32.
  
  Parameter mul : int32 -> int32 -> int32.
  
  Parameter div : int32 -> int32 -> int32.
  
  Parameter rem : int32 -> int32 -> int32.
  
  Parameter succ : int32 -> int32.
  
  Parameter pred : int32 -> int32.
  
  Parameter abs : int32 -> int32.
  
  Parameter max_int : int32.
  
  Parameter min_int : int32.
  
  Parameter logand : int32 -> int32 -> int32.
  
  Parameter logor : int32 -> int32 -> int32.
  
  Parameter logxor : int32 -> int32 -> int32.
  
  Parameter lognot : int32 -> int32.
  
  Parameter shift_left : int32 -> int -> int32.
  
  Parameter shift_right : int32 -> int -> int32.
  
  Parameter shift_right_logical : int32 -> int -> int32.
  
  Parameter of_int : int -> int32.
  
  Parameter to_int : int32 -> int.
  
  Parameter of_float : float -> int32.
  
  Parameter to_float : int32 -> float.
  
  Parameter of_string : string -> int32.
  
  Parameter of_string_opt : string -> option int32.
  
  Parameter to_string : int32 -> string.
  
  Parameter bits_of_float : float -> int32.
  
  Parameter float_of_bits : int32 -> float.
  
  Definition t : Set := int32.
  
  Parameter compare : t -> t -> int.
  
  Parameter equal : t -> t -> bool.
End Int32.

Module Int64.
  Parameter zero : int64.
  
  Parameter one : int64.
  
  Parameter minus_one : int64.
  
  Parameter neg : int64 -> int64.
  
  Parameter add : int64 -> int64 -> int64.
  
  Parameter sub : int64 -> int64 -> int64.
  
  Parameter mul : int64 -> int64 -> int64.
  
  Parameter div : int64 -> int64 -> int64.
  
  Parameter rem : int64 -> int64 -> int64.
  
  Parameter succ : int64 -> int64.
  
  Parameter pred : int64 -> int64.
  
  Parameter abs : int64 -> int64.
  
  Parameter max_int : int64.
  
  Parameter min_int : int64.
  
  Parameter logand : int64 -> int64 -> int64.
  
  Parameter logor : int64 -> int64 -> int64.
  
  Parameter logxor : int64 -> int64 -> int64.
  
  Parameter lognot : int64 -> int64.
  
  Parameter shift_left : int64 -> int -> int64.
  
  Parameter shift_right : int64 -> int -> int64.
  
  Parameter shift_right_logical : int64 -> int -> int64.
  
  Parameter of_int : int -> int64.
  
  Parameter to_int : int64 -> int.
  
  Parameter of_float : float -> int64.
  
  Parameter to_float : int64 -> float.
  
  Parameter of_int32 : int32 -> int64.
  
  Parameter to_int32 : int64 -> int32.
  
  Parameter of_nativeint : nativeint -> int64.
  
  Parameter to_nativeint : int64 -> nativeint.
  
  Parameter of_string : string -> int64.
  
  Parameter of_string_opt : string -> option int64.
  
  Parameter to_string : int64 -> string.
  
  Parameter bits_of_float : float -> int64.
  
  Parameter float_of_bits : int64 -> float.
  
  Definition t : Set := int64.
  
  Parameter compare : t -> t -> int.
  
  Parameter equal : t -> t -> bool.
End Int64.

Module Format.
  Parameter formatter : Set.
  
  Parameter pp_open_box : formatter -> int -> unit.
  
  Parameter pp_close_box : formatter -> unit -> unit.
  
  Parameter pp_open_hbox : formatter -> unit -> unit.
  
  Parameter pp_open_vbox : formatter -> int -> unit.
  
  Parameter pp_open_hvbox : formatter -> int -> unit.
  
  Parameter pp_open_hovbox : formatter -> int -> unit.
  
  Parameter pp_print_string : formatter -> string -> unit.
  
  Parameter pp_print_as : formatter -> int -> string -> unit.
  
  Parameter pp_print_int : formatter -> int -> unit.
  
  Parameter pp_print_float : formatter -> float -> unit.
  
  Parameter pp_print_char : formatter -> ascii -> unit.
  
  Parameter pp_print_bool : formatter -> bool -> unit.
  
  Parameter pp_print_space : formatter -> unit -> unit.
  
  Parameter pp_print_cut : formatter -> unit -> unit.
  
  Parameter pp_print_break : formatter -> int -> int -> unit.
  
  Parameter pp_force_newline : formatter -> unit -> unit.
  
  Parameter pp_print_if_newline : formatter -> unit -> unit.
  
  Parameter pp_print_flush : formatter -> unit -> unit.
  
  Parameter pp_print_newline : formatter -> unit -> unit.
  
  Parameter pp_set_margin : formatter -> int -> unit.
  
  Parameter pp_get_margin : formatter -> unit -> int.
  
  Parameter pp_set_max_indent : formatter -> int -> unit.
  
  Parameter pp_get_max_indent : formatter -> unit -> int.
  
  Parameter pp_set_max_boxes : formatter -> int -> unit.
  
  Parameter pp_get_max_boxes : formatter -> unit -> int.
  
  Parameter pp_over_max_boxes : formatter -> unit -> bool.
  
  Parameter pp_open_tbox : formatter -> unit -> unit.
  
  Parameter pp_close_tbox : formatter -> unit -> unit.
  
  Parameter pp_set_tab : formatter -> unit -> unit.
  
  Parameter pp_print_tab : formatter -> unit -> unit.
  
  Parameter pp_print_tbreak : formatter -> int -> int -> unit.
  
  Parameter pp_set_ellipsis_text : formatter -> string -> unit.
  
  Parameter pp_get_ellipsis_text : formatter -> unit -> string.
  
  Definition tag : Set := string.
  
  Parameter pp_open_tag : formatter -> string -> unit.
  
  Parameter pp_close_tag : formatter -> unit -> unit.
  
  Parameter pp_set_tags : formatter -> bool -> unit.
  
  Parameter pp_set_print_tags : formatter -> bool -> unit.
  
  Parameter pp_set_mark_tags : formatter -> bool -> unit.
  
  Parameter pp_get_print_tags : formatter -> unit -> bool.
  
  Parameter pp_get_mark_tags : formatter -> unit -> bool.
  
  Parameter pp_print_list : forall {a : Set},
    option (formatter -> unit -> unit) -> (formatter -> a -> unit) ->
    formatter -> list a -> unit.
  
  Parameter pp_print_text : formatter -> string -> unit.
  
  Parameter fprintf : forall {a : Set},
    formatter -> Pervasives.format a formatter unit -> a.
  
  Parameter sprintf : forall {a : Set}, Pervasives.format a unit string -> a.
  
  Parameter asprintf : forall {a : Set},
    Pervasives.format4 a formatter unit string -> a.
  
  Parameter ifprintf : forall {a : Set},
    formatter -> Pervasives.format a formatter unit -> a.
  
  Parameter kfprintf : forall {a b : Set},
    (formatter -> a) -> formatter -> Pervasives.format4 b formatter unit a -> b.
  
  Parameter ikfprintf : forall {a b : Set},
    (formatter -> a) -> formatter -> Pervasives.format4 b formatter unit a -> b.
  
  Parameter ksprintf : forall {a b : Set},
    (string -> a) -> Pervasives.format4 b unit string a -> b.
  
  Parameter kasprintf : forall {a b : Set},
    (string -> a) -> Pervasives.format4 b formatter unit a -> b.
End Format.

Module Type MBytes_type.
  Parameter t : Set.
  
  Parameter create : int -> t.
  
  Parameter length : t -> int.
  
  Parameter copy : t -> t.
  
  Parameter sub : t -> int -> int -> t.
  
  Parameter blit : t -> int -> t -> int -> int -> unit.
  
  Parameter blit_of_string : string -> int -> t -> int -> int -> unit.
  
  Parameter blit_to_bytes : t -> int -> bytes -> int -> int -> unit.
  
  Parameter of_string : string -> t.
  
  Parameter to_string : t -> string.
  
  Parameter sub_string : t -> int -> int -> string.
  
  Parameter get_char : t -> int -> ascii.
  
  Parameter get_uint8 : t -> int -> int.
  
  Parameter get_int8 : t -> int -> int.
  
  Parameter set_char : t -> int -> ascii -> unit.
  
  Parameter set_int8 : t -> int -> int -> unit.
  
  Parameter get_uint16 : t -> int -> int.
  
  Parameter get_int16 : t -> int -> int.
  
  Parameter get_int32 : t -> int -> int32.
  
  Parameter get_int64 : t -> int -> int64.
  
  Parameter set_int16 : t -> int -> int -> unit.
  
  Parameter set_int32 : t -> int -> int32 -> unit.
  
  Parameter set_int64 : t -> int -> int64 -> unit.
  
  Module LE.
    Parameter get_uint16 : t -> int -> int.
    
    Parameter get_int16 : t -> int -> int.
    
    Parameter get_int32 : t -> int -> int32.
    
    Parameter get_int64 : t -> int -> int64.
    
    Parameter set_int16 : t -> int -> int -> unit.
    
    Parameter set_int32 : t -> int -> int32 -> unit.
    
    Parameter set_int64 : t -> int -> int64 -> unit.
  End LE.
  
  Parameter op_eq : t -> t -> bool.
  
  Parameter op_ltgt : t -> t -> bool.
  
  Parameter op_lt : t -> t -> bool.
  
  Parameter op_lteq : t -> t -> bool.
  
  Parameter op_gteq : t -> t -> bool.
  
  Parameter op_gt : t -> t -> bool.
  
  Parameter compare : t -> t -> int.
  
  Parameter concat : string -> list t -> t.
  
  Inductive hex : Set :=
  | Hex : string -> hex.
  
  Parameter to_hex : t -> hex.
  
  Parameter of_hex : hex -> t.
End MBytes_type.

Module MBytes.
  Definition t : Set := string.
  Parameter create : int -> t.
  Parameter length : t -> int.
  Parameter copy : t -> t.
  Parameter sub : t -> int -> int -> t.
  Parameter blit : t -> int -> t -> int -> int -> unit.
  Parameter blit_of_string : string -> int -> t -> int -> int -> unit.
  Parameter blit_to_bytes : t -> int -> bytes -> int -> int -> unit.
  Definition of_string : string -> t := fun s => s.
  Definition to_string : t -> string := fun b => b.
  Parameter sub_string : t -> int -> int -> string.
  Parameter get_char : t -> int -> ascii.
  Parameter get_uint8 : t -> int -> int.
  Parameter get_int8 : t -> int -> int.
  Parameter set_char : t -> int -> ascii -> unit.
  Parameter set_int8 : t -> int -> int -> unit.
  Parameter get_uint16 : t -> int -> int.
  Parameter get_int16 : t -> int -> int.
  Parameter get_int32 : t -> int -> int32.
  Parameter get_int64 : t -> int -> int64.
  Parameter set_int16 : t -> int -> int -> unit.
  Parameter set_int32 : t -> int -> int32 -> unit.
  Parameter set_int64 : t -> int -> int64 -> unit.

  Module LE.
    Parameter get_uint16 : t -> int -> int.
    Parameter get_int16 : t -> int -> int.
    Parameter get_int32 : t -> int -> int32.
    Parameter get_int64 : t -> int -> int64.
    Parameter set_int16 : t -> int -> int -> unit.
    Parameter set_int32 : t -> int -> int32 -> unit.
    Parameter set_int64 : t -> int -> int64 -> unit.
  End LE.

  Parameter op_eq : t -> t -> bool.
  Parameter op_ltgt : t -> t -> bool.
  Parameter op_lt : t -> t -> bool.
  Parameter op_lteq : t -> t -> bool.
  Parameter op_gteq : t -> t -> bool.
  Parameter op_gt : t -> t -> bool.
  Parameter compare : t -> t -> int.
  Parameter concat : string -> list t -> t.
  
  Inductive hex : Set :=
  | Hex : string -> hex.
  
  Parameter to_hex : t -> hex.
  Parameter of_hex : hex -> t.
End MBytes.

Module MBytes_check : MBytes_type := MBytes.

Module Type Z_type.
  Parameter t : Set.
  
  Parameter zero : t.
  
  Parameter one : t.
  
  Parameter succ : t -> t.
  
  Parameter abs : t -> t.
  
  Parameter neg : t -> t.
  
  Parameter add : t -> t -> t.
  
  Parameter sub : t -> t -> t.
  
  Parameter mul : t -> t -> t.
  
  Parameter ediv_rem : t -> t -> t * t.
  
  Parameter logand : t -> t -> t.
  
  Parameter logor : t -> t -> t.
  
  Parameter logxor : t -> t -> t.
  
  Parameter lognot : t -> t.
  
  Parameter shift_left : t -> int -> t.
  
  Parameter shift_right : t -> int -> t.
  
  Parameter to_string : t -> string.
  
  Parameter of_string : string -> t.
  
  Parameter to_int64 : t -> int64.
  
  Parameter of_int64 : int64 -> t.
  
  Parameter to_int : t -> int.
  
  Parameter of_int : int -> t.
  
  Parameter to_bits : option int -> t -> MBytes.t.
  
  Parameter of_bits : MBytes.t -> t.
  
  Parameter equal : t -> t -> bool.
  
  Parameter compare : t -> t -> int.
  
  Parameter numbits : t -> int.
End Z_type.

Module Z.
  Definition t := Z.
  Definition zero := 0.
  Definition one := 1.
  Definition succ z := Z.add z 1.
  Definition abs := Z.abs.
  Definition neg z := -z.
  Definition add := Z.add.
  Definition sub := Z.sub.
  Definition mul := Z.mul.
  Parameter ediv_rem : t -> t -> t * t.
  Parameter logand : t -> t -> t.
  Parameter logor : t -> t -> t.
  Parameter logxor : t -> t -> t.
  Parameter lognot : t -> t.
  Parameter shift_left : t -> int -> t.
  Parameter shift_right : t -> int -> t.
  Parameter to_string : t -> string.
  Parameter of_string : string -> t.
  Parameter to_int64 : t -> int64.
  Parameter of_int64 : int64 -> t.
  Parameter to_int : t -> int.
  Parameter of_int : int -> t.
  Parameter to_bits : option int -> t -> MBytes.t.
  Parameter of_bits : MBytes.t -> t.
  Definition equal := Z.eqb.
  Parameter compare : t -> t -> int.
  Parameter numbits : t -> int.
End Z.

Module Z_check : Z_type := Z.

Module Type Lwt_type.
  Parameter t : forall (a : Set), Set.
  
  Parameter __return : forall {a : Set}, a -> t a.
  
  Parameter bind : forall {a b : Set}, t a -> (a -> t b) -> t b.
  
  Parameter op_gtgteq : forall {a b : Set}, t a -> (a -> t b) -> t b.
  
  Parameter op_eqltlt : forall {a b : Set}, (a -> t b) -> t a -> t b.
  
  Parameter map : forall {a b : Set}, (a -> b) -> t a -> t b.
  
  Parameter op_gtpipeeq : forall {a b : Set}, t a -> (a -> b) -> t b.
  
  Parameter op_eqpipelt : forall {a b : Set}, (a -> b) -> t a -> t b.
  
  Parameter return_unit : t unit.
  
  Parameter return_none : forall {a : Set}, t (option a).
  
  Parameter return_nil : forall {a : Set}, t (list a).
  
  Parameter return_true : t bool.
  
  Parameter return_false : t bool.
  
  Parameter join : list (t unit) -> t unit.
  
  Parameter op_ltandgt : t unit -> t unit -> t unit.
End Lwt_type.

Module Lwt.
  Definition t (a : Set) : Set := a.
  Definition __return {a : Set} (x : a) : t a := x.
  Definition bind {a b : Set} (x : t a) (f : a -> t b) : t b := f x.
  Definition op_gtgteq {a b : Set} : t a -> (a -> t b) -> t b := bind.
  Definition op_eqltlt {a b : Set} (f : a -> t b) (x : t a) : t b := f x.
  Definition map {a b : Set} (f : a -> b) (x : t a) : t b := f x.
  Definition op_gtpipeeq {a b : Set} (x : t a) (f : a -> b) : t b := f x.
  Definition op_eqpipelt {a b : Set} : (a -> b) -> t a -> t b := map.
  Definition return_unit : t unit := tt.
  Definition return_none {a : Set} : t (option a) := None.
  Definition return_nil {a : Set} : t (list a) := [].
  Definition return_true : t bool := true.
  Definition return_false : t bool := false.
  Parameter join : list (t unit) -> t unit.
  Parameter op_ltandgt : t unit -> t unit -> t unit.
End Lwt.

Module Lwt_check : Lwt_type := Lwt.

Module Lwt_list.
  Parameter map_s : forall {a b : Set},
    (a -> Lwt.t b) -> list a -> Lwt.t (list b).
  
  Parameter map_p : forall {a b : Set},
    (a -> Lwt.t b) -> list a -> Lwt.t (list b).
  
  Parameter mapi_s : forall {a b : Set},
    (int -> a -> Lwt.t b) -> list a -> Lwt.t (list b).
  
  Parameter mapi_p : forall {a b : Set},
    (int -> a -> Lwt.t b) -> list a -> Lwt.t (list b).
  
  Parameter rev_map_s : forall {a b : Set},
    (a -> Lwt.t b) -> list a -> Lwt.t (list b).
  
  Parameter rev_map_p : forall {a b : Set},
    (a -> Lwt.t b) -> list a -> Lwt.t (list b).
  
  Parameter fold_left_s : forall {a b : Set},
    (a -> b -> Lwt.t a) -> a -> list b -> Lwt.t a.
  
  Parameter fold_right_s : forall {a b : Set},
    (a -> b -> Lwt.t b) -> list a -> b -> Lwt.t b.
  
  Parameter for_all_s : forall {a : Set},
    (a -> Lwt.t bool) -> list a -> Lwt.t bool.
  
  Parameter for_all_p : forall {a : Set},
    (a -> Lwt.t bool) -> list a -> Lwt.t bool.
  
  Parameter exists_s : forall {a : Set},
    (a -> Lwt.t bool) -> list a -> Lwt.t bool.
  
  Parameter exists_p : forall {a : Set},
    (a -> Lwt.t bool) -> list a -> Lwt.t bool.
  
  Parameter find_s : forall {a : Set}, (a -> Lwt.t bool) -> list a -> Lwt.t a.
  
  Parameter filter_s : forall {a : Set},
    (a -> Lwt.t bool) -> list a -> Lwt.t (list a).
  
  Parameter filter_p : forall {a : Set},
    (a -> Lwt.t bool) -> list a -> Lwt.t (list a).
  
  Parameter filter_map_s : forall {a b : Set},
    (a -> Lwt.t (option b)) -> list a -> Lwt.t (list b).
  
  Parameter filter_map_p : forall {a b : Set},
    (a -> Lwt.t (option b)) -> list a -> Lwt.t (list b).
  
  Parameter partition_s : forall {a : Set},
    (a -> Lwt.t bool) -> list a -> Lwt.t (list a * list a).
  
  Parameter partition_p : forall {a : Set},
    (a -> Lwt.t bool) -> list a -> Lwt.t (list a * list a).
End Lwt_list.

Module Raw_hashes.
  Parameter blake2b : MBytes.t -> MBytes.t.
  
  Parameter sha256 : MBytes.t -> MBytes.t.
  
  Parameter sha512 : MBytes.t -> MBytes.t.
End Raw_hashes.

Module Compare.
  Module COMPARABLE.
    Record signature {t : Set} : Set := {
      t := t;
      compare : t -> t -> int;
    }.
  End COMPARABLE.
  
  Module S.
    Record signature {t : Set} : Set := {
      t := t;
      op_eq : t -> t -> bool;
      op_ltgt : t -> t -> bool;
      op_lt : t -> t -> bool;
      op_lteq : t -> t -> bool;
      op_gteq : t -> t -> bool;
      op_gt : t -> t -> bool;
      compare : t -> t -> int;
      equal : t -> t -> bool;
      max : t -> t -> t;
      min : t -> t -> t;
    }.
  End S.
  
  Parameter Make :
    forall (P : {t : Set & COMPARABLE.signature (t := t)}),
      {_ : unit & S.signature (t := (|P|).(COMPARABLE.t))}.
  
  Parameter Char : {_ : unit & S.signature (t := ascii)}.
  
  Parameter Bool : {_ : unit & S.signature (t := bool)}.
  
  Parameter Int : {_ : unit & S.signature (t := int)}.
  
  Parameter Int32 : {_ : unit & S.signature (t := int32)}.
  
  Parameter Uint32 : {_ : unit & S.signature (t := int32)}.
  
  Parameter Int64 : {_ : unit & S.signature (t := int64)}.
  
  Parameter Uint64 : {_ : unit & S.signature (t := int64)}.
  
  Parameter Float : {_ : unit & S.signature (t := float)}.
  
  Parameter String : {_ : unit & S.signature (t := string)}.
  
  Parameter Z : {_ : unit & S.signature (t := Z.t)}.
  
  Parameter List :
    forall (P : {t : Set & COMPARABLE.signature (t := t)}),
      {_ : unit & S.signature (t := (list (|P|).(COMPARABLE.t)))}.
  
  Parameter Option :
    forall (P : {t : Set & COMPARABLE.signature (t := t)}),
      {_ : unit & S.signature (t := (option (|P|).(COMPARABLE.t)))}.
End Compare.

Module Data_encoding.
  Inductive json : Set :=
  | Bool : bool -> json
  | Null : json
  | O : list (string * json) -> json
  | Float : float -> json
  | String : string -> json
  | A : list json -> json.
  
  Parameter json_schema : Set.
  
  Parameter t : forall (a : Set), Set.
  
  Definition encoding (a : Set) : Set := t a.
  
  Parameter classify : forall {a : Set},
    encoding a -> (* `Variable *) unit + (* `Fixed *) int + (* `Dynamic *) unit.
  
  Parameter splitted : forall {a : Set}, encoding a -> encoding a -> encoding a.
  
  Parameter null : encoding unit.
  
  Parameter empty : encoding unit.
  
  Parameter __unit_value : encoding unit.
  
  Parameter constant : string -> encoding unit.
  
  Parameter int8 : encoding int.
  
  Parameter uint8 : encoding int.
  
  Parameter int16 : encoding int.
  
  Parameter uint16 : encoding int.
  
  Parameter int31 : encoding int.
  
  Parameter __int32_value : encoding int32.
  
  Parameter __int64_value : encoding int64.
  
  Parameter n : encoding Z.t.
  
  Parameter z : encoding Z.t.
  
  Parameter __bool_value : encoding bool.
  
  Parameter __string_value : encoding string.
  
  Parameter __bytes_value : encoding MBytes.t.
  
  Parameter __float_value : encoding float.
  
  Parameter __option_value : forall {a : Set},
    encoding a -> encoding (option a).
  
  Parameter string_enum : forall {a : Set}, list (string * a) -> encoding a.
  
  Module Fixed.
    Parameter __string_value : int -> encoding string.
    
    Parameter __bytes_value : int -> encoding MBytes.t.
    
    Parameter add_padding : forall {a : Set}, encoding a -> int -> encoding a.
  End Fixed.
  
  Module __Variable.
    Parameter __string_value : encoding string.
    
    Parameter __bytes_value : encoding MBytes.t.
    
    Parameter array : forall {a : Set},
      option int -> encoding a -> encoding (array a).
    
    Parameter __list_value : forall {a : Set},
      option int -> encoding a -> encoding (list a).
  End __Variable.
  
  Module Bounded.
    Parameter __string_value : int -> encoding string.
    
    Parameter __bytes_value : int -> encoding MBytes.t.
  End Bounded.
  
  Parameter dynamic_size : forall {a : Set},
    option ((* `Uint16 *) unit + (* `Uint8 *) unit + (* `Uint30 *) unit) ->
    encoding a -> encoding a.
  
  Parameter __json_value : encoding json.
  
  Parameter __json_schema_value : encoding json_schema.
  
  Parameter field : forall (a : Set), Set.
  
  Parameter req : forall {t : Set},
    option string -> option string -> string -> encoding t -> field t.
  
  Parameter opt : forall {t : Set},
    option string -> option string -> string -> encoding t -> field (option t).
  
  Parameter varopt : forall {t : Set},
    option string -> option string -> string -> encoding t -> field (option t).
  
  Parameter dft : forall {t : Set},
    option string -> option string -> string -> encoding t -> t -> field t.
  
  Parameter obj1 : forall {f1 : Set}, field f1 -> encoding f1.
  
  Parameter obj2 : forall {f1 f2 : Set},
    field f1 -> field f2 -> encoding (f1 * f2).
  
  Parameter obj3 : forall {f1 f2 f3 : Set},
    field f1 -> field f2 -> field f3 -> encoding (f1 * f2 * f3).
  
  Parameter obj4 : forall {f1 f2 f3 f4 : Set},
    field f1 -> field f2 -> field f3 -> field f4 -> encoding (f1 * f2 * f3 * f4).
  
  Parameter obj5 : forall {f1 f2 f3 f4 f5 : Set},
    field f1 -> field f2 -> field f3 -> field f4 -> field f5 ->
    encoding (f1 * f2 * f3 * f4 * f5).
  
  Parameter obj6 : forall {f1 f2 f3 f4 f5 f6 : Set},
    field f1 -> field f2 -> field f3 -> field f4 -> field f5 -> field f6 ->
    encoding (f1 * f2 * f3 * f4 * f5 * f6).
  
  Parameter obj7 : forall {f1 f2 f3 f4 f5 f6 f7 : Set},
    field f1 -> field f2 -> field f3 -> field f4 -> field f5 -> field f6 ->
    field f7 -> encoding (f1 * f2 * f3 * f4 * f5 * f6 * f7).
  
  Parameter obj8 : forall {f1 f2 f3 f4 f5 f6 f7 f8 : Set},
    field f1 -> field f2 -> field f3 -> field f4 -> field f5 -> field f6 ->
    field f7 -> field f8 -> encoding (f1 * f2 * f3 * f4 * f5 * f6 * f7 * f8).
  
  Parameter obj9 : forall {f1 f2 f3 f4 f5 f6 f7 f8 f9 : Set},
    field f1 -> field f2 -> field f3 -> field f4 -> field f5 -> field f6 ->
    field f7 -> field f8 -> field f9 ->
    encoding (f1 * f2 * f3 * f4 * f5 * f6 * f7 * f8 * f9).
  
  Parameter obj10 : forall {f1 f10 f2 f3 f4 f5 f6 f7 f8 f9 : Set},
    field f1 -> field f2 -> field f3 -> field f4 -> field f5 -> field f6 ->
    field f7 -> field f8 -> field f9 -> field f10 ->
    encoding (f1 * f2 * f3 * f4 * f5 * f6 * f7 * f8 * f9 * f10).
  
  Parameter tup1 : forall {f1 : Set}, encoding f1 -> encoding f1.
  
  Parameter tup2 : forall {f1 f2 : Set},
    encoding f1 -> encoding f2 -> encoding (f1 * f2).
  
  Parameter tup3 : forall {f1 f2 f3 : Set},
    encoding f1 -> encoding f2 -> encoding f3 -> encoding (f1 * f2 * f3).
  
  Parameter tup4 : forall {f1 f2 f3 f4 : Set},
    encoding f1 -> encoding f2 -> encoding f3 -> encoding f4 ->
    encoding (f1 * f2 * f3 * f4).
  
  Parameter tup5 : forall {f1 f2 f3 f4 f5 : Set},
    encoding f1 -> encoding f2 -> encoding f3 -> encoding f4 -> encoding f5 ->
    encoding (f1 * f2 * f3 * f4 * f5).
  
  Parameter tup6 : forall {f1 f2 f3 f4 f5 f6 : Set},
    encoding f1 -> encoding f2 -> encoding f3 -> encoding f4 -> encoding f5 ->
    encoding f6 -> encoding (f1 * f2 * f3 * f4 * f5 * f6).
  
  Parameter tup7 : forall {f1 f2 f3 f4 f5 f6 f7 : Set},
    encoding f1 -> encoding f2 -> encoding f3 -> encoding f4 -> encoding f5 ->
    encoding f6 -> encoding f7 -> encoding (f1 * f2 * f3 * f4 * f5 * f6 * f7).
  
  Parameter tup8 : forall {f1 f2 f3 f4 f5 f6 f7 f8 : Set},
    encoding f1 -> encoding f2 -> encoding f3 -> encoding f4 -> encoding f5 ->
    encoding f6 -> encoding f7 -> encoding f8 ->
    encoding (f1 * f2 * f3 * f4 * f5 * f6 * f7 * f8).
  
  Parameter tup9 : forall {f1 f2 f3 f4 f5 f6 f7 f8 f9 : Set},
    encoding f1 -> encoding f2 -> encoding f3 -> encoding f4 -> encoding f5 ->
    encoding f6 -> encoding f7 -> encoding f8 -> encoding f9 ->
    encoding (f1 * f2 * f3 * f4 * f5 * f6 * f7 * f8 * f9).
  
  Parameter tup10 : forall {f1 f10 f2 f3 f4 f5 f6 f7 f8 f9 : Set},
    encoding f1 -> encoding f2 -> encoding f3 -> encoding f4 -> encoding f5 ->
    encoding f6 -> encoding f7 -> encoding f8 -> encoding f9 -> encoding f10 ->
    encoding (f1 * f2 * f3 * f4 * f5 * f6 * f7 * f8 * f9 * f10).
  
  Parameter merge_objs : forall {o1 o2 : Set},
    encoding o1 -> encoding o2 -> encoding (o1 * o2).
  
  Parameter merge_tups : forall {a1 a2 : Set},
    encoding a1 -> encoding a2 -> encoding (a1 * a2).
  
  Parameter array : forall {a : Set},
    option int -> encoding a -> encoding (array a).
  
  Parameter __list_value : forall {a : Set},
    option int -> encoding a -> encoding (list a).
  
  Parameter assoc : forall {a : Set},
    encoding a -> encoding (list (string * a)).
  
  Inductive case_tag : Set :=
  | Tag : int -> case_tag
  | Json_only : case_tag.
  
  Parameter case : forall (t : Set), Set.
  
  Parameter __case_value : forall {a t : Set},
    string -> option string -> case_tag -> encoding a -> (t -> option a) ->
    (a -> t) -> case t.
  
  Inductive tag_size : Set :=
  | Uint16 : tag_size
  | Uint8 : tag_size.
  
  Parameter union : forall {t : Set},
    option tag_size -> list (case t) -> encoding t.
  
  Parameter def : forall {t : Set},
    string -> option string -> option string -> encoding t -> encoding t.
  
  Parameter conv : forall {a b : Set},
    (a -> b) -> (b -> a) -> option json_schema -> encoding b -> encoding a.
  
  Parameter mu : forall {a : Set},
    string -> option string -> option string -> (encoding a -> encoding a) ->
    encoding a.
  
  Parameter lazy_t : forall (a : Set), Set.
  
  Parameter lazy_encoding : forall {a : Set}, encoding a -> encoding (lazy_t a).
  
  Parameter force_decode : forall {a : Set}, lazy_t a -> option a.
  
  Parameter force_bytes : forall {a : Set}, lazy_t a -> MBytes.t.
  
  Parameter make_lazy : forall {a : Set}, encoding a -> a -> lazy_t a.
  
  Parameter apply_lazy : forall {a b : Set},
    (a -> b) -> (MBytes.t -> b) -> (b -> b -> b) -> lazy_t a -> b.
  
  Module Json.
    Parameter schema : forall {a : Set},
      option string -> encoding a -> json_schema.
    
    Parameter construct : forall {t : Set}, encoding t -> t -> json.
    
    Parameter destruct : forall {t : Set}, encoding t -> json -> t.
    
    Reserved Notation "'path".
    
    Inductive path_item : Set :=
    | Index : int -> path_item
    | Field : string -> path_item
    | Next : path_item
    | Star : path_item
    
    where "'path" := (list path_item).
    
    Definition path := 'path.
    
    (* exception Cannot_destruct *)
    
    (* exception Unexpected *)
    
    (* exception No_case_matched *)
    
    (* exception Bad_array_size *)
    
    (* exception Missing_field *)
    
    (* exception Unexpected_field *)
    
    Parameter print_error :
      option (Format.formatter -> extensible_type -> unit) ->
      Format.formatter -> extensible_type -> unit.
    
    Parameter cannot_destruct : forall {a b : Set},
      Pervasives.format4 a Format.formatter unit b -> a.
    
    Parameter wrap_error : forall {a b : Set}, (a -> b) -> a -> b.
    
    Parameter pp : Format.formatter -> json -> unit.
  End Json.
  
  Module Binary.
    Parameter length : forall {a : Set}, encoding a -> a -> int.
    
    Parameter fixed_length : forall {a : Set}, encoding a -> option int.
    
    Parameter read : forall {a : Set},
      encoding a -> MBytes.t -> int -> int -> option (int * a).
    
    Parameter write : forall {a : Set},
      encoding a -> a -> MBytes.t -> int -> int -> option int.
    
    Parameter to_bytes : forall {a : Set}, encoding a -> a -> option MBytes.t.
    
    Parameter to_bytes_exn : forall {a : Set}, encoding a -> a -> MBytes.t.
    
    Parameter of_bytes : forall {a : Set}, encoding a -> MBytes.t -> option a.
    
    Parameter write_error : Set.
    
    (* exception Write_error *)
  End Binary.
  
  Parameter check_size : forall {a : Set}, int -> encoding a -> encoding a.
End Data_encoding.

Module Type Error_monad_type.
  Inductive error_category : Set :=
  | Permanent : error_category
  | Temporary : error_category
  | Branch : error_category.
  
  Definition __error : Set := extensible_type.
  
  Parameter pp : Format.formatter -> __error -> unit.
  
  Parameter error_encoding : Data_encoding.t __error.
  
  Parameter json_of_error : __error -> Data_encoding.json.
  
  Parameter error_of_json : Data_encoding.json -> __error.
  
  Module error_info.
    Record record : Set := Build {
      category : error_category;
      id : string;
      title : string;
      description : string;
      schema : Data_encoding.json_schema }.
    Definition with_category category (r : record) :=
      Build category r.(id) r.(title) r.(description) r.(schema).
    Definition with_id id (r : record) :=
      Build r.(category) id r.(title) r.(description) r.(schema).
    Definition with_title title (r : record) :=
      Build r.(category) r.(id) title r.(description) r.(schema).
    Definition with_description description (r : record) :=
      Build r.(category) r.(id) r.(title) description r.(schema).
    Definition with_schema schema (r : record) :=
      Build r.(category) r.(id) r.(title) r.(description) schema.
  End error_info.
  Definition error_info := error_info.record.
  
  Parameter pp_info : Format.formatter -> error_info -> unit.
  
  Parameter get_registered_errors : unit -> list error_info.
  
  Parameter register_error_kind : forall {err : Set},
    error_category -> string -> string -> string ->
    option (Format.formatter -> err -> unit) -> Data_encoding.t err ->
    (__error -> option err) -> (err -> __error) -> unit.
  
  Parameter classify_errors : list __error -> error_category.
  
  Definition tzresult (a : Set) : Set := Pervasives.result a (list __error).
  
  Parameter result_encoding : forall {a : Set},
    Data_encoding.t a -> Data_encoding.encoding (tzresult a).
  
  Parameter ok : forall {a : Set}, a -> tzresult a.
  
  Parameter __return : forall {a : Set}, a -> Lwt.t (tzresult a).
  
  Parameter return_unit : Lwt.t (tzresult unit).
  
  Parameter return_none : forall {a : Set}, Lwt.t (tzresult (option a)).
  
  Parameter return_some : forall {a : Set}, a -> Lwt.t (tzresult (option a)).
  
  Parameter return_nil : forall {a : Set}, Lwt.t (tzresult (list a)).
  
  Parameter return_true : Lwt.t (tzresult bool).
  
  Parameter return_false : Lwt.t (tzresult bool).
  
  Parameter __error_value : forall {a : Set}, __error -> tzresult a.
  
  Parameter fail : forall {a : Set}, __error -> Lwt.t (tzresult a).
  
  Parameter op_gtgtquestion : forall {a b : Set},
    tzresult a -> (a -> tzresult b) -> tzresult b.
  
  Parameter op_gtgteqquestion : forall {a b : Set},
    Lwt.t (tzresult a) -> (a -> Lwt.t (tzresult b)) -> Lwt.t (tzresult b).
  
  Parameter op_gtgteq : forall {a b : Set},
    Lwt.t a -> (a -> Lwt.t b) -> Lwt.t b.
  
  Parameter op_gtpipeeq : forall {a b : Set}, Lwt.t a -> (a -> b) -> Lwt.t b.
  
  Parameter op_gtgtpipequestion : forall {a b : Set},
    Lwt.t (tzresult a) -> (a -> b) -> Lwt.t (tzresult b).
  
  Parameter op_gtpipequestion : forall {a b : Set},
    tzresult a -> (a -> b) -> tzresult b.
  
  Parameter record_trace : forall {a : Set},
    __error -> tzresult a -> tzresult a.
  
  Parameter trace : forall {b : Set},
    __error -> Lwt.t (tzresult b) -> Lwt.t (tzresult b).
  
  Parameter record_trace_eval : forall {a : Set},
    (unit -> tzresult __error) -> tzresult a -> tzresult a.
  
  Parameter trace_eval : forall {b : Set},
    (unit -> Lwt.t (tzresult __error)) -> Lwt.t (tzresult b) ->
    Lwt.t (tzresult b).
  
  Parameter fail_unless : bool -> __error -> Lwt.t (tzresult unit).
  
  Parameter fail_when : bool -> __error -> Lwt.t (tzresult unit).
  
  Parameter iter_s : forall {a : Set},
    (a -> Lwt.t (tzresult unit)) -> list a -> Lwt.t (tzresult unit).
  
  Parameter iter_p : forall {a : Set},
    (a -> Lwt.t (tzresult unit)) -> list a -> Lwt.t (tzresult unit).
  
  Parameter map_s : forall {a b : Set},
    (a -> Lwt.t (tzresult b)) -> list a -> Lwt.t (tzresult (list b)).
  
  Parameter map_p : forall {a b : Set},
    (a -> Lwt.t (tzresult b)) -> list a -> Lwt.t (tzresult (list b)).
  
  Parameter map2 : forall {a b c : Set},
    (a -> b -> tzresult c) -> list a -> list b -> tzresult (list c).
  
  Parameter map2_s : forall {a b c : Set},
    (a -> b -> Lwt.t (tzresult c)) -> list a -> list b ->
    Lwt.t (tzresult (list c)).
  
  Parameter filter_map_s : forall {a b : Set},
    (a -> Lwt.t (tzresult (option b))) -> list a -> Lwt.t (tzresult (list b)).
  
  Parameter fold_left_s : forall {a b : Set},
    (a -> b -> Lwt.t (tzresult a)) -> a -> list b -> Lwt.t (tzresult a).
  
  Parameter fold_right_s : forall {a b : Set},
    (a -> b -> Lwt.t (tzresult b)) -> list a -> b -> Lwt.t (tzresult b).
  
  Parameter shell_error : Set.
  
  Definition shell_tzresult (a : Set) : Set :=
    Pervasives.result a (list shell_error).
End Error_monad_type.

Module Error_monad.
  Inductive error_category : Set :=
  | Permanent : error_category
  | Temporary : error_category
  | Branch : error_category.
  
  Definition __error : Set := extensible_type.
  
  Parameter pp : Format.formatter -> __error -> unit.
  
  Parameter error_encoding : Data_encoding.t __error.
  
  Parameter json_of_error : __error -> Data_encoding.json.
  
  Parameter error_of_json : Data_encoding.json -> __error.
  
  Module error_info.
    Record record : Set := Build {
      category : error_category;
      id : string;
      title : string;
      description : string;
      schema : Data_encoding.json_schema }.
    Definition with_category category (r : record) :=
      Build category r.(id) r.(title) r.(description) r.(schema).
    Definition with_id id (r : record) :=
      Build r.(category) id r.(title) r.(description) r.(schema).
    Definition with_title title (r : record) :=
      Build r.(category) r.(id) title r.(description) r.(schema).
    Definition with_description description (r : record) :=
      Build r.(category) r.(id) r.(title) description r.(schema).
    Definition with_schema schema (r : record) :=
      Build r.(category) r.(id) r.(title) r.(description) schema.
  End error_info.
  Definition error_info := error_info.record.
  
  Parameter pp_info : Format.formatter -> error_info -> unit.
  
  Parameter get_registered_errors : unit -> list error_info.
  
  Parameter register_error_kind : forall {err : Set},
    error_category -> string -> string -> string ->
    option (Format.formatter -> err -> unit) -> Data_encoding.t err ->
    (__error -> option err) -> (err -> __error) -> unit.
  
  Parameter classify_errors : list __error -> error_category.
  
  Definition tzresult (a : Set) : Set := Pervasives.result a (list __error).
  
  Parameter result_encoding : forall {a : Set},
    Data_encoding.t a -> Data_encoding.encoding (tzresult a).
  
  Definition ok {a : Set} (x : a) : tzresult a := Pervasives.Ok x.
  
  Definition __return {a : Set} (x : a) : Lwt.t (tzresult a) :=
    Lwt.__return (ok x).
  
  Parameter return_unit : Lwt.t (tzresult unit).
  
  Parameter return_none : forall {a : Set}, Lwt.t (tzresult (option a)).
  
  Parameter return_some : forall {a : Set}, a -> Lwt.t (tzresult (option a)).
  
  Parameter return_nil : forall {a : Set}, Lwt.t (tzresult (list a)).
  
  Parameter return_true : Lwt.t (tzresult bool).
  
  Parameter return_false : Lwt.t (tzresult bool).
  
  Parameter __error_value : forall {a : Set}, __error -> tzresult a.
  
  Parameter fail : forall {a : Set}, __error -> Lwt.t (tzresult a).
  
  Definition op_gtgtquestion {a b : Set}
    : tzresult a -> (a -> tzresult b) -> tzresult b :=
    fun x f =>
    match x with
    | Pervasives.Ok x => f x
    | Pervasives.Error error => Pervasives.Error error
    end.
  
  Definition op_gtgteqquestion {a b : Set}
    : Lwt.t (tzresult a) -> (a -> Lwt.t (tzresult b)) -> Lwt.t (tzresult b) :=
    fun x f =>
    Lwt.bind x (fun x =>
      match x with
      | Pervasives.Ok x => f x
      | Pervasives.Error error => Lwt.__return (Pervasives.Error error)
      end
    ).
  
  Parameter op_gtgteq : forall {a b : Set},
    Lwt.t a -> (a -> Lwt.t b) -> Lwt.t b.
  
  Parameter op_gtpipeeq : forall {a b : Set}, Lwt.t a -> (a -> b) -> Lwt.t b.
  
  Parameter op_gtgtpipequestion : forall {a b : Set},
    Lwt.t (tzresult a) -> (a -> b) -> Lwt.t (tzresult b).
  
  Parameter op_gtpipequestion : forall {a b : Set},
    tzresult a -> (a -> b) -> tzresult b.
  
  Parameter record_trace : forall {a : Set},
    __error -> tzresult a -> tzresult a.
  
  Parameter trace : forall {b : Set},
    __error -> Lwt.t (tzresult b) -> Lwt.t (tzresult b).
  
  Parameter record_trace_eval : forall {a : Set},
    (unit -> tzresult __error) -> tzresult a -> tzresult a.
  
  Parameter trace_eval : forall {b : Set},
    (unit -> Lwt.t (tzresult __error)) -> Lwt.t (tzresult b) ->
    Lwt.t (tzresult b).
  
  Parameter fail_unless : bool -> __error -> Lwt.t (tzresult unit).
  
  Parameter fail_when : bool -> __error -> Lwt.t (tzresult unit).
  
  Parameter iter_s : forall {a : Set},
    (a -> Lwt.t (tzresult unit)) -> list a -> Lwt.t (tzresult unit).
  
  Parameter iter_p : forall {a : Set},
    (a -> Lwt.t (tzresult unit)) -> list a -> Lwt.t (tzresult unit).
  
  Parameter map_s : forall {a b : Set},
    (a -> Lwt.t (tzresult b)) -> list a -> Lwt.t (tzresult (list b)).
  
  Parameter map_p : forall {a b : Set},
    (a -> Lwt.t (tzresult b)) -> list a -> Lwt.t (tzresult (list b)).
  
  Parameter map2 : forall {a b c : Set},
    (a -> b -> tzresult c) -> list a -> list b -> tzresult (list c).
  
  Parameter map2_s : forall {a b c : Set},
    (a -> b -> Lwt.t (tzresult c)) -> list a -> list b ->
    Lwt.t (tzresult (list c)).
  
  Parameter filter_map_s : forall {a b : Set},
    (a -> Lwt.t (tzresult (option b))) -> list a -> Lwt.t (tzresult (list b)).
  
  Parameter fold_left_s : forall {a b : Set},
    (a -> b -> Lwt.t (tzresult a)) -> a -> list b -> Lwt.t (tzresult a).
  
  Parameter fold_right_s : forall {a b : Set},
    (a -> b -> Lwt.t (tzresult b)) -> list a -> b -> Lwt.t (tzresult b).
  
  Parameter shell_error : Set.
  
  Definition shell_tzresult (a : Set) : Set :=
    Pervasives.result a (list shell_error).
End Error_monad.

Module Error_monad_check : Error_monad_type := Error_monad.

Import Error_monad.

Module Logging.
  Parameter debug : forall {a : Set},
    Pervasives.format4 a Format.formatter unit unit -> a.
  
  Parameter log_info : forall {a : Set},
    Pervasives.format4 a Format.formatter unit unit -> a.
  
  Parameter log_notice : forall {a : Set},
    Pervasives.format4 a Format.formatter unit unit -> a.
  
  Parameter warn : forall {a : Set},
    Pervasives.format4 a Format.formatter unit unit -> a.
  
  Parameter log_error : forall {a : Set},
    Pervasives.format4 a Format.formatter unit unit -> a.
  
  Parameter fatal_error : forall {a : Set},
    Pervasives.format4 a Format.formatter unit unit -> a.
  
  Parameter lwt_debug : forall {a : Set},
    Pervasives.format4 a Format.formatter unit (Lwt.t unit) -> a.
  
  Parameter lwt_log_info : forall {a : Set},
    Pervasives.format4 a Format.formatter unit (Lwt.t unit) -> a.
  
  Parameter lwt_log_notice : forall {a : Set},
    Pervasives.format4 a Format.formatter unit (Lwt.t unit) -> a.
  
  Parameter lwt_warn : forall {a : Set},
    Pervasives.format4 a Format.formatter unit (Lwt.t unit) -> a.
  
  Parameter lwt_log_error : forall {a : Set},
    Pervasives.format4 a Format.formatter unit (Lwt.t unit) -> a.
End Logging.

Module Time.
  Parameter t : Set.
  
  Parameter Included_S : {_ : unit & Compare.S.signature (t := t)}.
  
  Definition op_eq : t -> t -> bool := (|Included_S|).(Compare.S.op_eq).
  
  Definition op_ltgt : t -> t -> bool := (|Included_S|).(Compare.S.op_ltgt).
  
  Definition op_lt : t -> t -> bool := (|Included_S|).(Compare.S.op_lt).
  
  Definition op_lteq : t -> t -> bool := (|Included_S|).(Compare.S.op_lteq).
  
  Definition op_gteq : t -> t -> bool := (|Included_S|).(Compare.S.op_gteq).
  
  Definition op_gt : t -> t -> bool := (|Included_S|).(Compare.S.op_gt).
  
  Definition compare : t -> t -> int := (|Included_S|).(Compare.S.compare).
  
  Definition equal : t -> t -> bool := (|Included_S|).(Compare.S.equal).
  
  Definition max : t -> t -> t := (|Included_S|).(Compare.S.max).
  
  Definition min : t -> t -> t := (|Included_S|).(Compare.S.min).
  
  Parameter add : t -> int64 -> t.
  
  Parameter diff : t -> t -> int64.
  
  Parameter of_seconds : int64 -> t.
  
  Parameter to_seconds : t -> int64.
  
  Parameter of_notation : string -> option t.
  
  Parameter of_notation_exn : string -> t.
  
  Parameter to_notation : t -> string.
  
  Parameter encoding : Data_encoding.t t.
  
  Parameter rfc_encoding : Data_encoding.t t.
  
  Parameter pp_hum : Format.formatter -> t -> unit.
End Time.

Module Option.
  Parameter map : forall {a b : Set}, (a -> b) -> option a -> option b.
  
  Parameter apply : forall {a b : Set}, (a -> option b) -> option a -> option b.
  
  Parameter iter : forall {a : Set}, (a -> unit) -> option a -> unit.
  
  Parameter unopt : forall {a : Set}, a -> option a -> a.
  
  Parameter unopt_map : forall {a b : Set}, (a -> b) -> b -> option a -> b.
  
  Parameter first_some : forall {a : Set}, option a -> option a -> option a.
  
  Parameter try_with : forall {a : Set}, (unit -> a) -> option a.
  
  Parameter some : forall {a : Set}, a -> option a.
End Option.

Module RPC_arg.
  Parameter t : forall (a : Set), Set.
  
  Definition arg (a : Set) : Set := t a.
  
  Parameter make : forall {a : Set},
    option string -> string -> (string -> Pervasives.result a string) ->
    (a -> string) -> unit -> arg a.
  
  Module descr.
    Record record : Set := Build {
      name : string;
      descr : option string }.
    Definition with_name name (r : record) :=
      Build name r.(descr).
    Definition with_descr descr (r : record) :=
      Build r.(name) descr.
  End descr.
  Definition descr := descr.record.
  
  Parameter __descr_value : forall {a : Set}, arg a -> descr.
  
  Parameter __int_value : arg int.
  
  Parameter __int32_value : arg int32.
  
  Parameter __int64_value : arg int64.
  
  Parameter __float_value : arg float.
  
  Parameter __string_value : arg string.
  
  Parameter like : forall {a : Set}, arg a -> option string -> string -> arg a.
  
  Inductive eq : Set :=
  | Eq : eq.
  
  Parameter __eq_value : forall {a b : Set}, arg a -> arg b -> option eq.
End RPC_arg.

Module RPC_path.
  Parameter t : forall (prefix params : Set), Set.
  
  Definition path (prefix params : Set) : Set := t prefix params.
  
  Definition context (prefix : Set) : Set := path prefix prefix.
  
  Parameter root : context unit.
  
  Parameter open_root : forall {a : Set}, context a.
  
  Parameter add_suffix : forall {params prefix : Set},
    path prefix params -> string -> path prefix params.
  
  Parameter op_div : forall {params prefix : Set},
    path prefix params -> string -> path prefix params.
  
  Parameter add_arg : forall {a params prefix : Set},
    path prefix params -> RPC_arg.t a -> path prefix (params * a).
  
  Parameter op_divcolon : forall {a params prefix : Set},
    path prefix params -> RPC_arg.t a -> path prefix (params * a).
  
  Parameter add_final_args : forall {a params prefix : Set},
    path prefix params -> RPC_arg.t a -> path prefix (params * list a).
  
  Parameter op_divcolonstar : forall {a params prefix : Set},
    path prefix params -> RPC_arg.t a -> path prefix (params * list a).
End RPC_path.

Module RPC_query.
  Parameter t : forall (a : Set), Set.
  
  Definition query (a : Set) : Set := t a.
  
  Parameter empty : query unit.
  
  Parameter field : forall (a b : Set), Set.
  
  Parameter __field_value : forall {a b : Set},
    option string -> string -> RPC_arg.t a -> a -> (b -> a) -> field b a.
  
  Parameter opt_field : forall {a b : Set},
    option string -> string -> RPC_arg.t a -> (b -> option a) ->
    field b (option a).
  
  Parameter flag : forall {b : Set},
    option string -> string -> (b -> bool) -> field b bool.
  
  Parameter multi_field : forall {a b : Set},
    option string -> string -> RPC_arg.t a -> (b -> list a) -> field b (list a).
  
  Parameter open_query : forall (a b c : Set), Set.
  
  Parameter __query_value : forall {a b : Set}, b -> open_query a b b.
  
  Parameter op_pipeplus : forall {a b c d : Set},
    open_query a b (c -> d) -> field a c -> open_query a b d.
  
  Parameter seal : forall {a b : Set}, open_query a b a -> t a.
  
  Definition untyped : Set := list (string * string).
  
  (* exception Invalid *)
  
  Parameter parse : forall {a : Set}, query a -> untyped -> a.
End RPC_query.

Module RPC_service.
  Inductive meth : Set :=
  | PUT : meth
  | GET : meth
  | DELETE : meth
  | POST : meth
  | PATCH : meth.
  
  Parameter t : forall (prefix params query input output : Set), Set.
  
  Definition service (prefix params query input output : Set) : Set :=
    t prefix params query input output.
  
  Parameter get_service : forall {output params prefix query : Set},
    option string -> RPC_query.t query -> Data_encoding.t output ->
    RPC_path.t prefix params -> service prefix params query unit output.
  
  Parameter post_service : forall {input output params prefix query : Set},
    option string -> RPC_query.t query -> Data_encoding.t input ->
    Data_encoding.t output -> RPC_path.t prefix params ->
    service prefix params query input output.
  
  Parameter delete_service : forall {output params prefix query : Set},
    option string -> RPC_query.t query -> Data_encoding.t output ->
    RPC_path.t prefix params -> service prefix params query unit output.
  
  Parameter patch_service : forall {input output params prefix query : Set},
    option string -> RPC_query.t query -> Data_encoding.t input ->
    Data_encoding.t output -> RPC_path.t prefix params ->
    service prefix params query input output.
  
  Parameter put_service : forall {input output params prefix query : Set},
    option string -> RPC_query.t query -> Data_encoding.t input ->
    Data_encoding.t output -> RPC_path.t prefix params ->
    service prefix params query input output.
End RPC_service.

Module RPC_answer.
  Module stream.
    Record record {next shutdown : Set} : Set := Build {
      next : next;
      shutdown : shutdown }.
    Arguments record : clear implicits.
    Definition with_next {t_next t_shutdown} next
      (r : record t_next t_shutdown) :=
      Build t_next t_shutdown next r.(shutdown).
    Definition with_shutdown {t_next t_shutdown} shutdown
      (r : record t_next t_shutdown) :=
      Build t_next t_shutdown r.(next) shutdown.
  End stream.
  Definition stream_skeleton := stream.record.
  
  Reserved Notation "'stream".
  
  Inductive t (o : Set) : Set :=
  | OkStream : 'stream o -> t o
  | Unauthorized : option (list Error_monad.__error) -> t o
  | Error : option (list Error_monad.__error) -> t o
  | Ok : o -> t o
  | Not_found : option (list Error_monad.__error) -> t o
  | Forbidden : option (list Error_monad.__error) -> t o
  | Created : option string -> t o
  | Conflict : option (list Error_monad.__error) -> t o
  | No_content : t o
  
  where "'stream" := (fun (t_a : Set) =>
    stream_skeleton (unit -> Lwt.t (option t_a)) (unit -> unit)).
  
  Definition stream := 'stream.
  
  Arguments OkStream {_}.
  Arguments Unauthorized {_}.
  Arguments Error {_}.
  Arguments Ok {_}.
  Arguments Not_found {_}.
  Arguments Forbidden {_}.
  Arguments Created {_}.
  Arguments Conflict {_}.
  Arguments No_content {_}.
  
  Parameter __return : forall {o : Set}, o -> Lwt.t (t o).
  
  Parameter return_stream : forall {o : Set}, stream o -> Lwt.t (t o).
  
  Parameter not_found : forall {o : Set}, Lwt.t (t o).
  
  Parameter fail : forall {a : Set}, list Error_monad.__error -> Lwt.t (t a).
End RPC_answer.

Module RPC_directory.
  Parameter t : forall (prefix : Set), Set.
  
  Definition directory (prefix : Set) : Set := t prefix.
  
  Parameter empty : forall {prefix : Set}, directory prefix.
  
  Parameter map : forall {a b : Set},
    (a -> Lwt.t b) -> directory b -> directory a.
  
  Parameter prefix : forall {p pr : Set},
    RPC_path.path pr p -> directory p -> directory pr.
  
  Parameter merge : forall {a : Set}, directory a -> directory a -> directory a.
  
  Inductive step : Set :=
  | Static : string -> step
  | Dynamic : RPC_arg.descr -> step
  | DynamicTail : RPC_arg.descr -> step.
  
  Inductive conflict : Set :=
  | CService : RPC_service.meth -> conflict
  | CDir : conflict
  | CBuilder : conflict
  | CTail : conflict
  | CTypes : RPC_arg.descr -> RPC_arg.descr -> conflict
  | CType : RPC_arg.descr -> list string -> conflict.
  
  (* exception Conflict *)
  
  Parameter register : forall {input output params prefix query : Set},
    directory prefix -> RPC_service.t prefix params query input output ->
    (params -> query -> input -> Lwt.t (Error_monad.tzresult output)) ->
    directory prefix.
  
  Parameter opt_register : forall {input output params prefix query : Set},
    directory prefix -> RPC_service.t prefix params query input output ->
    (params -> query -> input -> Lwt.t (Error_monad.tzresult (option output)))
    -> directory prefix.
  
  Parameter gen_register : forall {input output params prefix query : Set},
    directory prefix -> RPC_service.t prefix params query input output ->
    (params -> query -> input ->
    Lwt.t
      ((* `OkStream *) RPC_answer.stream output +
        (* `Unauthorized *) option (list Error_monad.__error) +
        (* `Error *) option (list Error_monad.__error) + (* `Ok *) output +
        (* `Not_found *) option (list Error_monad.__error) +
        (* `Forbidden *) option (list Error_monad.__error) +
        (* `Created *) option string +
        (* `Conflict *) option (list Error_monad.__error) +
        (* `No_content *) unit)) -> directory prefix.
  
  Parameter lwt_register : forall {input output params prefix query : Set},
    directory prefix -> RPC_service.t prefix params query input output ->
    (params -> query -> input -> Lwt.t output) -> directory prefix.
  
  Parameter register0 : forall {i o q : Set},
    directory unit -> RPC_service.t unit unit q i o ->
    (q -> i -> Lwt.t (Error_monad.tzresult o)) -> directory unit.
  
  Parameter register1 : forall {a i o prefix q : Set},
    directory prefix -> RPC_service.t prefix (unit * a) q i o ->
    (a -> q -> i -> Lwt.t (Error_monad.tzresult o)) -> directory prefix.
  
  Parameter register2 : forall {a b i o prefix q : Set},
    directory prefix -> RPC_service.t prefix ((unit * a) * b) q i o ->
    (a -> b -> q -> i -> Lwt.t (Error_monad.tzresult o)) -> directory prefix.
  
  Parameter register3 : forall {a b c i o prefix q : Set},
    directory prefix -> RPC_service.t prefix (((unit * a) * b) * c) q i o ->
    (a -> b -> c -> q -> i -> Lwt.t (Error_monad.tzresult o)) ->
    directory prefix.
  
  Parameter register4 : forall {a b c d i o prefix q : Set},
    directory prefix ->
    RPC_service.t prefix ((((unit * a) * b) * c) * d) q i o ->
    (a -> b -> c -> d -> q -> i -> Lwt.t (Error_monad.tzresult o)) ->
    directory prefix.
  
  Parameter register5 : forall {a b c d e i o prefix q : Set},
    directory prefix ->
    RPC_service.t prefix (((((unit * a) * b) * c) * d) * e) q i o ->
    (a -> b -> c -> d -> e -> q -> i -> Lwt.t (Error_monad.tzresult o)) ->
    directory prefix.
  
  Parameter opt_register0 : forall {i o q : Set},
    directory unit -> RPC_service.t unit unit q i o ->
    (q -> i -> Lwt.t (Error_monad.tzresult (option o))) -> directory unit.
  
  Parameter opt_register1 : forall {a i o prefix q : Set},
    directory prefix -> RPC_service.t prefix (unit * a) q i o ->
    (a -> q -> i -> Lwt.t (Error_monad.tzresult (option o))) -> directory prefix.
  
  Parameter opt_register2 : forall {a b i o prefix q : Set},
    directory prefix -> RPC_service.t prefix ((unit * a) * b) q i o ->
    (a -> b -> q -> i -> Lwt.t (Error_monad.tzresult (option o))) ->
    directory prefix.
  
  Parameter opt_register3 : forall {a b c i o prefix q : Set},
    directory prefix -> RPC_service.t prefix (((unit * a) * b) * c) q i o ->
    (a -> b -> c -> q -> i -> Lwt.t (Error_monad.tzresult (option o))) ->
    directory prefix.
  
  Parameter opt_register4 : forall {a b c d i o prefix q : Set},
    directory prefix ->
    RPC_service.t prefix ((((unit * a) * b) * c) * d) q i o ->
    (a -> b -> c -> d -> q -> i -> Lwt.t (Error_monad.tzresult (option o))) ->
    directory prefix.
  
  Parameter opt_register5 : forall {a b c d e i o prefix q : Set},
    directory prefix ->
    RPC_service.t prefix (((((unit * a) * b) * c) * d) * e) q i o ->
    (a -> b -> c -> d -> e -> q -> i -> Lwt.t (Error_monad.tzresult (option o)))
    -> directory prefix.
  
  Parameter gen_register0 : forall {i o q : Set},
    directory unit -> RPC_service.t unit unit q i o ->
    (q -> i ->
    Lwt.t
      ((* `OkStream *) RPC_answer.stream o +
        (* `Unauthorized *) option (list Error_monad.__error) +
        (* `Error *) option (list Error_monad.__error) + (* `Ok *) o +
        (* `Not_found *) option (list Error_monad.__error) +
        (* `Forbidden *) option (list Error_monad.__error) +
        (* `Created *) option string +
        (* `Conflict *) option (list Error_monad.__error) +
        (* `No_content *) unit)) -> directory unit.
  
  Parameter gen_register1 : forall {a i o prefix q : Set},
    directory prefix -> RPC_service.t prefix (unit * a) q i o ->
    (a -> q -> i ->
    Lwt.t
      ((* `OkStream *) RPC_answer.stream o +
        (* `Unauthorized *) option (list Error_monad.__error) +
        (* `Error *) option (list Error_monad.__error) + (* `Ok *) o +
        (* `Not_found *) option (list Error_monad.__error) +
        (* `Forbidden *) option (list Error_monad.__error) +
        (* `Created *) option string +
        (* `Conflict *) option (list Error_monad.__error) +
        (* `No_content *) unit)) -> directory prefix.
  
  Parameter gen_register2 : forall {a b i o prefix q : Set},
    directory prefix -> RPC_service.t prefix ((unit * a) * b) q i o ->
    (a -> b -> q -> i ->
    Lwt.t
      ((* `OkStream *) RPC_answer.stream o +
        (* `Unauthorized *) option (list Error_monad.__error) +
        (* `Error *) option (list Error_monad.__error) + (* `Ok *) o +
        (* `Not_found *) option (list Error_monad.__error) +
        (* `Forbidden *) option (list Error_monad.__error) +
        (* `Created *) option string +
        (* `Conflict *) option (list Error_monad.__error) +
        (* `No_content *) unit)) -> directory prefix.
  
  Parameter gen_register3 : forall {a b c i o prefix q : Set},
    directory prefix -> RPC_service.t prefix (((unit * a) * b) * c) q i o ->
    (a -> b -> c -> q -> i ->
    Lwt.t
      ((* `OkStream *) RPC_answer.stream o +
        (* `Unauthorized *) option (list Error_monad.__error) +
        (* `Error *) option (list Error_monad.__error) + (* `Ok *) o +
        (* `Not_found *) option (list Error_monad.__error) +
        (* `Forbidden *) option (list Error_monad.__error) +
        (* `Created *) option string +
        (* `Conflict *) option (list Error_monad.__error) +
        (* `No_content *) unit)) -> directory prefix.
  
  Parameter gen_register4 : forall {a b c d i o prefix q : Set},
    directory prefix ->
    RPC_service.t prefix ((((unit * a) * b) * c) * d) q i o ->
    (a -> b -> c -> d -> q -> i ->
    Lwt.t
      ((* `OkStream *) RPC_answer.stream o +
        (* `Unauthorized *) option (list Error_monad.__error) +
        (* `Error *) option (list Error_monad.__error) + (* `Ok *) o +
        (* `Not_found *) option (list Error_monad.__error) +
        (* `Forbidden *) option (list Error_monad.__error) +
        (* `Created *) option string +
        (* `Conflict *) option (list Error_monad.__error) +
        (* `No_content *) unit)) -> directory prefix.
  
  Parameter gen_register5 : forall {a b c d e i o prefix q : Set},
    directory prefix ->
    RPC_service.t prefix (((((unit * a) * b) * c) * d) * e) q i o ->
    (a -> b -> c -> d -> e -> q -> i ->
    Lwt.t
      ((* `OkStream *) RPC_answer.stream o +
        (* `Unauthorized *) option (list Error_monad.__error) +
        (* `Error *) option (list Error_monad.__error) + (* `Ok *) o +
        (* `Not_found *) option (list Error_monad.__error) +
        (* `Forbidden *) option (list Error_monad.__error) +
        (* `Created *) option string +
        (* `Conflict *) option (list Error_monad.__error) +
        (* `No_content *) unit)) -> directory prefix.
  
  Parameter lwt_register0 : forall {i o q : Set},
    directory unit -> RPC_service.t unit unit q i o -> (q -> i -> Lwt.t o) ->
    directory unit.
  
  Parameter lwt_register1 : forall {a i o prefix q : Set},
    directory prefix -> RPC_service.t prefix (unit * a) q i o ->
    (a -> q -> i -> Lwt.t o) -> directory prefix.
  
  Parameter lwt_register2 : forall {a b i o prefix q : Set},
    directory prefix -> RPC_service.t prefix ((unit * a) * b) q i o ->
    (a -> b -> q -> i -> Lwt.t o) -> directory prefix.
  
  Parameter lwt_register3 : forall {a b c i o prefix q : Set},
    directory prefix -> RPC_service.t prefix (((unit * a) * b) * c) q i o ->
    (a -> b -> c -> q -> i -> Lwt.t o) -> directory prefix.
  
  Parameter lwt_register4 : forall {a b c d i o prefix q : Set},
    directory prefix ->
    RPC_service.t prefix ((((unit * a) * b) * c) * d) q i o ->
    (a -> b -> c -> d -> q -> i -> Lwt.t o) -> directory prefix.
  
  Parameter lwt_register5 : forall {a b c d e i o prefix q : Set},
    directory prefix ->
    RPC_service.t prefix (((((unit * a) * b) * c) * d) * e) q i o ->
    (a -> b -> c -> d -> e -> q -> i -> Lwt.t o) -> directory prefix.
  
  Parameter register_dynamic_directory : forall {a prefix : Set},
    option string -> directory prefix -> RPC_path.t prefix a ->
    (a -> Lwt.t (directory a)) -> directory prefix.
End RPC_directory.

Module Base58.
  Parameter encoding : forall (a : Set), Set.
  
  Parameter simple_decode : forall {a : Set}, encoding a -> string -> option a.
  
  Parameter simple_encode : forall {a : Set}, encoding a -> a -> string.
  
  Definition data : Set := extensible_type.
  
  Parameter register_encoding : forall {a : Set},
    string -> int -> (a -> string) -> (string -> option a) -> (a -> data) ->
    encoding a.
  
  Parameter check_encoded_prefix : forall {a : Set},
    encoding a -> string -> int -> unit.
  
  Parameter decode : string -> option data.
End Base58.

Module S.
  Module T.
    Record signature {t : Set} : Set := {
      t := t;
      op_eq : t -> t -> bool;
      op_ltgt : t -> t -> bool;
      op_lt : t -> t -> bool;
      op_lteq : t -> t -> bool;
      op_gteq : t -> t -> bool;
      op_gt : t -> t -> bool;
      compare : t -> t -> int;
      equal : t -> t -> bool;
      max : t -> t -> t;
      min : t -> t -> t;
      pp : Format.formatter -> t -> unit;
      encoding : Data_encoding.t t;
      to_bytes : t -> MBytes.t;
      of_bytes : MBytes.t -> option t;
    }.
  End T.
  
  Module HASHABLE.
    Record signature {t hash : Set} : Set := {
      t := t;
      op_eq : t -> t -> bool;
      op_ltgt : t -> t -> bool;
      op_lt : t -> t -> bool;
      op_lteq : t -> t -> bool;
      op_gteq : t -> t -> bool;
      op_gt : t -> t -> bool;
      compare : t -> t -> int;
      equal : t -> t -> bool;
      max : t -> t -> t;
      min : t -> t -> t;
      pp : Format.formatter -> t -> unit;
      encoding : Data_encoding.t t;
      to_bytes : t -> MBytes.t;
      of_bytes : MBytes.t -> option t;
      hash := hash;
      __hash_value : t -> hash;
      hash_raw : MBytes.t -> hash;
    }.
  End HASHABLE.
  
  Module MINIMAL_HASH.
    Record signature {t : Set} : Set := {
      t := t;
      name : string;
      title : string;
      pp : Format.formatter -> t -> unit;
      pp_short : Format.formatter -> t -> unit;
      op_eq : t -> t -> bool;
      op_ltgt : t -> t -> bool;
      op_lt : t -> t -> bool;
      op_lteq : t -> t -> bool;
      op_gteq : t -> t -> bool;
      op_gt : t -> t -> bool;
      compare : t -> t -> int;
      equal : t -> t -> bool;
      max : t -> t -> t;
      min : t -> t -> t;
      hash_bytes : option MBytes.t -> list MBytes.t -> t;
      hash_string : option string -> list string -> t;
      zero : t;
    }.
  End MINIMAL_HASH.
  
  Module RAW_DATA.
    Record signature {t : Set} : Set := {
      t := t;
      size : int;
      to_bytes : t -> MBytes.t;
      of_bytes_opt : MBytes.t -> option t;
      of_bytes_exn : MBytes.t -> t;
    }.
  End RAW_DATA.
  
  Module B58_DATA.
    Record signature {t : Set} : Set := {
      t := t;
      to_b58check : t -> string;
      to_short_b58check : t -> string;
      of_b58check_exn : string -> t;
      of_b58check_opt : string -> option t;
      (* extensible_type data *)
      b58check_encoding : Base58.encoding t;
    }.
  End B58_DATA.
  
  Module ENCODER.
    Record signature {t : Set} : Set := {
      t := t;
      encoding : Data_encoding.t t;
      rpc_arg : RPC_arg.t t;
    }.
  End ENCODER.
  
  Module SET.
    Record signature {elt t : Set} : Set := {
      elt := elt;
      t := t;
      empty : t;
      is_empty : t -> bool;
      mem : elt -> t -> bool;
      add : elt -> t -> t;
      singleton : elt -> t;
      remove : elt -> t -> t;
      union : t -> t -> t;
      inter : t -> t -> t;
      diff : t -> t -> t;
      compare : t -> t -> int;
      equal : t -> t -> bool;
      subset : t -> t -> bool;
      iter : (elt -> unit) -> t -> unit;
      map : (elt -> elt) -> t -> t;
      fold : forall {a : Set}, (elt -> a -> a) -> t -> a -> a;
      for_all : (elt -> bool) -> t -> bool;
      __exists : (elt -> bool) -> t -> bool;
      filter : (elt -> bool) -> t -> t;
      partition : (elt -> bool) -> t -> t * t;
      cardinal : t -> int;
      elements : t -> list elt;
      min_elt_opt : t -> option elt;
      max_elt_opt : t -> option elt;
      choose_opt : t -> option elt;
      split : elt -> t -> t * bool * t;
      find_opt : elt -> t -> option elt;
      find_first_opt : (elt -> bool) -> t -> option elt;
      find_last_opt : (elt -> bool) -> t -> option elt;
      of_list : list elt -> t;
    }.
  End SET.
  
  Module MAP.
    Record signature {key : Set} {t : Set -> Set} : Set := {
      key := key;
      t := t;
      empty : forall {a : Set}, t a;
      is_empty : forall {a : Set}, t a -> bool;
      mem : forall {a : Set}, key -> t a -> bool;
      add : forall {a : Set}, key -> a -> t a -> t a;
      update : forall {a : Set}, key -> (option a -> option a) -> t a -> t a;
      singleton : forall {a : Set}, key -> a -> t a;
      remove : forall {a : Set}, key -> t a -> t a;
      merge : forall {a b c : Set},
        (key -> option a -> option b -> option c) -> t a -> t b -> t c;
      union : forall {a : Set},
        (key -> a -> a -> option a) -> t a -> t a -> t a;
      compare : forall {a : Set}, (a -> a -> int) -> t a -> t a -> int;
      equal : forall {a : Set}, (a -> a -> bool) -> t a -> t a -> bool;
      iter : forall {a : Set}, (key -> a -> unit) -> t a -> unit;
      fold : forall {a b : Set}, (key -> a -> b -> b) -> t a -> b -> b;
      for_all : forall {a : Set}, (key -> a -> bool) -> t a -> bool;
      __exists : forall {a : Set}, (key -> a -> bool) -> t a -> bool;
      filter : forall {a : Set}, (key -> a -> bool) -> t a -> t a;
      partition : forall {a : Set}, (key -> a -> bool) -> t a -> t a * t a;
      cardinal : forall {a : Set}, t a -> int;
      bindings : forall {a : Set}, t a -> list (key * a);
      min_binding_opt : forall {a : Set}, t a -> option (key * a);
      max_binding_opt : forall {a : Set}, t a -> option (key * a);
      choose_opt : forall {a : Set}, t a -> option (key * a);
      split : forall {a : Set}, key -> t a -> t a * option a * t a;
      find_opt : forall {a : Set}, key -> t a -> option a;
      find_first_opt : forall {a : Set},
        (key -> bool) -> t a -> option (key * a);
      find_last_opt : forall {a : Set},
        (key -> bool) -> t a -> option (key * a);
      map : forall {a b : Set}, (a -> b) -> t a -> t b;
      mapi : forall {a b : Set}, (key -> a -> b) -> t a -> t b;
    }.
  End MAP.
  
  Module INDEXES_Set.
    Record signature {elt t : Set} : Set := {
      elt := elt;
      t := t;
      empty : t;
      is_empty : t -> bool;
      mem : elt -> t -> bool;
      add : elt -> t -> t;
      singleton : elt -> t;
      remove : elt -> t -> t;
      union : t -> t -> t;
      inter : t -> t -> t;
      diff : t -> t -> t;
      compare : t -> t -> int;
      equal : t -> t -> bool;
      subset : t -> t -> bool;
      iter : (elt -> unit) -> t -> unit;
      map : (elt -> elt) -> t -> t;
      fold : forall {a : Set}, (elt -> a -> a) -> t -> a -> a;
      for_all : (elt -> bool) -> t -> bool;
      __exists : (elt -> bool) -> t -> bool;
      filter : (elt -> bool) -> t -> t;
      partition : (elt -> bool) -> t -> t * t;
      cardinal : t -> int;
      elements : t -> list elt;
      min_elt : t -> elt;
      min_elt_opt : t -> option elt;
      max_elt : t -> elt;
      max_elt_opt : t -> option elt;
      choose : t -> elt;
      choose_opt : t -> option elt;
      split : elt -> t -> t * bool * t;
      find : elt -> t -> elt;
      find_opt : elt -> t -> option elt;
      find_first : (elt -> bool) -> t -> elt;
      find_first_opt : (elt -> bool) -> t -> option elt;
      find_last : (elt -> bool) -> t -> elt;
      find_last_opt : (elt -> bool) -> t -> option elt;
      of_list : list elt -> t;
      to_seq_from : elt -> t -> OCaml.Seq.t elt;
      to_seq : t -> OCaml.Seq.t elt;
      add_seq : OCaml.Seq.t elt -> t -> t;
      of_seq : OCaml.Seq.t elt -> t;
      encoding : Data_encoding.t t;
    }.
  End INDEXES_Set.
  
  Module INDEXES_Map.
    Record signature {key : Set} {t : Set -> Set} : Set := {
      key := key;
      t := t;
      empty : forall {a : Set}, t a;
      is_empty : forall {a : Set}, t a -> bool;
      mem : forall {a : Set}, key -> t a -> bool;
      add : forall {a : Set}, key -> a -> t a -> t a;
      update : forall {a : Set}, key -> (option a -> option a) -> t a -> t a;
      singleton : forall {a : Set}, key -> a -> t a;
      remove : forall {a : Set}, key -> t a -> t a;
      merge : forall {a b c : Set},
        (key -> option a -> option b -> option c) -> t a -> t b -> t c;
      union : forall {a : Set},
        (key -> a -> a -> option a) -> t a -> t a -> t a;
      compare : forall {a : Set}, (a -> a -> int) -> t a -> t a -> int;
      equal : forall {a : Set}, (a -> a -> bool) -> t a -> t a -> bool;
      iter : forall {a : Set}, (key -> a -> unit) -> t a -> unit;
      fold : forall {a b : Set}, (key -> a -> b -> b) -> t a -> b -> b;
      for_all : forall {a : Set}, (key -> a -> bool) -> t a -> bool;
      __exists : forall {a : Set}, (key -> a -> bool) -> t a -> bool;
      filter : forall {a : Set}, (key -> a -> bool) -> t a -> t a;
      partition : forall {a : Set}, (key -> a -> bool) -> t a -> t a * t a;
      cardinal : forall {a : Set}, t a -> int;
      bindings : forall {a : Set}, t a -> list (key * a);
      min_binding : forall {a : Set}, t a -> key * a;
      min_binding_opt : forall {a : Set}, t a -> option (key * a);
      max_binding : forall {a : Set}, t a -> key * a;
      max_binding_opt : forall {a : Set}, t a -> option (key * a);
      choose : forall {a : Set}, t a -> key * a;
      choose_opt : forall {a : Set}, t a -> option (key * a);
      split : forall {a : Set}, key -> t a -> t a * option a * t a;
      find : forall {a : Set}, key -> t a -> a;
      find_opt : forall {a : Set}, key -> t a -> option a;
      find_first : forall {a : Set}, (key -> bool) -> t a -> key * a;
      find_first_opt : forall {a : Set},
        (key -> bool) -> t a -> option (key * a);
      find_last : forall {a : Set}, (key -> bool) -> t a -> key * a;
      find_last_opt : forall {a : Set},
        (key -> bool) -> t a -> option (key * a);
      map : forall {a b : Set}, (a -> b) -> t a -> t b;
      mapi : forall {a b : Set}, (key -> a -> b) -> t a -> t b;
      to_seq : forall {a : Set}, t a -> OCaml.Seq.t (key * a);
      to_seq_from : forall {a : Set}, key -> t a -> OCaml.Seq.t (key * a);
      add_seq : forall {a : Set}, OCaml.Seq.t (key * a) -> t a -> t a;
      of_seq : forall {a : Set}, OCaml.Seq.t (key * a) -> t a;
      encoding : forall {a : Set}, Data_encoding.t a -> Data_encoding.t (t a);
    }.
  End INDEXES_Map.
  
  Module INDEXES.
    Record signature {t __Set_t : Set} {Map_t : Set -> Set} : Set := {
      t := t;
      to_path : t -> list string -> list string;
      of_path : list string -> option t;
      of_path_exn : list string -> t;
      prefix_path : string -> list string;
      path_length : int;
      __Set : INDEXES_Set.signature (elt := t) (t := __Set_t);
      Map : INDEXES_Map.signature (key := t) (t := Map_t);
    }.
  End INDEXES.
  
  Module HASH.
    Record signature {t __Set_t : Set} {Map_t : Set -> Set} : Set := {
      t := t;
      name : string;
      title : string;
      pp : Format.formatter -> t -> unit;
      pp_short : Format.formatter -> t -> unit;
      op_eq : t -> t -> bool;
      op_ltgt : t -> t -> bool;
      op_lt : t -> t -> bool;
      op_lteq : t -> t -> bool;
      op_gteq : t -> t -> bool;
      op_gt : t -> t -> bool;
      compare : t -> t -> int;
      equal : t -> t -> bool;
      max : t -> t -> t;
      min : t -> t -> t;
      hash_bytes : option MBytes.t -> list MBytes.t -> t;
      hash_string : option string -> list string -> t;
      zero : t;
      size : int;
      to_bytes : t -> MBytes.t;
      of_bytes_opt : MBytes.t -> option t;
      of_bytes_exn : MBytes.t -> t;
      to_b58check : t -> string;
      to_short_b58check : t -> string;
      of_b58check_exn : string -> t;
      of_b58check_opt : string -> option t;
      (* extensible_type_definition `Base58.data` *)
      b58check_encoding : Base58.encoding t;
      encoding : Data_encoding.t t;
      rpc_arg : RPC_arg.t t;
      to_path : t -> list string -> list string;
      of_path : list string -> option t;
      of_path_exn : list string -> t;
      prefix_path : string -> list string;
      path_length : int;
      __Set : INDEXES_Set.signature (elt := t) (t := __Set_t);
      Map : INDEXES_Map.signature (key := t) (t := Map_t);
    }.
  End HASH.
  
  Module MERKLE_TREE.
    Record signature {elt t __Set_t : Set} {Map_t : Set -> Set} {path : Set}
      : Set := {
      elt := elt;
      t := t;
      name : string;
      title : string;
      pp : Format.formatter -> t -> unit;
      pp_short : Format.formatter -> t -> unit;
      op_eq : t -> t -> bool;
      op_ltgt : t -> t -> bool;
      op_lt : t -> t -> bool;
      op_lteq : t -> t -> bool;
      op_gteq : t -> t -> bool;
      op_gt : t -> t -> bool;
      compare : t -> t -> int;
      equal : t -> t -> bool;
      max : t -> t -> t;
      min : t -> t -> t;
      hash_bytes : option MBytes.t -> list MBytes.t -> t;
      hash_string : option string -> list string -> t;
      zero : t;
      size : int;
      to_bytes : t -> MBytes.t;
      of_bytes_opt : MBytes.t -> option t;
      of_bytes_exn : MBytes.t -> t;
      to_b58check : t -> string;
      to_short_b58check : t -> string;
      of_b58check_exn : string -> t;
      of_b58check_opt : string -> option t;
      (* extensible_type_definition `Base58.data` *)
      b58check_encoding : Base58.encoding t;
      encoding : Data_encoding.t t;
      rpc_arg : RPC_arg.t t;
      to_path : t -> list string -> list string;
      of_path : list string -> option t;
      of_path_exn : list string -> t;
      prefix_path : string -> list string;
      path_length : int;
      __Set : INDEXES_Set.signature (elt := t) (t := __Set_t);
      Map : INDEXES_Map.signature (key := t) (t := Map_t);
      compute : list elt -> t;
      empty : t;
      path := path;
      compute_path : list elt -> int -> path;
      check_path : path -> elt -> t * int;
      path_encoding : Data_encoding.t path;
    }.
  End MERKLE_TREE.
  
  Module SPublic_key_hash.
    Record signature {t __Set_t : Set} {Map_t : Set -> Set} : Set := {
      t := t;
      pp : Format.formatter -> t -> unit;
      pp_short : Format.formatter -> t -> unit;
      op_eq : t -> t -> bool;
      op_ltgt : t -> t -> bool;
      op_lt : t -> t -> bool;
      op_lteq : t -> t -> bool;
      op_gteq : t -> t -> bool;
      op_gt : t -> t -> bool;
      compare : t -> t -> int;
      equal : t -> t -> bool;
      max : t -> t -> t;
      min : t -> t -> t;
      size : int;
      to_bytes : t -> MBytes.t;
      of_bytes_opt : MBytes.t -> option t;
      of_bytes_exn : MBytes.t -> t;
      to_b58check : t -> string;
      to_short_b58check : t -> string;
      of_b58check_exn : string -> t;
      of_b58check_opt : string -> option t;
      (* extensible_type_definition `Base58.data` *)
      b58check_encoding : Base58.encoding t;
      encoding : Data_encoding.t t;
      rpc_arg : RPC_arg.t t;
      to_path : t -> list string -> list string;
      of_path : list string -> option t;
      of_path_exn : list string -> t;
      prefix_path : string -> list string;
      path_length : int;
      __Set : INDEXES_Set.signature (elt := t) (t := __Set_t);
      Map : INDEXES_Map.signature (key := t) (t := Map_t);
      zero : t;
    }.
  End SPublic_key_hash.
  
  Module SPublic_key.
    Record signature {t public_key_hash_t : Set} : Set := {
      t := t;
      pp : Format.formatter -> t -> unit;
      op_eq : t -> t -> bool;
      op_ltgt : t -> t -> bool;
      op_lt : t -> t -> bool;
      op_lteq : t -> t -> bool;
      op_gteq : t -> t -> bool;
      op_gt : t -> t -> bool;
      compare : t -> t -> int;
      equal : t -> t -> bool;
      max : t -> t -> t;
      min : t -> t -> t;
      to_b58check : t -> string;
      to_short_b58check : t -> string;
      of_b58check_exn : string -> t;
      of_b58check_opt : string -> option t;
      (* extensible_type_definition `Base58.data` *)
      b58check_encoding : Base58.encoding t;
      encoding : Data_encoding.t t;
      rpc_arg : RPC_arg.t t;
      public_key_hash_t := public_key_hash_t;
      __hash_value : t -> public_key_hash_t;
    }.
  End SPublic_key.
  
  Module SIGNATURE.
    Record signature {Public_key_hash_t Public_key_hash___Set_t : Set}
      {Public_key_hash_Map_t : Set -> Set} {Public_key_t t watermark : Set}
      : Set := {
      Public_key_hash :
        SPublic_key_hash.signature (t := Public_key_hash_t)
          (__Set_t := Public_key_hash___Set_t) (Map_t := Public_key_hash_Map_t);
      Public_key :
        SPublic_key.signature (t := Public_key_t)
          (public_key_hash_t := Public_key_hash.(SPublic_key_hash.t));
      t := t;
      pp : Format.formatter -> t -> unit;
      size : int;
      to_bytes : t -> MBytes.t;
      of_bytes_opt : MBytes.t -> option t;
      of_bytes_exn : MBytes.t -> t;
      op_eq : t -> t -> bool;
      op_ltgt : t -> t -> bool;
      op_lt : t -> t -> bool;
      op_lteq : t -> t -> bool;
      op_gteq : t -> t -> bool;
      op_gt : t -> t -> bool;
      compare : t -> t -> int;
      equal : t -> t -> bool;
      max : t -> t -> t;
      min : t -> t -> t;
      to_b58check : t -> string;
      to_short_b58check : t -> string;
      of_b58check_exn : string -> t;
      of_b58check_opt : string -> option t;
      (* extensible_type_definition `Base58.data` *)
      b58check_encoding : Base58.encoding t;
      encoding : Data_encoding.t t;
      rpc_arg : RPC_arg.t t;
      zero : t;
      watermark := watermark;
      check :
        option watermark -> Public_key.(SPublic_key.t) -> t -> MBytes.t -> bool;
    }.
  End SIGNATURE.
End S.

Module __Set.
  Parameter Make :
    forall (Ord : {t : Set & Compare.COMPARABLE.signature (t := t)}),
      {t : Set &
        S.SET.signature (elt := (|Ord|).(Compare.COMPARABLE.t)) (t := t)}.
End __Set.

Module Map.
  Parameter Make :
    forall (Ord : {t : Set & Compare.COMPARABLE.signature (t := t)}),
      {t : Set -> Set &
        S.MAP.signature (key := (|Ord|).(Compare.COMPARABLE.t)) (t := t)}.
End Map.

Module Blake2B.
  Module Name.
    Record signature : Set := {
      name : string;
      title : string;
      size : option int;
    }.
  End Name.
  
  Module PrefixedName.
    Record signature : Set := {
      name : string;
      title : string;
      size : option int;
      b58check_prefix : string;
    }.
  End PrefixedName.
  
  Parameter Make_minimal :
    forall (Name : {_ : unit & Name.signature}),
      {t : Set & S.MINIMAL_HASH.signature (t := t)}.
  
  Module SRegister.
    Record signature : Set := {
      register_encoding : forall {a : Set},
        string -> int -> (a -> string) -> (string -> option a) ->
        (a -> Base58.data) -> Base58.encoding a;
    }.
  End SRegister.
  
  Parameter Make :
    forall (Register : {_ : unit & SRegister.signature}),
      (forall (Name : {_ : unit & PrefixedName.signature}),
        {'[t, __Set_t, Map_t] : [Set ** Set ** Set -> Set] &
          S.HASH.signature (t := t) (__Set_t := __Set_t) (Map_t := Map_t)}).
End Blake2B.

Parameter Ed25519 :
  {'[Public_key_hash_t, Public_key_hash___Set_t, Public_key_hash_Map_t,
    Public_key_t, t] : [Set ** Set ** Set -> Set ** Set ** Set] &
    S.SIGNATURE.signature (Public_key_hash_t := Public_key_hash_t)
      (Public_key_hash___Set_t := Public_key_hash___Set_t)
      (Public_key_hash_Map_t := Public_key_hash_Map_t)
      (Public_key_t := Public_key_t) (t := t) (watermark := MBytes.t)}.

Parameter Secp256k1 :
  {'[Public_key_hash_t, Public_key_hash___Set_t, Public_key_hash_Map_t,
    Public_key_t, t] : [Set ** Set ** Set -> Set ** Set ** Set] &
    S.SIGNATURE.signature (Public_key_hash_t := Public_key_hash_t)
      (Public_key_hash___Set_t := Public_key_hash___Set_t)
      (Public_key_hash_Map_t := Public_key_hash_Map_t)
      (Public_key_t := Public_key_t) (t := t) (watermark := MBytes.t)}.

Parameter P256 :
  {'[Public_key_hash_t, Public_key_hash___Set_t, Public_key_hash_Map_t,
    Public_key_t, t] : [Set ** Set ** Set -> Set ** Set ** Set] &
    S.SIGNATURE.signature (Public_key_hash_t := Public_key_hash_t)
      (Public_key_hash___Set_t := Public_key_hash___Set_t)
      (Public_key_hash_Map_t := Public_key_hash_Map_t)
      (Public_key_t := Public_key_t) (t := t) (watermark := MBytes.t)}.

Parameter Chain_id :
  {'[t, __Set_t, Map_t] : [Set ** Set ** Set -> Set] &
    S.HASH.signature (t := t) (__Set_t := __Set_t) (Map_t := Map_t)}.

Module Signature.
  Parameter signature_module_tag : unit.
  
  Inductive public_key_hash : Set :=
  | Ed25519Hash :
    (|Ed25519|).(S.SIGNATURE.Public_key_hash).(S.SPublic_key_hash.t) ->
    public_key_hash
  | Secp256k1Hash :
    (|Secp256k1|).(S.SIGNATURE.Public_key_hash).(S.SPublic_key_hash.t) ->
    public_key_hash
  | P256Hash :
    (|P256|).(S.SIGNATURE.Public_key_hash).(S.SPublic_key_hash.t) ->
    public_key_hash.
  
  Inductive public_key : Set :=
  | Ed25519 :
    (|Ed25519|).(S.SIGNATURE.Public_key).(S.SPublic_key.t) -> public_key
  | Secp256k1 :
    (|Secp256k1|).(S.SIGNATURE.Public_key).(S.SPublic_key.t) -> public_key
  | P256 : (|P256|).(S.SIGNATURE.Public_key).(S.SPublic_key.t) -> public_key.
  
  Inductive watermark : Set :=
  | Block_header : (|Chain_id|).(S.HASH.t) -> watermark
  | Endorsement : (|Chain_id|).(S.HASH.t) -> watermark
  | Generic_operation : watermark
  | Custom : MBytes.t -> watermark.
  
  Parameter Included_SIGNATURE :
    {'[Public_key_hash___Set_t, Public_key_hash_Map_t, t] :
      [Set ** Set -> Set ** Set] &
      S.SIGNATURE.signature (Public_key_hash_t := public_key_hash)
        (Public_key_hash___Set_t := Public_key_hash___Set_t)
        (Public_key_hash_Map_t := Public_key_hash_Map_t)
        (Public_key_t := public_key) (t := t) (watermark := watermark)}.
  
  Definition Public_key_hash :=
    existT (fun _ => _) tt (|Included_SIGNATURE|).(S.SIGNATURE.Public_key_hash).
  
  Definition Public_key :=
    existT (fun _ => _) tt (|Included_SIGNATURE|).(S.SIGNATURE.Public_key).
  
  Definition t := (|Included_SIGNATURE|).(S.SIGNATURE.t).
  
  Definition pp : Format.formatter -> t -> unit :=
    (|Included_SIGNATURE|).(S.SIGNATURE.pp).
  
  Definition size : int := (|Included_SIGNATURE|).(S.SIGNATURE.size).
  
  Definition to_bytes : t -> MBytes.t :=
    (|Included_SIGNATURE|).(S.SIGNATURE.to_bytes).
  
  Definition of_bytes_opt : MBytes.t -> option t :=
    (|Included_SIGNATURE|).(S.SIGNATURE.of_bytes_opt).
  
  Definition of_bytes_exn : MBytes.t -> t :=
    (|Included_SIGNATURE|).(S.SIGNATURE.of_bytes_exn).
  
  Definition op_eq : t -> t -> bool :=
    (|Included_SIGNATURE|).(S.SIGNATURE.op_eq).
  
  Definition op_ltgt : t -> t -> bool :=
    (|Included_SIGNATURE|).(S.SIGNATURE.op_ltgt).
  
  Definition op_lt : t -> t -> bool :=
    (|Included_SIGNATURE|).(S.SIGNATURE.op_lt).
  
  Definition op_lteq : t -> t -> bool :=
    (|Included_SIGNATURE|).(S.SIGNATURE.op_lteq).
  
  Definition op_gteq : t -> t -> bool :=
    (|Included_SIGNATURE|).(S.SIGNATURE.op_gteq).
  
  Definition op_gt : t -> t -> bool :=
    (|Included_SIGNATURE|).(S.SIGNATURE.op_gt).
  
  Definition compare : t -> t -> int :=
    (|Included_SIGNATURE|).(S.SIGNATURE.compare).
  
  Definition equal : t -> t -> bool :=
    (|Included_SIGNATURE|).(S.SIGNATURE.equal).
  
  Definition max : t -> t -> t := (|Included_SIGNATURE|).(S.SIGNATURE.max).
  
  Definition min : t -> t -> t := (|Included_SIGNATURE|).(S.SIGNATURE.min).
  
  Definition to_b58check : t -> string :=
    (|Included_SIGNATURE|).(S.SIGNATURE.to_b58check).
  
  Definition to_short_b58check : t -> string :=
    (|Included_SIGNATURE|).(S.SIGNATURE.to_short_b58check).
  
  Definition of_b58check_exn : string -> t :=
    (|Included_SIGNATURE|).(S.SIGNATURE.of_b58check_exn).
  
  Definition of_b58check_opt : string -> option t :=
    (|Included_SIGNATURE|).(S.SIGNATURE.of_b58check_opt).
  
  Definition b58check_encoding : Base58.encoding t :=
    (|Included_SIGNATURE|).(S.SIGNATURE.b58check_encoding).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_SIGNATURE|).(S.SIGNATURE.encoding).
  
  Definition rpc_arg : RPC_arg.t t :=
    (|Included_SIGNATURE|).(S.SIGNATURE.rpc_arg).
  
  Definition zero : t := (|Included_SIGNATURE|).(S.SIGNATURE.zero).
  
  Definition check :
    option watermark -> (|Public_key|).(S.SPublic_key.t) -> t -> MBytes.t ->
    bool := (|Included_SIGNATURE|).(S.SIGNATURE.check).
End Signature.

Parameter Block_hash :
  {'[t, __Set_t, Map_t] : [Set ** Set ** Set -> Set] &
    S.HASH.signature (t := t) (__Set_t := __Set_t) (Map_t := Map_t)}.

Parameter Operation_hash :
  {'[t, __Set_t, Map_t] : [Set ** Set ** Set -> Set] &
    S.HASH.signature (t := t) (__Set_t := __Set_t) (Map_t := Map_t)}.

Parameter Operation_list_hash :
  {'[t, __Set_t, Map_t, path] : [Set ** Set ** Set -> Set ** Set] &
    S.MERKLE_TREE.signature (elt := (|Operation_hash|).(S.HASH.t)) (t := t)
      (__Set_t := __Set_t) (Map_t := Map_t) (path := path)}.

Parameter Operation_list_list_hash :
  {'[t, __Set_t, Map_t, path] : [Set ** Set ** Set -> Set ** Set] &
    S.MERKLE_TREE.signature (elt := (|Operation_list_hash|).(S.MERKLE_TREE.t))
      (t := t) (__Set_t := __Set_t) (Map_t := Map_t) (path := path)}.

Parameter Protocol_hash :
  {'[t, __Set_t, Map_t] : [Set ** Set ** Set -> Set] &
    S.HASH.signature (t := t) (__Set_t := __Set_t) (Map_t := Map_t)}.

Parameter Context_hash :
  {'[t, __Set_t, Map_t] : [Set ** Set ** Set -> Set] &
    S.HASH.signature (t := t) (__Set_t := __Set_t) (Map_t := Map_t)}.

Module Micheline.
  Definition annot : Set := list string.
  
  Inductive node (l p : Set) : Set :=
  | Int : l -> Z.t -> node l p
  | String : l -> string -> node l p
  | Bytes : l -> MBytes.t -> node l p
  | Prim : l -> p -> list (node l p) -> annot -> node l p
  | Seq : l -> list (node l p) -> node l p.
  
  Arguments Int {_ _}.
  Arguments String {_ _}.
  Arguments Bytes {_ _}.
  Arguments Prim {_ _}.
  Arguments Seq {_ _}.
  
  Parameter canonical : forall (p : Set), Set.
  
  Definition canonical_location : Set := int.
  
  Parameter root : forall {p : Set}, canonical p -> node canonical_location p.
  
  Parameter canonical_location_encoding :
    Data_encoding.encoding canonical_location.
  
  Parameter canonical_encoding : forall {l : Set},
    string -> Data_encoding.encoding l -> Data_encoding.encoding (canonical l).
  
  Parameter canonical_encoding_v1 : forall {l : Set},
    string -> Data_encoding.encoding l -> Data_encoding.encoding (canonical l).
  
  Parameter location : forall {l p : Set}, node l p -> l.
  
  Parameter annotations : forall {l p : Set}, node l p -> list string.
  
  Parameter strip_locations : forall {A p : Set}, node A p -> canonical p.
  
  Parameter extract_locations : forall {l p : Set},
    node l p -> canonical p * list (canonical_location * l).
  
  Parameter inject_locations : forall {l p : Set},
    (canonical_location -> l) -> canonical p -> node l p.
End Micheline.

Module Block_header.
  Module shell_header.
    Record record : Set := Build {
      level : Int32.t;
      proto_level : int;
      predecessor : (|Block_hash|).(S.HASH.t);
      timestamp : Time.t;
      validation_passes : int;
      operations_hash : (|Operation_list_list_hash|).(S.MERKLE_TREE.t);
      fitness : list MBytes.t;
      context : (|Context_hash|).(S.HASH.t) }.
    Definition with_level level (r : record) :=
      Build level r.(proto_level) r.(predecessor) r.(timestamp)
        r.(validation_passes) r.(operations_hash) r.(fitness) r.(context).
    Definition with_proto_level proto_level (r : record) :=
      Build r.(level) proto_level r.(predecessor) r.(timestamp)
        r.(validation_passes) r.(operations_hash) r.(fitness) r.(context).
    Definition with_predecessor predecessor (r : record) :=
      Build r.(level) r.(proto_level) predecessor r.(timestamp)
        r.(validation_passes) r.(operations_hash) r.(fitness) r.(context).
    Definition with_timestamp timestamp (r : record) :=
      Build r.(level) r.(proto_level) r.(predecessor) timestamp
        r.(validation_passes) r.(operations_hash) r.(fitness) r.(context).
    Definition with_validation_passes validation_passes (r : record) :=
      Build r.(level) r.(proto_level) r.(predecessor) r.(timestamp)
        validation_passes r.(operations_hash) r.(fitness) r.(context).
    Definition with_operations_hash operations_hash (r : record) :=
      Build r.(level) r.(proto_level) r.(predecessor) r.(timestamp)
        r.(validation_passes) operations_hash r.(fitness) r.(context).
    Definition with_fitness fitness (r : record) :=
      Build r.(level) r.(proto_level) r.(predecessor) r.(timestamp)
        r.(validation_passes) r.(operations_hash) fitness r.(context).
    Definition with_context context (r : record) :=
      Build r.(level) r.(proto_level) r.(predecessor) r.(timestamp)
        r.(validation_passes) r.(operations_hash) r.(fitness) context.
  End shell_header.
  Definition shell_header := shell_header.record.
  
  Parameter shell_header_encoding : Data_encoding.t shell_header.
  
  Module t.
    Record record : Set := Build {
      shell : shell_header;
      protocol_data : MBytes.t }.
    Definition with_shell shell (r : record) :=
      Build shell r.(protocol_data).
    Definition with_protocol_data protocol_data (r : record) :=
      Build r.(shell) protocol_data.
  End t.
  Definition t := t.record.
  
  Parameter Included_HASHABLE :
    {_ : unit &
      S.HASHABLE.signature (t := t) (hash := (|Block_hash|).(S.HASH.t))}.
  
  Definition op_eq : t -> t -> bool := (|Included_HASHABLE|).(S.HASHABLE.op_eq).
  
  Definition op_ltgt : t -> t -> bool :=
    (|Included_HASHABLE|).(S.HASHABLE.op_ltgt).
  
  Definition op_lt : t -> t -> bool := (|Included_HASHABLE|).(S.HASHABLE.op_lt).
  
  Definition op_lteq : t -> t -> bool :=
    (|Included_HASHABLE|).(S.HASHABLE.op_lteq).
  
  Definition op_gteq : t -> t -> bool :=
    (|Included_HASHABLE|).(S.HASHABLE.op_gteq).
  
  Definition op_gt : t -> t -> bool := (|Included_HASHABLE|).(S.HASHABLE.op_gt).
  
  Definition compare : t -> t -> int :=
    (|Included_HASHABLE|).(S.HASHABLE.compare).
  
  Definition equal : t -> t -> bool := (|Included_HASHABLE|).(S.HASHABLE.equal).
  
  Definition max : t -> t -> t := (|Included_HASHABLE|).(S.HASHABLE.max).
  
  Definition min : t -> t -> t := (|Included_HASHABLE|).(S.HASHABLE.min).
  
  Definition pp : Format.formatter -> t -> unit :=
    (|Included_HASHABLE|).(S.HASHABLE.pp).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_HASHABLE|).(S.HASHABLE.encoding).
  
  Definition to_bytes : t -> MBytes.t :=
    (|Included_HASHABLE|).(S.HASHABLE.to_bytes).
  
  Definition of_bytes : MBytes.t -> option t :=
    (|Included_HASHABLE|).(S.HASHABLE.of_bytes).
  
  Definition __hash_value : t -> (|Block_hash|).(S.HASH.t) :=
    (|Included_HASHABLE|).(S.HASHABLE.__hash_value).
  
  Definition hash_raw : MBytes.t -> (|Block_hash|).(S.HASH.t) :=
    (|Included_HASHABLE|).(S.HASHABLE.hash_raw).
End Block_header.

Parameter Fitness : {_ : unit & S.T.signature (t := (list MBytes.t))}.

Module Operation.
  Module shell_header.
    Record record : Set := Build {
      branch : (|Block_hash|).(S.HASH.t) }.
    Definition with_branch branch (r : record) :=
      Build branch.
  End shell_header.
  Definition shell_header := shell_header.record.
  
  Parameter shell_header_encoding : Data_encoding.t shell_header.
  
  Module t.
    Record record : Set := Build {
      shell : shell_header;
      proto : MBytes.t }.
    Definition with_shell shell (r : record) :=
      Build shell r.(proto).
    Definition with_proto proto (r : record) :=
      Build r.(shell) proto.
  End t.
  Definition t := t.record.
  
  Parameter Included_HASHABLE :
    {_ : unit &
      S.HASHABLE.signature (t := t) (hash := (|Operation_hash|).(S.HASH.t))}.
  
  Definition op_eq : t -> t -> bool := (|Included_HASHABLE|).(S.HASHABLE.op_eq).
  
  Definition op_ltgt : t -> t -> bool :=
    (|Included_HASHABLE|).(S.HASHABLE.op_ltgt).
  
  Definition op_lt : t -> t -> bool := (|Included_HASHABLE|).(S.HASHABLE.op_lt).
  
  Definition op_lteq : t -> t -> bool :=
    (|Included_HASHABLE|).(S.HASHABLE.op_lteq).
  
  Definition op_gteq : t -> t -> bool :=
    (|Included_HASHABLE|).(S.HASHABLE.op_gteq).
  
  Definition op_gt : t -> t -> bool := (|Included_HASHABLE|).(S.HASHABLE.op_gt).
  
  Definition compare : t -> t -> int :=
    (|Included_HASHABLE|).(S.HASHABLE.compare).
  
  Definition equal : t -> t -> bool := (|Included_HASHABLE|).(S.HASHABLE.equal).
  
  Definition max : t -> t -> t := (|Included_HASHABLE|).(S.HASHABLE.max).
  
  Definition min : t -> t -> t := (|Included_HASHABLE|).(S.HASHABLE.min).
  
  Definition pp : Format.formatter -> t -> unit :=
    (|Included_HASHABLE|).(S.HASHABLE.pp).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_HASHABLE|).(S.HASHABLE.encoding).
  
  Definition to_bytes : t -> MBytes.t :=
    (|Included_HASHABLE|).(S.HASHABLE.to_bytes).
  
  Definition of_bytes : MBytes.t -> option t :=
    (|Included_HASHABLE|).(S.HASHABLE.of_bytes).
  
  Definition __hash_value : t -> (|Operation_hash|).(S.HASH.t) :=
    (|Included_HASHABLE|).(S.HASHABLE.__hash_value).
  
  Definition hash_raw : MBytes.t -> (|Operation_hash|).(S.HASH.t) :=
    (|Included_HASHABLE|).(S.HASHABLE.hash_raw).
End Operation.

Module Protocol.
  Module t.
    Record record {expected_env components : Set} : Set := Build {
      expected_env : expected_env;
      components : components }.
    Arguments record : clear implicits.
    Definition with_expected_env {t_expected_env t_components} expected_env
      (r : record t_expected_env t_components) :=
      Build t_expected_env t_components expected_env r.(components).
    Definition with_components {t_expected_env t_components} components
      (r : record t_expected_env t_components) :=
      Build t_expected_env t_components r.(expected_env) components.
  End t.
  Definition t_skeleton := t.record.
  
  Module component.
    Record record {name interface implementation : Set} : Set := Build {
      name : name;
      interface : interface;
      implementation : implementation }.
    Arguments record : clear implicits.
    Definition with_name {t_name t_interface t_implementation} name
      (r : record t_name t_interface t_implementation) :=
      Build t_name t_interface t_implementation name r.(interface)
        r.(implementation).
    Definition with_interface {t_name t_interface t_implementation} interface
      (r : record t_name t_interface t_implementation) :=
      Build t_name t_interface t_implementation r.(name) interface
        r.(implementation).
    Definition with_implementation {t_name t_interface t_implementation}
      implementation (r : record t_name t_interface t_implementation) :=
      Build t_name t_interface t_implementation r.(name) r.(interface)
        implementation.
  End component.
  Definition component_skeleton := component.record.
  
  Reserved Notation "'component".
  Reserved Notation "'t".
  
  Inductive env_version : Set :=
  | V1 : env_version
  
  where "'component" := (component_skeleton string (option string) string)
  and "'t" := (t_skeleton env_version (list 'component)).
  
  Definition component := 'component.
  Definition t := 't.
  
  Parameter component_encoding : Data_encoding.t component.
  
  Parameter env_version_encoding : Data_encoding.t env_version.
  
  Parameter Included_HASHABLE :
    {_ : unit &
      S.HASHABLE.signature (t := t) (hash := (|Protocol_hash|).(S.HASH.t))}.
  
  Definition op_eq : t -> t -> bool := (|Included_HASHABLE|).(S.HASHABLE.op_eq).
  
  Definition op_ltgt : t -> t -> bool :=
    (|Included_HASHABLE|).(S.HASHABLE.op_ltgt).
  
  Definition op_lt : t -> t -> bool := (|Included_HASHABLE|).(S.HASHABLE.op_lt).
  
  Definition op_lteq : t -> t -> bool :=
    (|Included_HASHABLE|).(S.HASHABLE.op_lteq).
  
  Definition op_gteq : t -> t -> bool :=
    (|Included_HASHABLE|).(S.HASHABLE.op_gteq).
  
  Definition op_gt : t -> t -> bool := (|Included_HASHABLE|).(S.HASHABLE.op_gt).
  
  Definition compare : t -> t -> int :=
    (|Included_HASHABLE|).(S.HASHABLE.compare).
  
  Definition equal : t -> t -> bool := (|Included_HASHABLE|).(S.HASHABLE.equal).
  
  Definition max : t -> t -> t := (|Included_HASHABLE|).(S.HASHABLE.max).
  
  Definition min : t -> t -> t := (|Included_HASHABLE|).(S.HASHABLE.min).
  
  Definition pp : Format.formatter -> t -> unit :=
    (|Included_HASHABLE|).(S.HASHABLE.pp).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_HASHABLE|).(S.HASHABLE.encoding).
  
  Definition to_bytes : t -> MBytes.t :=
    (|Included_HASHABLE|).(S.HASHABLE.to_bytes).
  
  Definition of_bytes : MBytes.t -> option t :=
    (|Included_HASHABLE|).(S.HASHABLE.of_bytes).
  
  Definition __hash_value : t -> (|Protocol_hash|).(S.HASH.t) :=
    (|Included_HASHABLE|).(S.HASHABLE.__hash_value).
  
  Definition hash_raw : MBytes.t -> (|Protocol_hash|).(S.HASH.t) :=
    (|Included_HASHABLE|).(S.HASHABLE.hash_raw).
End Protocol.

Module Context.
  Parameter t : Set.
  
  Definition key : Set := list string.
  
  Definition value : Set := MBytes.t.
  
  Parameter mem : t -> key -> Lwt.t bool.
  
  Parameter dir_mem : t -> key -> Lwt.t bool.
  
  Parameter get : t -> key -> Lwt.t (option value).
  
  Parameter set : t -> key -> value -> Lwt.t t.
  
  Parameter copy : t -> key -> key -> Lwt.t (option t).
  
  Parameter del : t -> key -> Lwt.t t.
  
  Parameter remove_rec : t -> key -> Lwt.t t.
  
  Inductive dir_or_key : Set :=
  | Dir : key -> dir_or_key
  | Key : key -> dir_or_key.
  
  Parameter fold : forall {a : Set},
    t -> key -> a -> (Context.dir_or_key -> a -> Lwt.t a) -> Lwt.t a.
  
  Parameter keys : t -> key -> Lwt.t (list key).
  
  Parameter fold_keys : forall {a : Set},
    t -> key -> a -> (key -> a -> Lwt.t a) -> Lwt.t a.
  
  Parameter register_resolver : forall {a : Set},
    Base58.encoding a -> (t -> string -> Lwt.t (list a)) -> unit.
  
  Parameter complete : t -> string -> Lwt.t (list string).
End Context.

Module Updater.
  Module validation_result.
    Record record : Set := Build {
      context : Context.t;
      fitness : (|Fitness|).(S.T.t);
      message : option string;
      max_operations_ttl : int;
      last_allowed_fork_level : Int32.t }.
    Definition with_context context (r : record) :=
      Build context r.(fitness) r.(message) r.(max_operations_ttl)
        r.(last_allowed_fork_level).
    Definition with_fitness fitness (r : record) :=
      Build r.(context) fitness r.(message) r.(max_operations_ttl)
        r.(last_allowed_fork_level).
    Definition with_message message (r : record) :=
      Build r.(context) r.(fitness) message r.(max_operations_ttl)
        r.(last_allowed_fork_level).
    Definition with_max_operations_ttl max_operations_ttl (r : record) :=
      Build r.(context) r.(fitness) r.(message) max_operations_ttl
        r.(last_allowed_fork_level).
    Definition with_last_allowed_fork_level last_allowed_fork_level
      (r : record) :=
      Build r.(context) r.(fitness) r.(message) r.(max_operations_ttl)
        last_allowed_fork_level.
  End validation_result.
  Definition validation_result := validation_result.record.
  
  Module quota.
    Record record : Set := Build {
      max_size : int;
      max_op : option int }.
    Definition with_max_size max_size (r : record) :=
      Build max_size r.(max_op).
    Definition with_max_op max_op (r : record) :=
      Build r.(max_size) max_op.
  End quota.
  Definition quota := quota.record.
  
  Module rpc_context.
    Record record : Set := Build {
      block_hash : (|Block_hash|).(S.HASH.t);
      block_header : Block_header.shell_header;
      context : Context.t }.
    Definition with_block_hash block_hash (r : record) :=
      Build block_hash r.(block_header) r.(context).
    Definition with_block_header block_header (r : record) :=
      Build r.(block_hash) block_header r.(context).
    Definition with_context context (r : record) :=
      Build r.(block_hash) r.(block_header) context.
  End rpc_context.
  Definition rpc_context := rpc_context.record.
  
  Module PROTOCOL.
    Record signature {block_header_data block_header block_header_metadata
      operation_data operation_receipt operation validation_state : Set} : Set
      := {
      max_block_length : int;
      max_operation_data_length : int;
      validation_passes : list quota;
      block_header_data := block_header_data;
      block_header_data_encoding : Data_encoding.t block_header_data;
      block_header := block_header;
      block_header_metadata := block_header_metadata;
      block_header_metadata_encoding : Data_encoding.t block_header_metadata;
      operation_data := operation_data;
      operation_receipt := operation_receipt;
      operation := operation;
      operation_data_encoding : Data_encoding.t operation_data;
      operation_receipt_encoding : Data_encoding.t operation_receipt;
      operation_data_and_receipt_encoding :
        Data_encoding.t (operation_data * operation_receipt);
      acceptable_passes : operation -> list int;
      compare_operations : operation -> operation -> int;
      validation_state := validation_state;
      current_context :
        validation_state -> Lwt.t (Error_monad.tzresult Context.t);
      begin_partial_application :
        (|Chain_id|).(S.HASH.t) -> Context.t -> Time.t -> (|Fitness|).(S.T.t) ->
        block_header -> Lwt.t (Error_monad.tzresult validation_state);
      begin_application :
        (|Chain_id|).(S.HASH.t) -> Context.t -> Time.t -> (|Fitness|).(S.T.t) ->
        block_header -> Lwt.t (Error_monad.tzresult validation_state);
      begin_construction :
        (|Chain_id|).(S.HASH.t) -> Context.t -> Time.t -> Int32.t ->
        (|Fitness|).(S.T.t) -> (|Block_hash|).(S.HASH.t) -> Time.t ->
        option block_header_data -> unit ->
        Lwt.t (Error_monad.tzresult validation_state);
      apply_operation :
        validation_state -> operation ->
        Lwt.t (Error_monad.tzresult (validation_state * operation_receipt));
      finalize_block :
        validation_state ->
        Lwt.t (Error_monad.tzresult (validation_result * block_header_metadata));
      rpc_services : RPC_directory.t rpc_context;
      init :
        Context.t -> Block_header.shell_header ->
        Lwt.t (Error_monad.tzresult validation_result);
    }.
  End PROTOCOL.
  
  Parameter activate :
    Context.t -> (|Protocol_hash|).(S.HASH.t) -> Lwt.t Context.t.
  
  Parameter fork_test_chain :
    Context.t -> (|Protocol_hash|).(S.HASH.t) -> Time.t -> Lwt.t Context.t.
End Updater.

Module RPC_context.
  Definition t : Set := Updater.rpc_context.
  
  Module simple.
    Record record {pr : Set} : Set := Build {
      call_proto_service0 :
        forall {q i o : Set},
          RPC_service.t t t q i o -> pr -> q -> i ->
          Lwt.t (Error_monad.shell_tzresult o);
      call_proto_service1 :
        forall {a q i o : Set},
          RPC_service.t t (t * a) q i o -> pr -> a -> q -> i ->
          Lwt.t (Error_monad.shell_tzresult o);
      call_proto_service2 :
        forall {a b q i o : Set},
          RPC_service.t t ((t * a) * b) q i o -> pr -> a -> b -> q -> i ->
          Lwt.t (Error_monad.shell_tzresult o);
      call_proto_service3 :
        forall {a b c q i o : Set},
          RPC_service.t t (((t * a) * b) * c) q i o -> pr -> a -> b -> c -> q ->
          i -> Lwt.t (Error_monad.shell_tzresult o) }.
    Arguments record : clear implicits.
  End simple.
  Definition simple := simple.record.
  
  Parameter make_call0 : forall {i o pr q : Set},
    RPC_service.t t t q i o -> simple pr -> pr -> q -> i ->
    Lwt.t (Error_monad.shell_tzresult o).
  
  Parameter make_call1 : forall {a i o pr q : Set},
    RPC_service.t t (t * a) q i o -> simple pr -> pr -> a -> q -> i ->
    Lwt.t (Error_monad.shell_tzresult o).
  
  Parameter make_call2 : forall {a b i o pr q : Set},
    RPC_service.t t ((t * a) * b) q i o -> simple pr -> pr -> a -> b -> q ->
    i -> Lwt.t (Error_monad.shell_tzresult o).
  
  Parameter make_call3 : forall {a b c i o pr q : Set},
    RPC_service.t t (((t * a) * b) * c) q i o -> simple pr -> pr -> a -> b ->
    c -> q -> i -> Lwt.t (Error_monad.shell_tzresult o).
  
  Parameter make_opt_call0 : forall {i o pr q : Set},
    RPC_service.t t t q i o -> simple pr -> pr -> q -> i ->
    Lwt.t (Error_monad.shell_tzresult (option o)).
  
  Parameter make_opt_call1 : forall {a i o pr q : Set},
    RPC_service.t t (t * a) q i o -> simple pr -> pr -> a -> q -> i ->
    Lwt.t (Error_monad.shell_tzresult (option o)).
  
  Parameter make_opt_call2 : forall {a b i o pr q : Set},
    RPC_service.t t ((t * a) * b) q i o -> simple pr -> pr -> a -> b -> q ->
    i -> Lwt.t (Error_monad.shell_tzresult (option o)).
  
  Parameter make_opt_call3 : forall {a b c i o pr q : Set},
    RPC_service.t t (((t * a) * b) * c) q i o -> simple pr -> pr -> a -> b ->
    c -> q -> i -> Lwt.t (Error_monad.shell_tzresult (option o)).
End RPC_context.

Module Notations.
  Notation "'let=' x ':=' X 'in' Y" :=
    (Error_monad.op_gtgteq X (fun x => Y))
    (at level 200, x ident, X at level 100, Y at level 200).

  Notation "'let=' ' x ':=' X 'in' Y" :=
    (Error_monad.op_gtgteq X (fun x => Y))
    (at level 200, x pattern, X at level 100, Y at level 200).

  Notation "'let=?' x ':=' X 'in' Y" :=
    (Error_monad.op_gtgteqquestion X (fun x => Y))
    (at level 200, x ident, X at level 100, Y at level 200).

  Notation "'let=?' ' x ':=' X 'in' Y" :=
    (Error_monad.op_gtgteqquestion X (fun x => Y))
    (at level 200, x pattern, X at level 100, Y at level 200).

  Notation "'let?' x ':=' X 'in' Y" :=
    (Error_monad.op_gtgtquestion X (fun x => Y))
    (at level 200, x ident, X at level 100, Y at level 200).

  Notation "'let?' ' x ':=' X 'in' Y" :=
    (Error_monad.op_gtgtquestion X (fun x => Y))
    (at level 200, x pattern, X at level 100, Y at level 200).
End Notations.
