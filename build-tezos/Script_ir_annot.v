(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Unset Positivity Checking.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Script_typed_ir.

Import Alpha_context.

Import Micheline.

Import Script_tc_errors.

Import Script_typed_ir.

Definition default_now_annot : option (* `Var_annot *) string :=
  Some (Var_annot "now").

Definition default_amount_annot : option (* `Var_annot *) string :=
  Some (Var_annot "amount").

Definition default_balance_annot : option (* `Var_annot *) string :=
  Some (Var_annot "balance").

Definition default_steps_annot : option (* `Var_annot *) string :=
  Some (Var_annot "steps").

Definition default_source_annot : option (* `Var_annot *) string :=
  Some (Var_annot "source").

Definition default_sender_annot : option (* `Var_annot *) string :=
  Some (Var_annot "sender").

Definition default_self_annot : option (* `Var_annot *) string :=
  Some (Var_annot "self").

Definition default_arg_annot : option (* `Var_annot *) string :=
  Some (Var_annot "arg").

Definition default_param_annot : option (* `Var_annot *) string :=
  Some (Var_annot "parameter").

Definition default_storage_annot : option (* `Var_annot *) string :=
  Some (Var_annot "storage").

Definition default_car_annot : option (* `Field_annot *) string :=
  Some (Field_annot "car").

Definition default_cdr_annot : option (* `Field_annot *) string :=
  Some (Field_annot "cdr").

Definition default_contract_annot : option (* `Field_annot *) string :=
  Some (Field_annot "contract").

Definition default_addr_annot : option (* `Field_annot *) string :=
  Some (Field_annot "address").

Definition default_manager_annot : option (* `Field_annot *) string :=
  Some (Field_annot "manager").

Definition default_pack_annot : option (* `Field_annot *) string :=
  Some (Field_annot "packed").

Definition default_unpack_annot : option (* `Field_annot *) string :=
  Some (Field_annot "unpacked").

Definition default_slice_annot : option (* `Field_annot *) string :=
  Some (Field_annot "slice").

Definition default_elt_annot : option (* `Field_annot *) string :=
  Some (Field_annot "elt").

Definition default_key_annot : option (* `Field_annot *) string :=
  Some (Field_annot "key").

Definition default_hd_annot : option (* `Field_annot *) string :=
  Some (Field_annot "hd").

Definition default_tl_annot : option (* `Field_annot *) string :=
  Some (Field_annot "tl").

Definition default_some_annot : option (* `Field_annot *) string :=
  Some (Field_annot "some").

Definition default_left_annot : option (* `Field_annot *) string :=
  Some (Field_annot "left").

Definition default_right_annot : option (* `Field_annot *) string :=
  Some (Field_annot "right").

Definition default_binding_annot : option (* `Field_annot *) string :=
  Some (Field_annot "bnd").

Definition unparse_type_annot
  (function_parameter : option Script_typed_ir.type_annot) : list string :=
  match function_parameter with
  | None => nil
  | Some (Type_annot a) => [ Pervasives.op_caret ":" a ]
  end.

Definition unparse_var_annot
  (function_parameter : option Script_typed_ir.var_annot) : list string :=
  match function_parameter with
  | None => nil
  | Some (Var_annot a) => [ Pervasives.op_caret "@" a ]
  end.

Definition unparse_field_annot
  (function_parameter : option Script_typed_ir.field_annot) : list string :=
  match function_parameter with
  | None => nil
  | Some (Field_annot a) => [ Pervasives.op_caret "%" a ]
  end.

Definition field_to_var_annot
  (function_parameter : option Script_typed_ir.field_annot)
  : option Script_typed_ir.var_annot :=
  match function_parameter with
  | None => None
  | Some (Field_annot s) => Some (Var_annot s)
  end.

Definition type_to_var_annot
  (function_parameter : option Script_typed_ir.type_annot)
  : option Script_typed_ir.var_annot :=
  match function_parameter with
  | None => None
  | Some (Type_annot s) => Some (Var_annot s)
  end.

Definition var_to_field_annot
  (function_parameter : option Script_typed_ir.var_annot)
  : option Script_typed_ir.field_annot :=
  match function_parameter with
  | None => None
  | Some (Var_annot s) => Some (Field_annot s)
  end.

Definition default_annot {A : Set}
  (default : option A) (function_parameter : option A) : option A :=
  match function_parameter with
  | None => default
  | annot => annot
  end.

Definition gen_access_annot
  (value_annot : option Script_typed_ir.var_annot)
  (op_staroptstar : option (option Script_typed_ir.field_annot))
  : option Script_typed_ir.field_annot -> option Script_typed_ir.var_annot :=
  let default :=
    match op_staroptstar with
    | Some op_starsthstar => op_starsthstar
    | None => None
    end in
  fun field_annot =>
    match (value_annot, field_annot, default) with
    |
      ((None, None, _) | (Some _, None, None) | (None, Some (Field_annot ""), _))
      => None
    | (None, Some (Field_annot f), _) => Some (Var_annot f)
    | (Some (Var_annot v), (None | Some (Field_annot "")), Some (Field_annot f))
      => Some (Var_annot (String.concat "." [ v; f ]))
    | (Some (Var_annot v), Some (Field_annot f), _) =>
      Some (Var_annot (String.concat "." [ v; f ]))
    end.

Definition merge_type_annot
  (legacy : bool) (annot1 : option Script_typed_ir.type_annot)
  (annot2 : option Script_typed_ir.type_annot)
  : Error_monad.tzresult (option Script_typed_ir.type_annot) :=
  match (annot1, annot2) with
  | ((None, None) | (Some _, None) | (None, Some _)) => Error_monad.ok None
  | (Some (Type_annot a1), Some (Type_annot a2)) =>
    if Pervasives.op_pipepipe legacy (String.equal a1 a2) then
      Error_monad.ok annot1
    else
      Error_monad.__error_value extensible_type_value
  end.

Definition merge_field_annot
  (legacy : bool) (annot1 : option Script_typed_ir.field_annot)
  (annot2 : option Script_typed_ir.field_annot)
  : Error_monad.tzresult (option Script_typed_ir.field_annot) :=
  match (annot1, annot2) with
  | ((None, None) | (Some _, None) | (None, Some _)) => Error_monad.ok None
  | (Some (Field_annot a1), Some (Field_annot a2)) =>
    if Pervasives.op_pipepipe legacy (String.equal a1 a2) then
      Error_monad.ok annot1
    else
      Error_monad.__error_value extensible_type_value
  end.

Definition merge_var_annot
  (annot1 : option Script_typed_ir.var_annot)
  (annot2 : option Script_typed_ir.var_annot)
  : option Script_typed_ir.var_annot :=
  match (annot1, annot2) with
  | ((None, None) | (Some _, None) | (None, Some _)) => None
  | (Some (Var_annot a1), Some (Var_annot a2)) =>
    if String.equal a1 a2 then
      annot1
    else
      None
  end.

Definition error_unexpected_annot {A : Set}
  (loc : Alpha_context.Script.location) (annot : list A)
  : Error_monad.tzresult unit :=
  match annot with
  | [] => Error_monad.ok tt
  | cons _ _ => Error_monad.__error_value extensible_type_value
  end.

Definition fail_unexpected_annot {A : Set}
  (loc : Alpha_context.Script.location) (annot : list A)
  : Lwt.t (Error_monad.tzresult unit) :=
  Lwt.__return (error_unexpected_annot loc annot).

Definition parse_annots
  (loc : Alpha_context.Script.location) (op_staroptstar : option bool)
  : option bool -> list string ->
  Error_monad.tzresult (list (* `Field_annot *) (option string)) :=
  let allow_special_var :=
    match op_staroptstar with
    | Some op_starsthstar => op_starsthstar
    | None => false
    end in
  fun op_staroptstar =>
    let allow_special_field :=
      match op_staroptstar with
      | Some op_starsthstar => op_starsthstar
      | None => false
      end in
    fun l =>
      let sub_or_wildcard {A : Set}
        (specials : list ascii) (wrap : option string -> A) (s : string)
        (acc : list A) : Error_monad.tzresult (list A) :=
        let len := String.length s in
        if (|Compare.Int|).(Compare.S.op_eq) len 1 then
          Pervasives.op_atat Error_monad.ok (cons (wrap None) acc)
        else
          match
            ((String.get s 1),
              match String.get s 1 with
              | "@" % char =>
                Pervasives.op_andand ((|Compare.Int|).(Compare.S.op_eq) len 2)
                  (List.mem "@" % char specials)
              | _ => false
              end,
              match String.get s 1 with
              | "%" % char => List.mem "%" % char specials
              | _ => false
              end) with
          |
            (("a" % char | "b" % char | "c" % char | "d" % char | "e" % char |
            "f" % char | "g" % char | "h" % char | "i" % char | "j" % char |
            "k" % char | "l" % char | "m" % char | "n" % char | "o" % char |
            "p" % char | "q" % char | "r" % char | "s" % char | "t" % char |
            "u" % char | "v" % char | "w" % char | "x" % char | "y" % char |
            "z" % char | "A" % char | "B" % char | "C" % char | "D" % char |
            "E" % char | "F" % char | "G" % char | "H" % char | "I" % char |
            "J" % char | "K" % char | "L" % char | "M" % char | "N" % char |
            "O" % char | "P" % char | "Q" % char | "R" % char | "S" % char |
            "T" % char | "U" % char | "V" % char | "W" % char | "X" % char |
            "Y" % char | "Z" % char | "_" % char), _, _) =>
            Pervasives.op_atat Error_monad.ok
              (cons (wrap (Some (String.sub s 1 (Pervasives.op_minus len 1))))
                acc)
          | ("@" % char, true, _) =>
            Pervasives.op_atat Error_monad.ok (cons (wrap (Some "@")) acc)
          | ("%" % char, _, true) =>
            if (|Compare.Int|).(Compare.S.op_eq) len 2 then
              Pervasives.op_atat Error_monad.ok (cons (wrap (Some "%")) acc)
            else
              if
                Pervasives.op_andand ((|Compare.Int|).(Compare.S.op_eq) len 3)
                  ((|Compare.Char|).(Compare.S.op_eq) (String.get s 2)
                    "%" % char) then
                Pervasives.op_atat Error_monad.ok (cons (wrap (Some "%%")) acc)
              else
                Error_monad.__error_value extensible_type_value
          | (_, _, _) => Error_monad.__error_value extensible_type_value
          end in
      Error_monad.op_gtpipequestion
        (List.fold_left
          (fun acc =>
            fun s =>
              Error_monad.op_gtgtquestion acc
                (fun acc =>
                  if (|Compare.Int|).(Compare.S.op_eq) (String.length s) 0 then
                    Error_monad.__error_value extensible_type_value
                  else
                    match String.get s 0 with
                    | ":" % char =>
                      sub_or_wildcard nil (fun a => Type_annot a) s acc
                    | "@" % char =>
                      sub_or_wildcard
                        (if allow_special_var then
                          [ "%" % char ]
                        else
                          nil) (fun a => Var_annot a) s acc
                    | "%" % char =>
                      sub_or_wildcard
                        (if allow_special_field then
                          [ "@" % char ]
                        else
                          nil) (fun a => Field_annot a) s acc
                    | _ => Error_monad.__error_value extensible_type_value
                    end)) (Error_monad.ok nil) l) List.rev.

Definition opt_var_of_var_opt {A : Set}
  (function_parameter : (* `Var_annot *) option A)
  : option (* `Var_annot *) A :=
  match function_parameter with
  | Var_annot None => None
  | Var_annot (Some a) => Some (Var_annot a)
  end.

Definition opt_field_of_field_opt {A : Set}
  (function_parameter : (* `Field_annot *) option A)
  : option (* `Field_annot *) A :=
  match function_parameter with
  | Field_annot None => None
  | Field_annot (Some a) => Some (Field_annot a)
  end.

Definition opt_type_of_type_opt {A : Set}
  (function_parameter : (* `Type_annot *) option A)
  : option (* `Type_annot *) A :=
  match function_parameter with
  | Type_annot None => None
  | Type_annot (Some a) => Some (Type_annot a)
  end.

Definition classify_annot
  (loc : Alpha_context.Script.location)
  (l : list (* `Var_annot *) (option string))
  : Error_monad.tzresult
    (list (option Script_typed_ir.var_annot) *
      list (option Script_typed_ir.type_annot) *
      list (option Script_typed_ir.field_annot)) :=
  (* ❌ Try-with are not handled *)
  try
    (let '(_, rv, _, rt, _, rf) :=
      List.fold_left
        (fun function_parameter =>
          let '(in_v, rv, in_t, rt, in_f, rf) := function_parameter in
          fun a =>
            match (a, in_v, rv, in_t, rt, in_f, rf) with
            |
              (((Var_annot _) as a, true, _, _, _, _, _) |
              ((Var_annot _) as a, false, [], _, _, _, _)) =>
              (true, (cons (opt_var_of_var_opt a) rv), false, rt, false, rf)
            |
              (((Type_annot _) as a, _, _, true, _, _, _) |
              ((Type_annot _) as a, _, _, false, [], _, _)) =>
              (false, rv, true, (cons (opt_type_of_type_opt a) rt), false, rf)
            |
              (((Field_annot _) as a, _, _, _, _, true, _) |
              ((Field_annot _) as a, _, _, _, _, false, [])) =>
              (false, rv, false, rt, true, (cons (opt_field_of_field_opt a) rf))
            | _ => Pervasives.raise extensible_type_value
            end) (false, nil, false, nil, false, nil) l in
    Error_monad.ok ((List.rev rv), (List.rev rt), (List.rev rf))).

Definition get_one_annot {A : Set}
  (loc : Alpha_context.Script.location) (function_parameter : list (option A))
  : Error_monad.tzresult (option A) :=
  match function_parameter with
  | [] => Error_monad.ok None
  | cons a [] => Error_monad.ok a
  | _ => Error_monad.__error_value extensible_type_value
  end.

Definition get_two_annot {A : Set}
  (loc : Alpha_context.Script.location) (function_parameter : list (option A))
  : Error_monad.tzresult (option A * option A) :=
  match function_parameter with
  | [] => Error_monad.ok (None, None)
  | cons a [] => Error_monad.ok (a, None)
  | cons a (cons b []) => Error_monad.ok (a, b)
  | _ => Error_monad.__error_value extensible_type_value
  end.

Definition parse_type_annot (loc : Z) (annot : list string)
  : Error_monad.tzresult (option Script_typed_ir.type_annot) :=
  Error_monad.op_gtgtquestion
    (Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc))
    (fun function_parameter =>
      let '(vars, types, fields) := function_parameter in
      Error_monad.op_gtgtquestion (error_unexpected_annot loc vars)
        (fun function_parameter =>
          let '_ := function_parameter in
          Error_monad.op_gtgtquestion (error_unexpected_annot loc fields)
            (fun function_parameter =>
              let '_ := function_parameter in
              get_one_annot loc types))).

Definition parse_type_field_annot (loc : Z) (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.type_annot * option Script_typed_ir.field_annot) :=
  Error_monad.op_gtgtquestion
    (Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc))
    (fun function_parameter =>
      let '(vars, types, fields) := function_parameter in
      Error_monad.op_gtgtquestion (error_unexpected_annot loc vars)
        (fun function_parameter =>
          let '_ := function_parameter in
          Error_monad.op_gtgtquestion (get_one_annot loc types)
            (fun __t_value =>
              Error_monad.op_gtpipequestion (get_one_annot loc fields)
                (fun f => (__t_value, f))))).

Definition parse_composed_type_annot (loc : Z) (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.type_annot * option Script_typed_ir.field_annot *
      option Script_typed_ir.field_annot) :=
  Error_monad.op_gtgtquestion
    (Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc))
    (fun function_parameter =>
      let '(vars, types, fields) := function_parameter in
      Error_monad.op_gtgtquestion (error_unexpected_annot loc vars)
        (fun function_parameter =>
          let '_ := function_parameter in
          Error_monad.op_gtgtquestion (get_one_annot loc types)
            (fun __t_value =>
              Error_monad.op_gtpipequestion (get_two_annot loc fields)
                (fun function_parameter =>
                  let '(f1, f2) := function_parameter in
                  (__t_value, f1, f2))))).

Definition parse_field_annot (loc : Z) (annot : list string)
  : Error_monad.tzresult (option Script_typed_ir.field_annot) :=
  Error_monad.op_gtgtquestion
    (Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc))
    (fun function_parameter =>
      let '(vars, types, fields) := function_parameter in
      Error_monad.op_gtgtquestion (error_unexpected_annot loc vars)
        (fun function_parameter =>
          let '_ := function_parameter in
          Error_monad.op_gtgtquestion (error_unexpected_annot loc types)
            (fun function_parameter =>
              let '_ := function_parameter in
              get_one_annot loc fields))).

Definition extract_field_annot (function_parameter : Alpha_context.Script.node)
  : Error_monad.tzresult
    (Alpha_context.Script.node * option Script_typed_ir.field_annot) :=
  match function_parameter with
  | Micheline.Prim loc prim args annot =>
    let fix extract_first (acc : list string) (function_parameter : list string)
      {struct acc} : option string * Micheline.annot :=
      match function_parameter with
      | [] => (None, annot)
      | cons s rest =>
        if
          Pervasives.op_andand
            ((|Compare.Int|).(Compare.S.op_gt) (String.length s) 0)
            ((|Compare.Char|).(Compare.S.op_eq) (String.get s 0) "%" % char)
          then
          ((Some s), (List.rev_append acc rest))
        else
          extract_first (cons s acc) rest
      end in
    let '(field_annot, annot) := extract_first nil annot in
    let field_annot :=
      match field_annot with
      | None => None
      | Some field_annot =>
        Some
          (Field_annot
            (String.sub field_annot 1
              (Pervasives.op_minus (String.length field_annot) 1)))
      end in
    Error_monad.ok ((Micheline.Prim loc prim args annot), field_annot)
  | expr => Error_monad.ok (expr, None)
  end.

Definition check_correct_field
  (f1 : option Script_typed_ir.field_annot)
  (f2 : option Script_typed_ir.field_annot) : Error_monad.tzresult unit :=
  match (f1, f2) with
  | ((None, _) | (_, None)) => Error_monad.ok tt
  | (Some (Field_annot s1), Some (Field_annot s2)) =>
    if String.equal s1 s2 then
      Error_monad.ok tt
    else
      Error_monad.__error_value extensible_type_value
  end.

Definition parse_var_annot
  (loc : Z) (default : option (option Script_typed_ir.var_annot))
  (annot : list string)
  : Error_monad.tzresult (option Script_typed_ir.var_annot) :=
  Error_monad.op_gtgtquestion
    (Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc))
    (fun function_parameter =>
      let '(vars, types, fields) := function_parameter in
      Error_monad.op_gtgtquestion (error_unexpected_annot loc types)
        (fun function_parameter =>
          let '_ := function_parameter in
          Error_monad.op_gtgtquestion (error_unexpected_annot loc fields)
            (fun function_parameter =>
              let '_ := function_parameter in
              Error_monad.op_gtpipequestion (get_one_annot loc vars)
                (fun function_parameter =>
                  match function_parameter with
                  | (Some _) as a => a
                  | None =>
                    match default with
                    | Some a => a
                    | None => None
                    end
                  end)))).

Definition split_last_dot
  (function_parameter : option (* `Field_annot *) string)
  : option (* `Var_annot *) string * option (* `Field_annot *) string :=
  match function_parameter with
  | None => (None, None)
  | Some (Field_annot s) =>
    match String.rindex_opt s "." % char with
    | None => (None, (Some (Field_annot s)))
    | Some i =>
      let s1 := String.sub s 0 i in
      let s2 :=
        String.sub s (Pervasives.op_plus i 1)
          (Pervasives.op_minus (Pervasives.op_minus (String.length s) i) 1) in
      let f :=
        if
          Pervasives.op_pipepipe ((|Compare.String|).(Compare.S.equal) s2 "car")
            ((|Compare.String|).(Compare.S.equal) s2 "cdr") then
          None
        else
          Some (Field_annot s2) in
      ((Some (Var_annot s1)), f)
    end
  end.

Definition common_prefix
  (v1 : option (* `Var_annot *) (|Compare.String|).(Compare.S.t))
  (v2 : option (* `Var_annot *) (|Compare.String|).(Compare.S.t))
  : option (* `Var_annot *) (|Compare.String|).(Compare.S.t) :=
  match
    ((v1, v2),
      match (v1, v2) with
      | (Some (Var_annot s1), Some (Var_annot s2)) =>
        (|Compare.String|).(Compare.S.equal) s1 s2
      | _ => false
      end) with
  | ((Some (Var_annot s1), Some (Var_annot s2)), true) => v1
  | ((Some _, None), _) => v1
  | ((None, Some _), _) => v2
  | ((_, _), _) => None
  end.

Definition parse_constr_annot
  (loc : Z) (if_special_first : option (option Script_typed_ir.field_annot))
  (if_special_second : option (option Script_typed_ir.field_annot))
  (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.type_annot *
      option Script_typed_ir.field_annot * option Script_typed_ir.field_annot) :=
  Error_monad.op_gtgtquestion
    (Error_monad.op_gtgtquestion (parse_annots loc None (Some true) annot)
      (classify_annot loc))
    (fun function_parameter =>
      let '(vars, types, fields) := function_parameter in
      Error_monad.op_gtgtquestion (get_one_annot loc vars)
        (fun v =>
          Error_monad.op_gtgtquestion (get_one_annot loc types)
            (fun __t_value =>
              Error_monad.op_gtgtquestion (get_two_annot loc fields)
                (fun function_parameter =>
                  let '(f1, f2) := function_parameter in
                  Error_monad.op_gtgtquestion
                    match (if_special_first, f1) with
                    | (Some special_var, Some (Field_annot "@")) =>
                      Error_monad.ok (split_last_dot special_var)
                    | (None, Some (Field_annot "@")) =>
                      Error_monad.__error_value extensible_type_value
                    | (_, _) => Error_monad.ok (v, f1)
                    end
                    (fun function_parameter =>
                      let '(v1, f1) := function_parameter in
                      Error_monad.op_gtpipequestion
                        match (if_special_second, f2) with
                        | (Some special_var, Some (Field_annot "@")) =>
                          Error_monad.ok (split_last_dot special_var)
                        | (None, Some (Field_annot "@")) =>
                          Error_monad.__error_value extensible_type_value
                        | (_, _) => Error_monad.ok (v, f2)
                        end
                        (fun function_parameter =>
                          let '(v2, f2) := function_parameter in
                          let v :=
                            match v with
                            | None => common_prefix v1 v2
                            | Some _ => v
                            end in
                          (v, __t_value, f1, f2))))))).

Definition parse_two_var_annot (loc : Z) (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.var_annot) :=
  Error_monad.op_gtgtquestion
    (Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc))
    (fun function_parameter =>
      let '(vars, types, fields) := function_parameter in
      Error_monad.op_gtgtquestion (error_unexpected_annot loc types)
        (fun function_parameter =>
          let '_ := function_parameter in
          Error_monad.op_gtgtquestion (error_unexpected_annot loc fields)
            (fun function_parameter =>
              let '_ := function_parameter in
              get_two_annot loc vars))).

Definition parse_destr_annot
  (loc : Z) (annot : list string)
  (default_accessor : option Script_typed_ir.field_annot)
  (field_name : option Script_typed_ir.field_annot)
  (pair_annot : option Script_typed_ir.var_annot)
  (value_annot : option Script_typed_ir.var_annot)
  : Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.field_annot) :=
  Error_monad.op_gtgtquestion
    (Error_monad.op_gtgtquestion (parse_annots loc (Some true) None annot)
      (classify_annot loc))
    (fun function_parameter =>
      let '(vars, types, fields) := function_parameter in
      Error_monad.op_gtgtquestion (error_unexpected_annot loc types)
        (fun function_parameter =>
          let '_ := function_parameter in
          Error_monad.op_gtgtquestion (get_one_annot loc vars)
            (fun v =>
              Error_monad.op_gtpipequestion (get_one_annot loc fields)
                (fun f =>
                  let default :=
                    gen_access_annot pair_annot (Some default_accessor)
                      field_name in
                  let v :=
                    match v with
                    | Some (Var_annot "%") => field_to_var_annot field_name
                    | Some (Var_annot "%%") => default
                    | Some _ => v
                    | None => value_annot
                    end in
                  (v, f))))).

Definition parse_entrypoint_annot
  (loc : Z) (default : option (option Script_typed_ir.var_annot))
  (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.field_annot) :=
  Error_monad.op_gtgtquestion
    (Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc))
    (fun function_parameter =>
      let '(vars, types, fields) := function_parameter in
      Error_monad.op_gtgtquestion (error_unexpected_annot loc types)
        (fun function_parameter =>
          let '_ := function_parameter in
          Error_monad.op_gtgtquestion (get_one_annot loc fields)
            (fun f =>
              Error_monad.op_gtpipequestion (get_one_annot loc vars)
                (fun function_parameter =>
                  match function_parameter with
                  | (Some _) as a => (a, f)
                  | None =>
                    match default with
                    | Some a => (a, f)
                    | None => (None, f)
                    end
                  end)))).

Definition parse_var_type_annot (loc : Z) (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.type_annot) :=
  Error_monad.op_gtgtquestion
    (Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc))
    (fun function_parameter =>
      let '(vars, types, fields) := function_parameter in
      Error_monad.op_gtgtquestion (error_unexpected_annot loc fields)
        (fun function_parameter =>
          let '_ := function_parameter in
          Error_monad.op_gtgtquestion (get_one_annot loc vars)
            (fun v =>
              Error_monad.op_gtpipequestion (get_one_annot loc types)
                (fun __t_value => (v, __t_value))))).
