(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Unset Positivity Checking.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Script_tc_errors.
Require Tezos.Script_typed_ir.

Import Alpha_context.

Import Micheline.

Import Script_tc_errors.

Import Script_typed_ir.

Definition default_now_annot : option Script_typed_ir.var_annot :=
  Some (Script_typed_ir.Var_annot "now").

Definition default_amount_annot : option Script_typed_ir.var_annot :=
  Some (Script_typed_ir.Var_annot "amount").

Definition default_balance_annot : option Script_typed_ir.var_annot :=
  Some (Script_typed_ir.Var_annot "balance").

Definition default_steps_annot : option Script_typed_ir.var_annot :=
  Some (Script_typed_ir.Var_annot "steps").

Definition default_source_annot : option Script_typed_ir.var_annot :=
  Some (Script_typed_ir.Var_annot "source").

Definition default_sender_annot : option Script_typed_ir.var_annot :=
  Some (Script_typed_ir.Var_annot "sender").

Definition default_self_annot : option Script_typed_ir.var_annot :=
  Some (Script_typed_ir.Var_annot "self").

Definition default_arg_annot : option Script_typed_ir.var_annot :=
  Some (Script_typed_ir.Var_annot "arg").

Definition default_param_annot : option Script_typed_ir.var_annot :=
  Some (Script_typed_ir.Var_annot "parameter").

Definition default_storage_annot : option Script_typed_ir.var_annot :=
  Some (Script_typed_ir.Var_annot "storage").

Definition default_car_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot "car").

Definition default_cdr_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot "cdr").

Definition default_contract_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot "contract").

Definition default_addr_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot "address").

Definition default_manager_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot "manager").

Definition default_pack_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot "packed").

Definition default_unpack_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot "unpacked").

Definition default_slice_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot "slice").

Definition default_elt_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot "elt").

Definition default_key_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot "key").

Definition default_hd_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot "hd").

Definition default_tl_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot "tl").

Definition default_some_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot "some").

Definition default_left_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot "left").

Definition default_right_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot "right").

Definition default_binding_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot "bnd").

Definition unparse_type_annot
  (function_parameter : option Script_typed_ir.type_annot) : list string :=
  match function_parameter with
  | None => nil
  | Some (Script_typed_ir.Type_annot __a_value) =>
    [ Pervasives.op_caret ":" __a_value ]
  end.

Definition unparse_var_annot
  (function_parameter : option Script_typed_ir.var_annot) : list string :=
  match function_parameter with
  | None => nil
  | Some (Script_typed_ir.Var_annot __a_value) =>
    [ Pervasives.op_caret "@" __a_value ]
  end.

Definition unparse_field_annot
  (function_parameter : option Script_typed_ir.field_annot) : list string :=
  match function_parameter with
  | None => nil
  | Some (Script_typed_ir.Field_annot __a_value) =>
    [ Pervasives.op_caret "%" __a_value ]
  end.

Definition field_to_var_annot
  (function_parameter : option Script_typed_ir.field_annot)
  : option Script_typed_ir.var_annot :=
  match function_parameter with
  | None => None
  | Some (Script_typed_ir.Field_annot s) => Some (Script_typed_ir.Var_annot s)
  end.

Definition type_to_var_annot
  (function_parameter : option Script_typed_ir.type_annot)
  : option Script_typed_ir.var_annot :=
  match function_parameter with
  | None => None
  | Some (Script_typed_ir.Type_annot s) => Some (Script_typed_ir.Var_annot s)
  end.

Definition var_to_field_annot
  (function_parameter : option Script_typed_ir.var_annot)
  : option Script_typed_ir.field_annot :=
  match function_parameter with
  | None => None
  | Some (Script_typed_ir.Var_annot s) => Some (Script_typed_ir.Field_annot s)
  end.

Definition default_annot {A : Set}
  (default : option A) (function_parameter : option A) : option A :=
  match function_parameter with
  | None => default
  | annot => annot
  end.

Definition gen_access_annot
  (value_annot : option Script_typed_ir.var_annot)
  (op_staroptstar : option (option Script_typed_ir.field_annot))
  : option Script_typed_ir.field_annot -> option Script_typed_ir.var_annot :=
  let default :=
    match op_staroptstar with
    | Some op_starsthstar => op_starsthstar
    | None => None
    end in
  fun field_annot =>
    match (value_annot, field_annot, default) with
    |
      ((None, None, _) | (Some _, None, None) |
      (None, Some (Script_typed_ir.Field_annot ""), _)) => None
    | (None, Some (Script_typed_ir.Field_annot f), _) =>
      Some (Script_typed_ir.Var_annot f)
    |
      (Some (Script_typed_ir.Var_annot v),
        (None | Some (Script_typed_ir.Field_annot "")),
        Some (Script_typed_ir.Field_annot f)) =>
      Some (Script_typed_ir.Var_annot (String.concat "." [ v; f ]))
    |
      (Some (Script_typed_ir.Var_annot v), Some (Script_typed_ir.Field_annot f),
        _) => Some (Script_typed_ir.Var_annot (String.concat "." [ v; f ]))
    end.

Definition merge_type_annot
  (legacy : bool) (annot1 : option Script_typed_ir.type_annot)
  (annot2 : option Script_typed_ir.type_annot)
  : Error_monad.tzresult (option Script_typed_ir.type_annot) :=
  match (annot1, annot2) with
  | ((None, None) | (Some _, None) | (None, Some _)) => Error_monad.ok None
  | (Some (Script_typed_ir.Type_annot a1), Some (Script_typed_ir.Type_annot a2))
    =>
    if Pervasives.op_pipepipe legacy (String.equal a1 a2) then
      Error_monad.ok annot1
    else
      Error_monad.__error_value extensible_type_value
  end.

Definition merge_field_annot
  (legacy : bool) (annot1 : option Script_typed_ir.field_annot)
  (annot2 : option Script_typed_ir.field_annot)
  : Error_monad.tzresult (option Script_typed_ir.field_annot) :=
  match (annot1, annot2) with
  | ((None, None) | (Some _, None) | (None, Some _)) => Error_monad.ok None
  |
    (Some (Script_typed_ir.Field_annot a1),
      Some (Script_typed_ir.Field_annot a2)) =>
    if Pervasives.op_pipepipe legacy (String.equal a1 a2) then
      Error_monad.ok annot1
    else
      Error_monad.__error_value extensible_type_value
  end.

Definition merge_var_annot
  (annot1 : option Script_typed_ir.var_annot)
  (annot2 : option Script_typed_ir.var_annot)
  : option Script_typed_ir.var_annot :=
  match (annot1, annot2) with
  | ((None, None) | (Some _, None) | (None, Some _)) => None
  | (Some (Script_typed_ir.Var_annot a1), Some (Script_typed_ir.Var_annot a2))
    =>
    if String.equal a1 a2 then
      annot1
    else
      None
  end.

Definition error_unexpected_annot {A : Set}
  (loc : Alpha_context.Script.location) (annot : list A)
  : Error_monad.tzresult unit :=
  match annot with
  | [] => Error_monad.ok tt
  | cons _ _ => Error_monad.__error_value extensible_type_value
  end.

Definition fail_unexpected_annot {A : Set}
  (loc : Alpha_context.Script.location) (annot : list A)
  : Lwt.t (Error_monad.tzresult unit) :=
  Lwt.__return (error_unexpected_annot loc annot).

Inductive annot_opt : Set :=
| Field_annot_opt : option string -> annot_opt
| Type_annot_opt : option string -> annot_opt
| Var_annot_opt : option string -> annot_opt.

Definition parse_annots
  (loc : Alpha_context.Script.location) (op_staroptstar : option bool)
  : option bool -> list string -> Error_monad.tzresult (list annot_opt) :=
  let allow_special_var :=
    match op_staroptstar with
    | Some op_starsthstar => op_starsthstar
    | None => false
    end in
  fun op_staroptstar =>
    let allow_special_field :=
      match op_staroptstar with
      | Some op_starsthstar => op_starsthstar
      | None => false
      end in
    fun l =>
      let sub_or_wildcard {A : Set}
        (specials : list ascii) (wrap : option string -> A) (s : string)
        (acc : list A) : Error_monad.tzresult (list A) :=
        let len := String.length s in
        if (|Compare.Int|).(Compare.S.op_eq) len 1 then
          Error_monad.ok (cons (wrap None) acc)
        else
          match
            ((String.get s 1),
              match String.get s 1 with
              | "@" % char =>
                Pervasives.op_andand ((|Compare.Int|).(Compare.S.op_eq) len 2)
                  (List.mem "@" % char specials)
              | _ => false
              end,
              match String.get s 1 with
              | "%" % char => List.mem "%" % char specials
              | _ => false
              end) with
          |
            (("a" % char | "b" % char | "c" % char | "d" % char | "e" % char |
            "f" % char | "g" % char | "h" % char | "i" % char | "j" % char |
            "k" % char | "l" % char | "m" % char | "n" % char | "o" % char |
            "p" % char | "q" % char | "r" % char | "s" % char | "t" % char |
            "u" % char | "v" % char | "w" % char | "x" % char | "y" % char |
            "z" % char | "A" % char | "B" % char | "C" % char | "D" % char |
            "E" % char | "F" % char | "G" % char | "H" % char | "I" % char |
            "J" % char | "K" % char | "L" % char | "M" % char | "N" % char |
            "O" % char | "P" % char | "Q" % char | "R" % char | "S" % char |
            "T" % char | "U" % char | "V" % char | "W" % char | "X" % char |
            "Y" % char | "Z" % char | "_" % char), _, _) =>
            Error_monad.ok
              (cons (wrap (Some (String.sub s 1 (Pervasives.op_minus len 1))))
                acc)
          | ("@" % char, true, _) => Error_monad.ok (cons (wrap (Some "@")) acc)
          | ("%" % char, _, true) =>
            if (|Compare.Int|).(Compare.S.op_eq) len 2 then
              Error_monad.ok (cons (wrap (Some "%")) acc)
            else
              if
                Pervasives.op_andand ((|Compare.Int|).(Compare.S.op_eq) len 3)
                  ((|Compare.Char|).(Compare.S.op_eq) (String.get s 2)
                    "%" % char) then
                Error_monad.ok (cons (wrap (Some "%%")) acc)
              else
                Error_monad.__error_value extensible_type_value
          | (_, _, _) => Error_monad.__error_value extensible_type_value
          end in
      Error_monad.op_gtpipequestion
        (List.fold_left
          (fun acc =>
            fun s =>
              let? acc := acc in
              if (|Compare.Int|).(Compare.S.op_eq) (String.length s) 0 then
                Error_monad.__error_value extensible_type_value
              else
                match String.get s 0 with
                | ":" % char =>
                  sub_or_wildcard nil
                    (fun __a_value => Type_annot_opt __a_value) s acc
                | "@" % char =>
                  sub_or_wildcard
                    (if allow_special_var then
                      [ "%" % char ]
                    else
                      nil) (fun __a_value => Var_annot_opt __a_value) s acc
                | "%" % char =>
                  sub_or_wildcard
                    (if allow_special_field then
                      [ "@" % char ]
                    else
                      nil) (fun __a_value => Field_annot_opt __a_value) s acc
                | _ => Error_monad.__error_value extensible_type_value
                end) (Error_monad.ok nil) l) List.rev.

Definition opt_var_of_var_opt (function_parameter : option string)
  : option Script_typed_ir.var_annot :=
  match function_parameter with
  | None => None
  | Some __a_value => Some (Script_typed_ir.Var_annot __a_value)
  end.

Definition opt_field_of_field_opt (function_parameter : option string)
  : option Script_typed_ir.field_annot :=
  match function_parameter with
  | None => None
  | Some __a_value => Some (Script_typed_ir.Field_annot __a_value)
  end.

Definition opt_type_of_type_opt (function_parameter : option string)
  : option Script_typed_ir.type_annot :=
  match function_parameter with
  | None => None
  | Some __a_value => Some (Script_typed_ir.Type_annot __a_value)
  end.

Definition classify_annot
  (loc : Alpha_context.Script.location) (l : list annot_opt)
  : Error_monad.tzresult
    (list (option Script_typed_ir.var_annot) *
      list (option Script_typed_ir.type_annot) *
      list (option Script_typed_ir.field_annot)) :=
  (* ❌ Try-with are not handled *)
  try
    (let '(_, rv, _, rt, _, rf) :=
      List.fold_left
        (fun function_parameter =>
          let '(in_v, rv, in_t, rt, in_f, rf) := function_parameter in
          fun __a_value =>
            match (__a_value, in_v, rv, in_t, rt, in_f, rf) with
            |
              ((Var_annot_opt __a_value, true, _, _, _, _, _) |
              (Var_annot_opt __a_value, false, [], _, _, _, _)) =>
              (true, (cons (opt_var_of_var_opt __a_value) rv), false, rt, false,
                rf)
            |
              ((Type_annot_opt __a_value, _, _, true, _, _, _) |
              (Type_annot_opt __a_value, _, _, false, [], _, _)) =>
              (false, rv, true, (cons (opt_type_of_type_opt __a_value) rt),
                false, rf)
            |
              ((Field_annot_opt __a_value, _, _, _, _, true, _) |
              (Field_annot_opt __a_value, _, _, _, _, false, [])) =>
              (false, rv, false, rt, true,
                (cons (opt_field_of_field_opt __a_value) rf))
            | _ => Pervasives.raise extensible_type_value
            end) (false, nil, false, nil, false, nil) l in
    Error_monad.ok ((List.rev rv), (List.rev rt), (List.rev rf))).

Definition get_one_annot {A : Set}
  (loc : Alpha_context.Script.location) (function_parameter : list (option A))
  : Error_monad.tzresult (option A) :=
  match function_parameter with
  | [] => Error_monad.ok None
  | cons __a_value [] => Error_monad.ok __a_value
  | _ => Error_monad.__error_value extensible_type_value
  end.

Definition get_two_annot {A : Set}
  (loc : Alpha_context.Script.location) (function_parameter : list (option A))
  : Error_monad.tzresult (option A * option A) :=
  match function_parameter with
  | [] => Error_monad.ok (None, None)
  | cons __a_value [] => Error_monad.ok (__a_value, None)
  | cons __a_value (cons __b_value []) => Error_monad.ok (__a_value, __b_value)
  | _ => Error_monad.__error_value extensible_type_value
  end.

Definition parse_type_annot (loc : Z) (annot : list string)
  : Error_monad.tzresult (option Script_typed_ir.type_annot) :=
  let? '(vars, types, fields) :=
    Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc) in
  let? '_ := error_unexpected_annot loc vars in
  let? '_ := error_unexpected_annot loc fields in
  get_one_annot loc types.

Definition parse_type_field_annot (loc : Z) (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.type_annot * option Script_typed_ir.field_annot) :=
  let? '(vars, types, fields) :=
    Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc) in
  let? '_ := error_unexpected_annot loc vars in
  let? __t_value := get_one_annot loc types in
  Error_monad.op_gtpipequestion (get_one_annot loc fields)
    (fun f => (__t_value, f)).

Definition parse_composed_type_annot (loc : Z) (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.type_annot * option Script_typed_ir.field_annot *
      option Script_typed_ir.field_annot) :=
  let? '(vars, types, fields) :=
    Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc) in
  let? '_ := error_unexpected_annot loc vars in
  let? __t_value := get_one_annot loc types in
  Error_monad.op_gtpipequestion (get_two_annot loc fields)
    (fun function_parameter =>
      let '(f1, f2) := function_parameter in
      (__t_value, f1, f2)).

Definition parse_field_annot (loc : Z) (annot : list string)
  : Error_monad.tzresult (option Script_typed_ir.field_annot) :=
  let? '(vars, types, fields) :=
    Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc) in
  let? '_ := error_unexpected_annot loc vars in
  let? '_ := error_unexpected_annot loc types in
  get_one_annot loc fields.

Definition extract_field_annot (function_parameter : Alpha_context.Script.node)
  : Error_monad.tzresult
    (Alpha_context.Script.node * option Script_typed_ir.field_annot) :=
  match function_parameter with
  | Micheline.Prim loc prim args annot =>
    let fix extract_first (acc : list string) (function_parameter : list string)
      {struct acc} : option string * Micheline.annot :=
      match function_parameter with
      | [] => (None, annot)
      | cons s rest =>
        if
          Pervasives.op_andand
            ((|Compare.Int|).(Compare.S.op_gt) (String.length s) 0)
            ((|Compare.Char|).(Compare.S.op_eq) (String.get s 0) "%" % char)
          then
          ((Some s), (List.rev_append acc rest))
        else
          extract_first (cons s acc) rest
      end in
    let '(field_annot, annot) := extract_first nil annot in
    let field_annot :=
      match field_annot with
      | None => None
      | Some field_annot =>
        Some
          (Script_typed_ir.Field_annot
            (String.sub field_annot 1
              (Pervasives.op_minus (String.length field_annot) 1)))
      end in
    Error_monad.ok ((Micheline.Prim loc prim args annot), field_annot)
  | expr => Error_monad.ok (expr, None)
  end.

Definition check_correct_field
  (f1 : option Script_typed_ir.field_annot)
  (f2 : option Script_typed_ir.field_annot) : Error_monad.tzresult unit :=
  match (f1, f2) with
  | ((None, _) | (_, None)) => Error_monad.ok tt
  |
    (Some (Script_typed_ir.Field_annot s1),
      Some (Script_typed_ir.Field_annot s2)) =>
    if String.equal s1 s2 then
      Error_monad.ok tt
    else
      Error_monad.__error_value extensible_type_value
  end.

Definition parse_var_annot
  (loc : Z) (default : option (option Script_typed_ir.var_annot))
  (annot : list string)
  : Error_monad.tzresult (option Script_typed_ir.var_annot) :=
  let? '(vars, types, fields) :=
    Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc) in
  let? '_ := error_unexpected_annot loc types in
  let? '_ := error_unexpected_annot loc fields in
  Error_monad.op_gtpipequestion (get_one_annot loc vars)
    (fun function_parameter =>
      match function_parameter with
      | (Some _) as __a_value => __a_value
      | None =>
        match default with
        | Some __a_value => __a_value
        | None => None
        end
      end).

Definition split_last_dot
  (function_parameter : option Script_typed_ir.field_annot)
  : option Script_typed_ir.var_annot * option Script_typed_ir.field_annot :=
  match function_parameter with
  | None => (None, None)
  | Some (Script_typed_ir.Field_annot s) =>
    match String.rindex_opt s "." % char with
    | None => (None, (Some (Script_typed_ir.Field_annot s)))
    | Some i =>
      let s1 := String.sub s 0 i in
      let s2 :=
        String.sub s (Pervasives.op_plus i 1)
          (Pervasives.op_minus (Pervasives.op_minus (String.length s) i) 1) in
      let f :=
        if
          Pervasives.op_pipepipe ((|Compare.String|).(Compare.S.equal) s2 "car")
            ((|Compare.String|).(Compare.S.equal) s2 "cdr") then
          None
        else
          Some (Script_typed_ir.Field_annot s2) in
      ((Some (Script_typed_ir.Var_annot s1)), f)
    end
  end.

Definition common_prefix
  (v1 : option Script_typed_ir.var_annot)
  (v2 : option Script_typed_ir.var_annot) : option Script_typed_ir.var_annot :=
  match
    ((v1, v2),
      match (v1, v2) with
      |
        (Some (Script_typed_ir.Var_annot s1),
          Some (Script_typed_ir.Var_annot s2)) =>
        (|Compare.String|).(Compare.S.equal) s1 s2
      | _ => false
      end) with
  |
    ((Some (Script_typed_ir.Var_annot s1), Some (Script_typed_ir.Var_annot s2)),
      true) => v1
  | ((Some _, None), _) => v1
  | ((None, Some _), _) => v2
  | ((_, _), _) => None
  end.

Definition parse_constr_annot
  (loc : Z) (if_special_first : option (option Script_typed_ir.field_annot))
  (if_special_second : option (option Script_typed_ir.field_annot))
  (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.type_annot *
      option Script_typed_ir.field_annot * option Script_typed_ir.field_annot) :=
  let? '(vars, types, fields) :=
    Error_monad.op_gtgtquestion (parse_annots loc None (Some true) annot)
      (classify_annot loc) in
  let? v := get_one_annot loc vars in
  let? __t_value := get_one_annot loc types in
  let? '(f1, f2) := get_two_annot loc fields in
  let? '(v1, f1) :=
    match (if_special_first, f1) with
    | (Some special_var, Some (Script_typed_ir.Field_annot "@")) =>
      Error_monad.ok (split_last_dot special_var)
    | (None, Some (Script_typed_ir.Field_annot "@")) =>
      Error_monad.__error_value extensible_type_value
    | (_, _) => Error_monad.ok (v, f1)
    end in
  Error_monad.op_gtpipequestion
    match (if_special_second, f2) with
    | (Some special_var, Some (Script_typed_ir.Field_annot "@")) =>
      Error_monad.ok (split_last_dot special_var)
    | (None, Some (Script_typed_ir.Field_annot "@")) =>
      Error_monad.__error_value extensible_type_value
    | (_, _) => Error_monad.ok (v, f2)
    end
    (fun function_parameter =>
      let '(v2, f2) := function_parameter in
      let v :=
        match v with
        | None => common_prefix v1 v2
        | Some _ => v
        end in
      (v, __t_value, f1, f2)).

Definition parse_two_var_annot (loc : Z) (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.var_annot) :=
  let? '(vars, types, fields) :=
    Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc) in
  let? '_ := error_unexpected_annot loc types in
  let? '_ := error_unexpected_annot loc fields in
  get_two_annot loc vars.

Definition parse_destr_annot
  (loc : Z) (annot : list string)
  (default_accessor : option Script_typed_ir.field_annot)
  (field_name : option Script_typed_ir.field_annot)
  (pair_annot : option Script_typed_ir.var_annot)
  (value_annot : option Script_typed_ir.var_annot)
  : Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.field_annot) :=
  let? '(vars, types, fields) :=
    Error_monad.op_gtgtquestion (parse_annots loc (Some true) None annot)
      (classify_annot loc) in
  let? '_ := error_unexpected_annot loc types in
  let? v := get_one_annot loc vars in
  Error_monad.op_gtpipequestion (get_one_annot loc fields)
    (fun f =>
      let default :=
        gen_access_annot pair_annot (Some default_accessor) field_name in
      let v :=
        match v with
        | Some (Script_typed_ir.Var_annot "%") => field_to_var_annot field_name
        | Some (Script_typed_ir.Var_annot "%%") => default
        | Some _ => v
        | None => value_annot
        end in
      (v, f)).

Definition parse_entrypoint_annot
  (loc : Z) (default : option (option Script_typed_ir.var_annot))
  (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.field_annot) :=
  let? '(vars, types, fields) :=
    Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc) in
  let? '_ := error_unexpected_annot loc types in
  let? f := get_one_annot loc fields in
  Error_monad.op_gtpipequestion (get_one_annot loc vars)
    (fun function_parameter =>
      match function_parameter with
      | (Some _) as __a_value => (__a_value, f)
      | None =>
        match default with
        | Some __a_value => (__a_value, f)
        | None => (None, f)
        end
      end).

Definition parse_var_type_annot (loc : Z) (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.type_annot) :=
  let? '(vars, types, fields) :=
    Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc) in
  let? '_ := error_unexpected_annot loc fields in
  let? v := get_one_annot loc vars in
  Error_monad.op_gtpipequestion (get_one_annot loc types)
    (fun __t_value => (v, __t_value)).
