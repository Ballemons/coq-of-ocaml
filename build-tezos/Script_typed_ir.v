(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Unset Positivity Checking.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.

Import Alpha_context.

Import Alpha_context.Script_int.

Inductive var_annot : Set :=
| Var_annot : string -> var_annot.

Inductive type_annot : Set :=
| Type_annot : string -> type_annot.

Inductive field_annot : Set :=
| Field_annot : string -> field_annot.

Definition address : Set := Alpha_context.Contract.t * string.

Definition pair (a b : Set) : Set := a * b.

Inductive union (a b : Set) : Set :=
| L : a -> union a b
| R : b -> union a b.

Arguments L {_ _}.
Arguments R {_ _}.

Inductive comb : Set :=
| Comb : comb.

Inductive leaf : Set :=
| Leaf : leaf.

Inductive comparable_struct : Set :=
| Int_key : option type_annot -> comparable_struct
| Nat_key : option type_annot -> comparable_struct
| String_key : option type_annot -> comparable_struct
| Bytes_key : option type_annot -> comparable_struct
| Mutez_key : option type_annot -> comparable_struct
| Bool_key : option type_annot -> comparable_struct
| Key_hash_key : option type_annot -> comparable_struct
| Timestamp_key : option type_annot -> comparable_struct
| Address_key : option type_annot -> comparable_struct
| Pair_key :
  comparable_struct * option field_annot ->
  comparable_struct * option field_annot -> option type_annot ->
  comparable_struct.

Definition comparable_ty : Set := comparable_struct.

Module Boxed_set.
  Record signature {elt OPS_t : Set} : Set := {
    elt := elt;
    elt_ty : comparable_ty;
    OPS : S.SET.signature elt OPS_t;
    boxed : OPS.(S.SET.t);
    size : int;
  }.
  Arguments signature : clear implicits.
End Boxed_set.

Definition set (elt : Set) : Set :=
  {OPS_t : Set @ Boxed_set.signature elt OPS_t}.

Module Boxed_map.
  Record signature {key value : Set} {OPS_t : Set -> Set} : Set := {
    key := key;
    value := value;
    key_ty : comparable_ty;
    OPS : S.MAP.signature key OPS_t;
    boxed : OPS.(S.MAP.t) value * int;
  }.
  Arguments signature : clear implicits.
End Boxed_map.

Definition map (key value : Set) : Set :=
  {OPS_t : Set -> Set @ Boxed_map.signature key value OPS_t}.

Definition operation : Set :=
  Alpha_context.packed_internal_operation *
    option Alpha_context.Contract.big_map_diff.

Module script.
  Record record {code arg_type storage storage_type root_name : Set} : Set := Build {
    code : code;
    arg_type : arg_type;
    storage : storage;
    storage_type : storage_type;
    root_name : root_name }.
  Arguments record : clear implicits.
  Definition with_code {t_code t_arg_type t_storage t_storage_type t_root_name}
    code (r : record t_code t_arg_type t_storage t_storage_type t_root_name) :=
    Build t_code t_arg_type t_storage t_storage_type t_root_name code
      r.(arg_type) r.(storage) r.(storage_type) r.(root_name).
  Definition with_arg_type
    {t_code t_arg_type t_storage t_storage_type t_root_name} arg_type
    (r : record t_code t_arg_type t_storage t_storage_type t_root_name) :=
    Build t_code t_arg_type t_storage t_storage_type t_root_name r.(code)
      arg_type r.(storage) r.(storage_type) r.(root_name).
  Definition with_storage
    {t_code t_arg_type t_storage t_storage_type t_root_name} storage
    (r : record t_code t_arg_type t_storage t_storage_type t_root_name) :=
    Build t_code t_arg_type t_storage t_storage_type t_root_name r.(code)
      r.(arg_type) storage r.(storage_type) r.(root_name).
  Definition with_storage_type
    {t_code t_arg_type t_storage t_storage_type t_root_name} storage_type
    (r : record t_code t_arg_type t_storage t_storage_type t_root_name) :=
    Build t_code t_arg_type t_storage t_storage_type t_root_name r.(code)
      r.(arg_type) r.(storage) storage_type r.(root_name).
  Definition with_root_name
    {t_code t_arg_type t_storage t_storage_type t_root_name} root_name
    (r : record t_code t_arg_type t_storage t_storage_type t_root_name) :=
    Build t_code t_arg_type t_storage t_storage_type t_root_name r.(code)
      r.(arg_type) r.(storage) r.(storage_type) root_name.
End script.
Definition script_skeleton := script.record.

Module lambda.
  Record record {lam : Set} : Set := Build {
    lam : lam }.
  Arguments record : clear implicits.
  Definition with_lam {t_lam} lam (r : record t_lam) :=
    Build t_lam lam.
End lambda.
Definition lambda_skeleton := lambda.record.

Module descr.
  Record record {loc bef aft instr : Set} : Set := Build {
    loc : loc;
    bef : bef;
    aft : aft;
    instr : instr }.
  Arguments record : clear implicits.
  Definition with_loc {t_loc t_bef t_aft t_instr} loc
    (r : record t_loc t_bef t_aft t_instr) :=
    Build t_loc t_bef t_aft t_instr loc r.(bef) r.(aft) r.(instr).
  Definition with_bef {t_loc t_bef t_aft t_instr} bef
    (r : record t_loc t_bef t_aft t_instr) :=
    Build t_loc t_bef t_aft t_instr r.(loc) bef r.(aft) r.(instr).
  Definition with_aft {t_loc t_bef t_aft t_instr} aft
    (r : record t_loc t_bef t_aft t_instr) :=
    Build t_loc t_bef t_aft t_instr r.(loc) r.(bef) aft r.(instr).
  Definition with_instr {t_loc t_bef t_aft t_instr} instr
    (r : record t_loc t_bef t_aft t_instr) :=
    Build t_loc t_bef t_aft t_instr r.(loc) r.(bef) r.(aft) instr.
End descr.
Definition descr_skeleton := descr.record.

Module big_map.
  Record record {id diff key_type value_type : Set} : Set := Build {
    id : id;
    diff : diff;
    key_type : key_type;
    value_type : value_type }.
  Arguments record : clear implicits.
  Definition with_id {t_id t_diff t_key_type t_value_type} id
    (r : record t_id t_diff t_key_type t_value_type) :=
    Build t_id t_diff t_key_type t_value_type id r.(diff) r.(key_type)
      r.(value_type).
  Definition with_diff {t_id t_diff t_key_type t_value_type} diff
    (r : record t_id t_diff t_key_type t_value_type) :=
    Build t_id t_diff t_key_type t_value_type r.(id) diff r.(key_type)
      r.(value_type).
  Definition with_key_type {t_id t_diff t_key_type t_value_type} key_type
    (r : record t_id t_diff t_key_type t_value_type) :=
    Build t_id t_diff t_key_type t_value_type r.(id) r.(diff) key_type
      r.(value_type).
  Definition with_value_type {t_id t_diff t_key_type t_value_type} value_type
    (r : record t_id t_diff t_key_type t_value_type) :=
    Build t_id t_diff t_key_type t_value_type r.(id) r.(diff) r.(key_type)
      value_type.
End big_map.
Definition big_map_skeleton := big_map.record.

Reserved Notation "'end_of_stack".
Reserved Notation "'typed_contract".
Reserved Notation "'big_map".
Reserved Notation "'descr".
Reserved Notation "'lambda".
Reserved Notation "'script".

Inductive ty : Set :=
| Unit_t : option type_annot -> ty
| Int_t : option type_annot -> ty
| Nat_t : option type_annot -> ty
| Signature_t : option type_annot -> ty
| String_t : option type_annot -> ty
| Bytes_t : option type_annot -> ty
| Mutez_t : option type_annot -> ty
| Key_hash_t : option type_annot -> ty
| Key_t : option type_annot -> ty
| Timestamp_t : option type_annot -> ty
| Address_t : option type_annot -> ty
| Bool_t : option type_annot -> ty
| Pair_t :
  ty * option field_annot * option var_annot ->
  ty * option field_annot * option var_annot -> option type_annot -> bool -> ty
| Union_t :
  ty * option field_annot -> ty * option field_annot -> option type_annot ->
  bool -> ty
| Lambda_t : ty -> ty -> option type_annot -> ty
| Option_t : ty -> option type_annot -> bool -> ty
| List_t : ty -> option type_annot -> bool -> ty
| Set_t : comparable_ty -> option type_annot -> ty
| Map_t : comparable_ty -> ty -> option type_annot -> bool -> ty
| Big_map_t : comparable_ty -> ty -> option type_annot -> ty
| Contract_t : ty -> option type_annot -> ty
| Operation_t : option type_annot -> ty
| Chain_id_t : option type_annot -> ty

with stack_ty : Set :=
| Item_t : ty -> stack_ty -> option var_annot -> stack_ty
| Empty_t : stack_ty

with instr : Set :=
| Drop : instr
| Dup : instr
| Swap : instr
| Const : forall {ty_ : Set}, ty_ -> instr
| Cons_pair : instr
| Car : instr
| Cdr : instr
| Cons_some : instr
| Cons_none : ty -> instr
| If_none : 'descr -> 'descr -> instr
| Left : instr
| Right : instr
| If_left : 'descr -> 'descr -> instr
| Cons_list : instr
| Nil : instr
| If_cons : 'descr -> 'descr -> instr
| List_map : 'descr -> instr
| List_iter : 'descr -> instr
| List_size : instr
| Empty_set : comparable_ty -> instr
| Set_iter : 'descr -> instr
| Set_mem : instr
| Set_update : instr
| Set_size : instr
| Empty_map : comparable_ty -> ty -> instr
| Map_map : 'descr -> instr
| Map_iter : 'descr -> instr
| Map_mem : instr
| Map_get : instr
| Map_update : instr
| Map_size : instr
| Empty_big_map : comparable_ty -> ty -> instr
| Big_map_mem : instr
| Big_map_get : instr
| Big_map_update : instr
| Concat_string : instr
| Concat_string_pair : instr
| Slice_string : instr
| String_size : instr
| Concat_bytes : instr
| Concat_bytes_pair : instr
| Slice_bytes : instr
| Bytes_size : instr
| Add_seconds_to_timestamp : instr
| Add_timestamp_to_seconds : instr
| Sub_timestamp_seconds : instr
| Diff_timestamps : instr
| Add_tez : instr
| Sub_tez : instr
| Mul_teznat : instr
| Mul_nattez : instr
| Ediv_teznat : instr
| Ediv_tez : instr
| Or : instr
| And : instr
| Xor : instr
| Not : instr
| Is_nat : instr
| Neg_nat : instr
| Neg_int : instr
| Abs_int : instr
| Int_nat : instr
| Add_intint : instr
| Add_intnat : instr
| Add_natint : instr
| Add_natnat : instr
| Sub_int : instr
| Mul_intint : instr
| Mul_intnat : instr
| Mul_natint : instr
| Mul_natnat : instr
| Ediv_intint : instr
| Ediv_intnat : instr
| Ediv_natint : instr
| Ediv_natnat : instr
| Lsl_nat : instr
| Lsr_nat : instr
| Or_nat : instr
| And_nat : instr
| And_int_nat : instr
| Xor_nat : instr
| Not_nat : instr
| Not_int : instr
| Seq : 'descr -> 'descr -> instr
| If : 'descr -> 'descr -> instr
| Loop : 'descr -> instr
| Loop_left : 'descr -> instr
| Dip : 'descr -> instr
| Exec : instr
| Apply : ty -> instr
| Lambda : 'lambda -> instr
| Failwith : ty -> instr
| Nop : instr
| Compare : comparable_ty -> instr
| Eq : instr
| Neq : instr
| Lt : instr
| Gt : instr
| Le : instr
| Ge : instr
| Address : instr
| Contract : ty -> string -> instr
| Transfer_tokens : instr
| Create_account : instr
| Implicit_account : instr
| Create_contract : ty -> ty -> 'lambda -> option string -> instr
| Create_contract_2 : ty -> ty -> 'lambda -> option string -> instr
| Set_delegate : instr
| Now : instr
| Balance : instr
| Check_signature : instr
| Hash_key : instr
| Pack : ty -> instr
| Unpack : ty -> instr
| Blake2b : instr
| Sha256 : instr
| Sha512 : instr
| Steps_to_quota : instr
| Source : instr
| Sender : instr
| Self : ty -> string -> instr
| Amount : instr
| Dig : int -> stack_prefix_preservation_witness -> instr
| Dug : int -> stack_prefix_preservation_witness -> instr
| Dipn : int -> stack_prefix_preservation_witness -> 'descr -> instr
| Dropn : int -> stack_prefix_preservation_witness -> instr
| ChainId : instr

with stack_prefix_preservation_witness : Set :=
| Prefix :
  stack_prefix_preservation_witness -> stack_prefix_preservation_witness
| Rest : stack_prefix_preservation_witness

where "'end_of_stack" := (unit)
and "'typed_contract" := (ty * address)
and "'big_map" := (fun (t_key t_value : Set) =>
  big_map_skeleton (option Z.t) (map t_key (option t_value)) ty ty)
and "'descr" :=
  (descr_skeleton Alpha_context.Script.location stack_ty stack_ty instr)
and "'lambda" := (lambda_skeleton ('descr * Alpha_context.Script.node))
and "'script" := (fun (t_storage : Set) =>
  script_skeleton 'lambda ty t_storage ty (option string)).

Definition end_of_stack := 'end_of_stack.
Definition typed_contract := 'typed_contract.
Definition big_map := 'big_map.
Definition descr := 'descr.
Definition lambda := 'lambda.
Definition script := 'script.

Inductive ex_big_map : Set :=
| Ex_bm : forall {key value : Set}, big_map key value -> ex_big_map.
