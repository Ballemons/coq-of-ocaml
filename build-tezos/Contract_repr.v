(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Unset Positivity Checking.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Contract_hash.
Require Tezos.Storage_description.

Inductive t : Set :=
| Implicit : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -> t
| Originated : Contract_hash.t -> t.

Definition CompareModule :=
  Compare.Make
    (let t := t in
    let compare (l1 : t) (l2 : t) : Z :=
      match (l1, l2) with
      | (Implicit pkh1, Implicit pkh2) =>
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.compare) pkh1 pkh2
      | (Originated h1, Originated h2) => Contract_hash.compare h1 h2
      | (Implicit _, Originated _) => (-1)
      | (Originated _, Implicit _) => 1
      end in
    existT (A := Set) _ _
      {|
        Compare.COMPARABLE.compare := compare
      |}).

Definition op_eq := (|CompareModule|).(Compare.S.op_eq).

Definition op_ltgt := (|CompareModule|).(Compare.S.op_ltgt).

Definition op_lt := (|CompareModule|).(Compare.S.op_lt).

Definition op_lteq := (|CompareModule|).(Compare.S.op_lteq).

Definition op_gteq := (|CompareModule|).(Compare.S.op_gteq).

Definition op_gt := (|CompareModule|).(Compare.S.op_gt).

Definition compare := (|CompareModule|).(Compare.S.compare).

Definition equal := (|CompareModule|).(Compare.S.equal).

Definition max := (|CompareModule|).(Compare.S.max).

Definition min := (|CompareModule|).(Compare.S.min).

Definition contract : Set := t.

(* ❌ Structure item `typext` not handled. *)
(* type_extension *)

Definition to_b58check (function_parameter : t) : string :=
  match function_parameter with
  | Implicit pbk =>
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.to_b58check) pbk
  | Originated h => Contract_hash.to_b58check h
  end.

Definition of_b58check (s : string) : Error_monad.tzresult t :=
  let '_ := Base58.decode s in
  Error_monad.__error_value extensible_type_value.

Definition pp (ppf : Format.formatter) (function_parameter : t) : unit :=
  match function_parameter with
  | Implicit pbk =>
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.pp) ppf pbk
  | Originated h => Contract_hash.pp ppf h
  end.

Definition pp_short (ppf : Format.formatter) (function_parameter : t) : unit :=
  match function_parameter with
  | Implicit pbk =>
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.pp_short) ppf pbk
  | Originated h => Contract_hash.pp_short ppf h
  end.

Definition encoding : Data_encoding.encoding t := axiom.

(* ❌ Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition implicit_contract
  (id : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) : t := Implicit id.

Definition is_implicit (function_parameter : t)
  : option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) :=
  match function_parameter with
  | Implicit m => Some m
  | Originated _ => None
  end.

Definition is_originated (function_parameter : t) : option Contract_hash.t :=
  match function_parameter with
  | Implicit _ => None
  | Originated h => Some h
  end.

Module origination_nonce.
  Record record : Set := Build {
    operation_hash : (|Operation_hash|).(S.HASH.t);
    origination_index : int32 }.
  Definition with_operation_hash operation_hash (r : record) :=
    Build operation_hash r.(origination_index).
  Definition with_origination_index origination_index (r : record) :=
    Build r.(operation_hash) origination_index.
End origination_nonce.
Definition origination_nonce := origination_nonce.record.

Definition origination_nonce_encoding
  : Data_encoding.encoding origination_nonce :=
  (let arg :=
    Data_encoding.conv
      (fun function_parameter =>
        let '{|
          origination_nonce.operation_hash := operation_hash;
            origination_nonce.origination_index := origination_index
            |} := function_parameter in
        (operation_hash, origination_index))
      (fun function_parameter =>
        let '(operation_hash, origination_index) := function_parameter in
        {| origination_nonce.operation_hash := operation_hash;
          origination_nonce.origination_index := origination_index |}) in
  fun eta => arg None eta)
    (Data_encoding.obj2
      (Data_encoding.req None None "operation"
        (|Operation_hash|).(S.HASH.encoding))
      (Data_encoding.dft None None "index" Data_encoding.__int32_value
        (* ❌ Constant of type int32 is converted to int *)
        0)).

Definition originated_contract (__nonce_value : origination_nonce) : t :=
  let data :=
    Data_encoding.Binary.to_bytes_exn origination_nonce_encoding __nonce_value
    in
  Originated (Contract_hash.hash_bytes None [ data ]).

Definition originated_contracts (function_parameter : origination_nonce)
  : origination_nonce -> list t :=
  let '{|
    origination_nonce.operation_hash := first_hash;
      origination_nonce.origination_index := first
      |} := function_parameter in
  fun function_parameter =>
    let
      '{|
        origination_nonce.operation_hash := last_hash;
          origination_nonce.origination_index := last
          |} as origination_nonce := function_parameter in
    (* ❌ Sequences of instructions are ignored (operator ";") *)
    (* ❌ instruction_sequence ";" *)
    let fix contracts
      (acc : list t) (origination_index : (|Compare.Int32|).(Compare.S.t))
      {struct acc} : list t :=
      if (|Compare.Int32|).(Compare.S.op_lt) origination_index first then
        acc
      else
        let origination_nonce :=
          origination_nonce.with_origination_index origination_index
            origination_nonce in
        let acc := cons (originated_contract origination_nonce) acc in
        contracts acc (Int32.pred origination_index) in
    contracts nil (Int32.pred last).

Definition initial_origination_nonce
  (operation_hash : (|Operation_hash|).(S.HASH.t)) : origination_nonce :=
  {| origination_nonce.operation_hash := operation_hash;
    origination_nonce.origination_index :=
      (* ❌ Constant of type int32 is converted to int *)
      0 |}.

Definition incr_origination_nonce (__nonce_value : origination_nonce)
  : origination_nonce :=
  let origination_index :=
    Int32.succ __nonce_value.(origination_nonce.origination_index) in
  origination_nonce.with_origination_index origination_index __nonce_value.

Definition rpc_arg : RPC_arg.arg t :=
  let construct := to_b58check in
  let destruct (__hash_value : string) : Pervasives.result t string :=
    match of_b58check __hash_value with
    | Pervasives.Error _ => Pervasives.Error "Cannot parse contract id"
    | Pervasives.Ok contract => Pervasives.Ok contract
    end in
  RPC_arg.make (Some "A contract identifier encoded in b58check.") "contract_id"
    destruct construct tt.

Definition Index :=
  let t := contract in
  let path_length := 7 in
  let to_path (c : t) (l : list string) : list string :=
    let raw_key := Data_encoding.Binary.to_bytes_exn encoding c in
    let 'MBytes.Hex __key_value := MBytes.to_hex raw_key in
    let 'MBytes.Hex index_key := MBytes.to_hex (Raw_hashes.blake2b raw_key) in
    cons (String.sub index_key 0 2)
      (cons (String.sub index_key 2 2)
        (cons (String.sub index_key 4 2)
          (cons (String.sub index_key 6 2)
            (cons (String.sub index_key 8 2)
              (cons (String.sub index_key 10 2) (cons __key_value l)))))) in
  let of_path (function_parameter : list (|Compare.String|).(Compare.S.t))
    : option t :=
    match function_parameter with
    |
      ([] | cons _ [] | cons _ (cons _ []) | cons _ (cons _ (cons _ [])) |
      cons _ (cons _ (cons _ (cons _ []))) |
      cons _ (cons _ (cons _ (cons _ (cons _ [])))) |
      cons _ (cons _ (cons _ (cons _ (cons _ (cons _ []))))) |
      cons _ (cons _ (cons _ (cons _ (cons _ (cons _ (cons _ (cons _ _))))))))
      => None
    |
      cons index1
        (cons index2
          (cons index3
            (cons index4 (cons index5 (cons index6 (cons __key_value [])))))) =>
      let raw_key := MBytes.of_hex (MBytes.Hex __key_value) in
      let 'MBytes.Hex index_key := MBytes.to_hex (Raw_hashes.blake2b raw_key) in
      (* ❌ Sequences of instructions are ignored (operator ";") *)
      (* ❌ instruction_sequence ";" *)
      (* ❌ Sequences of instructions are ignored (operator ";") *)
      (* ❌ instruction_sequence ";" *)
      (* ❌ Sequences of instructions are ignored (operator ";") *)
      (* ❌ instruction_sequence ";" *)
      (* ❌ Sequences of instructions are ignored (operator ";") *)
      (* ❌ instruction_sequence ";" *)
      (* ❌ Sequences of instructions are ignored (operator ";") *)
      (* ❌ instruction_sequence ";" *)
      (* ❌ Sequences of instructions are ignored (operator ";") *)
      (* ❌ instruction_sequence ";" *)
      Data_encoding.Binary.of_bytes encoding raw_key
    end in
  existT (A := unit) (fun _ => _) tt
    {|
      Storage_description.INDEX.path_length := path_length;
      Storage_description.INDEX.to_path := to_path;
      Storage_description.INDEX.of_path := of_path;
      Storage_description.INDEX.rpc_arg := rpc_arg;
      Storage_description.INDEX.encoding := encoding;
      Storage_description.INDEX.compare := compare
    |}.
