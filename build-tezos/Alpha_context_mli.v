(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Contract_repr.
Require Tezos.Michelson_v1_primitives.
Require Tezos.Nonce_hash.
Require Tezos.Nonce_storage.
Require Tezos.Script_expr_hash.
Require Tezos.Script_int_repr.
Require Tezos.Storage_mli. Module Storage := Storage_mli.
Require Tezos.Storage_description.
Require Tezos.Tez_repr.

Module BASIC_DATA.
  Record signature {t : Set} : Set := {
    t := t;
    op_eq : t -> t -> bool;
    op_ltgt : t -> t -> bool;
    op_lt : t -> t -> bool;
    op_lteq : t -> t -> bool;
    op_gteq : t -> t -> bool;
    op_gt : t -> t -> bool;
    compare : t -> t -> int;
    equal : t -> t -> bool;
    max : t -> t -> t;
    min : t -> t -> t;
    encoding : Data_encoding.t t;
    pp : Format.formatter -> t -> unit;
  }.
End BASIC_DATA.

Parameter t : Set.

Definition context : Set := t.

Definition public_key : Set := (|Signature.Public_key|).(S.SPublic_key.t).

Definition public_key_hash : Set :=
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t).

Definition signature : Set := Signature.t.

Module Tez.
  Parameter Included_BASIC_DATA :
    {_ : unit & BASIC_DATA.signature (t := Tez_repr.t)}.
  
  Definition t := (|Included_BASIC_DATA|).(BASIC_DATA.t).
  
  Definition op_eq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -> t -> int :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -> t -> unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Definition tez : Set := t.
  
  Parameter zero : tez.
  
  Parameter one_mutez : tez.
  
  Parameter one_cent : tez.
  
  Parameter fifty_cents : tez.
  
  Parameter one : tez.
  
  Parameter op_minusquestion : tez -> tez -> Error_monad.tzresult tez.
  
  Parameter op_plusquestion : tez -> tez -> Error_monad.tzresult tez.
  
  Parameter op_starquestion : tez -> int64 -> Error_monad.tzresult tez.
  
  Parameter op_divquestion : tez -> int64 -> Error_monad.tzresult tez.
  
  Parameter of_string : string -> option tez.
  
  Parameter to_string : tez -> string.
  
  Parameter of_mutez : int64 -> option tez.
  
  Parameter to_mutez : tez -> int64.
End Tez.

Module Period.
  Parameter Included_BASIC_DATA : {t : Set & BASIC_DATA.signature (t := t)}.
  
  Definition t := (|Included_BASIC_DATA|).(BASIC_DATA.t).
  
  Definition op_eq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -> t -> int :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -> t -> unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Definition period : Set := t.
  
  Parameter rpc_arg : RPC_arg.arg period.
  
  Parameter of_seconds : int64 -> Error_monad.tzresult period.
  
  Parameter to_seconds : period -> int64.
  
  Parameter mult : int32 -> period -> Error_monad.tzresult period.
  
  Parameter zero : period.
  
  Parameter one_second : period.
  
  Parameter one_minute : period.
  
  Parameter one_hour : period.
End Period.

Module Timestamp.
  Parameter Included_BASIC_DATA :
    {_ : unit & BASIC_DATA.signature (t := Time.t)}.
  
  Definition t := (|Included_BASIC_DATA|).(BASIC_DATA.t).
  
  Definition op_eq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -> t -> int :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -> t -> unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Definition time : Set := t.
  
  Parameter op_plusquestion : time -> Period.t -> Error_monad.tzresult time.
  
  Parameter op_minusquestion : time -> time -> Error_monad.tzresult Period.t.
  
  Parameter of_notation : string -> option time.
  
  Parameter to_notation : time -> string.
  
  Parameter of_seconds_string : string -> option time.
  
  Parameter to_seconds_string : time -> string.
  
  Parameter current : context -> time.
End Timestamp.

Module Raw_level.
  Parameter Included_BASIC_DATA : {t : Set & BASIC_DATA.signature (t := t)}.
  
  Definition t := (|Included_BASIC_DATA|).(BASIC_DATA.t).
  
  Definition op_eq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -> t -> int :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -> t -> unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Definition raw_level : Set := t.
  
  Parameter rpc_arg : RPC_arg.arg raw_level.
  
  Parameter diff : raw_level -> raw_level -> int32.
  
  Parameter root : raw_level.
  
  Parameter succ : raw_level -> raw_level.
  
  Parameter pred : raw_level -> option raw_level.
  
  Parameter to_int32 : raw_level -> int32.
  
  Parameter of_int32 : int32 -> Error_monad.tzresult raw_level.
End Raw_level.

Module Cycle.
  Parameter Included_BASIC_DATA : {t : Set & BASIC_DATA.signature (t := t)}.
  
  Definition t := (|Included_BASIC_DATA|).(BASIC_DATA.t).
  
  Definition op_eq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -> t -> int :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -> t -> unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Definition cycle : Set := t.
  
  Parameter rpc_arg : RPC_arg.arg cycle.
  
  Parameter root : cycle.
  
  Parameter succ : cycle -> cycle.
  
  Parameter pred : cycle -> option cycle.
  
  Parameter add : cycle -> int -> cycle.
  
  Parameter sub : cycle -> int -> option cycle.
  
  Parameter to_int32 : cycle -> int32.
  
  Parameter Map : {t : Set -> Set & S.MAP.signature (key := cycle) (t := t)}.
End Cycle.

Module Gas.
  Module ConstructorRecords_t.
    Module t.
      Module Limited.
        Record record {remaining : Set} : Set := Build {
          remaining : remaining }.
        Arguments record : clear implicits.
        Definition with_remaining {t_remaining} remaining
          (r : record t_remaining) :=
          Build t_remaining remaining.
      End Limited.
      Definition Limited_skeleton := Limited.record.
    End t.
  End ConstructorRecords_t.
  Import ConstructorRecords_t.
  
  Reserved Notation "'t.Limited".
  
  Inductive t : Set :=
  | Unaccounted : t
  | Limited : 't.Limited -> t
  
  where "'t.Limited" := (t.Limited_skeleton Z.t).
  
  Module t.
    Include ConstructorRecords_t.t.
    Definition Limited := 't.Limited.
  End t.
  
  Parameter encoding : Data_encoding.encoding t.
  
  Parameter pp : Format.formatter -> t -> unit.
  
  Parameter cost : Set.
  
  Parameter cost_encoding : Data_encoding.encoding cost.
  
  Parameter pp_cost : Format.formatter -> cost -> unit.
  
  (* extensible_type_definition `error` *)
  
  (* extensible_type_definition `error` *)
  
  (* extensible_type_definition `error` *)
  
  Parameter free : cost.
  
  Parameter atomic_step_cost : int -> cost.
  
  Parameter step_cost : int -> cost.
  
  Parameter alloc_cost : int -> cost.
  
  Parameter alloc_bytes_cost : int -> cost.
  
  Parameter alloc_mbytes_cost : int -> cost.
  
  Parameter alloc_bits_cost : int -> cost.
  
  Parameter read_bytes_cost : Z.t -> cost.
  
  Parameter write_bytes_cost : Z.t -> cost.
  
  Parameter op_starat : int -> cost -> cost.
  
  Parameter op_plusat : cost -> cost -> cost.
  
  Parameter check_limit : context -> Z.t -> Error_monad.tzresult unit.
  
  Parameter set_limit : context -> Z.t -> context.
  
  Parameter set_unlimited : context -> context.
  
  Parameter consume : context -> cost -> Error_monad.tzresult context.
  
  Parameter check_enough : context -> cost -> Error_monad.tzresult unit.
  
  Parameter level : context -> t.
  
  Parameter consumed : context -> context -> Z.t.
  
  Parameter block_level : context -> Z.t.
End Gas.

Module Script_int := Script_int_repr.

Module Script_timestamp.
  Import Script_int.
  
  Parameter t : Set.
  
  Parameter compare : t -> t -> int.
  
  Parameter to_string : t -> string.
  
  Parameter to_notation : t -> option string.
  
  Parameter to_num_str : t -> string.
  
  Parameter of_string : string -> option t.
  
  Parameter diff : t -> t -> Script_int.num.
  
  Parameter add_delta : t -> Script_int.num -> t.
  
  Parameter sub_delta : t -> Script_int.num -> t.
  
  Parameter now : context -> t.
  
  Parameter to_zint : t -> Z.t.
  
  Parameter of_zint : Z.t -> t.
End Script_timestamp.

Module Script.
  Definition prim : Set := Michelson_v1_primitives.prim.
  
  Definition location : Set := Micheline.canonical_location.
  
  Definition annot : Set := Micheline.annot.
  
  Definition expr : Set := Micheline.canonical prim.
  
  Definition lazy_expr : Set := Data_encoding.lazy_t expr.
  
  Parameter __lazy_expr_value : expr -> lazy_expr.
  
  Definition node : Set := Micheline.node location prim.
  
  Module t.
    Record record : Set := Build {
      code : lazy_expr;
      storage : lazy_expr }.
    Definition with_code code (r : record) :=
      Build code r.(storage).
    Definition with_storage storage (r : record) :=
      Build r.(code) storage.
  End t.
  Definition t := t.record.
  
  Parameter location_encoding : Data_encoding.t location.
  
  Parameter expr_encoding : Data_encoding.t expr.
  
  Parameter prim_encoding : Data_encoding.t prim.
  
  Parameter encoding : Data_encoding.t t.
  
  Parameter lazy_expr_encoding : Data_encoding.t lazy_expr.
  
  Parameter deserialized_cost : expr -> Gas.cost.
  
  Parameter serialized_cost : MBytes.t -> Gas.cost.
  
  Parameter traversal_cost : node -> Gas.cost.
  
  Parameter node_cost : node -> Gas.cost.
  
  Parameter int_node_cost : Z.t -> Gas.cost.
  
  Parameter int_node_cost_of_numbits : int -> Gas.cost.
  
  Parameter string_node_cost : string -> Gas.cost.
  
  Parameter string_node_cost_of_length : int -> Gas.cost.
  
  Parameter bytes_node_cost : MBytes.t -> Gas.cost.
  
  Parameter bytes_node_cost_of_length : int -> Gas.cost.
  
  Parameter prim_node_cost_nonrec : list expr -> annot -> Gas.cost.
  
  Parameter prim_node_cost_nonrec_of_length : int -> annot -> Gas.cost.
  
  Parameter seq_node_cost_nonrec : list expr -> Gas.cost.
  
  Parameter seq_node_cost_nonrec_of_length : int -> Gas.cost.
  
  Parameter minimal_deserialize_cost : lazy_expr -> Gas.cost.
  
  Parameter force_decode_in_context :
    context -> lazy_expr -> Lwt.t (Error_monad.tzresult (expr * context)).
  
  Parameter force_bytes_in_context :
    context -> lazy_expr -> Lwt.t (Error_monad.tzresult (MBytes.t * context)).
  
  Parameter unit_parameter : lazy_expr.
  
  Module Legacy_support.
    Parameter manager_script_code : lazy_expr.
    
    Parameter add_do :
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -> lazy_expr ->
      lazy_expr -> Lwt.t (Error_monad.tzresult (lazy_expr * lazy_expr)).
    
    Parameter add_set_delegate :
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -> lazy_expr ->
      lazy_expr -> Lwt.t (Error_monad.tzresult (lazy_expr * lazy_expr)).
    
    Parameter has_default_entrypoint : lazy_expr -> bool.
    
    Parameter add_root_entrypoint :
      lazy_expr -> Lwt.t (Error_monad.tzresult lazy_expr).
  End Legacy_support.
End Script.

Module Constants.
  Module fixed.
    Record record : Set := Build {
      proof_of_work_nonce_size : int;
      nonce_length : int;
      max_revelations_per_block : int;
      max_operation_data_length : int;
      max_proposals_per_delegate : int }.
    Definition with_proof_of_work_nonce_size proof_of_work_nonce_size
      (r : record) :=
      Build proof_of_work_nonce_size r.(nonce_length)
        r.(max_revelations_per_block) r.(max_operation_data_length)
        r.(max_proposals_per_delegate).
    Definition with_nonce_length nonce_length (r : record) :=
      Build r.(proof_of_work_nonce_size) nonce_length
        r.(max_revelations_per_block) r.(max_operation_data_length)
        r.(max_proposals_per_delegate).
    Definition with_max_revelations_per_block max_revelations_per_block
      (r : record) :=
      Build r.(proof_of_work_nonce_size) r.(nonce_length)
        max_revelations_per_block r.(max_operation_data_length)
        r.(max_proposals_per_delegate).
    Definition with_max_operation_data_length max_operation_data_length
      (r : record) :=
      Build r.(proof_of_work_nonce_size) r.(nonce_length)
        r.(max_revelations_per_block) max_operation_data_length
        r.(max_proposals_per_delegate).
    Definition with_max_proposals_per_delegate max_proposals_per_delegate
      (r : record) :=
      Build r.(proof_of_work_nonce_size) r.(nonce_length)
        r.(max_revelations_per_block) r.(max_operation_data_length)
        max_proposals_per_delegate.
  End fixed.
  Definition fixed := fixed.record.
  
  Parameter fixed_encoding : Data_encoding.t fixed.
  
  Parameter __fixed_value : fixed.
  
  Parameter proof_of_work_nonce_size : int.
  
  Parameter nonce_length : int.
  
  Parameter max_revelations_per_block : int.
  
  Parameter max_operation_data_length : int.
  
  Parameter max_proposals_per_delegate : int.
  
  Module parametric.
    Record record : Set := Build {
      preserved_cycles : int;
      blocks_per_cycle : int32;
      blocks_per_commitment : int32;
      blocks_per_roll_snapshot : int32;
      blocks_per_voting_period : int32;
      time_between_blocks : list Period.t;
      endorsers_per_block : int;
      hard_gas_limit_per_operation : Z.t;
      hard_gas_limit_per_block : Z.t;
      proof_of_work_threshold : int64;
      tokens_per_roll : Tez.t;
      michelson_maximum_type_size : int;
      seed_nonce_revelation_tip : Tez.t;
      origination_size : int;
      block_security_deposit : Tez.t;
      endorsement_security_deposit : Tez.t;
      block_reward : Tez.t;
      endorsement_reward : Tez.t;
      cost_per_byte : Tez.t;
      hard_storage_limit_per_operation : Z.t;
      test_chain_duration : int64;
      quorum_min : int32;
      quorum_max : int32;
      min_proposal_quorum : int32;
      initial_endorsers : int;
      delay_per_missing_endorsement : Period.t }.
    Definition with_preserved_cycles preserved_cycles (r : record) :=
      Build preserved_cycles r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_blocks_per_cycle blocks_per_cycle (r : record) :=
      Build r.(preserved_cycles) blocks_per_cycle r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_blocks_per_commitment blocks_per_commitment (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) blocks_per_commitment
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_blocks_per_roll_snapshot blocks_per_roll_snapshot
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        blocks_per_roll_snapshot r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_blocks_per_voting_period blocks_per_voting_period
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) blocks_per_voting_period
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_time_between_blocks time_between_blocks (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        time_between_blocks r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_endorsers_per_block endorsers_per_block (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) endorsers_per_block
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_hard_gas_limit_per_operation hard_gas_limit_per_operation
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        hard_gas_limit_per_operation r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_hard_gas_limit_per_block hard_gas_limit_per_block
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) hard_gas_limit_per_block
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_proof_of_work_threshold proof_of_work_threshold
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        proof_of_work_threshold r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_tokens_per_roll tokens_per_roll (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) tokens_per_roll
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_michelson_maximum_type_size michelson_maximum_type_size
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        michelson_maximum_type_size r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_seed_nonce_revelation_tip seed_nonce_revelation_tip
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) seed_nonce_revelation_tip
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_origination_size origination_size (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        origination_size r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_block_security_deposit block_security_deposit
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) block_security_deposit
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_endorsement_security_deposit endorsement_security_deposit
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        endorsement_security_deposit r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_block_reward block_reward (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) block_reward r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_endorsement_reward endorsement_reward (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) endorsement_reward
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_cost_per_byte cost_per_byte (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        cost_per_byte r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_hard_storage_limit_per_operation
      hard_storage_limit_per_operation (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) hard_storage_limit_per_operation
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_test_chain_duration test_chain_duration (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        test_chain_duration r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_quorum_min quorum_min (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) quorum_min r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_quorum_max quorum_max (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) quorum_max
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_min_proposal_quorum min_proposal_quorum (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        min_proposal_quorum r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_initial_endorsers initial_endorsers (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) initial_endorsers
        r.(delay_per_missing_endorsement).
    Definition with_delay_per_missing_endorsement delay_per_missing_endorsement
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        delay_per_missing_endorsement.
  End parametric.
  Definition parametric := parametric.record.
  
  Parameter parametric_encoding : Data_encoding.t parametric.
  
  Parameter __parametric_value : context -> parametric.
  
  Parameter preserved_cycles : context -> int.
  
  Parameter blocks_per_cycle : context -> int32.
  
  Parameter blocks_per_commitment : context -> int32.
  
  Parameter blocks_per_roll_snapshot : context -> int32.
  
  Parameter blocks_per_voting_period : context -> int32.
  
  Parameter time_between_blocks : context -> list Period.t.
  
  Parameter endorsers_per_block : context -> int.
  
  Parameter initial_endorsers : context -> int.
  
  Parameter delay_per_missing_endorsement : context -> Period.t.
  
  Parameter hard_gas_limit_per_operation : context -> Z.t.
  
  Parameter hard_gas_limit_per_block : context -> Z.t.
  
  Parameter cost_per_byte : context -> Tez.t.
  
  Parameter hard_storage_limit_per_operation : context -> Z.t.
  
  Parameter proof_of_work_threshold : context -> int64.
  
  Parameter tokens_per_roll : context -> Tez.t.
  
  Parameter michelson_maximum_type_size : context -> int.
  
  Parameter block_reward : context -> Tez.t.
  
  Parameter endorsement_reward : context -> Tez.t.
  
  Parameter seed_nonce_revelation_tip : context -> Tez.t.
  
  Parameter origination_size : context -> int.
  
  Parameter block_security_deposit : context -> Tez.t.
  
  Parameter endorsement_security_deposit : context -> Tez.t.
  
  Parameter test_chain_duration : context -> int64.
  
  Parameter quorum_min : context -> int32.
  
  Parameter quorum_max : context -> int32.
  
  Parameter min_proposal_quorum : context -> int32.
  
  Module t.
    Record record : Set := Build {
      fixed : fixed;
      parametric : parametric }.
    Definition with_fixed fixed (r : record) :=
      Build fixed r.(parametric).
    Definition with_parametric parametric (r : record) :=
      Build r.(fixed) parametric.
  End t.
  Definition t := t.record.
  
  Parameter encoding : Data_encoding.t t.
End Constants.

Module Voting_period.
  Parameter Included_BASIC_DATA : {t : Set & BASIC_DATA.signature (t := t)}.
  
  Definition t := (|Included_BASIC_DATA|).(BASIC_DATA.t).
  
  Definition op_eq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -> t -> int :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -> t -> unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Definition voting_period : Set := t.
  
  Parameter rpc_arg : RPC_arg.arg voting_period.
  
  Parameter root : voting_period.
  
  Parameter succ : voting_period -> voting_period.
  
  Inductive kind : Set :=
  | Proposal : kind
  | Testing_vote : kind
  | Testing : kind
  | Promotion_vote : kind.
  
  Parameter kind_encoding : Data_encoding.encoding kind.
  
  Parameter to_int32 : voting_period -> int32.
End Voting_period.

Module Level.
  Module t.
    Record record : Set := Build {
      level : Raw_level.t;
      level_position : int32;
      cycle : Cycle.t;
      cycle_position : int32;
      voting_period : Voting_period.t;
      voting_period_position : int32;
      expected_commitment : bool }.
    Definition with_level level (r : record) :=
      Build level r.(level_position) r.(cycle) r.(cycle_position)
        r.(voting_period) r.(voting_period_position) r.(expected_commitment).
    Definition with_level_position level_position (r : record) :=
      Build r.(level) level_position r.(cycle) r.(cycle_position)
        r.(voting_period) r.(voting_period_position) r.(expected_commitment).
    Definition with_cycle cycle (r : record) :=
      Build r.(level) r.(level_position) cycle r.(cycle_position)
        r.(voting_period) r.(voting_period_position) r.(expected_commitment).
    Definition with_cycle_position cycle_position (r : record) :=
      Build r.(level) r.(level_position) r.(cycle) cycle_position
        r.(voting_period) r.(voting_period_position) r.(expected_commitment).
    Definition with_voting_period voting_period (r : record) :=
      Build r.(level) r.(level_position) r.(cycle) r.(cycle_position)
        voting_period r.(voting_period_position) r.(expected_commitment).
    Definition with_voting_period_position voting_period_position
      (r : record) :=
      Build r.(level) r.(level_position) r.(cycle) r.(cycle_position)
        r.(voting_period) voting_period_position r.(expected_commitment).
    Definition with_expected_commitment expected_commitment (r : record) :=
      Build r.(level) r.(level_position) r.(cycle) r.(cycle_position)
        r.(voting_period) r.(voting_period_position) expected_commitment.
  End t.
  Definition t := t.record.
  
  Parameter Included_BASIC_DATA : {_ : unit & BASIC_DATA.signature (t := t)}.
  
  Definition op_eq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -> t -> int :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -> t -> unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Parameter pp_full : Format.formatter -> t -> unit.
  
  Definition level : Set := t.
  
  Parameter root : context -> level.
  
  Parameter succ : context -> level -> level.
  
  Parameter pred : context -> level -> option level.
  
  Parameter from_raw : context -> option int32 -> Raw_level.t -> level.
  
  Parameter diff : level -> level -> int32.
  
  Parameter current : context -> level.
  
  Parameter last_level_in_cycle : context -> Cycle.t -> level.
  
  Parameter levels_in_cycle : context -> Cycle.t -> list level.
  
  Parameter levels_in_current_cycle :
    context -> option int32 -> unit -> list level.
  
  Parameter last_allowed_fork_level : context -> Raw_level.t.
End Level.

Module Fitness.
  Parameter t : Set.
  
  Parameter op_eq : t -> t -> bool.
  
  Parameter op_ltgt : t -> t -> bool.
  
  Parameter op_lt : t -> t -> bool.
  
  Parameter op_lteq : t -> t -> bool.
  
  Parameter op_gteq : t -> t -> bool.
  
  Parameter op_gt : t -> t -> bool.
  
  Parameter compare : t -> t -> int.
  
  Parameter equal : t -> t -> bool.
  
  Parameter max : t -> t -> t.
  
  Parameter min : t -> t -> t.
  
  Parameter pp : Format.formatter -> t -> unit.
  
  Parameter encoding : Data_encoding.t t.
  
  Parameter to_bytes : t -> MBytes.t.
  
  Parameter of_bytes : MBytes.t -> option t.
  
  Definition fitness : Set := t.
  
  Parameter increase : option int -> context -> context.
  
  Parameter current : context -> int64.
  
  Parameter to_int64 : fitness -> Error_monad.tzresult int64.
End Fitness.

Module Nonce.
  Definition t : Set := Nonce_storage.t.
  
  Definition nonce : Set := t.
  
  Parameter encoding : Data_encoding.t nonce.
  
  Definition unrevealed : Set := Storage.unrevealed_nonce.
  
  Parameter record_hash :
    context -> unrevealed -> Lwt.t (Error_monad.tzresult context).
  
  Parameter reveal :
    context -> Level.t -> nonce -> Lwt.t (Error_monad.tzresult context).
  
  Definition status : Set := Storage.nonce_status.
  
  Parameter get : context -> Level.t -> Lwt.t (Error_monad.tzresult status).
  
  Parameter of_bytes : MBytes.t -> Error_monad.tzresult nonce.
  
  Parameter __hash_value : nonce -> Nonce_hash.t.
  
  Parameter check_hash : nonce -> Nonce_hash.t -> bool.
End Nonce.

Module Seed.
  Parameter seed : Set.
  
  (* extensible_type_definition `error` *)
  
  Parameter for_cycle : context -> Cycle.t -> Lwt.t (Error_monad.tzresult seed).
  
  Parameter cycle_end :
    context -> Cycle.t ->
    Lwt.t (Error_monad.tzresult (context * list Nonce.unrevealed)).
  
  Parameter seed_encoding : Data_encoding.t seed.
End Seed.

Module Big_map.
  Definition id : Set := Z.t.
  
  Parameter fresh : context -> Lwt.t (Error_monad.tzresult (context * id)).
  
  Parameter fresh_temporary : context -> context * id.
  
  Parameter mem :
    context -> id -> Script_expr_hash.t ->
    Lwt.t (Error_monad.tzresult (context * bool)).
  
  Parameter get_opt :
    context -> id -> Script_expr_hash.t ->
    Lwt.t (Error_monad.tzresult (context * option Script.expr)).
  
  Parameter rpc_arg : RPC_arg.t id.
  
  Parameter cleanup_temporary : context -> Lwt.t context.
  
  Parameter __exists :
    context -> id ->
    Lwt.t (Error_monad.tzresult (context * option (Script.expr * Script.expr))).
End Big_map.

Module Contract.
  Parameter Included_BASIC_DATA : {t : Set & BASIC_DATA.signature (t := t)}.
  
  Definition t := (|Included_BASIC_DATA|).(BASIC_DATA.t).
  
  Definition op_eq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -> t -> int :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -> t -> unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Definition contract : Set := t.
  
  Parameter rpc_arg : RPC_arg.arg contract.
  
  Parameter to_b58check : contract -> string.
  
  Parameter of_b58check : string -> Error_monad.tzresult contract.
  
  Parameter implicit_contract : public_key_hash -> contract.
  
  Parameter is_implicit : contract -> option public_key_hash.
  
  Parameter __exists : context -> contract -> Lwt.t (Error_monad.tzresult bool).
  
  Parameter must_exist :
    context -> contract -> Lwt.t (Error_monad.tzresult unit).
  
  Parameter allocated :
    context -> contract -> Lwt.t (Error_monad.tzresult bool).
  
  Parameter must_be_allocated :
    context -> contract -> Lwt.t (Error_monad.tzresult unit).
  
  Parameter __list_value : context -> Lwt.t (list contract).
  
  Parameter get_manager_key :
    context -> public_key_hash -> Lwt.t (Error_monad.tzresult public_key).
  
  Parameter is_manager_key_revealed :
    context -> public_key_hash -> Lwt.t (Error_monad.tzresult bool).
  
  Parameter reveal_manager_key :
    context -> public_key_hash -> public_key ->
    Lwt.t (Error_monad.tzresult context).
  
  Parameter get_script_code :
    context -> contract ->
    Lwt.t (Error_monad.tzresult (context * option Script.lazy_expr)).
  
  Parameter get_script :
    context -> contract ->
    Lwt.t (Error_monad.tzresult (context * option Script.t)).
  
  Parameter get_storage :
    context -> contract ->
    Lwt.t (Error_monad.tzresult (context * option Script.expr)).
  
  Parameter get_counter :
    context -> public_key_hash -> Lwt.t (Error_monad.tzresult Z.t).
  
  Parameter get_balance :
    context -> contract -> Lwt.t (Error_monad.tzresult Tez.t).
  
  Parameter init_origination_nonce :
    context -> (|Operation_hash|).(S.HASH.t) -> context.
  
  Parameter unset_origination_nonce : context -> context.
  
  Parameter fresh_contract_from_current_nonce :
    context -> Lwt.t (Error_monad.tzresult (context * t)).
  
  Parameter originated_from_current_nonce :
    context -> context -> Lwt.t (Error_monad.tzresult (list contract)).
  
  Module ConstructorRecords_big_map_diff_item.
    Module big_map_diff_item.
      Module Update.
        Record record {big_map diff_key diff_key_hash diff_value : Set} : Set := Build {
          big_map : big_map;
          diff_key : diff_key;
          diff_key_hash : diff_key_hash;
          diff_value : diff_value }.
        Arguments record : clear implicits.
        Definition with_big_map
          {t_big_map t_diff_key t_diff_key_hash t_diff_value} big_map
          (r : record t_big_map t_diff_key t_diff_key_hash t_diff_value) :=
          Build t_big_map t_diff_key t_diff_key_hash t_diff_value big_map
            r.(diff_key) r.(diff_key_hash) r.(diff_value).
        Definition with_diff_key
          {t_big_map t_diff_key t_diff_key_hash t_diff_value} diff_key
          (r : record t_big_map t_diff_key t_diff_key_hash t_diff_value) :=
          Build t_big_map t_diff_key t_diff_key_hash t_diff_value r.(big_map)
            diff_key r.(diff_key_hash) r.(diff_value).
        Definition with_diff_key_hash
          {t_big_map t_diff_key t_diff_key_hash t_diff_value} diff_key_hash
          (r : record t_big_map t_diff_key t_diff_key_hash t_diff_value) :=
          Build t_big_map t_diff_key t_diff_key_hash t_diff_value r.(big_map)
            r.(diff_key) diff_key_hash r.(diff_value).
        Definition with_diff_value
          {t_big_map t_diff_key t_diff_key_hash t_diff_value} diff_value
          (r : record t_big_map t_diff_key t_diff_key_hash t_diff_value) :=
          Build t_big_map t_diff_key t_diff_key_hash t_diff_value r.(big_map)
            r.(diff_key) r.(diff_key_hash) diff_value.
      End Update.
      Definition Update_skeleton := Update.record.
      
      Module Alloc.
        Record record {big_map key_type value_type : Set} : Set := Build {
          big_map : big_map;
          key_type : key_type;
          value_type : value_type }.
        Arguments record : clear implicits.
        Definition with_big_map {t_big_map t_key_type t_value_type} big_map
          (r : record t_big_map t_key_type t_value_type) :=
          Build t_big_map t_key_type t_value_type big_map r.(key_type)
            r.(value_type).
        Definition with_key_type {t_big_map t_key_type t_value_type} key_type
          (r : record t_big_map t_key_type t_value_type) :=
          Build t_big_map t_key_type t_value_type r.(big_map) key_type
            r.(value_type).
        Definition with_value_type {t_big_map t_key_type t_value_type}
          value_type (r : record t_big_map t_key_type t_value_type) :=
          Build t_big_map t_key_type t_value_type r.(big_map) r.(key_type)
            value_type.
      End Alloc.
      Definition Alloc_skeleton := Alloc.record.
    End big_map_diff_item.
  End ConstructorRecords_big_map_diff_item.
  Import ConstructorRecords_big_map_diff_item.
  
  Reserved Notation "'big_map_diff_item.Update".
  Reserved Notation "'big_map_diff_item.Alloc".
  
  Inductive big_map_diff_item : Set :=
  | Update : 'big_map_diff_item.Update -> big_map_diff_item
  | Clear : Big_map.id -> big_map_diff_item
  | Copy : Big_map.id -> Big_map.id -> big_map_diff_item
  | Alloc : 'big_map_diff_item.Alloc -> big_map_diff_item
  
  where "'big_map_diff_item.Update" :=
    (big_map_diff_item.Update_skeleton Big_map.id Script.expr Script_expr_hash.t
      (option Script.expr))
  and "'big_map_diff_item.Alloc" :=
    (big_map_diff_item.Alloc_skeleton Big_map.id Script.expr Script.expr).
  
  Module big_map_diff_item.
    Include ConstructorRecords_big_map_diff_item.big_map_diff_item.
    Definition Update := 'big_map_diff_item.Update.
    Definition Alloc := 'big_map_diff_item.Alloc.
  End big_map_diff_item.
  
  Definition big_map_diff : Set := list big_map_diff_item.
  
  Parameter big_map_diff_encoding : Data_encoding.t big_map_diff.
  
  Parameter originate :
    context -> contract -> Tez.t -> Script.t * option big_map_diff ->
    option public_key_hash -> Lwt.t (Error_monad.tzresult context).
  
  (* extensible_type_definition `error` *)
  
  Parameter spend :
    context -> contract -> Tez.t -> Lwt.t (Error_monad.tzresult context).
  
  Parameter credit :
    context -> contract -> Tez.t -> Lwt.t (Error_monad.tzresult context).
  
  Parameter update_script_storage :
    context -> contract -> Script.expr -> option big_map_diff ->
    Lwt.t (Error_monad.tzresult context).
  
  Parameter used_storage_space :
    context -> t -> Lwt.t (Error_monad.tzresult Z.t).
  
  Parameter increment_counter :
    context -> public_key_hash -> Lwt.t (Error_monad.tzresult context).
  
  Parameter check_counter_increment :
    context -> public_key_hash -> Z.t -> Lwt.t (Error_monad.tzresult unit).
  
  Parameter origination_nonce : Set.
  
  Parameter initial_origination_nonce :
    (|Operation_hash|).(S.HASH.t) -> origination_nonce.
  
  Parameter originated_contract : origination_nonce -> contract.
End Contract.

Module Delegate.
  Inductive balance : Set :=
  | Contract : Contract.t -> balance
  | Rewards :
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -> Cycle.t -> balance
  | Fees :
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -> Cycle.t -> balance
  | Deposits :
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -> Cycle.t -> balance.
  
  Inductive balance_update : Set :=
  | Debited : Tez.t -> balance_update
  | Credited : Tez.t -> balance_update.
  
  Definition balance_updates : Set := list (balance * balance_update).
  
  Parameter balance_updates_encoding : Data_encoding.t balance_updates.
  
  Parameter cleanup_balance_updates : balance_updates -> balance_updates.
  
  Parameter get :
    context -> Contract.t ->
    Lwt.t (Error_monad.tzresult (option public_key_hash)).
  
  Parameter set :
    context -> Contract.t -> option public_key_hash ->
    Lwt.t (Error_monad.tzresult context).
  
  Parameter fold : forall {a : Set},
    context -> a -> (public_key_hash -> a -> Lwt.t a) -> Lwt.t a.
  
  Parameter __list_value : context -> Lwt.t (list public_key_hash).
  
  Parameter freeze_deposit :
    context -> public_key_hash -> Tez.t -> Lwt.t (Error_monad.tzresult context).
  
  Parameter freeze_rewards :
    context -> public_key_hash -> Tez.t -> Lwt.t (Error_monad.tzresult context).
  
  Parameter freeze_fees :
    context -> public_key_hash -> Tez.t -> Lwt.t (Error_monad.tzresult context).
  
  Parameter cycle_end :
    context -> Cycle.t -> list Nonce.unrevealed ->
    Lwt.t
      (Error_monad.tzresult
        (context * balance_updates *
          list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))).
  
  Module frozen_balance.
    Record record : Set := Build {
      deposit : Tez.t;
      fees : Tez.t;
      rewards : Tez.t }.
    Definition with_deposit deposit (r : record) :=
      Build deposit r.(fees) r.(rewards).
    Definition with_fees fees (r : record) :=
      Build r.(deposit) fees r.(rewards).
    Definition with_rewards rewards (r : record) :=
      Build r.(deposit) r.(fees) rewards.
  End frozen_balance.
  Definition frozen_balance := frozen_balance.record.
  
  Parameter punish :
    context -> public_key_hash -> Cycle.t ->
    Lwt.t (Error_monad.tzresult (context * frozen_balance)).
  
  Parameter full_balance :
    context -> public_key_hash -> Lwt.t (Error_monad.tzresult Tez.t).
  
  Parameter has_frozen_balance :
    context -> public_key_hash -> Cycle.t -> Lwt.t (Error_monad.tzresult bool).
  
  Parameter __frozen_balance_value :
    context -> public_key_hash -> Lwt.t (Error_monad.tzresult Tez.t).
  
  Parameter frozen_balance_encoding : Data_encoding.t frozen_balance.
  
  Parameter frozen_balance_by_cycle_encoding :
    Data_encoding.t ((|Cycle.Map|).(S.MAP.t) frozen_balance).
  
  Parameter frozen_balance_by_cycle :
    context -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
    Lwt.t ((|Cycle.Map|).(S.MAP.t) frozen_balance).
  
  Parameter staking_balance :
    context -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
    Lwt.t (Error_monad.tzresult Tez.t).
  
  Parameter delegated_contracts :
    context -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
    Lwt.t (list Contract_repr.t).
  
  Parameter delegated_balance :
    context -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
    Lwt.t (Error_monad.tzresult Tez.t).
  
  Parameter deactivated :
    context -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
    Lwt.t (Error_monad.tzresult bool).
  
  Parameter grace_period :
    context -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
    Lwt.t (Error_monad.tzresult Cycle.t).
End Delegate.

Module Vote.
  Definition proposal : Set := (|Protocol_hash|).(S.HASH.t).
  
  Parameter record_proposal :
    context -> (|Protocol_hash|).(S.HASH.t) -> public_key_hash ->
    Lwt.t (Error_monad.tzresult context).
  
  Parameter get_proposals :
    context ->
    Lwt.t
      (Error_monad.tzresult
        ((|Protocol_hash|).(S.HASH.Map).(S.INDEXES_Map.t) int32)).
  
  Parameter clear_proposals : context -> Lwt.t context.
  
  Parameter recorded_proposal_count_for_delegate :
    context -> public_key_hash -> Lwt.t (Error_monad.tzresult int).
  
  Parameter listings_encoding :
    Data_encoding.t
      (list ((|Signature.Public_key_hash|).(S.SPublic_key_hash.t) * int32)).
  
  Parameter freeze_listings : context -> Lwt.t (Error_monad.tzresult context).
  
  Parameter clear_listings : context -> Lwt.t (Error_monad.tzresult context).
  
  Parameter listing_size : context -> Lwt.t (Error_monad.tzresult int32).
  
  Parameter in_listings : context -> public_key_hash -> Lwt.t bool.
  
  Parameter get_listings : context -> Lwt.t (list (public_key_hash * int32)).
  
  Inductive ballot : Set :=
  | Yay : ballot
  | Nay : ballot
  | Pass : ballot.
  
  Parameter ballot_encoding : Data_encoding.t ballot.
  
  Module ballots.
    Record record : Set := Build {
      yay : int32;
      nay : int32;
      pass : int32 }.
    Definition with_yay yay (r : record) :=
      Build yay r.(nay) r.(pass).
    Definition with_nay nay (r : record) :=
      Build r.(yay) nay r.(pass).
    Definition with_pass pass (r : record) :=
      Build r.(yay) r.(nay) pass.
  End ballots.
  Definition ballots := ballots.record.
  
  Parameter ballots_encoding : Data_encoding.t ballots.
  
  Parameter has_recorded_ballot : context -> public_key_hash -> Lwt.t bool.
  
  Parameter record_ballot :
    context -> public_key_hash -> ballot -> Lwt.t (Error_monad.tzresult context).
  
  Parameter get_ballots : context -> Lwt.t (Error_monad.tzresult ballots).
  
  Parameter get_ballot_list :
    context ->
    Lwt.t (list ((|Signature.Public_key_hash|).(S.SPublic_key_hash.t) * ballot)).
  
  Parameter clear_ballots : context -> Lwt.t context.
  
  Parameter get_current_period_kind :
    context -> Lwt.t (Error_monad.tzresult Voting_period.kind).
  
  Parameter set_current_period_kind :
    context -> Voting_period.kind -> Lwt.t (Error_monad.tzresult context).
  
  Parameter get_current_quorum : context -> Lwt.t (Error_monad.tzresult int32).
  
  Parameter get_participation_ema :
    context -> Lwt.t (Error_monad.tzresult int32).
  
  Parameter set_participation_ema :
    context -> int32 -> Lwt.t (Error_monad.tzresult context).
  
  Parameter get_current_proposal :
    context -> Lwt.t (Error_monad.tzresult proposal).
  
  Parameter init_current_proposal :
    context -> proposal -> Lwt.t (Error_monad.tzresult context).
  
  Parameter clear_current_proposal :
    context -> Lwt.t (Error_monad.tzresult context).
End Vote.

Module Block_header.
  Module contents.
    Record record : Set := Build {
      priority : int;
      seed_nonce_hash : option Nonce_hash.t;
      proof_of_work_nonce : MBytes.t }.
    Definition with_priority priority (r : record) :=
      Build priority r.(seed_nonce_hash) r.(proof_of_work_nonce).
    Definition with_seed_nonce_hash seed_nonce_hash (r : record) :=
      Build r.(priority) seed_nonce_hash r.(proof_of_work_nonce).
    Definition with_proof_of_work_nonce proof_of_work_nonce (r : record) :=
      Build r.(priority) r.(seed_nonce_hash) proof_of_work_nonce.
  End contents.
  Definition contents := contents.record.
  
  Module protocol_data.
    Record record : Set := Build {
      contents : contents;
      signature : Signature.t }.
    Definition with_contents contents (r : record) :=
      Build contents r.(signature).
    Definition with_signature signature (r : record) :=
      Build r.(contents) signature.
  End protocol_data.
  Definition protocol_data := protocol_data.record.
  
  Module block_header.
    Record record : Set := Build {
      shell : Block_header.shell_header;
      protocol_data : protocol_data }.
    Definition with_shell shell (r : record) :=
      Build shell r.(protocol_data).
    Definition with_protocol_data protocol_data (r : record) :=
      Build r.(shell) protocol_data.
  End block_header.
  Definition block_header := block_header.record.
  
  Definition raw : Set := Block_header.t.
  
  Definition shell_header : Set := Block_header.shell_header.
  
  Parameter __raw_value : block_header -> raw.
  
  Parameter __hash_value : block_header -> (|Block_hash|).(S.HASH.t).
  
  Parameter hash_raw : raw -> (|Block_hash|).(S.HASH.t).
  
  Parameter encoding : Data_encoding.encoding block_header.
  
  Parameter raw_encoding : Data_encoding.t raw.
  
  Parameter contents_encoding : Data_encoding.t contents.
  
  Parameter unsigned_encoding : Data_encoding.t (shell_header * contents).
  
  Parameter protocol_data_encoding : Data_encoding.encoding protocol_data.
  
  Parameter shell_header_encoding : Data_encoding.encoding shell_header.
  
  Parameter max_header_length : int.
End Block_header.

Module Kind.
  Inductive seed_nonce_revelation : Set :=
  | Seed_nonce_revelation_kind : seed_nonce_revelation.
  
  Inductive double_endorsement_evidence : Set :=
  | Double_endorsement_evidence_kind : double_endorsement_evidence.
  
  Inductive double_baking_evidence : Set :=
  | Double_baking_evidence_kind : double_baking_evidence.
  
  Inductive activate_account : Set :=
  | Activate_account_kind : activate_account.
  
  Inductive endorsement : Set :=
  | Endorsement_kind : endorsement.
  
  Inductive proposals : Set :=
  | Proposals_kind : proposals.
  
  Inductive ballot : Set :=
  | Ballot_kind : ballot.
  
  Inductive reveal : Set :=
  | Reveal_kind : reveal.
  
  Inductive transaction : Set :=
  | Transaction_kind : transaction.
  
  Inductive origination : Set :=
  | Origination_kind : origination.
  
  Inductive delegation : Set :=
  | Delegation_kind : delegation.
  
  Inductive manager : Set :=
  | Reveal_manager_kind : manager
  | Transaction_manager_kind : manager
  | Origination_manager_kind : manager
  | Delegation_manager_kind : manager.
End Kind.

Module ConstructorRecords_contents_list_contents_manager_operation.
  Module contents.
    Module Endorsement.
      Record record {level : Set} : Set := Build {
        level : level }.
      Arguments record : clear implicits.
      Definition with_level {t_level} level (r : record t_level) :=
        Build t_level level.
    End Endorsement.
    Definition Endorsement_skeleton := Endorsement.record.
    
    Module Seed_nonce_revelation.
      Record record {level nonce : Set} : Set := Build {
        level : level;
        nonce : nonce }.
      Arguments record : clear implicits.
      Definition with_level {t_level t_nonce} level
        (r : record t_level t_nonce) :=
        Build t_level t_nonce level r.(nonce).
      Definition with_nonce {t_level t_nonce} nonce
        (r : record t_level t_nonce) :=
        Build t_level t_nonce r.(level) nonce.
    End Seed_nonce_revelation.
    Definition Seed_nonce_revelation_skeleton := Seed_nonce_revelation.record.
    
    Module Double_endorsement_evidence.
      Record record {op1 op2 : Set} : Set := Build {
        op1 : op1;
        op2 : op2 }.
      Arguments record : clear implicits.
      Definition with_op1 {t_op1 t_op2} op1 (r : record t_op1 t_op2) :=
        Build t_op1 t_op2 op1 r.(op2).
      Definition with_op2 {t_op1 t_op2} op2 (r : record t_op1 t_op2) :=
        Build t_op1 t_op2 r.(op1) op2.
    End Double_endorsement_evidence.
    Definition Double_endorsement_evidence_skeleton :=
      Double_endorsement_evidence.record.
    
    Module Double_baking_evidence.
      Record record {bh1 bh2 : Set} : Set := Build {
        bh1 : bh1;
        bh2 : bh2 }.
      Arguments record : clear implicits.
      Definition with_bh1 {t_bh1 t_bh2} bh1 (r : record t_bh1 t_bh2) :=
        Build t_bh1 t_bh2 bh1 r.(bh2).
      Definition with_bh2 {t_bh1 t_bh2} bh2 (r : record t_bh1 t_bh2) :=
        Build t_bh1 t_bh2 r.(bh1) bh2.
    End Double_baking_evidence.
    Definition Double_baking_evidence_skeleton := Double_baking_evidence.record.
    
    Module Activate_account.
      Record record {id activation_code : Set} : Set := Build {
        id : id;
        activation_code : activation_code }.
      Arguments record : clear implicits.
      Definition with_id {t_id t_activation_code} id
        (r : record t_id t_activation_code) :=
        Build t_id t_activation_code id r.(activation_code).
      Definition with_activation_code {t_id t_activation_code} activation_code
        (r : record t_id t_activation_code) :=
        Build t_id t_activation_code r.(id) activation_code.
    End Activate_account.
    Definition Activate_account_skeleton := Activate_account.record.
    
    Module Proposals.
      Record record {source period proposals : Set} : Set := Build {
        source : source;
        period : period;
        proposals : proposals }.
      Arguments record : clear implicits.
      Definition with_source {t_source t_period t_proposals} source
        (r : record t_source t_period t_proposals) :=
        Build t_source t_period t_proposals source r.(period) r.(proposals).
      Definition with_period {t_source t_period t_proposals} period
        (r : record t_source t_period t_proposals) :=
        Build t_source t_period t_proposals r.(source) period r.(proposals).
      Definition with_proposals {t_source t_period t_proposals} proposals
        (r : record t_source t_period t_proposals) :=
        Build t_source t_period t_proposals r.(source) r.(period) proposals.
    End Proposals.
    Definition Proposals_skeleton := Proposals.record.
    
    Module Ballot.
      Record record {source period proposal ballot : Set} : Set := Build {
        source : source;
        period : period;
        proposal : proposal;
        ballot : ballot }.
      Arguments record : clear implicits.
      Definition with_source {t_source t_period t_proposal t_ballot} source
        (r : record t_source t_period t_proposal t_ballot) :=
        Build t_source t_period t_proposal t_ballot source r.(period)
          r.(proposal) r.(ballot).
      Definition with_period {t_source t_period t_proposal t_ballot} period
        (r : record t_source t_period t_proposal t_ballot) :=
        Build t_source t_period t_proposal t_ballot r.(source) period
          r.(proposal) r.(ballot).
      Definition with_proposal {t_source t_period t_proposal t_ballot} proposal
        (r : record t_source t_period t_proposal t_ballot) :=
        Build t_source t_period t_proposal t_ballot r.(source) r.(period)
          proposal r.(ballot).
      Definition with_ballot {t_source t_period t_proposal t_ballot} ballot
        (r : record t_source t_period t_proposal t_ballot) :=
        Build t_source t_period t_proposal t_ballot r.(source) r.(period)
          r.(proposal) ballot.
    End Ballot.
    Definition Ballot_skeleton := Ballot.record.
    
    Module Manager_operation.
      Record record {source fee counter operation gas_limit storage_limit : Set} :
        Set := Build {
        source : source;
        fee : fee;
        counter : counter;
        operation : operation;
        gas_limit : gas_limit;
        storage_limit : storage_limit }.
      Arguments record : clear implicits.
      Definition with_source
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit}
        source
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          source r.(fee) r.(counter) r.(operation) r.(gas_limit)
          r.(storage_limit).
      Definition with_fee
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit} fee
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          r.(source) fee r.(counter) r.(operation) r.(gas_limit)
          r.(storage_limit).
      Definition with_counter
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit}
        counter
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          r.(source) r.(fee) counter r.(operation) r.(gas_limit)
          r.(storage_limit).
      Definition with_operation
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit}
        operation
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          r.(source) r.(fee) r.(counter) operation r.(gas_limit)
          r.(storage_limit).
      Definition with_gas_limit
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit}
        gas_limit
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          r.(source) r.(fee) r.(counter) r.(operation) gas_limit
          r.(storage_limit).
      Definition with_storage_limit
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit}
        storage_limit
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          r.(source) r.(fee) r.(counter) r.(operation) r.(gas_limit)
          storage_limit.
    End Manager_operation.
    Definition Manager_operation_skeleton := Manager_operation.record.
  End contents.
  Module manager_operation.
    Module Transaction.
      Record record {amount parameters entrypoint destination : Set} : Set := Build {
        amount : amount;
        parameters : parameters;
        entrypoint : entrypoint;
        destination : destination }.
      Arguments record : clear implicits.
      Definition with_amount {t_amount t_parameters t_entrypoint t_destination}
        amount (r : record t_amount t_parameters t_entrypoint t_destination) :=
        Build t_amount t_parameters t_entrypoint t_destination amount
          r.(parameters) r.(entrypoint) r.(destination).
      Definition with_parameters
        {t_amount t_parameters t_entrypoint t_destination} parameters
        (r : record t_amount t_parameters t_entrypoint t_destination) :=
        Build t_amount t_parameters t_entrypoint t_destination r.(amount)
          parameters r.(entrypoint) r.(destination).
      Definition with_entrypoint
        {t_amount t_parameters t_entrypoint t_destination} entrypoint
        (r : record t_amount t_parameters t_entrypoint t_destination) :=
        Build t_amount t_parameters t_entrypoint t_destination r.(amount)
          r.(parameters) entrypoint r.(destination).
      Definition with_destination
        {t_amount t_parameters t_entrypoint t_destination} destination
        (r : record t_amount t_parameters t_entrypoint t_destination) :=
        Build t_amount t_parameters t_entrypoint t_destination r.(amount)
          r.(parameters) r.(entrypoint) destination.
    End Transaction.
    Definition Transaction_skeleton := Transaction.record.
    
    Module Origination.
      Record record {delegate script credit preorigination : Set} : Set := Build {
        delegate : delegate;
        script : script;
        credit : credit;
        preorigination : preorigination }.
      Arguments record : clear implicits.
      Definition with_delegate {t_delegate t_script t_credit t_preorigination}
        delegate (r : record t_delegate t_script t_credit t_preorigination) :=
        Build t_delegate t_script t_credit t_preorigination delegate r.(script)
          r.(credit) r.(preorigination).
      Definition with_script {t_delegate t_script t_credit t_preorigination}
        script (r : record t_delegate t_script t_credit t_preorigination) :=
        Build t_delegate t_script t_credit t_preorigination r.(delegate) script
          r.(credit) r.(preorigination).
      Definition with_credit {t_delegate t_script t_credit t_preorigination}
        credit (r : record t_delegate t_script t_credit t_preorigination) :=
        Build t_delegate t_script t_credit t_preorigination r.(delegate)
          r.(script) credit r.(preorigination).
      Definition with_preorigination
        {t_delegate t_script t_credit t_preorigination} preorigination
        (r : record t_delegate t_script t_credit t_preorigination) :=
        Build t_delegate t_script t_credit t_preorigination r.(delegate)
          r.(script) r.(credit) preorigination.
    End Origination.
    Definition Origination_skeleton := Origination.record.
  End manager_operation.
End ConstructorRecords_contents_list_contents_manager_operation.
Import ConstructorRecords_contents_list_contents_manager_operation.

Module operation.
  Record record {shell protocol_data : Set} : Set := Build {
    shell : shell;
    protocol_data : protocol_data }.
  Arguments record : clear implicits.
  Definition with_shell {t_shell t_protocol_data} shell
    (r : record t_shell t_protocol_data) :=
    Build t_shell t_protocol_data shell r.(protocol_data).
  Definition with_protocol_data {t_shell t_protocol_data} protocol_data
    (r : record t_shell t_protocol_data) :=
    Build t_shell t_protocol_data r.(shell) protocol_data.
End operation.
Definition operation_skeleton := operation.record.

Module protocol_data.
  Record record {contents signature : Set} : Set := Build {
    contents : contents;
    signature : signature }.
  Arguments record : clear implicits.
  Definition with_contents {t_contents t_signature} contents
    (r : record t_contents t_signature) :=
    Build t_contents t_signature contents r.(signature).
  Definition with_signature {t_contents t_signature} signature
    (r : record t_contents t_signature) :=
    Build t_contents t_signature r.(contents) signature.
End protocol_data.
Definition protocol_data_skeleton := protocol_data.record.

Reserved Notation "'contents.Endorsement".
Reserved Notation "'contents.Seed_nonce_revelation".
Reserved Notation "'contents.Double_endorsement_evidence".
Reserved Notation "'contents.Double_baking_evidence".
Reserved Notation "'contents.Activate_account".
Reserved Notation "'contents.Proposals".
Reserved Notation "'contents.Ballot".
Reserved Notation "'contents.Manager_operation".
Reserved Notation "'manager_operation.Transaction".
Reserved Notation "'manager_operation.Origination".
Reserved Notation "'protocol_data".
Reserved Notation "'operation".
Reserved Notation "'counter".

Inductive contents_list : Set :=
| Single : contents -> contents_list
| Cons : contents -> contents_list -> contents_list

with contents : Set :=
| Endorsement : 'contents.Endorsement -> contents
| Seed_nonce_revelation : 'contents.Seed_nonce_revelation -> contents
| Double_endorsement_evidence :
  'contents.Double_endorsement_evidence -> contents
| Double_baking_evidence : 'contents.Double_baking_evidence -> contents
| Activate_account : 'contents.Activate_account -> contents
| Proposals : 'contents.Proposals -> contents
| Ballot : 'contents.Ballot -> contents
| Manager_operation : 'contents.Manager_operation -> contents

with manager_operation : Set :=
| Reveal : (|Signature.Public_key|).(S.SPublic_key.t) -> manager_operation
| Transaction : 'manager_operation.Transaction -> manager_operation
| Origination : 'manager_operation.Origination -> manager_operation
| Delegation :
  option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
  manager_operation

where "'protocol_data" :=
  (protocol_data_skeleton contents_list (option Signature.t))
and "'operation" := (operation_skeleton Operation.shell_header 'protocol_data)
and "'counter" := (Z.t)
and "'contents.Endorsement" := (contents.Endorsement_skeleton Raw_level.t)
and "'contents.Seed_nonce_revelation" :=
  (contents.Seed_nonce_revelation_skeleton Raw_level.t Nonce.t)
and "'contents.Double_endorsement_evidence" :=
  (contents.Double_endorsement_evidence_skeleton 'operation 'operation)
and "'contents.Double_baking_evidence" :=
  (contents.Double_baking_evidence_skeleton Block_header.block_header
    Block_header.block_header)
and "'contents.Activate_account" :=
  (contents.Activate_account_skeleton
    (|Ed25519|).(S.SIGNATURE.Public_key_hash).(S.SPublic_key_hash.t)
    Blinded_public_key_hash.activation_code)
and "'contents.Proposals" :=
  (contents.Proposals_skeleton
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) Voting_period.t
    (list (|Protocol_hash|).(S.HASH.t)))
and "'contents.Ballot" :=
  (contents.Ballot_skeleton (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)
    Voting_period.t (|Protocol_hash|).(S.HASH.t) Vote.ballot)
and "'contents.Manager_operation" :=
  (contents.Manager_operation_skeleton
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) Tez.tez 'counter
    manager_operation Z.t Z.t)
and "'manager_operation.Transaction" :=
  (manager_operation.Transaction_skeleton Tez.tez Script.lazy_expr string
    Contract.contract)
and "'manager_operation.Origination" :=
  (manager_operation.Origination_skeleton
    (option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) Script.t
    Tez.tez (option Contract.t)).

Module contents.
  Include ConstructorRecords_contents_list_contents_manager_operation.contents.
  Definition Endorsement := 'contents.Endorsement.
  Definition Seed_nonce_revelation := 'contents.Seed_nonce_revelation.
  Definition Double_endorsement_evidence :=
    'contents.Double_endorsement_evidence.
  Definition Double_baking_evidence := 'contents.Double_baking_evidence.
  Definition Activate_account := 'contents.Activate_account.
  Definition Proposals := 'contents.Proposals.
  Definition Ballot := 'contents.Ballot.
  Definition Manager_operation := 'contents.Manager_operation.
End contents.
Module manager_operation.
  Include ConstructorRecords_contents_list_contents_manager_operation.manager_operation.
  Definition Transaction := 'manager_operation.Transaction.
  Definition Origination := 'manager_operation.Origination.
End manager_operation.

Definition protocol_data := 'protocol_data.
Definition operation := 'operation.
Definition counter := 'counter.

Module internal_operation.
  Record record : Set := Build {
    source : Contract.contract;
    operation : manager_operation;
    nonce : int }.
  Definition with_source source (r : record) :=
    Build source r.(operation) r.(nonce).
  Definition with_operation operation (r : record) :=
    Build r.(source) operation r.(nonce).
  Definition with_nonce nonce (r : record) :=
    Build r.(source) r.(operation) nonce.
End internal_operation.
Definition internal_operation := internal_operation.record.

Inductive packed_manager_operation : Set :=
| Manager : manager_operation -> packed_manager_operation.

Inductive packed_contents : Set :=
| Contents : contents -> packed_contents.

Inductive packed_contents_list : Set :=
| Contents_list : contents_list -> packed_contents_list.

Inductive packed_protocol_data : Set :=
| Operation_data : protocol_data -> packed_protocol_data.

Module packed_operation.
  Record record : Set := Build {
    shell : Operation.shell_header;
    protocol_data : packed_protocol_data }.
  Definition with_shell shell (r : record) :=
    Build shell r.(protocol_data).
  Definition with_protocol_data protocol_data (r : record) :=
    Build r.(shell) protocol_data.
End packed_operation.
Definition packed_operation := packed_operation.record.

Inductive packed_internal_operation : Set :=
| Internal_operation : internal_operation -> packed_internal_operation.

Parameter manager_kind : manager_operation -> Kind.manager.

Module Fees.
  Parameter origination_burn :
    context -> Lwt.t (Error_monad.tzresult (context * Tez.t)).
  
  Parameter record_paid_storage_space :
    context -> Contract.t ->
    Lwt.t (Error_monad.tzresult (context * Z.t * Z.t * Tez.t)).
  
  Parameter start_counting_storage_fees : context -> context.
  
  Parameter burn_storage_fees :
    context -> Z.t -> Contract.t -> Lwt.t (Error_monad.tzresult context).
  
  (* extensible_type_definition `error` *)
  
  (* extensible_type_definition `error` *)
  
  (* extensible_type_definition `error` *)
  
  Parameter check_storage_limit : context -> Z.t -> Error_monad.tzresult unit.
End Fees.

Module Operation.
  Definition contents : Set := contents.
  
  Definition packed_contents : Set := packed_contents.
  
  Parameter contents_encoding : Data_encoding.t packed_contents.
  
  Definition protocol_data : Set := protocol_data.
  
  Definition packed_protocol_data : Set := packed_protocol_data.
  
  Parameter protocol_data_encoding : Data_encoding.t packed_protocol_data.
  
  Parameter unsigned_encoding :
    Data_encoding.t (Operation.shell_header * packed_contents_list).
  
  Definition raw : Set := Operation.t.
  
  Parameter raw_encoding : Data_encoding.t raw.
  
  Parameter contents_list_encoding : Data_encoding.t packed_contents_list.
  
  Definition t : Set := operation.
  
  Definition packed : Set := packed_operation.
  
  Parameter encoding : Data_encoding.t packed.
  
  Parameter __raw_value : operation -> raw.
  
  Parameter __hash_value : operation -> (|Operation_hash|).(S.HASH.t).
  
  Parameter hash_raw : raw -> (|Operation_hash|).(S.HASH.t).
  
  Parameter hash_packed : packed_operation -> (|Operation_hash|).(S.HASH.t).
  
  Parameter acceptable_passes : packed_operation -> list int.
  
  (* extensible_type_definition `error` *)
  
  (* extensible_type_definition `error` *)
  
  Parameter check_signature :
    public_key -> (|Chain_id|).(S.HASH.t) -> operation ->
    Lwt.t (Error_monad.tzresult unit).
  
  Parameter check_signature_sync :
    public_key -> (|Chain_id|).(S.HASH.t) -> operation ->
    Error_monad.tzresult unit.
  
  Parameter internal_operation_encoding :
    Data_encoding.t packed_internal_operation.
  
  Parameter __pack : operation -> packed_operation.
  
  Inductive eq : Set :=
  | Eq : eq.
  
  Parameter equal : operation -> operation -> option eq.
  
  Module Encoding.
    Module ConstructorRecords_case.
      Module case.
        Module Case.
          Record record {tag name encoding select proj inj : Set} : Set := Build {
            tag : tag;
            name : name;
            encoding : encoding;
            select : select;
            proj : proj;
            inj : inj }.
          Arguments record : clear implicits.
          Definition with_tag {t_tag t_name t_encoding t_select t_proj t_inj}
            tag (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj tag r.(name)
              r.(encoding) r.(select) r.(proj) r.(inj).
          Definition with_name {t_tag t_name t_encoding t_select t_proj t_inj}
            name (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) name
              r.(encoding) r.(select) r.(proj) r.(inj).
          Definition with_encoding
            {t_tag t_name t_encoding t_select t_proj t_inj} encoding
            (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
              encoding r.(select) r.(proj) r.(inj).
          Definition with_select {t_tag t_name t_encoding t_select t_proj t_inj}
            select (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
              r.(encoding) select r.(proj) r.(inj).
          Definition with_proj {t_tag t_name t_encoding t_select t_proj t_inj}
            proj (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
              r.(encoding) r.(select) proj r.(inj).
          Definition with_inj {t_tag t_name t_encoding t_select t_proj t_inj}
            inj (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
              r.(encoding) r.(select) r.(proj) inj.
        End Case.
        Definition Case_skeleton := Case.record.
      End case.
    End ConstructorRecords_case.
    Import ConstructorRecords_case.
    
    Reserved Notation "'case.Case".
    
    Inductive case : Set :=
    | Case : forall {a : Set}, 'case.Case a -> case
    
    where "'case.Case" := (fun (t_a : Set) =>
      case.Case_skeleton int string (Data_encoding.t t_a)
        (packed_contents -> option contents) (contents -> t_a) (t_a -> contents)).
    
    Module case.
      Include ConstructorRecords_case.case.
      Definition Case := 'case.Case.
    End case.
    
    Parameter endorsement_case : case.
    
    Parameter seed_nonce_revelation_case : case.
    
    Parameter double_endorsement_evidence_case : case.
    
    Parameter double_baking_evidence_case : case.
    
    Parameter activate_account_case : case.
    
    Parameter proposals_case : case.
    
    Parameter ballot_case : case.
    
    Parameter reveal_case : case.
    
    Parameter transaction_case : case.
    
    Parameter origination_case : case.
    
    Parameter delegation_case : case.
    
    Module Manager_operations.
      Module ConstructorRecords_case.
        Module case.
          Module MCase.
            Record record {tag name encoding select proj inj : Set} : Set := Build {
              tag : tag;
              name : name;
              encoding : encoding;
              select : select;
              proj : proj;
              inj : inj }.
            Arguments record : clear implicits.
            Definition with_tag {t_tag t_name t_encoding t_select t_proj t_inj}
              tag (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
              Build t_tag t_name t_encoding t_select t_proj t_inj tag r.(name)
                r.(encoding) r.(select) r.(proj) r.(inj).
            Definition with_name {t_tag t_name t_encoding t_select t_proj t_inj}
              name (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
              Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) name
                r.(encoding) r.(select) r.(proj) r.(inj).
            Definition with_encoding
              {t_tag t_name t_encoding t_select t_proj t_inj} encoding
              (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
              Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag)
                r.(name) encoding r.(select) r.(proj) r.(inj).
            Definition with_select
              {t_tag t_name t_encoding t_select t_proj t_inj} select
              (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
              Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag)
                r.(name) r.(encoding) select r.(proj) r.(inj).
            Definition with_proj {t_tag t_name t_encoding t_select t_proj t_inj}
              proj (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
              Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag)
                r.(name) r.(encoding) r.(select) proj r.(inj).
            Definition with_inj {t_tag t_name t_encoding t_select t_proj t_inj}
              inj (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
              Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag)
                r.(name) r.(encoding) r.(select) r.(proj) inj.
          End MCase.
          Definition MCase_skeleton := MCase.record.
        End case.
      End ConstructorRecords_case.
      Import ConstructorRecords_case.
      
      Reserved Notation "'case.MCase".
      
      Inductive case : Set :=
      | MCase : forall {a : Set}, 'case.MCase a -> case
      
      where "'case.MCase" := (fun (t_a : Set) =>
        case.MCase_skeleton int string (Data_encoding.t t_a)
          (packed_manager_operation -> option manager_operation)
          (manager_operation -> t_a) (t_a -> manager_operation)).
      
      Module case.
        Include ConstructorRecords_case.case.
        Definition MCase := 'case.MCase.
      End case.
      
      Parameter reveal_case : case.
      
      Parameter transaction_case : case.
      
      Parameter origination_case : case.
      
      Parameter delegation_case : case.
    End Manager_operations.
  End Encoding.
  
  Parameter of_list : list packed_contents -> packed_contents_list.
  
  Parameter to_list : packed_contents_list -> list packed_contents.
End Operation.

Module Roll.
  Definition t : Set := int32.
  
  Definition roll : Set := t.
  
  Parameter encoding : Data_encoding.t roll.
  
  Parameter snapshot_rolls : context -> Lwt.t (Error_monad.tzresult context).
  
  Parameter cycle_end :
    context -> Cycle.t -> Lwt.t (Error_monad.tzresult context).
  
  Parameter baking_rights_owner :
    context -> Level.t -> int -> Lwt.t (Error_monad.tzresult public_key).
  
  Parameter endorsement_rights_owner :
    context -> Level.t -> int -> Lwt.t (Error_monad.tzresult public_key).
  
  Parameter delegate_pubkey :
    context -> public_key_hash -> Lwt.t (Error_monad.tzresult public_key).
  
  Parameter get_rolls :
    context -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
    Lwt.t (Error_monad.tzresult (list roll)).
  
  Parameter get_change :
    context -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
    Lwt.t (Error_monad.tzresult Tez.t).
End Roll.

Module Commitment.
  Module t.
    Record record : Set := Build {
      blinded_public_key_hash : Blinded_public_key_hash.t;
      amount : Tez.tez }.
    Definition with_blinded_public_key_hash blinded_public_key_hash
      (r : record) :=
      Build blinded_public_key_hash r.(amount).
    Definition with_amount amount (r : record) :=
      Build r.(blinded_public_key_hash) amount.
  End t.
  Definition t := t.record.
  
  Parameter get_opt :
    context -> Blinded_public_key_hash.t ->
    Lwt.t (Error_monad.tzresult (option Tez.t)).
  
  Parameter delete :
    context -> Blinded_public_key_hash.t -> Lwt.t (Error_monad.tzresult context).
End Commitment.

Module Bootstrap.
  Parameter cycle_end :
    context -> Cycle.t -> Lwt.t (Error_monad.tzresult context).
End Bootstrap.

Module Global.
  Parameter get_block_priority : context -> Lwt.t (Error_monad.tzresult int).
  
  Parameter set_block_priority :
    context -> int -> Lwt.t (Error_monad.tzresult context).
End Global.

Parameter prepare_first_block :
  Context.t ->
  (context -> Script.t ->
  Lwt.t
    (Error_monad.tzresult ((Script.t * option Contract.big_map_diff) * context)))
  -> Int32.t -> Time.t -> Fitness.t -> Lwt.t (Error_monad.tzresult context).

Parameter prepare :
  Context.t -> Int32.t -> Time.t -> Time.t -> Fitness.t ->
  Lwt.t (Error_monad.tzresult context).

Parameter finalize : option string -> context -> Updater.validation_result.

Parameter activate : context -> (|Protocol_hash|).(S.HASH.t) -> Lwt.t context.

Parameter fork_test_chain :
  context -> (|Protocol_hash|).(S.HASH.t) -> Time.t -> Lwt.t context.

Parameter record_endorsement :
  context -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -> context.

Parameter allowed_endorsements :
  context ->
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
    ((|Signature.Public_key|).(S.SPublic_key.t) * list int * bool).

Parameter init_endorsements :
  context ->
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
    ((|Signature.Public_key|).(S.SPublic_key.t) * list int * bool) -> context.

Parameter included_endorsements : context -> int.

Parameter reset_internal_nonce : context -> context.

Parameter fresh_internal_nonce :
  context -> Error_monad.tzresult (context * int).

Parameter record_internal_nonce : context -> int -> context.

Parameter internal_nonce_already_recorded : context -> int -> bool.

Parameter add_fees : context -> Tez.t -> Lwt.t (Error_monad.tzresult context).

Parameter add_rewards :
  context -> Tez.t -> Lwt.t (Error_monad.tzresult context).

Parameter add_deposit :
  context -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -> Tez.t ->
  Lwt.t (Error_monad.tzresult context).

Parameter get_fees : context -> Tez.t.

Parameter get_rewards : context -> Tez.t.

Parameter get_deposits :
  context ->
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t) Tez.t.

Parameter description : Storage_description.t context.
