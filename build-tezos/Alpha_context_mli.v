(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Unset Positivity Checking.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Contract_repr.
Require Tezos.Nonce_hash.
Require Tezos.Script_expr_hash.
Require Tezos.Storage_description.

Module BASIC_DATA.
  Record signature {t : Set} := {
    t := t;
    op_eq : t -> t -> bool;
    op_ltgt : t -> t -> bool;
    op_lt : t -> t -> bool;
    op_lteq : t -> t -> bool;
    op_gteq : t -> t -> bool;
    op_gt : t -> t -> bool;
    compare : t -> t -> Z;
    equal : t -> t -> bool;
    max : t -> t -> t;
    min : t -> t -> t;
    encoding : Data_encoding.t t;
    pp : Format.formatter -> t -> unit;
  }.
  Arguments signature : clear implicits.
End BASIC_DATA.

Parameter t : Set.

Definition context := t.

Definition public_key := (|Signature.Public_key|).(S.SPublic_key.t).

Definition public_key_hash :=
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t).

Definition signature := Signature.t.

Module Tez.
  Parameter Included_BASIC_DATA : {t : _ & BASIC_DATA.signature t}.
  
  Definition t := (|Included_BASIC_DATA|).(BASIC_DATA.t).
  
  Definition op_eq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -> t -> Z :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -> t -> unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Definition tez := t.
  
  Parameter zero : tez.
  
  Parameter one_mutez : tez.
  
  Parameter one_cent : tez.
  
  Parameter fifty_cents : tez.
  
  Parameter one : tez.
  
  Parameter op_minusquestion : tez -> tez -> Error_monad.tzresult tez.
  
  Parameter op_plusquestion : tez -> tez -> Error_monad.tzresult tez.
  
  Parameter op_starquestion : tez -> int64 -> Error_monad.tzresult tez.
  
  Parameter op_divquestion : tez -> int64 -> Error_monad.tzresult tez.
  
  Parameter of_string : string -> option tez.
  
  Parameter to_string : tez -> string.
  
  Parameter of_mutez : int64 -> option tez.
  
  Parameter to_mutez : tez -> int64.
End Tez.

Module Period.
  Parameter Included_BASIC_DATA : {t : _ & BASIC_DATA.signature t}.
  
  Definition t := (|Included_BASIC_DATA|).(BASIC_DATA.t).
  
  Definition op_eq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -> t -> Z :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -> t -> unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Definition period := t.
  
  Parameter rpc_arg : RPC_arg.arg period.
  
  Parameter of_seconds : int64 -> Error_monad.tzresult period.
  
  Parameter to_seconds : period -> int64.
  
  Parameter mult : int32 -> period -> Error_monad.tzresult period.
  
  Parameter zero : period.
  
  Parameter one_second : period.
  
  Parameter one_minute : period.
  
  Parameter one_hour : period.
End Period.

Module Timestamp.
  Parameter Included_BASIC_DATA : {_ : unit & BASIC_DATA.signature Time.t}.
  
  Definition t := (|Included_BASIC_DATA|).(BASIC_DATA.t).
  
  Definition op_eq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -> t -> Z :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -> t -> unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Definition time := t.
  
  Parameter op_plusquestion : time -> Period.t -> Error_monad.tzresult time.
  
  Parameter op_minusquestion : time -> time -> Error_monad.tzresult Period.t.
  
  Parameter of_notation : string -> option time.
  
  Parameter to_notation : time -> string.
  
  Parameter of_seconds_string : string -> option time.
  
  Parameter to_seconds_string : time -> string.
  
  Parameter current : context -> time.
End Timestamp.

Module Raw_level.
  Parameter Included_BASIC_DATA : {t : _ & BASIC_DATA.signature t}.
  
  Definition t := (|Included_BASIC_DATA|).(BASIC_DATA.t).
  
  Definition op_eq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -> t -> Z :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -> t -> unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Definition raw_level := t.
  
  Parameter rpc_arg : RPC_arg.arg raw_level.
  
  Parameter diff : raw_level -> raw_level -> int32.
  
  Parameter root : raw_level.
  
  Parameter succ : raw_level -> raw_level.
  
  Parameter pred : raw_level -> option raw_level.
  
  Parameter to_int32 : raw_level -> int32.
  
  Parameter of_int32 : int32 -> Error_monad.tzresult raw_level.
End Raw_level.

Module Cycle.
  Parameter Included_BASIC_DATA : {t : _ & BASIC_DATA.signature t}.
  
  Definition t := (|Included_BASIC_DATA|).(BASIC_DATA.t).
  
  Definition op_eq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -> t -> Z :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -> t -> unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Definition cycle := t.
  
  Parameter rpc_arg : RPC_arg.arg cycle.
  
  Parameter root : cycle.
  
  Parameter succ : cycle -> cycle.
  
  Parameter pred : cycle -> option cycle.
  
  Parameter add : cycle -> Z -> cycle.
  
  Parameter sub : cycle -> Z -> option cycle.
  
  Parameter to_int32 : cycle -> int32.
  
  Parameter Map : {t : _ & S.MAP.signature cycle t}.
End Cycle.

Module Gas.
  Module t.
    Module Limited.
      Record record {remaining : Set} := {
        remaining : remaining }.
      Arguments record : clear implicits.
    End Limited.
    Definition Limited_skeleton := Limited.record.
  End t.
  
  Reserved Notation "'t.Limited".
  
  Inductive t : Set :=
  | Unaccounted : t
  | Limited : 't.Limited -> t
  
  where "'t.Limited" := (t.Limited_skeleton Z.t).
  
  Module ConstructorRecordNotations_t.
    Module t.
      Definition Limited := 't.Limited.
    End t.
  End ConstructorRecordNotations_t.
  Import ConstructorRecordNotations_t.
  
  Parameter encoding : Data_encoding.encoding t.
  
  Parameter pp : Format.formatter -> t -> unit.
  
  Parameter cost : Set.
  
  Parameter cost_encoding : Data_encoding.encoding cost.
  
  Parameter pp_cost : Format.formatter -> cost -> unit.
  
  (* extensible_type error *)
  
  (* extensible_type error *)
  
  (* extensible_type error *)
  
  Parameter free : cost.
  
  Parameter atomic_step_cost : Z -> cost.
  
  Parameter step_cost : Z -> cost.
  
  Parameter alloc_cost : Z -> cost.
  
  Parameter alloc_bytes_cost : Z -> cost.
  
  Parameter alloc_mbytes_cost : Z -> cost.
  
  Parameter alloc_bits_cost : Z -> cost.
  
  Parameter read_bytes_cost : Z.t -> cost.
  
  Parameter write_bytes_cost : Z.t -> cost.
  
  Parameter op_starat : Z -> cost -> cost.
  
  Parameter op_plusat : cost -> cost -> cost.
  
  Parameter check_limit : context -> Z.t -> Error_monad.tzresult unit.
  
  Parameter set_limit : context -> Z.t -> context.
  
  Parameter set_unlimited : context -> context.
  
  Parameter consume : context -> cost -> Error_monad.tzresult context.
  
  Parameter check_enough : context -> cost -> Error_monad.tzresult unit.
  
  Parameter level : context -> t.
  
  Parameter consumed : context -> context -> Z.t.
  
  Parameter block_level : context -> Z.t.
End Gas.

Module Script_int.
  Parameter num : forall (t : Set), Set.
  
  Parameter n : Set.
  
  Parameter z : Set.
  
  Parameter zero_n : num n.
  
  Parameter zero : num z.
  
  Parameter compare : forall {a : Set}, num a -> num a -> Z.
  
  Parameter to_string : forall {A : Set}, num A -> string.
  
  Parameter of_string : string -> option (num z).
  
  Parameter to_int64 : forall {A : Set}, num A -> option int64.
  
  Parameter of_int64 : int64 -> num z.
  
  Parameter to_int : forall {A : Set}, num A -> option Z.
  
  Parameter of_int : Z -> num z.
  
  Parameter of_zint : Z.t -> num z.
  
  Parameter to_zint : forall {a : Set}, num a -> Z.t.
  
  Parameter add_n : num n -> num n -> num n.
  
  Parameter mul_n : num n -> num n -> num n.
  
  Parameter ediv_n : num n -> num n -> option (num n * num n).
  
  Parameter add : forall {A B : Set}, num A -> num B -> num z.
  
  Parameter sub : forall {A B : Set}, num A -> num B -> num z.
  
  Parameter mul : forall {A B : Set}, num A -> num B -> num z.
  
  Parameter ediv : forall {A B : Set}, num A -> num B -> option (num z * num n).
  
  Parameter abs : num z -> num n.
  
  Parameter is_nat : num z -> option (num n).
  
  Parameter neg : forall {A : Set}, num A -> num z.
  
  Parameter int : num n -> num z.
  
  Parameter lognot : forall {A : Set}, num A -> num z.
  
  Parameter shift_left_n : num n -> num n -> option (num n).
  
  Parameter shift_right_n : num n -> num n -> option (num n).
  
  Parameter shift_left : forall {a : Set}, num a -> num n -> option (num a).
  
  Parameter shift_right : forall {a : Set}, num a -> num n -> option (num a).
  
  Parameter logor : forall {a : Set}, num a -> num a -> num a.
  
  Parameter logand : forall {A : Set}, num A -> num n -> num n.
  
  Parameter logxor : num n -> num n -> num n.
End Script_int.

Module Script_timestamp.
  Import Script_int.
  
  Parameter t : Set.
  
  Parameter compare : t -> t -> Z.
  
  Parameter to_string : t -> string.
  
  Parameter to_notation : t -> option string.
  
  Parameter to_num_str : t -> string.
  
  Parameter of_string : string -> option t.
  
  Parameter diff : t -> t -> Script_int.num Script_int.z.
  
  Parameter add_delta : t -> Script_int.num Script_int.z -> t.
  
  Parameter sub_delta : t -> Script_int.num Script_int.z -> t.
  
  Parameter now : context -> t.
  
  Parameter to_zint : t -> Z.t.
  
  Parameter of_zint : Z.t -> t.
End Script_timestamp.

Module Script.
  Inductive prim : Set :=
  | K_parameter : prim
  | K_storage : prim
  | K_code : prim
  | D_False : prim
  | D_Elt : prim
  | D_Left : prim
  | D_None : prim
  | D_Pair : prim
  | D_Right : prim
  | D_Some : prim
  | D_True : prim
  | D_Unit : prim
  | I_PACK : prim
  | I_UNPACK : prim
  | I_BLAKE2B : prim
  | I_SHA256 : prim
  | I_SHA512 : prim
  | I_ABS : prim
  | I_ADD : prim
  | I_AMOUNT : prim
  | I_AND : prim
  | I_BALANCE : prim
  | I_CAR : prim
  | I_CDR : prim
  | I_CHAIN_ID : prim
  | I_CHECK_SIGNATURE : prim
  | I_COMPARE : prim
  | I_CONCAT : prim
  | I_CONS : prim
  | I_CREATE_ACCOUNT : prim
  | I_CREATE_CONTRACT : prim
  | I_IMPLICIT_ACCOUNT : prim
  | I_DIP : prim
  | I_DROP : prim
  | I_DUP : prim
  | I_EDIV : prim
  | I_EMPTY_BIG_MAP : prim
  | I_EMPTY_MAP : prim
  | I_EMPTY_SET : prim
  | I_EQ : prim
  | I_EXEC : prim
  | I_APPLY : prim
  | I_FAILWITH : prim
  | I_GE : prim
  | I_GET : prim
  | I_GT : prim
  | I_HASH_KEY : prim
  | I_IF : prim
  | I_IF_CONS : prim
  | I_IF_LEFT : prim
  | I_IF_NONE : prim
  | I_INT : prim
  | I_LAMBDA : prim
  | I_LE : prim
  | I_LEFT : prim
  | I_LOOP : prim
  | I_LSL : prim
  | I_LSR : prim
  | I_LT : prim
  | I_MAP : prim
  | I_MEM : prim
  | I_MUL : prim
  | I_NEG : prim
  | I_NEQ : prim
  | I_NIL : prim
  | I_NONE : prim
  | I_NOT : prim
  | I_NOW : prim
  | I_OR : prim
  | I_PAIR : prim
  | I_PUSH : prim
  | I_RIGHT : prim
  | I_SIZE : prim
  | I_SOME : prim
  | I_SOURCE : prim
  | I_SENDER : prim
  | I_SELF : prim
  | I_SLICE : prim
  | I_STEPS_TO_QUOTA : prim
  | I_SUB : prim
  | I_SWAP : prim
  | I_TRANSFER_TOKENS : prim
  | I_SET_DELEGATE : prim
  | I_UNIT : prim
  | I_UPDATE : prim
  | I_XOR : prim
  | I_ITER : prim
  | I_LOOP_LEFT : prim
  | I_ADDRESS : prim
  | I_CONTRACT : prim
  | I_ISNAT : prim
  | I_CAST : prim
  | I_RENAME : prim
  | I_DIG : prim
  | I_DUG : prim
  | T_bool : prim
  | T_contract : prim
  | T_int : prim
  | T_key : prim
  | T_key_hash : prim
  | T_lambda : prim
  | T_list : prim
  | T_map : prim
  | T_big_map : prim
  | T_nat : prim
  | T_option : prim
  | T_or : prim
  | T_pair : prim
  | T_set : prim
  | T_signature : prim
  | T_string : prim
  | T_bytes : prim
  | T_mutez : prim
  | T_timestamp : prim
  | T_unit : prim
  | T_operation : prim
  | T_address : prim
  | T_chain_id : prim.
  
  Definition location := Micheline.canonical_location.
  
  Definition annot := Micheline.annot.
  
  Definition expr := Micheline.canonical prim.
  
  Definition lazy_expr := Data_encoding.lazy_t expr.
  
  Parameter __lazy_expr_value : expr -> lazy_expr.
  
  Definition node := Micheline.node location prim.
  
  Module t.
    Record record := Build {
      code : lazy_expr;
      storage : lazy_expr }.
    Definition with_code code (r : record) :=
      Build code r.(storage).
    Definition with_storage storage (r : record) :=
      Build r.(code) storage.
  End t.
  Definition t := t.record.
  
  Parameter location_encoding : Data_encoding.t location.
  
  Parameter expr_encoding : Data_encoding.t expr.
  
  Parameter prim_encoding : Data_encoding.t prim.
  
  Parameter encoding : Data_encoding.t t.
  
  Parameter lazy_expr_encoding : Data_encoding.t lazy_expr.
  
  Parameter deserialized_cost : expr -> Gas.cost.
  
  Parameter serialized_cost : MBytes.t -> Gas.cost.
  
  Parameter traversal_cost : node -> Gas.cost.
  
  Parameter node_cost : node -> Gas.cost.
  
  Parameter int_node_cost : Z.t -> Gas.cost.
  
  Parameter int_node_cost_of_numbits : Z -> Gas.cost.
  
  Parameter string_node_cost : string -> Gas.cost.
  
  Parameter string_node_cost_of_length : Z -> Gas.cost.
  
  Parameter bytes_node_cost : MBytes.t -> Gas.cost.
  
  Parameter bytes_node_cost_of_length : Z -> Gas.cost.
  
  Parameter prim_node_cost_nonrec : list expr -> annot -> Gas.cost.
  
  Parameter prim_node_cost_nonrec_of_length : Z -> annot -> Gas.cost.
  
  Parameter seq_node_cost_nonrec : list expr -> Gas.cost.
  
  Parameter seq_node_cost_nonrec_of_length : Z -> Gas.cost.
  
  Parameter minimal_deserialize_cost : lazy_expr -> Gas.cost.
  
  Parameter force_decode :
    context -> lazy_expr -> Lwt.t (Error_monad.tzresult (expr * context)).
  
  Parameter force_bytes :
    context -> lazy_expr -> Lwt.t (Error_monad.tzresult (MBytes.t * context)).
  
  Parameter unit_parameter : lazy_expr.
  
  Module Legacy_support.
    Parameter manager_script_code : lazy_expr.
    
    Parameter add_do :
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -> lazy_expr ->
      lazy_expr -> Lwt.t (Error_monad.tzresult (lazy_expr * lazy_expr)).
    
    Parameter add_set_delegate :
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -> lazy_expr ->
      lazy_expr -> Lwt.t (Error_monad.tzresult (lazy_expr * lazy_expr)).
    
    Parameter has_default_entrypoint : lazy_expr -> bool.
    
    Parameter add_root_entrypoint :
      lazy_expr -> Lwt.t (Error_monad.tzresult lazy_expr).
  End Legacy_support.
End Script.

Module Constants.
  Module fixed.
    Record record := Build {
      proof_of_work_nonce_size : Z;
      nonce_length : Z;
      max_revelations_per_block : Z;
      max_operation_data_length : Z;
      max_proposals_per_delegate : Z }.
    Definition with_proof_of_work_nonce_size proof_of_work_nonce_size
      (r : record) :=
      Build proof_of_work_nonce_size r.(nonce_length)
        r.(max_revelations_per_block) r.(max_operation_data_length)
        r.(max_proposals_per_delegate).
    Definition with_nonce_length nonce_length (r : record) :=
      Build r.(proof_of_work_nonce_size) nonce_length
        r.(max_revelations_per_block) r.(max_operation_data_length)
        r.(max_proposals_per_delegate).
    Definition with_max_revelations_per_block max_revelations_per_block
      (r : record) :=
      Build r.(proof_of_work_nonce_size) r.(nonce_length)
        max_revelations_per_block r.(max_operation_data_length)
        r.(max_proposals_per_delegate).
    Definition with_max_operation_data_length max_operation_data_length
      (r : record) :=
      Build r.(proof_of_work_nonce_size) r.(nonce_length)
        r.(max_revelations_per_block) max_operation_data_length
        r.(max_proposals_per_delegate).
    Definition with_max_proposals_per_delegate max_proposals_per_delegate
      (r : record) :=
      Build r.(proof_of_work_nonce_size) r.(nonce_length)
        r.(max_revelations_per_block) r.(max_operation_data_length)
        max_proposals_per_delegate.
  End fixed.
  Definition fixed := fixed.record.
  
  Parameter fixed_encoding : Data_encoding.t fixed.
  
  Parameter __fixed_value : fixed.
  
  Parameter proof_of_work_nonce_size : Z.
  
  Parameter nonce_length : Z.
  
  Parameter max_revelations_per_block : Z.
  
  Parameter max_operation_data_length : Z.
  
  Parameter max_proposals_per_delegate : Z.
  
  Module parametric.
    Record record := Build {
      preserved_cycles : Z;
      blocks_per_cycle : int32;
      blocks_per_commitment : int32;
      blocks_per_roll_snapshot : int32;
      blocks_per_voting_period : int32;
      time_between_blocks : list Period.t;
      endorsers_per_block : Z;
      hard_gas_limit_per_operation : Z.t;
      hard_gas_limit_per_block : Z.t;
      proof_of_work_threshold : int64;
      tokens_per_roll : Tez.t;
      michelson_maximum_type_size : Z;
      seed_nonce_revelation_tip : Tez.t;
      origination_size : Z;
      block_security_deposit : Tez.t;
      endorsement_security_deposit : Tez.t;
      block_reward : Tez.t;
      endorsement_reward : Tez.t;
      cost_per_byte : Tez.t;
      hard_storage_limit_per_operation : Z.t;
      test_chain_duration : int64;
      quorum_min : int32;
      quorum_max : int32;
      min_proposal_quorum : int32;
      initial_endorsers : Z;
      delay_per_missing_endorsement : Period.t }.
    Definition with_preserved_cycles preserved_cycles (r : record) :=
      Build preserved_cycles r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_blocks_per_cycle blocks_per_cycle (r : record) :=
      Build r.(preserved_cycles) blocks_per_cycle r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_blocks_per_commitment blocks_per_commitment (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) blocks_per_commitment
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_blocks_per_roll_snapshot blocks_per_roll_snapshot
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        blocks_per_roll_snapshot r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_blocks_per_voting_period blocks_per_voting_period
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) blocks_per_voting_period
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_time_between_blocks time_between_blocks (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        time_between_blocks r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_endorsers_per_block endorsers_per_block (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) endorsers_per_block
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_hard_gas_limit_per_operation hard_gas_limit_per_operation
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        hard_gas_limit_per_operation r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_hard_gas_limit_per_block hard_gas_limit_per_block
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) hard_gas_limit_per_block
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_proof_of_work_threshold proof_of_work_threshold
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        proof_of_work_threshold r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_tokens_per_roll tokens_per_roll (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) tokens_per_roll
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_michelson_maximum_type_size michelson_maximum_type_size
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        michelson_maximum_type_size r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_seed_nonce_revelation_tip seed_nonce_revelation_tip
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) seed_nonce_revelation_tip
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_origination_size origination_size (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        origination_size r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_block_security_deposit block_security_deposit
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) block_security_deposit
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_endorsement_security_deposit endorsement_security_deposit
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        endorsement_security_deposit r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_block_reward block_reward (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) block_reward r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_endorsement_reward endorsement_reward (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) endorsement_reward
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_cost_per_byte cost_per_byte (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        cost_per_byte r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_hard_storage_limit_per_operation
      hard_storage_limit_per_operation (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) hard_storage_limit_per_operation
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_test_chain_duration test_chain_duration (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        test_chain_duration r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_quorum_min quorum_min (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) quorum_min r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_quorum_max quorum_max (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) quorum_max
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_min_proposal_quorum min_proposal_quorum (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        min_proposal_quorum r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_initial_endorsers initial_endorsers (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) initial_endorsers
        r.(delay_per_missing_endorsement).
    Definition with_delay_per_missing_endorsement delay_per_missing_endorsement
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        delay_per_missing_endorsement.
  End parametric.
  Definition parametric := parametric.record.
  
  Parameter parametric_encoding : Data_encoding.t parametric.
  
  Parameter __parametric_value : context -> parametric.
  
  Parameter preserved_cycles : context -> Z.
  
  Parameter blocks_per_cycle : context -> int32.
  
  Parameter blocks_per_commitment : context -> int32.
  
  Parameter blocks_per_roll_snapshot : context -> int32.
  
  Parameter blocks_per_voting_period : context -> int32.
  
  Parameter time_between_blocks : context -> list Period.t.
  
  Parameter endorsers_per_block : context -> Z.
  
  Parameter initial_endorsers : context -> Z.
  
  Parameter delay_per_missing_endorsement : context -> Period.t.
  
  Parameter hard_gas_limit_per_operation : context -> Z.t.
  
  Parameter hard_gas_limit_per_block : context -> Z.t.
  
  Parameter cost_per_byte : context -> Tez.t.
  
  Parameter hard_storage_limit_per_operation : context -> Z.t.
  
  Parameter proof_of_work_threshold : context -> int64.
  
  Parameter tokens_per_roll : context -> Tez.t.
  
  Parameter michelson_maximum_type_size : context -> Z.
  
  Parameter block_reward : context -> Tez.t.
  
  Parameter endorsement_reward : context -> Tez.t.
  
  Parameter seed_nonce_revelation_tip : context -> Tez.t.
  
  Parameter origination_size : context -> Z.
  
  Parameter block_security_deposit : context -> Tez.t.
  
  Parameter endorsement_security_deposit : context -> Tez.t.
  
  Parameter test_chain_duration : context -> int64.
  
  Parameter quorum_min : context -> int32.
  
  Parameter quorum_max : context -> int32.
  
  Parameter min_proposal_quorum : context -> int32.
  
  Module t.
    Record record := Build {
      fixed : fixed;
      parametric : parametric }.
    Definition with_fixed fixed (r : record) :=
      Build fixed r.(parametric).
    Definition with_parametric parametric (r : record) :=
      Build r.(fixed) parametric.
  End t.
  Definition t := t.record.
  
  Parameter encoding : Data_encoding.t t.
End Constants.

Module Voting_period.
  Parameter Included_BASIC_DATA : {t : _ & BASIC_DATA.signature t}.
  
  Definition t := (|Included_BASIC_DATA|).(BASIC_DATA.t).
  
  Definition op_eq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -> t -> Z :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -> t -> unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Definition voting_period := t.
  
  Parameter rpc_arg : RPC_arg.arg voting_period.
  
  Parameter root : voting_period.
  
  Parameter succ : voting_period -> voting_period.
  
  Inductive kind : Set :=
  | Proposal : kind
  | Testing_vote : kind
  | Testing : kind
  | Promotion_vote : kind.
  
  Parameter kind_encoding : Data_encoding.encoding kind.
  
  Parameter to_int32 : voting_period -> int32.
End Voting_period.

Module Level.
  Module t.
    Record record := Build {
      level : Raw_level.t;
      level_position : int32;
      cycle : Cycle.t;
      cycle_position : int32;
      voting_period : Voting_period.t;
      voting_period_position : int32;
      expected_commitment : bool }.
    Definition with_level level (r : record) :=
      Build level r.(level_position) r.(cycle) r.(cycle_position)
        r.(voting_period) r.(voting_period_position) r.(expected_commitment).
    Definition with_level_position level_position (r : record) :=
      Build r.(level) level_position r.(cycle) r.(cycle_position)
        r.(voting_period) r.(voting_period_position) r.(expected_commitment).
    Definition with_cycle cycle (r : record) :=
      Build r.(level) r.(level_position) cycle r.(cycle_position)
        r.(voting_period) r.(voting_period_position) r.(expected_commitment).
    Definition with_cycle_position cycle_position (r : record) :=
      Build r.(level) r.(level_position) r.(cycle) cycle_position
        r.(voting_period) r.(voting_period_position) r.(expected_commitment).
    Definition with_voting_period voting_period (r : record) :=
      Build r.(level) r.(level_position) r.(cycle) r.(cycle_position)
        voting_period r.(voting_period_position) r.(expected_commitment).
    Definition with_voting_period_position voting_period_position
      (r : record) :=
      Build r.(level) r.(level_position) r.(cycle) r.(cycle_position)
        r.(voting_period) voting_period_position r.(expected_commitment).
    Definition with_expected_commitment expected_commitment (r : record) :=
      Build r.(level) r.(level_position) r.(cycle) r.(cycle_position)
        r.(voting_period) r.(voting_period_position) expected_commitment.
  End t.
  Definition t := t.record.
  
  Parameter Included_BASIC_DATA : {_ : unit & BASIC_DATA.signature t}.
  
  Definition op_eq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -> t -> Z :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -> t -> unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Parameter pp_full : Format.formatter -> t -> unit.
  
  Definition level := t.
  
  Parameter root : context -> level.
  
  Parameter succ : context -> level -> level.
  
  Parameter pred : context -> level -> option level.
  
  Parameter from_raw : context -> option int32 -> Raw_level.t -> level.
  
  Parameter diff : level -> level -> int32.
  
  Parameter current : context -> level.
  
  Parameter last_level_in_cycle : context -> Cycle.t -> level.
  
  Parameter levels_in_cycle : context -> Cycle.t -> list level.
  
  Parameter levels_in_current_cycle :
    context -> option int32 -> unit -> list level.
  
  Parameter last_allowed_fork_level : context -> Raw_level.t.
End Level.

Module Fitness.
  Parameter t : Set.
  
  Parameter op_eq : t -> t -> bool.
  
  Parameter op_ltgt : t -> t -> bool.
  
  Parameter op_lt : t -> t -> bool.
  
  Parameter op_lteq : t -> t -> bool.
  
  Parameter op_gteq : t -> t -> bool.
  
  Parameter op_gt : t -> t -> bool.
  
  Parameter compare : t -> t -> Z.
  
  Parameter equal : t -> t -> bool.
  
  Parameter max : t -> t -> t.
  
  Parameter min : t -> t -> t.
  
  Parameter pp : Format.formatter -> t -> unit.
  
  Parameter encoding : Data_encoding.t t.
  
  Parameter to_bytes : t -> MBytes.t.
  
  Parameter of_bytes : MBytes.t -> option t.
  
  Definition fitness := t.
  
  Parameter increase : option Z -> context -> context.
  
  Parameter current : context -> int64.
  
  Parameter to_int64 : fitness -> Error_monad.tzresult int64.
End Fitness.

Module Nonce.
  Parameter t : Set.
  
  Definition nonce := t.
  
  Parameter encoding : Data_encoding.t nonce.
  
  Module unrevealed.
    Record record := Build {
      nonce_hash : Nonce_hash.t;
      delegate : public_key_hash;
      rewards : Tez.t;
      fees : Tez.t }.
    Definition with_nonce_hash nonce_hash (r : record) :=
      Build nonce_hash r.(delegate) r.(rewards) r.(fees).
    Definition with_delegate delegate (r : record) :=
      Build r.(nonce_hash) delegate r.(rewards) r.(fees).
    Definition with_rewards rewards (r : record) :=
      Build r.(nonce_hash) r.(delegate) rewards r.(fees).
    Definition with_fees fees (r : record) :=
      Build r.(nonce_hash) r.(delegate) r.(rewards) fees.
  End unrevealed.
  Definition unrevealed := unrevealed.record.
  
  Parameter record_hash :
    context -> unrevealed -> Lwt.t (Error_monad.tzresult context).
  
  Parameter reveal :
    context -> Level.t -> nonce -> Lwt.t (Error_monad.tzresult context).
  
  Inductive status : Set :=
  | Unrevealed : unrevealed -> status
  | Revealed : nonce -> status.
  
  Parameter get : context -> Level.t -> Lwt.t (Error_monad.tzresult status).
  
  Parameter of_bytes : MBytes.t -> Error_monad.tzresult nonce.
  
  Parameter __hash_value : nonce -> Nonce_hash.t.
  
  Parameter check_hash : nonce -> Nonce_hash.t -> bool.
End Nonce.

Module Seed.
  Parameter seed : Set.
  
  (* extensible_type error *)
  
  Parameter for_cycle : context -> Cycle.t -> Lwt.t (Error_monad.tzresult seed).
  
  Parameter cycle_end :
    context -> Cycle.t ->
    Lwt.t (Error_monad.tzresult (context * list Nonce.unrevealed)).
  
  Parameter seed_encoding : Data_encoding.t seed.
End Seed.

Module Big_map.
  Definition id := Z.t.
  
  Parameter fresh : context -> Lwt.t (Error_monad.tzresult (context * id)).
  
  Parameter fresh_temporary : context -> context * id.
  
  Parameter mem :
    context -> id -> Script_expr_hash.t ->
    Lwt.t (Error_monad.tzresult (context * bool)).
  
  Parameter get_opt :
    context -> id -> Script_expr_hash.t ->
    Lwt.t (Error_monad.tzresult (context * option Script.expr)).
  
  Parameter rpc_arg : RPC_arg.t id.
  
  Parameter cleanup_temporary : context -> Lwt.t context.
  
  Parameter __exists :
    context -> id ->
    Lwt.t (Error_monad.tzresult (context * option (Script.expr * Script.expr))).
End Big_map.

Module Contract.
  Parameter Included_BASIC_DATA : {t : _ & BASIC_DATA.signature t}.
  
  Definition t := (|Included_BASIC_DATA|).(BASIC_DATA.t).
  
  Definition op_eq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -> t -> Z :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -> t -> bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -> t -> t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -> t -> unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Definition contract := t.
  
  Parameter rpc_arg : RPC_arg.arg contract.
  
  Parameter to_b58check : contract -> string.
  
  Parameter of_b58check : string -> Error_monad.tzresult contract.
  
  Parameter implicit_contract : public_key_hash -> contract.
  
  Parameter is_implicit : contract -> option public_key_hash.
  
  Parameter __exists : context -> contract -> Lwt.t (Error_monad.tzresult bool).
  
  Parameter must_exist :
    context -> contract -> Lwt.t (Error_monad.tzresult unit).
  
  Parameter allocated :
    context -> contract -> Lwt.t (Error_monad.tzresult bool).
  
  Parameter must_be_allocated :
    context -> contract -> Lwt.t (Error_monad.tzresult unit).
  
  Parameter __list_value : context -> Lwt.t (list contract).
  
  Parameter get_manager_key :
    context -> public_key_hash -> Lwt.t (Error_monad.tzresult public_key).
  
  Parameter is_manager_key_revealed :
    context -> public_key_hash -> Lwt.t (Error_monad.tzresult bool).
  
  Parameter reveal_manager_key :
    context -> public_key_hash -> public_key ->
    Lwt.t (Error_monad.tzresult context).
  
  Parameter get_script_code :
    context -> contract ->
    Lwt.t (Error_monad.tzresult (context * option Script.lazy_expr)).
  
  Parameter get_script :
    context -> contract ->
    Lwt.t (Error_monad.tzresult (context * option Script.t)).
  
  Parameter get_storage :
    context -> contract ->
    Lwt.t (Error_monad.tzresult (context * option Script.expr)).
  
  Parameter get_counter :
    context -> public_key_hash -> Lwt.t (Error_monad.tzresult Z.t).
  
  Parameter get_balance :
    context -> contract -> Lwt.t (Error_monad.tzresult Tez.t).
  
  Parameter init_origination_nonce :
    context -> (|Operation_hash|).(S.HASH.t) -> context.
  
  Parameter unset_origination_nonce : context -> context.
  
  Parameter fresh_contract_from_current_nonce :
    context -> Lwt.t (Error_monad.tzresult (context * t)).
  
  Parameter originated_from_current_nonce :
    context -> context -> Lwt.t (Error_monad.tzresult (list contract)).
  
  Module big_map_diff_item.
    Module Update.
      Record record {big_map diff_key diff_key_hash diff_value : Set} := {
        big_map : big_map;
        diff_key : diff_key;
        diff_key_hash : diff_key_hash;
        diff_value : diff_value }.
      Arguments record : clear implicits.
    End Update.
    Definition Update_skeleton := Update.record.
    
    Module Alloc.
      Record record {big_map key_type value_type : Set} := {
        big_map : big_map;
        key_type : key_type;
        value_type : value_type }.
      Arguments record : clear implicits.
    End Alloc.
    Definition Alloc_skeleton := Alloc.record.
  End big_map_diff_item.
  
  Reserved Notation "'big_map_diff_item.Update".
  Reserved Notation "'big_map_diff_item.Alloc".
  
  Inductive big_map_diff_item : Set :=
  | Update : 'big_map_diff_item.Update -> big_map_diff_item
  | Clear : Big_map.id -> big_map_diff_item
  | Copy : Big_map.id -> Big_map.id -> big_map_diff_item
  | Alloc : 'big_map_diff_item.Alloc -> big_map_diff_item
  
  where "'big_map_diff_item.Update" :=
    (big_map_diff_item.Update_skeleton Big_map.id Script.expr Script_expr_hash.t
      (option Script.expr))
  and "'big_map_diff_item.Alloc" :=
    (big_map_diff_item.Alloc_skeleton Big_map.id Script.expr Script.expr).
  
  Module ConstructorRecordNotations_big_map_diff_item.
    Module big_map_diff_item.
      Definition Update := 'big_map_diff_item.Update.
      Definition Alloc := 'big_map_diff_item.Alloc.
    End big_map_diff_item.
  End ConstructorRecordNotations_big_map_diff_item.
  Import ConstructorRecordNotations_big_map_diff_item.
  
  Definition big_map_diff := list big_map_diff_item.
  
  Parameter big_map_diff_encoding : Data_encoding.t big_map_diff.
  
  Parameter originate :
    context -> contract -> Tez.t -> Script.t * option big_map_diff ->
    option public_key_hash -> Lwt.t (Error_monad.tzresult context).
  
  (* extensible_type error *)
  
  Parameter spend :
    context -> contract -> Tez.t -> Lwt.t (Error_monad.tzresult context).
  
  Parameter credit :
    context -> contract -> Tez.t -> Lwt.t (Error_monad.tzresult context).
  
  Parameter update_script_storage :
    context -> contract -> Script.expr -> option big_map_diff ->
    Lwt.t (Error_monad.tzresult context).
  
  Parameter used_storage_space :
    context -> t -> Lwt.t (Error_monad.tzresult Z.t).
  
  Parameter increment_counter :
    context -> public_key_hash -> Lwt.t (Error_monad.tzresult context).
  
  Parameter check_counter_increment :
    context -> public_key_hash -> Z.t -> Lwt.t (Error_monad.tzresult unit).
  
  Parameter origination_nonce : Set.
  
  Parameter initial_origination_nonce :
    (|Operation_hash|).(S.HASH.t) -> origination_nonce.
  
  Parameter originated_contract : origination_nonce -> contract.
End Contract.

Module Delegate.
  Inductive balance : Set :=
  | Contract : Contract.t -> balance
  | Rewards :
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -> Cycle.t -> balance
  | Fees :
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -> Cycle.t -> balance
  | Deposits :
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -> Cycle.t -> balance.
  
  Inductive balance_update : Set :=
  | Debited : Tez.t -> balance_update
  | Credited : Tez.t -> balance_update.
  
  Definition balance_updates := list (balance * balance_update).
  
  Parameter balance_updates_encoding : Data_encoding.t balance_updates.
  
  Parameter cleanup_balance_updates : balance_updates -> balance_updates.
  
  Parameter get :
    context -> Contract.t ->
    Lwt.t (Error_monad.tzresult (option public_key_hash)).
  
  Parameter set :
    context -> Contract.t -> option public_key_hash ->
    Lwt.t (Error_monad.tzresult context).
  
  Parameter fold : forall {a : Set},
    context -> a -> (public_key_hash -> a -> Lwt.t a) -> Lwt.t a.
  
  Parameter __list_value : context -> Lwt.t (list public_key_hash).
  
  Parameter freeze_deposit :
    context -> public_key_hash -> Tez.t -> Lwt.t (Error_monad.tzresult context).
  
  Parameter freeze_rewards :
    context -> public_key_hash -> Tez.t -> Lwt.t (Error_monad.tzresult context).
  
  Parameter freeze_fees :
    context -> public_key_hash -> Tez.t -> Lwt.t (Error_monad.tzresult context).
  
  Parameter cycle_end :
    context -> Cycle.t -> list Nonce.unrevealed ->
    Lwt.t
      (Error_monad.tzresult
        (context * balance_updates *
          list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))).
  
  Module frozen_balance.
    Record record := Build {
      deposit : Tez.t;
      fees : Tez.t;
      rewards : Tez.t }.
    Definition with_deposit deposit (r : record) :=
      Build deposit r.(fees) r.(rewards).
    Definition with_fees fees (r : record) :=
      Build r.(deposit) fees r.(rewards).
    Definition with_rewards rewards (r : record) :=
      Build r.(deposit) r.(fees) rewards.
  End frozen_balance.
  Definition frozen_balance := frozen_balance.record.
  
  Parameter punish :
    context -> public_key_hash -> Cycle.t ->
    Lwt.t (Error_monad.tzresult (context * frozen_balance)).
  
  Parameter full_balance :
    context -> public_key_hash -> Lwt.t (Error_monad.tzresult Tez.t).
  
  Parameter has_frozen_balance :
    context -> public_key_hash -> Cycle.t -> Lwt.t (Error_monad.tzresult bool).
  
  Parameter __frozen_balance_value :
    context -> public_key_hash -> Lwt.t (Error_monad.tzresult Tez.t).
  
  Parameter frozen_balance_encoding : Data_encoding.t frozen_balance.
  
  Parameter frozen_balance_by_cycle_encoding :
    Data_encoding.t ((|Cycle.Map|).(S.MAP.t) frozen_balance).
  
  Parameter frozen_balance_by_cycle :
    context -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
    Lwt.t ((|Cycle.Map|).(S.MAP.t) frozen_balance).
  
  Parameter staking_balance :
    context -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
    Lwt.t (Error_monad.tzresult Tez.t).
  
  Parameter delegated_contracts :
    context -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
    Lwt.t (list Contract_repr.t).
  
  Parameter delegated_balance :
    context -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
    Lwt.t (Error_monad.tzresult Tez.t).
  
  Parameter deactivated :
    context -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
    Lwt.t (Error_monad.tzresult bool).
  
  Parameter grace_period :
    context -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
    Lwt.t (Error_monad.tzresult Cycle.t).
End Delegate.

Module Vote.
  Definition proposal := (|Protocol_hash|).(S.HASH.t).
  
  Parameter record_proposal :
    context -> (|Protocol_hash|).(S.HASH.t) -> public_key_hash ->
    Lwt.t (Error_monad.tzresult context).
  
  Parameter get_proposals :
    context ->
    Lwt.t
      (Error_monad.tzresult
        ((|Protocol_hash|).(S.HASH.Map).(S.INDEXES_Map.t) int32)).
  
  Parameter clear_proposals : context -> Lwt.t context.
  
  Parameter recorded_proposal_count_for_delegate :
    context -> public_key_hash -> Lwt.t (Error_monad.tzresult Z).
  
  Parameter listings_encoding :
    Data_encoding.t
      (list ((|Signature.Public_key_hash|).(S.SPublic_key_hash.t) * int32)).
  
  Parameter freeze_listings : context -> Lwt.t (Error_monad.tzresult context).
  
  Parameter clear_listings : context -> Lwt.t (Error_monad.tzresult context).
  
  Parameter listing_size : context -> Lwt.t (Error_monad.tzresult int32).
  
  Parameter in_listings : context -> public_key_hash -> Lwt.t bool.
  
  Parameter get_listings : context -> Lwt.t (list (public_key_hash * int32)).
  
  Inductive ballot : Set :=
  | Yay : ballot
  | Nay : ballot
  | Pass : ballot.
  
  Parameter ballot_encoding : Data_encoding.t ballot.
  
  Module ballots.
    Record record := Build {
      yay : int32;
      nay : int32;
      pass : int32 }.
    Definition with_yay yay (r : record) :=
      Build yay r.(nay) r.(pass).
    Definition with_nay nay (r : record) :=
      Build r.(yay) nay r.(pass).
    Definition with_pass pass (r : record) :=
      Build r.(yay) r.(nay) pass.
  End ballots.
  Definition ballots := ballots.record.
  
  Parameter ballots_encoding : Data_encoding.t ballots.
  
  Parameter has_recorded_ballot : context -> public_key_hash -> Lwt.t bool.
  
  Parameter record_ballot :
    context -> public_key_hash -> ballot -> Lwt.t (Error_monad.tzresult context).
  
  Parameter get_ballots : context -> Lwt.t (Error_monad.tzresult ballots).
  
  Parameter get_ballot_list :
    context ->
    Lwt.t (list ((|Signature.Public_key_hash|).(S.SPublic_key_hash.t) * ballot)).
  
  Parameter clear_ballots : context -> Lwt.t context.
  
  Parameter get_current_period_kind :
    context -> Lwt.t (Error_monad.tzresult Voting_period.kind).
  
  Parameter set_current_period_kind :
    context -> Voting_period.kind -> Lwt.t (Error_monad.tzresult context).
  
  Parameter get_current_quorum : context -> Lwt.t (Error_monad.tzresult int32).
  
  Parameter get_participation_ema :
    context -> Lwt.t (Error_monad.tzresult int32).
  
  Parameter set_participation_ema :
    context -> int32 -> Lwt.t (Error_monad.tzresult context).
  
  Parameter get_current_proposal :
    context -> Lwt.t (Error_monad.tzresult proposal).
  
  Parameter init_current_proposal :
    context -> proposal -> Lwt.t (Error_monad.tzresult context).
  
  Parameter clear_current_proposal :
    context -> Lwt.t (Error_monad.tzresult context).
End Vote.

Module Block_header.
  Module contents.
    Record record := Build {
      priority : Z;
      seed_nonce_hash : option Nonce_hash.t;
      proof_of_work_nonce : MBytes.t }.
    Definition with_priority priority (r : record) :=
      Build priority r.(seed_nonce_hash) r.(proof_of_work_nonce).
    Definition with_seed_nonce_hash seed_nonce_hash (r : record) :=
      Build r.(priority) seed_nonce_hash r.(proof_of_work_nonce).
    Definition with_proof_of_work_nonce proof_of_work_nonce (r : record) :=
      Build r.(priority) r.(seed_nonce_hash) proof_of_work_nonce.
  End contents.
  Definition contents := contents.record.
  
  Module protocol_data.
    Record record := Build {
      contents : contents;
      signature : Signature.t }.
    Definition with_contents contents (r : record) :=
      Build contents r.(signature).
    Definition with_signature signature (r : record) :=
      Build r.(contents) signature.
  End protocol_data.
  Definition protocol_data := protocol_data.record.
  
  Module t.
    Record record := Build {
      shell : Block_header.shell_header;
      protocol_data : protocol_data }.
    Definition with_shell shell (r : record) :=
      Build shell r.(protocol_data).
    Definition with_protocol_data protocol_data (r : record) :=
      Build r.(shell) protocol_data.
  End t.
  Definition t := t.record.
  
  Definition block_header := t.
  
  Definition raw := Block_header.t.
  
  Definition shell_header := Block_header.shell_header.
  
  Parameter __raw_value : block_header -> raw.
  
  Parameter __hash_value : block_header -> (|Block_hash|).(S.HASH.t).
  
  Parameter hash_raw : raw -> (|Block_hash|).(S.HASH.t).
  
  Parameter encoding : Data_encoding.encoding block_header.
  
  Parameter raw_encoding : Data_encoding.t raw.
  
  Parameter contents_encoding : Data_encoding.t contents.
  
  Parameter unsigned_encoding : Data_encoding.t (shell_header * contents).
  
  Parameter protocol_data_encoding : Data_encoding.encoding protocol_data.
  
  Parameter shell_header_encoding : Data_encoding.encoding shell_header.
  
  Parameter max_header_length : Z.
End Block_header.

Module Kind.
  Inductive seed_nonce_revelation : Set :=
  | Seed_nonce_revelation_kind : seed_nonce_revelation.
  
  Inductive double_endorsement_evidence : Set :=
  | Double_endorsement_evidence_kind : double_endorsement_evidence.
  
  Inductive double_baking_evidence : Set :=
  | Double_baking_evidence_kind : double_baking_evidence.
  
  Inductive activate_account : Set :=
  | Activate_account_kind : activate_account.
  
  Inductive endorsement : Set :=
  | Endorsement_kind : endorsement.
  
  Inductive proposals : Set :=
  | Proposals_kind : proposals.
  
  Inductive ballot : Set :=
  | Ballot_kind : ballot.
  
  Inductive reveal : Set :=
  | Reveal_kind : reveal.
  
  Inductive transaction : Set :=
  | Transaction_kind : transaction.
  
  Inductive origination : Set :=
  | Origination_kind : origination.
  
  Inductive delegation : Set :=
  | Delegation_kind : delegation.
  
  Reserved Notation "'manager".
  
  Inductive manager_gadt : Set :=
  | Reveal_manager_kind : manager_gadt
  | Transaction_manager_kind : manager_gadt
  | Origination_manager_kind : manager_gadt
  | Delegation_manager_kind : manager_gadt
  
  where "'manager" := (fun (_ : Set) => manager_gadt).
  
  Definition manager := 'manager.
End Kind.

Module contents.
  Module Endorsement.
    Record record {level : Set} := {
      level : level }.
    Arguments record : clear implicits.
  End Endorsement.
  Definition Endorsement_skeleton := Endorsement.record.
  
  Module Seed_nonce_revelation.
    Record record {level nonce : Set} := {
      level : level;
      nonce : nonce }.
    Arguments record : clear implicits.
  End Seed_nonce_revelation.
  Definition Seed_nonce_revelation_skeleton := Seed_nonce_revelation.record.
  
  Module Double_endorsement_evidence.
    Record record {op1 op2 : Set} := {
      op1 : op1;
      op2 : op2 }.
    Arguments record : clear implicits.
  End Double_endorsement_evidence.
  Definition Double_endorsement_evidence_skeleton :=
    Double_endorsement_evidence.record.
  
  Module Double_baking_evidence.
    Record record {bh1 bh2 : Set} := {
      bh1 : bh1;
      bh2 : bh2 }.
    Arguments record : clear implicits.
  End Double_baking_evidence.
  Definition Double_baking_evidence_skeleton := Double_baking_evidence.record.
  
  Module Activate_account.
    Record record {id activation_code : Set} := {
      id : id;
      activation_code : activation_code }.
    Arguments record : clear implicits.
  End Activate_account.
  Definition Activate_account_skeleton := Activate_account.record.
  
  Module Proposals.
    Record record {source period proposals : Set} := {
      source : source;
      period : period;
      proposals : proposals }.
    Arguments record : clear implicits.
  End Proposals.
  Definition Proposals_skeleton := Proposals.record.
  
  Module Ballot.
    Record record {source period proposal ballot : Set} := {
      source : source;
      period : period;
      proposal : proposal;
      ballot : ballot }.
    Arguments record : clear implicits.
  End Ballot.
  Definition Ballot_skeleton := Ballot.record.
  
  Module Manager_operation.
    Record record {source fee counter operation gas_limit storage_limit : Set} := {
      source : source;
      fee : fee;
      counter : counter;
      operation : operation;
      gas_limit : gas_limit;
      storage_limit : storage_limit }.
    Arguments record : clear implicits.
  End Manager_operation.
  Definition Manager_operation_skeleton := Manager_operation.record.
End contents.

Module manager_operation.
  Module Transaction.
    Record record {amount parameters entrypoint destination : Set} := {
      amount : amount;
      parameters : parameters;
      entrypoint : entrypoint;
      destination : destination }.
    Arguments record : clear implicits.
  End Transaction.
  Definition Transaction_skeleton := Transaction.record.
  
  Module Origination.
    Record record {delegate script credit preorigination : Set} := {
      delegate : delegate;
      script : script;
      credit : credit;
      preorigination : preorigination }.
    Arguments record : clear implicits.
  End Origination.
  Definition Origination_skeleton := Origination.record.
End manager_operation.

Module operation.
  Record record {shell protocol_data : Set} := Build {
    shell : shell;
    protocol_data : protocol_data }.
  Arguments record : clear implicits.
  Definition with_shell {t_shell t_protocol_data} shell
    (r : record t_shell t_protocol_data) :=
    Build t_shell t_protocol_data shell r.(protocol_data).
  Definition with_protocol_data {t_shell t_protocol_data} protocol_data
    (r : record t_shell t_protocol_data) :=
    Build t_shell t_protocol_data r.(shell) protocol_data.
End operation.
Definition operation_skeleton := operation.record.

Module protocol_data.
  Record record {contents signature : Set} := Build {
    contents : contents;
    signature : signature }.
  Arguments record : clear implicits.
  Definition with_contents {t_contents t_signature} contents
    (r : record t_contents t_signature) :=
    Build t_contents t_signature contents r.(signature).
  Definition with_signature {t_contents t_signature} signature
    (r : record t_contents t_signature) :=
    Build t_contents t_signature r.(contents) signature.
End protocol_data.
Definition protocol_data_skeleton := protocol_data.record.

Reserved Notation "'contents.Endorsement".
Reserved Notation "'contents.Seed_nonce_revelation".
Reserved Notation "'contents.Double_endorsement_evidence".
Reserved Notation "'contents.Double_baking_evidence".
Reserved Notation "'contents.Activate_account".
Reserved Notation "'contents.Proposals".
Reserved Notation "'contents.Ballot".
Reserved Notation "'contents.Manager_operation".
Reserved Notation "'manager_operation.Transaction".
Reserved Notation "'manager_operation.Origination".
Reserved Notation "'contents_list".
Reserved Notation "'protocol_data".
Reserved Notation "'operation".
Reserved Notation "'contents".
Reserved Notation "'manager_operation".
Reserved Notation "'counter".

Inductive contents_list_gadt : Set :=
| Single : forall {kind : Set}, 'contents kind -> contents_list_gadt
| Cons : forall {kind : Set},
  'contents (Kind.manager kind) -> contents_list_gadt -> contents_list_gadt

with contents_gadt : Set :=
| Endorsement : 'contents.Endorsement -> contents_gadt
| Seed_nonce_revelation : 'contents.Seed_nonce_revelation -> contents_gadt
| Double_endorsement_evidence :
  'contents.Double_endorsement_evidence -> contents_gadt
| Double_baking_evidence : 'contents.Double_baking_evidence -> contents_gadt
| Activate_account : 'contents.Activate_account -> contents_gadt
| Proposals : 'contents.Proposals -> contents_gadt
| Ballot : 'contents.Ballot -> contents_gadt
| Manager_operation : forall {kind : Set},
  'contents.Manager_operation kind -> contents_gadt

with manager_operation_gadt : Set :=
| Reveal : (|Signature.Public_key|).(S.SPublic_key.t) -> manager_operation_gadt
| Transaction : 'manager_operation.Transaction -> manager_operation_gadt
| Origination : 'manager_operation.Origination -> manager_operation_gadt
| Delegation :
  option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
  manager_operation_gadt

where "'contents_list" := (fun (_ : Set) => contents_list_gadt)
and "'protocol_data" := (fun (t_kind : Set) =>
  protocol_data_skeleton ('contents_list t_kind) (option Signature.t))
and "'operation" := (fun (t_kind : Set) =>
  operation_skeleton Operation.shell_header ('protocol_data t_kind))
and "'contents" := (fun (_ : Set) => contents_gadt)
and "'manager_operation" := (fun (_ : Set) => manager_operation_gadt)
and "'counter" := (Z.t)
and "'contents.Endorsement" := (contents.Endorsement_skeleton Raw_level.t)
and "'contents.Seed_nonce_revelation" :=
  (contents.Seed_nonce_revelation_skeleton Raw_level.t Nonce.t)
and "'contents.Double_endorsement_evidence" :=
  (contents.Double_endorsement_evidence_skeleton ('operation Kind.endorsement)
    ('operation Kind.endorsement))
and "'contents.Double_baking_evidence" :=
  (contents.Double_baking_evidence_skeleton Block_header.t Block_header.t)
and "'contents.Activate_account" :=
  (contents.Activate_account_skeleton
    (|Ed25519|).(S.SIGNATURE.Public_key_hash).(S.SPublic_key_hash.t)
    Blinded_public_key_hash.activation_code)
and "'contents.Proposals" :=
  (contents.Proposals_skeleton
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) Voting_period.t
    (list (|Protocol_hash|).(S.HASH.t)))
and "'contents.Ballot" :=
  (contents.Ballot_skeleton (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)
    Voting_period.t (|Protocol_hash|).(S.HASH.t) Vote.ballot)
and "'contents.Manager_operation" := (fun (t_kind : Set) =>
  contents.Manager_operation_skeleton
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) Tez.tez 'counter
    ('manager_operation t_kind) Z.t Z.t)
and "'manager_operation.Transaction" :=
  (manager_operation.Transaction_skeleton Tez.tez Script.lazy_expr string
    Contract.contract)
and "'manager_operation.Origination" :=
  (manager_operation.Origination_skeleton
    (option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) Script.t
    Tez.tez (option Contract.t)).

Module
  ConstructorRecordNotations_contents_list_gadt_contents_gadt_manager_operation_gadt.
  Module contents.
    Definition Endorsement := 'contents.Endorsement.
    Definition Seed_nonce_revelation := 'contents.Seed_nonce_revelation.
    Definition Double_endorsement_evidence :=
      'contents.Double_endorsement_evidence.
    Definition Double_baking_evidence := 'contents.Double_baking_evidence.
    Definition Activate_account := 'contents.Activate_account.
    Definition Proposals := 'contents.Proposals.
    Definition Ballot := 'contents.Ballot.
    Definition Manager_operation := 'contents.Manager_operation.
  End contents.
  Module manager_operation.
    Definition Transaction := 'manager_operation.Transaction.
    Definition Origination := 'manager_operation.Origination.
  End manager_operation.
End
  ConstructorRecordNotations_contents_list_gadt_contents_gadt_manager_operation_gadt.
Import
  ConstructorRecordNotations_contents_list_gadt_contents_gadt_manager_operation_gadt.

Definition contents_list := 'contents_list.
Definition protocol_data := 'protocol_data.
Definition operation := 'operation.
Definition contents := 'contents.
Definition manager_operation := 'manager_operation.
Definition counter := 'counter.

Module internal_operation.
  Record record {kind : Set} := Build {
    source : Contract.contract;
    operation : manager_operation kind;
    nonce : Z }.
  Arguments record : clear implicits.
  Definition with_source {t_kind} source (r : record t_kind) :=
    Build t_kind source r.(operation) r.(nonce).
  Definition with_operation {t_kind} operation (r : record t_kind) :=
    Build t_kind r.(source) operation r.(nonce).
  Definition with_nonce {t_kind} nonce (r : record t_kind) :=
    Build t_kind r.(source) r.(operation) nonce.
End internal_operation.
Definition internal_operation := internal_operation.record.

Inductive packed_manager_operation : Set :=
| Manager : forall {kind : Set},
  manager_operation kind -> packed_manager_operation.

Inductive packed_contents : Set :=
| Contents : forall {kind : Set}, contents kind -> packed_contents.

Inductive packed_contents_list : Set :=
| Contents_list : forall {kind : Set},
  contents_list kind -> packed_contents_list.

Inductive packed_protocol_data : Set :=
| Operation_data : forall {kind : Set},
  protocol_data kind -> packed_protocol_data.

Module packed_operation.
  Record record := Build {
    shell : Operation.shell_header;
    protocol_data : packed_protocol_data }.
  Definition with_shell shell (r : record) :=
    Build shell r.(protocol_data).
  Definition with_protocol_data protocol_data (r : record) :=
    Build r.(shell) protocol_data.
End packed_operation.
Definition packed_operation := packed_operation.record.

Inductive packed_internal_operation : Set :=
| Internal_operation : forall {kind : Set},
  internal_operation kind -> packed_internal_operation.

Parameter manager_kind : forall {kind : Set},
  manager_operation kind -> Kind.manager kind.

Module Fees.
  Parameter origination_burn :
    context -> Lwt.t (Error_monad.tzresult (context * Tez.t)).
  
  Parameter record_paid_storage_space :
    context -> Contract.t ->
    Lwt.t (Error_monad.tzresult (context * Z.t * Z.t * Tez.t)).
  
  Parameter start_counting_storage_fees : context -> context.
  
  Parameter burn_storage_fees :
    context -> Z.t -> Contract.t -> Lwt.t (Error_monad.tzresult context).
  
  (* extensible_type error *)
  
  (* extensible_type error *)
  
  (* extensible_type error *)
  
  Parameter check_storage_limit : context -> Z.t -> Error_monad.tzresult unit.
End Fees.

Module Operation.
  Definition contents (kind : Set) := contents kind.
  
  Definition packed_contents := packed_contents.
  
  Parameter contents_encoding : Data_encoding.t packed_contents.
  
  Definition protocol_data (kind : Set) := protocol_data kind.
  
  Definition packed_protocol_data := packed_protocol_data.
  
  Parameter protocol_data_encoding : Data_encoding.t packed_protocol_data.
  
  Parameter unsigned_encoding :
    Data_encoding.t (Operation.shell_header * packed_contents_list).
  
  Module raw.
    Record record := Build {
      shell : Operation.shell_header;
      proto : MBytes.t }.
    Definition with_shell shell (r : record) :=
      Build shell r.(proto).
    Definition with_proto proto (r : record) :=
      Build r.(shell) proto.
  End raw.
  Definition raw := raw.record.
  
  Parameter raw_encoding : Data_encoding.t raw.
  
  Parameter contents_list_encoding : Data_encoding.t packed_contents_list.
  
  Module t.
    Record record {kind : Set} := Build {
      shell : Operation.shell_header;
      protocol_data : protocol_data kind }.
    Arguments record : clear implicits.
    Definition with_shell {t_kind} shell (r : record t_kind) :=
      Build t_kind shell r.(protocol_data).
    Definition with_protocol_data {t_kind} protocol_data (r : record t_kind) :=
      Build t_kind r.(shell) protocol_data.
  End t.
  Definition t := t.record.
  
  Definition packed := packed_operation.
  
  Parameter encoding : Data_encoding.t packed.
  
  Parameter __raw_value : forall {A : Set}, operation A -> raw.
  
  Parameter __hash_value : forall {A : Set},
    operation A -> (|Operation_hash|).(S.HASH.t).
  
  Parameter hash_raw : raw -> (|Operation_hash|).(S.HASH.t).
  
  Parameter hash_packed : packed_operation -> (|Operation_hash|).(S.HASH.t).
  
  Parameter acceptable_passes : packed_operation -> list Z.
  
  (* extensible_type error *)
  
  (* extensible_type error *)
  
  Parameter check_signature : forall {A : Set},
    public_key -> (|Chain_id|).(S.HASH.t) -> operation A ->
    Lwt.t (Error_monad.tzresult unit).
  
  Parameter check_signature_sync : forall {A : Set},
    public_key -> (|Chain_id|).(S.HASH.t) -> operation A ->
    Error_monad.tzresult unit.
  
  Parameter internal_operation_encoding :
    Data_encoding.t packed_internal_operation.
  
  Parameter pack : forall {kind : Set}, operation kind -> packed_operation.
  
  Reserved Notation "'eq".
  
  Inductive eq_gadt : Set :=
  | Eq : eq_gadt
  
  where "'eq" := (fun (_ _ : Set) => eq_gadt).
  
  Definition eq := 'eq.
  
  Parameter equal : forall {a b : Set},
    operation a -> operation b -> option (eq a b).
  
  Module Encoding.
    Module case.
      Module Case.
        Record record {tag name encoding select proj inj : Set} := {
          tag : tag;
          name : name;
          encoding : encoding;
          select : select;
          proj : proj;
          inj : inj }.
        Arguments record : clear implicits.
      End Case.
      Definition Case_skeleton := Case.record.
    End case.
    
    Reserved Notation "'case.Case".
    
    Inductive case (b : Set) : Set :=
    | Case : forall {a : Set}, 'case.Case a b -> case b
    
    where "'case.Case" := (fun (t_a t_b : Set) =>
      case.Case_skeleton Z string (Data_encoding.t t_a)
        (packed_contents -> option (contents t_b)) (contents t_b -> t_a)
        (t_a -> contents t_b)).
    
    Module ConstructorRecordNotations_case.
      Module case.
        Definition Case := 'case.Case.
      End case.
    End ConstructorRecordNotations_case.
    Import ConstructorRecordNotations_case.
    
    Arguments Case {_ _}.
    
    Parameter endorsement_case : case Kind.endorsement.
    
    Parameter seed_nonce_revelation_case : case Kind.seed_nonce_revelation.
    
    Parameter double_endorsement_evidence_case :
      case Kind.double_endorsement_evidence.
    
    Parameter double_baking_evidence_case : case Kind.double_baking_evidence.
    
    Parameter activate_account_case : case Kind.activate_account.
    
    Parameter proposals_case : case Kind.proposals.
    
    Parameter ballot_case : case Kind.ballot.
    
    Parameter reveal_case : case (Kind.manager Kind.reveal).
    
    Parameter transaction_case : case (Kind.manager Kind.transaction).
    
    Parameter origination_case : case (Kind.manager Kind.origination).
    
    Parameter delegation_case : case (Kind.manager Kind.delegation).
    
    Module Manager_operations.
      Module case.
        Module MCase.
          Record record {tag name encoding select proj inj : Set} := {
            tag : tag;
            name : name;
            encoding : encoding;
            select : select;
            proj : proj;
            inj : inj }.
          Arguments record : clear implicits.
        End MCase.
        Definition MCase_skeleton := MCase.record.
      End case.
      
      Reserved Notation "'case.MCase".
      Reserved Notation "'case".
      
      Inductive case_gadt : Set :=
      | MCase : forall {a kind : Set}, 'case.MCase a kind -> case_gadt
      
      where "'case" := (fun (_ : Set) => case_gadt)
      and "'case.MCase" := (fun (t_a t_kind : Set) =>
        case.MCase_skeleton Z string (Data_encoding.t t_a)
          (packed_manager_operation -> option (manager_operation t_kind))
          (manager_operation t_kind -> t_a) (t_a -> manager_operation t_kind)).
      
      Module ConstructorRecordNotations_case_gadt.
        Module case.
          Definition MCase := 'case.MCase.
        End case.
      End ConstructorRecordNotations_case_gadt.
      Import ConstructorRecordNotations_case_gadt.
      
      Definition case := 'case.
      
      Parameter reveal_case : case Kind.reveal.
      
      Parameter transaction_case : case Kind.transaction.
      
      Parameter origination_case : case Kind.origination.
      
      Parameter delegation_case : case Kind.delegation.
    End Manager_operations.
  End Encoding.
  
  Parameter of_list : list packed_contents -> packed_contents_list.
  
  Parameter to_list : packed_contents_list -> list packed_contents.
End Operation.

Module Roll.
  Definition t := int32.
  
  Definition roll := t.
  
  Parameter encoding : Data_encoding.t roll.
  
  Parameter snapshot_rolls : context -> Lwt.t (Error_monad.tzresult context).
  
  Parameter cycle_end :
    context -> Cycle.t -> Lwt.t (Error_monad.tzresult context).
  
  Parameter baking_rights_owner :
    context -> Level.t -> Z -> Lwt.t (Error_monad.tzresult public_key).
  
  Parameter endorsement_rights_owner :
    context -> Level.t -> Z -> Lwt.t (Error_monad.tzresult public_key).
  
  Parameter delegate_pubkey :
    context -> public_key_hash -> Lwt.t (Error_monad.tzresult public_key).
  
  Parameter get_rolls :
    context -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
    Lwt.t (Error_monad.tzresult (list roll)).
  
  Parameter get_change :
    context -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
    Lwt.t (Error_monad.tzresult Tez.t).
End Roll.

Module Commitment.
  Module t.
    Record record := Build {
      blinded_public_key_hash : Blinded_public_key_hash.t;
      amount : Tez.tez }.
    Definition with_blinded_public_key_hash blinded_public_key_hash
      (r : record) :=
      Build blinded_public_key_hash r.(amount).
    Definition with_amount amount (r : record) :=
      Build r.(blinded_public_key_hash) amount.
  End t.
  Definition t := t.record.
  
  Parameter get_opt :
    context -> Blinded_public_key_hash.t ->
    Lwt.t (Error_monad.tzresult (option Tez.t)).
  
  Parameter delete :
    context -> Blinded_public_key_hash.t -> Lwt.t (Error_monad.tzresult context).
End Commitment.

Module Bootstrap.
  Parameter cycle_end :
    context -> Cycle.t -> Lwt.t (Error_monad.tzresult context).
End Bootstrap.

Module Global.
  Parameter get_block_priority : context -> Lwt.t (Error_monad.tzresult Z).
  
  Parameter set_block_priority :
    context -> Z -> Lwt.t (Error_monad.tzresult context).
End Global.

Parameter prepare_first_block :
  Context.t ->
  (context -> Script.t ->
  Lwt.t
    (Error_monad.tzresult ((Script.t * option Contract.big_map_diff) * context)))
  -> Int32.t -> Time.t -> Fitness.t -> Lwt.t (Error_monad.tzresult context).

Parameter prepare :
  Context.t -> Int32.t -> Time.t -> Time.t -> Fitness.t ->
  Lwt.t (Error_monad.tzresult context).

Parameter finalize : option string -> context -> Updater.validation_result.

Parameter activate : context -> (|Protocol_hash|).(S.HASH.t) -> Lwt.t context.

Parameter fork_test_chain :
  context -> (|Protocol_hash|).(S.HASH.t) -> Time.t -> Lwt.t context.

Parameter record_endorsement :
  context -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -> context.

Parameter allowed_endorsements :
  context ->
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
    ((|Signature.Public_key|).(S.SPublic_key.t) * list Z * bool).

Parameter init_endorsements :
  context ->
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
    ((|Signature.Public_key|).(S.SPublic_key.t) * list Z * bool) -> context.

Parameter included_endorsements : context -> Z.

Parameter reset_internal_nonce : context -> context.

Parameter fresh_internal_nonce : context -> Error_monad.tzresult (context * Z).

Parameter record_internal_nonce : context -> Z -> context.

Parameter internal_nonce_already_recorded : context -> Z -> bool.

Parameter add_fees : context -> Tez.t -> Lwt.t (Error_monad.tzresult context).

Parameter add_rewards :
  context -> Tez.t -> Lwt.t (Error_monad.tzresult context).

Parameter add_deposit :
  context -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -> Tez.t ->
  Lwt.t (Error_monad.tzresult context).

Parameter get_fees : context -> Tez.t.

Parameter get_rewards : context -> Tez.t.

Parameter get_deposits :
  context ->
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t) Tez.t.

Parameter description : Storage_description.t context.
