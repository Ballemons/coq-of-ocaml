(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Unset Positivity Checking.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Gas_limit_repr.
Require Tezos.Misc.
Require Tezos.Raw_context.
Require Tezos.Storage_description.
Require Tezos.Storage_sigs.

Import Storage_sigs.

Definition Registered :=
  let ghost := false in
  existT (A := unit) (fun _ => _) tt
    {|
      Storage_sigs.REGISTER.ghost := ghost
    |}.

Definition Ghost :=
  let ghost := true in
  existT (A := unit) (fun _ => _) tt
    {|
      Storage_sigs.REGISTER.ghost := ghost
    |}.

Module ENCODER.
  Record signature {t : Set} : Set := {
    t := t;
    of_bytes : list string -> MBytes.t -> Error_monad.tzresult t;
    to_bytes : t -> MBytes.t;
  }.
  Arguments signature : clear implicits.
End ENCODER.

Definition Make_encoder :=
  fun (V : {t : Set & VALUE.signature t}) =>
    ((let of_bytes (__key_value : list string) (__b_value : MBytes.t)
      : Error_monad.tzresult (|V|).(Storage_sigs.VALUE.t) :=
      match
        Data_encoding.Binary.of_bytes (|V|).(Storage_sigs.VALUE.encoding)
          __b_value with
      | None => Error_monad.__error_value extensible_type_value
      | Some v => Pervasives.Ok v
      end in
    let to_bytes (v : (|V|).(Storage_sigs.VALUE.t)) : MBytes.t :=
      match Data_encoding.Binary.to_bytes (|V|).(Storage_sigs.VALUE.encoding) v
        with
      | Some __b_value => __b_value
      | None => MBytes.create 0
      end in
    existT (A := unit) (fun _ => _) tt
      {|
        ENCODER.of_bytes := of_bytes;
        ENCODER.to_bytes := to_bytes
      |}) : {_ : unit & ENCODER.signature (|V|).(Storage_sigs.VALUE.t)}).

Definition len_name : string := "len".

Definition data_name : string := "data".

Definition encode_len_value (__bytes_value : MBytes.t) : MBytes.t :=
  let length := MBytes.length __bytes_value in
  (Data_encoding.Binary.to_bytes_exn Data_encoding.int31) length.

Definition decode_len_value (__key_value : list string) (len : MBytes.t)
  : Lwt.t (Error_monad.tzresult int) :=
  match (Data_encoding.Binary.of_bytes Data_encoding.int31) len with
  | None => Error_monad.fail extensible_type_value
  | Some len => Error_monad.__return len
  end.

Definition map_key
  (f : Context.key -> Context.key) (function_parameter : Context.dir_or_key)
  : Context.dir_or_key :=
  match function_parameter with
  | Context.Key k => Context.Key (f k)
  | Context.Dir k => Context.Dir (f k)
  end.

Definition Make_subcontext :=
  fun (R : {_ : unit & REGISTER.signature}) =>
    fun (C : {t : Set & Raw_context.T.signature t}) =>
      fun (N : {_ : unit & NAME.signature}) =>
        ((let t := (|C|).(Raw_context.T.t) in
        let context := t in
        let name_length := List.length (|N|).(Storage_sigs.NAME.name) in
        let to_key (k : list string) : list string :=
          Pervasives.op_at (|N|).(Storage_sigs.NAME.name) k in
        let of_key {A : Set} (k : list A) : list A :=
          Misc.remove_elem_from_list name_length k in
        let mem (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          : Lwt.t bool :=
          (|C|).(Raw_context.T.mem) __t_value (to_key k) in
        let dir_mem
          (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          : Lwt.t bool :=
          (|C|).(Raw_context.T.dir_mem) __t_value (to_key k) in
        let get (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          : Lwt.t (Error_monad.tzresult Raw_context.value) :=
          (|C|).(Raw_context.T.get) __t_value (to_key k) in
        let get_option
          (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          : Lwt.t (option Raw_context.value) :=
          (|C|).(Raw_context.T.get_option) __t_value (to_key k) in
        let init
          (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          (v : Raw_context.value)
          : Lwt.t (Error_monad.tzresult (|C|).(Raw_context.T.context)) :=
          (|C|).(Raw_context.T.init) __t_value (to_key k) v in
        let set
          (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          (v : Raw_context.value)
          : Lwt.t (Error_monad.tzresult (|C|).(Raw_context.T.context)) :=
          (|C|).(Raw_context.T.set) __t_value (to_key k) v in
        let init_set
          (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          (v : Raw_context.value) : Lwt.t (|C|).(Raw_context.T.context) :=
          (|C|).(Raw_context.T.init_set) __t_value (to_key k) v in
        let set_option
          (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          (v : option Raw_context.value)
          : Lwt.t (|C|).(Raw_context.T.context) :=
          (|C|).(Raw_context.T.set_option) __t_value (to_key k) v in
        let delete (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          : Lwt.t (Error_monad.tzresult (|C|).(Raw_context.T.context)) :=
          (|C|).(Raw_context.T.delete) __t_value (to_key k) in
        let remove (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          : Lwt.t (|C|).(Raw_context.T.context) :=
          (|C|).(Raw_context.T.remove) __t_value (to_key k) in
        let remove_rec
          (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          : Lwt.t (|C|).(Raw_context.T.context) :=
          (|C|).(Raw_context.T.remove_rec) __t_value (to_key k) in
        let copy
          (__t_value : (|C|).(Raw_context.T.context)) (from : list string)
          (to_ : list string)
          : Lwt.t (Error_monad.tzresult (|C|).(Raw_context.T.context)) :=
          (|C|).(Raw_context.T.copy) __t_value (to_key from) (to_key to_) in
        let fold {A : Set}
          (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          (init : A) (f : Context.dir_or_key -> A -> Lwt.t A) : Lwt.t A :=
          (|C|).(Raw_context.T.fold) __t_value (to_key k) init
            (fun k => fun acc => f (map_key of_key k) acc) in
        let keys (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          : Lwt.t (list (list string)) :=
          Error_monad.op_gtpipeeq
            ((|C|).(Raw_context.T.keys) __t_value (to_key k))
            (fun keys => List.map of_key keys) in
        let fold_keys {A : Set}
          (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          (init : A) (f : list string -> A -> Lwt.t A) : Lwt.t A :=
          (|C|).(Raw_context.T.fold_keys) __t_value (to_key k) init
            (fun k => fun acc => f (of_key k) acc) in
        let project := (|C|).(Raw_context.T.project) in
        let absolute_key (c : (|C|).(Raw_context.T.context)) (k : list string)
          : Raw_context.key :=
          (|C|).(Raw_context.T.absolute_key) c (to_key k) in
        let consume_gas := (|C|).(Raw_context.T.consume_gas) in
        let check_enough_gas := (|C|).(Raw_context.T.check_enough_gas) in
        let description :=
          let description :=
            if (|R|).(Storage_sigs.REGISTER.ghost) then
              Storage_description.create tt
            else
              (|C|).(Raw_context.T.description) in
          Storage_description.register_named_subcontext description
            (|N|).(Storage_sigs.NAME.name) in
        existT (A := unit) (fun _ => _) tt
          {|
            Raw_context.T.mem := mem;
            Raw_context.T.dir_mem := dir_mem;
            Raw_context.T.get := get;
            Raw_context.T.get_option := get_option;
            Raw_context.T.init := init;
            Raw_context.T.set := set;
            Raw_context.T.init_set := init_set;
            Raw_context.T.set_option := set_option;
            Raw_context.T.delete := delete;
            Raw_context.T.remove := remove;
            Raw_context.T.remove_rec := remove_rec;
            Raw_context.T.copy := copy;
            Raw_context.T.fold {_} := fold;
            Raw_context.T.keys := keys;
            Raw_context.T.fold_keys {_} := fold_keys;
            Raw_context.T.project := project;
            Raw_context.T.absolute_key := absolute_key;
            Raw_context.T.consume_gas := consume_gas;
            Raw_context.T.check_enough_gas := check_enough_gas;
            Raw_context.T.description := description
          |}) : {_ : unit & Raw_context.T.signature (|C|).(Raw_context.T.t)}).

Definition Make_single_data_storage :=
  fun (R : {_ : unit & REGISTER.signature}) =>
    fun (C : {t : Set & Raw_context.T.signature t}) =>
      fun (N : {_ : unit & NAME.signature}) =>
        fun (V : {t : Set & VALUE.signature t}) =>
          ((let tag_Single_data_storage := tt in
          let t := (|C|).(Raw_context.T.t) in
          let context := t in
          let value := (|V|).(Storage_sigs.VALUE.t) in
          let mem (__t_value : (|C|).(Raw_context.T.context)) : Lwt.t bool :=
            (|C|).(Raw_context.T.mem) __t_value (|N|).(Storage_sigs.NAME.name)
            in
          let Encoder := Make_encoder (existT (A := Set) _ _ (|V|)) in
          let of_bytes := (|Encoder|).(ENCODER.of_bytes) in
          let to_bytes := (|Encoder|).(ENCODER.to_bytes) in
          let get (__t_value : (|C|).(Raw_context.T.context))
            : Lwt.t (Error_monad.tzresult (|V|).(Storage_sigs.VALUE.t)) :=
            let=? __b_value :=
              (|C|).(Raw_context.T.get) __t_value (|N|).(Storage_sigs.NAME.name)
              in
            let __key_value :=
              (|C|).(Raw_context.T.absolute_key) __t_value
                (|N|).(Storage_sigs.NAME.name) in
            Lwt.__return (of_bytes __key_value __b_value) in
          let get_option (__t_value : (|C|).(Raw_context.T.context))
            : Lwt.t (Error_monad.tzresult (option (|V|).(Storage_sigs.VALUE.t))) :=
            let= function_parameter :=
              (|C|).(Raw_context.T.get_option) __t_value
                (|N|).(Storage_sigs.NAME.name) in
            match function_parameter with
            | None => Error_monad.return_none
            | Some __b_value =>
              let __key_value :=
                (|C|).(Raw_context.T.absolute_key) __t_value
                  (|N|).(Storage_sigs.NAME.name) in
              match of_bytes __key_value __b_value with
              | Pervasives.Ok v => Error_monad.return_some v
              | Pervasives.Error __error_value =>
                Lwt.__return (Pervasives.Error __error_value)
              end
            end in
          let init
            (__t_value : (|C|).(Raw_context.T.context))
            (v : (|V|).(Storage_sigs.VALUE.t))
            : Lwt.t (Error_monad.tzresult Raw_context.root_context) :=
            let=? __t_value :=
              (|C|).(Raw_context.T.init) __t_value
                (|N|).(Storage_sigs.NAME.name) (to_bytes v) in
            Error_monad.__return ((|C|).(Raw_context.T.project) __t_value) in
          let set
            (__t_value : (|C|).(Raw_context.T.context))
            (v : (|V|).(Storage_sigs.VALUE.t))
            : Lwt.t (Error_monad.tzresult Raw_context.root_context) :=
            let=? __t_value :=
              (|C|).(Raw_context.T.set) __t_value (|N|).(Storage_sigs.NAME.name)
                (to_bytes v) in
            Error_monad.__return ((|C|).(Raw_context.T.project) __t_value) in
          let init_set
            (__t_value : (|C|).(Raw_context.T.context))
            (v : (|V|).(Storage_sigs.VALUE.t))
            : Lwt.t Raw_context.root_context :=
            let= __t_value :=
              (|C|).(Raw_context.T.init_set) __t_value
                (|N|).(Storage_sigs.NAME.name) (to_bytes v) in
            Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
          let set_option
            (__t_value : (|C|).(Raw_context.T.context))
            (v : option (|V|).(Storage_sigs.VALUE.t))
            : Lwt.t Raw_context.root_context :=
            let= __t_value :=
              (|C|).(Raw_context.T.set_option) __t_value
                (|N|).(Storage_sigs.NAME.name) (Option.map to_bytes v) in
            Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
          let remove (__t_value : (|C|).(Raw_context.T.context))
            : Lwt.t Raw_context.root_context :=
            let= __t_value :=
              (|C|).(Raw_context.T.remove) __t_value
                (|N|).(Storage_sigs.NAME.name) in
            Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
          let delete (__t_value : (|C|).(Raw_context.T.context))
            : Lwt.t (Error_monad.tzresult Raw_context.root_context) :=
            let=? __t_value :=
              (|C|).(Raw_context.T.delete) __t_value
                (|N|).(Storage_sigs.NAME.name) in
            Error_monad.__return ((|C|).(Raw_context.T.project) __t_value) in
          (* ❌ top_level_evaluation *)
          existT (A := unit) (fun _ => _) tt
            {|
              Storage_sigs.Single_data_storage.tag_Single_data_storage :=
                tag_Single_data_storage;
              Storage_sigs.Single_data_storage.mem := mem;
              Storage_sigs.Single_data_storage.get := get;
              Storage_sigs.Single_data_storage.get_option := get_option;
              Storage_sigs.Single_data_storage.init := init;
              Storage_sigs.Single_data_storage.set := set;
              Storage_sigs.Single_data_storage.init_set := init_set;
              Storage_sigs.Single_data_storage.set_option := set_option;
              Storage_sigs.Single_data_storage.delete := delete;
              Storage_sigs.Single_data_storage.remove := remove
            |})
            :
              {_ : unit &
                Single_data_storage.signature (|C|).(Raw_context.T.t)
                  (|V|).(Storage_sigs.VALUE.t)}).

Module INDEX.
  Record signature {t : Set} {ipath : Set -> Set} : Set := {
    t := t;
    path_length : int;
    to_path : t -> list string -> list string;
    of_path : list string -> option t;
    ipath := ipath;
    args : unit -> Storage_description.args;
  }.
  Arguments signature : clear implicits.
End INDEX.

Definition Pair :=
  fun (I1 : {'[t, ipath] : [Set ** Set -> Set] & INDEX.signature t ipath}) =>
    fun (I2 : {'[t, ipath] : [Set ** Set -> Set] & INDEX.signature t ipath}) =>
      ((let t := (|I1|).(INDEX.t) * (|I2|).(INDEX.t) in
      let path_length :=
        Pervasives.op_plus (|I1|).(INDEX.path_length) (|I2|).(INDEX.path_length)
        in
      let to_path (function_parameter : (|I1|).(INDEX.t) * (|I2|).(INDEX.t))
        : list string -> list string :=
        let '(x, y) := function_parameter in
        fun l => (|I1|).(INDEX.to_path) x ((|I2|).(INDEX.to_path) y l) in
      let of_path (l : list string)
        : option ((|I1|).(INDEX.t) * (|I2|).(INDEX.t)) :=
        match Misc.take (|I1|).(INDEX.path_length) l with
        | None => None
        | Some (l1, l2) =>
          match (((|I1|).(INDEX.of_path) l1), ((|I2|).(INDEX.of_path) l2)) with
          | (Some x, Some y) => Some (x, y)
          | _ => None
          end
        end in
      let ipath (a : Set) := (|I2|).(INDEX.ipath) ((|I1|).(INDEX.ipath) a) in
      let args (function_parameter : unit) : Storage_description.args :=
        let '_ := function_parameter in
        Storage_description.Pair ((|I1|).(INDEX.args) tt)
          ((|I2|).(INDEX.args) tt) in
      existT (A := Set -> Set) _ _
        {|
          INDEX.path_length := path_length;
          INDEX.to_path := to_path;
          INDEX.of_path := of_path;
          INDEX.args := args
        |})
        :
          {ipath : Set -> Set &
            INDEX.signature ((|I1|).(INDEX.t) * (|I2|).(INDEX.t)) ipath}).

Definition Make_data_set_storage :=
  fun (C : {t : Set & Raw_context.T.signature t}) =>
    fun (I : {'[t, ipath] : [Set ** Set -> Set] & INDEX.signature t ipath}) =>
      ((let t := (|C|).(Raw_context.T.t) in
      let context := t in
      let elt := (|I|).(INDEX.t) in
      let inited := MBytes.of_string "inited" in
      let mem (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
        : Lwt.t bool :=
        (|C|).(Raw_context.T.mem) s ((|I|).(INDEX.to_path) i nil) in
      let add (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
        : Lwt.t Raw_context.root_context :=
        let= __t_value :=
          (|C|).(Raw_context.T.init_set) s ((|I|).(INDEX.to_path) i nil) inited
          in
        Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
      let del (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
        : Lwt.t Raw_context.root_context :=
        let= __t_value :=
          (|C|).(Raw_context.T.remove) s ((|I|).(INDEX.to_path) i nil) in
        Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
      let set
        (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
        (function_parameter : bool) : Lwt.t Raw_context.root_context :=
        match function_parameter with
        | true => add s i
        | false => del s i
        end in
      let clear (s : (|C|).(Raw_context.T.context))
        : Lwt.t Raw_context.root_context :=
        let= __t_value := (|C|).(Raw_context.T.remove_rec) s nil in
        Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
      let fold {A : Set}
        (s : (|C|).(Raw_context.T.context)) (init : A)
        (f : (|I|).(INDEX.t) -> A -> Lwt.t A) : Lwt.t A :=
        let fix dig
          (i : (|Compare.Int|).(Compare.S.t)) (path : Raw_context.key) (acc : A)
          {struct i} : Lwt.t A :=
          if (|Compare.Int|).(Compare.S.op_lteq) i 1 then
            (|C|).(Raw_context.T.fold) s path acc
              (fun k =>
                fun acc =>
                  match k with
                  | Context.Dir _ => Lwt.__return acc
                  | Context.Key file =>
                    match (|I|).(INDEX.of_path) file with
                    | None =>
                      (* ❌ Assert instruction is not handled. *)
                      assert (Lwt.t _) false
                    | Some __p_value => f __p_value acc
                    end
                  end)
          else
            (|C|).(Raw_context.T.fold) s path acc
              (fun k =>
                fun acc =>
                  match k with
                  | Context.Dir k => dig (Pervasives.op_minus i 1) k acc
                  | Context.Key _ => Lwt.__return acc
                  end) in
        dig (|I|).(INDEX.path_length) nil init in
      let elements (s : (|C|).(Raw_context.T.context))
        : Lwt.t (list (|I|).(INDEX.t)) :=
        fold s (nil (A := elt))
          (fun __p_value => fun acc => Lwt.__return (cons __p_value acc)) in
      (* ❌ top_level_evaluation *)
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.Data_set_storage.mem := mem;
          Storage_sigs.Data_set_storage.add := add;
          Storage_sigs.Data_set_storage.del := del;
          Storage_sigs.Data_set_storage.set := set;
          Storage_sigs.Data_set_storage.elements := elements;
          Storage_sigs.Data_set_storage.fold {_} := fold;
          Storage_sigs.Data_set_storage.clear := clear
        |})
        :
          {_ : unit &
            Data_set_storage.signature (|C|).(Raw_context.T.t) (|I|).(INDEX.t)}).

Definition Make_indexed_data_storage :=
  fun (C : {t : Set & Raw_context.T.signature t}) =>
    fun (I : {'[t, ipath] : [Set ** Set -> Set] & INDEX.signature t ipath}) =>
      fun (V : {t : Set & VALUE.signature t}) =>
        ((let tag_Non_iterable_indexed_data_storage := tt in
        let t := (|C|).(Raw_context.T.t) in
        let context := t in
        let key := (|I|).(INDEX.t) in
        let value := (|V|).(Storage_sigs.VALUE.t) in
        let Encoder := Make_encoder (existT (A := Set) _ _ (|V|)) in
        let of_bytes := (|Encoder|).(ENCODER.of_bytes) in
        let to_bytes := (|Encoder|).(ENCODER.to_bytes) in
        let mem (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t bool :=
          (|C|).(Raw_context.T.mem) s ((|I|).(INDEX.to_path) i nil) in
        let get (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t (Error_monad.tzresult (|V|).(Storage_sigs.VALUE.t)) :=
          let=? __b_value :=
            (|C|).(Raw_context.T.get) s ((|I|).(INDEX.to_path) i nil) in
          let __key_value :=
            (|C|).(Raw_context.T.absolute_key) s ((|I|).(INDEX.to_path) i nil)
            in
          Lwt.__return (of_bytes __key_value __b_value) in
        let get_option (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t (Error_monad.tzresult (option (|V|).(Storage_sigs.VALUE.t))) :=
          let= function_parameter :=
            (|C|).(Raw_context.T.get_option) s ((|I|).(INDEX.to_path) i nil) in
          match function_parameter with
          | None => Error_monad.return_none
          | Some __b_value =>
            let __key_value :=
              (|C|).(Raw_context.T.absolute_key) s ((|I|).(INDEX.to_path) i nil)
              in
            match of_bytes __key_value __b_value with
            | Pervasives.Ok v => Error_monad.return_some v
            | Pervasives.Error __error_value =>
              Lwt.__return (Pervasives.Error __error_value)
            end
          end in
        let set
          (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          (v : (|V|).(Storage_sigs.VALUE.t))
          : Lwt.t (Error_monad.tzresult Raw_context.root_context) :=
          let=? __t_value :=
            (|C|).(Raw_context.T.set) s ((|I|).(INDEX.to_path) i nil)
              (to_bytes v) in
          Error_monad.__return ((|C|).(Raw_context.T.project) __t_value) in
        let init
          (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          (v : (|V|).(Storage_sigs.VALUE.t))
          : Lwt.t (Error_monad.tzresult Raw_context.root_context) :=
          let=? __t_value :=
            (|C|).(Raw_context.T.init) s ((|I|).(INDEX.to_path) i nil)
              (to_bytes v) in
          Error_monad.__return ((|C|).(Raw_context.T.project) __t_value) in
        let init_set
          (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          (v : (|V|).(Storage_sigs.VALUE.t)) : Lwt.t Raw_context.root_context :=
          let= __t_value :=
            (|C|).(Raw_context.T.init_set) s ((|I|).(INDEX.to_path) i nil)
              (to_bytes v) in
          Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
        let set_option
          (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          (v : option (|V|).(Storage_sigs.VALUE.t))
          : Lwt.t Raw_context.root_context :=
          let= __t_value :=
            (|C|).(Raw_context.T.set_option) s ((|I|).(INDEX.to_path) i nil)
              (Option.map to_bytes v) in
          Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
        let remove (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t Raw_context.root_context :=
          let= __t_value :=
            (|C|).(Raw_context.T.remove) s ((|I|).(INDEX.to_path) i nil) in
          Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
        let delete (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t (Error_monad.tzresult Raw_context.root_context) :=
          let=? __t_value :=
            (|C|).(Raw_context.T.delete) s ((|I|).(INDEX.to_path) i nil) in
          Error_monad.__return ((|C|).(Raw_context.T.project) __t_value) in
        let clear (s : (|C|).(Raw_context.T.context))
          : Lwt.t Raw_context.root_context :=
          let= __t_value := (|C|).(Raw_context.T.remove_rec) s nil in
          Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
        let fold_keys {A : Set}
          (s : (|C|).(Raw_context.T.context)) (init : A)
          (f : (|I|).(INDEX.t) -> A -> Lwt.t A) : Lwt.t A :=
          let fix dig
            (i : (|Compare.Int|).(Compare.S.t)) (path : Raw_context.key)
            (acc : A) {struct i} : Lwt.t A :=
            if (|Compare.Int|).(Compare.S.op_lteq) i 1 then
              (|C|).(Raw_context.T.fold) s path acc
                (fun k =>
                  fun acc =>
                    match k with
                    | Context.Dir _ => Lwt.__return acc
                    | Context.Key file =>
                      match (|I|).(INDEX.of_path) file with
                      | None =>
                        (* ❌ Assert instruction is not handled. *)
                        assert (Lwt.t _) false
                      | Some path => f path acc
                      end
                    end)
            else
              (|C|).(Raw_context.T.fold) s path acc
                (fun k =>
                  fun acc =>
                    match k with
                    | Context.Dir k => dig (Pervasives.op_minus i 1) k acc
                    | Context.Key _ => Lwt.__return acc
                    end) in
          dig (|I|).(INDEX.path_length) nil init in
        let fold {A : Set}
          (s : (|C|).(Raw_context.T.context)) (init : A)
          (f : (|I|).(INDEX.t) -> (|V|).(Storage_sigs.VALUE.t) -> A -> Lwt.t A)
          : Lwt.t A :=
          let f (path : (|I|).(INDEX.t)) (acc : A) : Lwt.t A :=
            let= function_parameter := get s path in
            match function_parameter with
            | Pervasives.Error _ => Lwt.__return acc
            | Pervasives.Ok v => f path v acc
            end in
          fold_keys s init f in
        let bindings (s : (|C|).(Raw_context.T.context))
          : Lwt.t (list ((|I|).(INDEX.t) * (|V|).(Storage_sigs.VALUE.t))) :=
          fold s (nil (A := key * value))
            (fun __p_value =>
              fun v => fun acc => Lwt.__return (cons (__p_value, v) acc)) in
        let keys (s : (|C|).(Raw_context.T.context))
          : Lwt.t (list (|I|).(INDEX.t)) :=
          fold_keys s (nil (A := key))
            (fun __p_value => fun acc => Lwt.__return (cons __p_value acc)) in
        (* ❌ top_level_evaluation *)
        existT (A := unit) (fun _ => _) tt
          {|
            Storage_sigs.Indexed_data_storage.tag_Non_iterable_indexed_data_storage :=
              tag_Non_iterable_indexed_data_storage;
            Storage_sigs.Indexed_data_storage.mem := mem;
            Storage_sigs.Indexed_data_storage.get := get;
            Storage_sigs.Indexed_data_storage.get_option := get_option;
            Storage_sigs.Indexed_data_storage.set := set;
            Storage_sigs.Indexed_data_storage.init := init;
            Storage_sigs.Indexed_data_storage.init_set := init_set;
            Storage_sigs.Indexed_data_storage.set_option := set_option;
            Storage_sigs.Indexed_data_storage.delete := delete;
            Storage_sigs.Indexed_data_storage.remove := remove;
            Storage_sigs.Indexed_data_storage.clear := clear;
            Storage_sigs.Indexed_data_storage.keys := keys;
            Storage_sigs.Indexed_data_storage.bindings := bindings;
            Storage_sigs.Indexed_data_storage.fold {_} := fold;
            Storage_sigs.Indexed_data_storage.fold_keys {_} := fold_keys
          |})
          :
            {_ : unit &
              Indexed_data_storage.signature (|C|).(Raw_context.T.t)
                (|I|).(INDEX.t) (|V|).(Storage_sigs.VALUE.t)}).

Definition Make_indexed_carbonated_data_storage :=
  fun (C : {t : Set & Raw_context.T.signature t}) =>
    fun (I : {'[t, ipath] : [Set ** Set -> Set] & INDEX.signature t ipath}) =>
      fun (V : {t : Set & VALUE.signature t}) =>
        ((let tag_Non_iterable_indexed_carbonated_data_storage := tt in
        let t := (|C|).(Raw_context.T.t) in
        let context := t in
        let key := (|I|).(INDEX.t) in
        let value := (|V|).(Storage_sigs.VALUE.t) in
        let Encoder := Make_encoder (existT (A := Set) _ _ (|V|)) in
        let of_bytes := (|Encoder|).(ENCODER.of_bytes) in
        let to_bytes := (|Encoder|).(ENCODER.to_bytes) in
        let data_key (i : (|I|).(INDEX.t)) : list string :=
          (|I|).(INDEX.to_path) i [ data_name ] in
        let len_key (i : (|I|).(INDEX.t)) : list string :=
          (|I|).(INDEX.to_path) i [ len_name ] in
        let consume_mem_gas (c : (|C|).(Raw_context.T.context))
          : Lwt.t (Error_monad.tzresult (|C|).(Raw_context.T.context)) :=
          Lwt.__return
            ((|C|).(Raw_context.T.consume_gas) c
              (Gas_limit_repr.read_bytes_cost Z.zero)) in
        let existing_size
          (c : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t (Error_monad.tzresult (int * bool)) :=
          let= function_parameter :=
            (|C|).(Raw_context.T.get_option) c (len_key i) in
          match function_parameter with
          | None => Error_monad.__return (0, false)
          | Some len =>
            let=? len := decode_len_value (len_key i) len in
            Error_monad.__return (len, true)
          end in
        let consume_read_gas
          (get :
            (|C|).(Raw_context.T.context) -> list string ->
            Lwt.t (Error_monad.tzresult MBytes.t))
          (c : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t (Error_monad.tzresult (|C|).(Raw_context.T.context)) :=
          let=? len := get c (len_key i) in
          let=? len := decode_len_value (len_key i) len in
          Lwt.__return
            ((|C|).(Raw_context.T.consume_gas) c
              (Gas_limit_repr.read_bytes_cost (Z.of_int len))) in
        let consume_serialize_write_gas {A : Set}
          (set :
            (|C|).(Raw_context.T.context) -> list string -> MBytes.t ->
            Lwt.t (Error_monad.tzresult A)) (c : (|C|).(Raw_context.T.context))
          (i : (|I|).(INDEX.t)) (v : (|V|).(Storage_sigs.VALUE.t))
          : Lwt.t (Error_monad.tzresult (A * MBytes.t)) :=
          let __bytes_value := to_bytes v in
          let len := MBytes.length __bytes_value in
          let=? c :=
            Lwt.__return
              ((|C|).(Raw_context.T.consume_gas) c
                (Gas_limit_repr.alloc_mbytes_cost len)) in
          let=? c :=
            Lwt.__return
              ((|C|).(Raw_context.T.consume_gas) c
                (Gas_limit_repr.write_bytes_cost (Z.of_int len))) in
          let=? c := set c (len_key i) (encode_len_value __bytes_value) in
          Error_monad.__return (c, __bytes_value) in
        let consume_remove_gas {A : Set}
          (del :
            (|C|).(Raw_context.T.context) -> list string ->
            Lwt.t (Error_monad.tzresult A)) (c : (|C|).(Raw_context.T.context))
          (i : (|I|).(INDEX.t)) : Lwt.t (Error_monad.tzresult A) :=
          let=? c :=
            Lwt.__return
              ((|C|).(Raw_context.T.consume_gas) c
                (Gas_limit_repr.write_bytes_cost Z.zero)) in
          del c (len_key i) in
        let mem (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t (Error_monad.tzresult (Raw_context.root_context * bool)) :=
          let=? s := consume_mem_gas s in
          let= __exists := (|C|).(Raw_context.T.mem) s (data_key i) in
          Error_monad.__return (((|C|).(Raw_context.T.project) s), __exists) in
        let get (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t
            (Error_monad.tzresult
              (Raw_context.root_context * (|V|).(Storage_sigs.VALUE.t))) :=
          let=? s := consume_read_gas (|C|).(Raw_context.T.get) s i in
          let=? __b_value := (|C|).(Raw_context.T.get) s (data_key i) in
          let __key_value := (|C|).(Raw_context.T.absolute_key) s (data_key i)
            in
          let=? v := Lwt.__return (of_bytes __key_value __b_value) in
          Error_monad.__return (((|C|).(Raw_context.T.project) s), v) in
        let get_option (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t
            (Error_monad.tzresult
              (Raw_context.root_context * option (|V|).(Storage_sigs.VALUE.t))) :=
          let=? s := consume_mem_gas s in
          let= __exists := (|C|).(Raw_context.T.mem) s (data_key i) in
          if __exists then
            let=? '(s, v) := get s i in
            Error_monad.__return (s, (Some v))
          else
            Error_monad.__return (((|C|).(Raw_context.T.project) s), None) in
        let set
          (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          (v : (|V|).(Storage_sigs.VALUE.t))
          : Lwt.t (Error_monad.tzresult (Raw_context.root_context * int)) :=
          let=? '(prev_size, _) := existing_size s i in
          let=? '(s, __bytes_value) :=
            consume_serialize_write_gas (|C|).(Raw_context.T.set) s i v in
          let=? __t_value :=
            (|C|).(Raw_context.T.set) s (data_key i) __bytes_value in
          let size_diff :=
            Pervasives.op_minus (MBytes.length __bytes_value) prev_size in
          Error_monad.__return
            (((|C|).(Raw_context.T.project) __t_value), size_diff) in
        let init
          (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          (v : (|V|).(Storage_sigs.VALUE.t))
          : Lwt.t (Error_monad.tzresult (Raw_context.root_context * int)) :=
          let=? '(s, __bytes_value) :=
            consume_serialize_write_gas (|C|).(Raw_context.T.init) s i v in
          let=? __t_value :=
            (|C|).(Raw_context.T.init) s (data_key i) __bytes_value in
          let size := MBytes.length __bytes_value in
          Error_monad.__return (((|C|).(Raw_context.T.project) __t_value), size)
          in
        let init_set
          (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          (v : (|V|).(Storage_sigs.VALUE.t))
          : Lwt.t (Error_monad.tzresult (Raw_context.root_context * int * bool)) :=
          let init_set
            (s : (|C|).(Raw_context.T.context)) (i : Raw_context.key)
            (v : Raw_context.value)
            : Lwt.t (Error_monad.tzresult (|C|).(Raw_context.T.context)) :=
            Error_monad.op_gtgteq ((|C|).(Raw_context.T.init_set) s i v)
              Error_monad.__return in
          let=? '(prev_size, existed) := existing_size s i in
          let=? '(s, __bytes_value) :=
            consume_serialize_write_gas init_set s i v in
          let=? __t_value := init_set s (data_key i) __bytes_value in
          let size_diff :=
            Pervasives.op_minus (MBytes.length __bytes_value) prev_size in
          Error_monad.__return
            (((|C|).(Raw_context.T.project) __t_value), size_diff, existed) in
        let remove (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t (Error_monad.tzresult (Raw_context.root_context * int * bool)) :=
          let remove (s : (|C|).(Raw_context.T.context)) (i : Raw_context.key)
            : Lwt.t (Error_monad.tzresult (|C|).(Raw_context.T.context)) :=
            Error_monad.op_gtgteq ((|C|).(Raw_context.T.remove) s i)
              Error_monad.__return in
          let=? '(prev_size, existed) := existing_size s i in
          let=? s := consume_remove_gas remove s i in
          let=? __t_value := remove s (data_key i) in
          Error_monad.__return
            (((|C|).(Raw_context.T.project) __t_value), prev_size, existed) in
        let delete (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t (Error_monad.tzresult (Raw_context.root_context * int)) :=
          let=? '(prev_size, _) := existing_size s i in
          let=? s := consume_remove_gas (|C|).(Raw_context.T.delete) s i in
          let=? __t_value := (|C|).(Raw_context.T.delete) s (data_key i) in
          Error_monad.__return
            (((|C|).(Raw_context.T.project) __t_value), prev_size) in
        let set_option
          (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          (v : option (|V|).(Storage_sigs.VALUE.t))
          : Lwt.t (Error_monad.tzresult (Raw_context.root_context * int * bool)) :=
          match v with
          | None => remove s i
          | Some v => init_set s i v
          end in
        let fold_keys_unaccounted {A : Set}
          (s : (|C|).(Raw_context.T.context)) (init : A)
          (f : (|I|).(INDEX.t) -> A -> Lwt.t A) : Lwt.t A :=
          let fix dig
            (i : (|Compare.Int|).(Compare.S.t)) (path : Raw_context.key)
            (acc : A) {struct i} : Lwt.t A :=
            if (|Compare.Int|).(Compare.S.op_lteq) i 0 then
              (|C|).(Raw_context.T.fold) s path acc
                (fun k =>
                  fun acc =>
                    match k with
                    | Context.Dir _ => Lwt.__return acc
                    | Context.Key file =>
                      match
                        ((List.rev file),
                          match List.rev file with
                          | cons last _ =>
                            (|Compare.String|).(Compare.S.op_eq) last len_name
                          | _ => false
                          end,
                          match List.rev file with
                          | cons last rest =>
                            (|Compare.String|).(Compare.S.op_eq) last data_name
                          | _ => false
                          end) with
                      | (cons last _, true, _) => Lwt.__return acc
                      | (cons last rest, _, true) =>
                        let file := List.rev rest in
                        match (|I|).(INDEX.of_path) file with
                        | None =>
                          (* ❌ Assert instruction is not handled. *)
                          assert (Lwt.t _) false
                        | Some path => f path acc
                        end
                      | (_, _, _) =>
                        (* ❌ Assert instruction is not handled. *)
                        assert (Lwt.t _) false
                      end
                    end)
            else
              (|C|).(Raw_context.T.fold) s path acc
                (fun k =>
                  fun acc =>
                    match k with
                    | Context.Dir k => dig (Pervasives.op_minus i 1) k acc
                    | Context.Key _ => Lwt.__return acc
                    end) in
          dig (|I|).(INDEX.path_length) nil init in
        let keys_unaccounted (s : (|C|).(Raw_context.T.context))
          : Lwt.t (list (|I|).(INDEX.t)) :=
          fold_keys_unaccounted s (nil (A := key))
            (fun __p_value => fun acc => Lwt.__return (cons __p_value acc)) in
        (* ❌ top_level_evaluation *)
        existT (A := unit) (fun _ => _) tt
          {|
            Storage_sigs.Non_iterable_indexed_carbonated_data_storage.tag_Non_iterable_indexed_carbonated_data_storage :=
              tag_Non_iterable_indexed_carbonated_data_storage;
            Storage_sigs.Non_iterable_indexed_carbonated_data_storage.mem := mem;
            Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get := get;
            Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get_option :=
              get_option;
            Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set := set;
            Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init :=
              init;
            Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init_set :=
              init_set;
            Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set_option :=
              set_option;
            Storage_sigs.Non_iterable_indexed_carbonated_data_storage.delete :=
              delete;
            Storage_sigs.Non_iterable_indexed_carbonated_data_storage.remove :=
              remove
          |})
          :
            {_ : unit &
              Non_iterable_indexed_carbonated_data_storage.signature
                (|C|).(Raw_context.T.t) (|I|).(INDEX.t)
                (|V|).(Storage_sigs.VALUE.t)}).

Definition Make_indexed_data_snapshotable_storage :=
  fun (C : {t : Set & Raw_context.T.signature t}) =>
    fun
      (Snapshot_index :
        {'[t, ipath] : [Set ** Set -> Set] & INDEX.signature t ipath}) =>
      fun (I : {'[t, ipath] : [Set ** Set -> Set] & INDEX.signature t ipath}) =>
        fun (V : {t : Set & VALUE.signature t}) =>
          ((let snapshot := (|Snapshot_index|).(INDEX.t) in
          let data_name := [ "current" ] in
          let snapshot_name := [ "snapshot" ] in
          let C_data :=
            ((Make_subcontext
              (existT (A := unit) (fun _ => _) tt (|Registered|)))
              (existT (A := Set) _ _ (|C|)))
              (let name := data_name in
              existT (A := unit) (fun _ => _) tt
                {|
                  Storage_sigs.NAME.name := name
                |}) in
          let C_snapshot :=
            ((Make_subcontext
              (existT (A := unit) (fun _ => _) tt (|Registered|)))
              (existT (A := Set) _ _ (|C|)))
              (let name := snapshot_name in
              existT (A := unit) (fun _ => _) tt
                {|
                  Storage_sigs.NAME.name := name
                |}) in
          let Data_storage :=
            ((Make_indexed_data_storage (existT (A := Set) _ _ (|C_data|)))
              (existT (A := [Set ** Set -> Set]) _ [_, _] (|I|)))
              (existT (A := Set) _ _ (|V|)) in
          let tag_Non_iterable_indexed_data_storage :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.tag_Non_iterable_indexed_data_storage)
            in
          let t := (|Data_storage|).(Storage_sigs.Indexed_data_storage.t) in
          let context :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.context) in
          let key := (|Data_storage|).(Storage_sigs.Indexed_data_storage.key) in
          let value :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.value) in
          let mem := (|Data_storage|).(Storage_sigs.Indexed_data_storage.mem) in
          let get := (|Data_storage|).(Storage_sigs.Indexed_data_storage.get) in
          let get_option :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.get_option) in
          let set := (|Data_storage|).(Storage_sigs.Indexed_data_storage.set) in
          let init := (|Data_storage|).(Storage_sigs.Indexed_data_storage.init)
            in
          let init_set :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.init_set) in
          let set_option :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.set_option) in
          let delete :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.delete) in
          let remove :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.remove) in
          let clear :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.clear) in
          let keys := (|Data_storage|).(Storage_sigs.Indexed_data_storage.keys)
            in
          let bindings :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.bindings) in
          let fold {a : Set} :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.fold) in
          let fold_keys {a : Set} :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.fold_keys) in
          let Pair_Snapshot_index_I :=
            (Pair
              (existT (A := [Set ** Set -> Set]) _ [_, _] (|Snapshot_index|)))
              (existT (A := [Set ** Set -> Set]) _ [_, _] (|I|)) in
          let Snapshot :=
            ((Make_indexed_data_storage (existT (A := Set) _ _ (|C_snapshot|)))
              (existT (A := [Set ** Set -> Set]) _ [_, _]
                (|Pair_Snapshot_index_I|))) (existT (A := Set) _ _ (|V|)) in
          let snapshot_path (id : (|Snapshot_index|).(INDEX.t)) : list string :=
            Pervasives.op_at snapshot_name
              ((|Snapshot_index|).(INDEX.to_path) id nil) in
          let snapshot_exists
            (s : (|C|).(Raw_context.T.context))
            (id : (|Snapshot_index|).(INDEX.t)) : Lwt.t bool :=
            (|C|).(Raw_context.T.dir_mem) s (snapshot_path id) in
          let __snapshot_value
            (s : (|C|).(Raw_context.T.context))
            (id : (|Snapshot_index|).(INDEX.t))
            : Lwt.t (Error_monad.tzresult Raw_context.root_context) :=
            let=? __t_value :=
              (|C|).(Raw_context.T.copy) s data_name (snapshot_path id) in
            Error_monad.__return ((|C|).(Raw_context.T.project) __t_value) in
          let delete_snapshot
            (s : (|C|).(Raw_context.T.context))
            (id : (|Snapshot_index|).(INDEX.t))
            : Lwt.t Raw_context.root_context :=
            let= __t_value :=
              (|C|).(Raw_context.T.remove_rec) s (snapshot_path id) in
            Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
          existT (A := unit) (fun _ => _) tt
            {|
              Storage_sigs.Indexed_data_snapshotable_storage.tag_Non_iterable_indexed_data_storage :=
                tag_Non_iterable_indexed_data_storage;
              Storage_sigs.Indexed_data_snapshotable_storage.mem := mem;
              Storage_sigs.Indexed_data_snapshotable_storage.get := get;
              Storage_sigs.Indexed_data_snapshotable_storage.get_option :=
                get_option;
              Storage_sigs.Indexed_data_snapshotable_storage.set := set;
              Storage_sigs.Indexed_data_snapshotable_storage.init := init;
              Storage_sigs.Indexed_data_snapshotable_storage.init_set :=
                init_set;
              Storage_sigs.Indexed_data_snapshotable_storage.set_option :=
                set_option;
              Storage_sigs.Indexed_data_snapshotable_storage.delete := delete;
              Storage_sigs.Indexed_data_snapshotable_storage.remove := remove;
              Storage_sigs.Indexed_data_snapshotable_storage.clear := clear;
              Storage_sigs.Indexed_data_snapshotable_storage.keys := keys;
              Storage_sigs.Indexed_data_snapshotable_storage.bindings :=
                bindings;
              Storage_sigs.Indexed_data_snapshotable_storage.fold {_} := fold;
              Storage_sigs.Indexed_data_snapshotable_storage.fold_keys {_} :=
                fold_keys;
              Storage_sigs.Indexed_data_snapshotable_storage.Snapshot :=
                (|Snapshot|);
              Storage_sigs.Indexed_data_snapshotable_storage.snapshot_exists :=
                snapshot_exists;
              Storage_sigs.Indexed_data_snapshotable_storage.__snapshot_value :=
                __snapshot_value;
              Storage_sigs.Indexed_data_snapshotable_storage.delete_snapshot :=
                delete_snapshot
            |})
            :
              {_ : unit &
                Indexed_data_snapshotable_storage.signature
                  (|Snapshot_index|).(INDEX.t) (|I|).(INDEX.t)
                  (|C|).(Raw_context.T.t) (|V|).(Storage_sigs.VALUE.t)}).

Definition Make_indexed_subcontext :=
  fun (C : {t : Set & Raw_context.T.signature t}) =>
    fun (I : {'[t, ipath] : [Set ** Set -> Set] & INDEX.signature t ipath}) =>
      ((let t := (|C|).(Raw_context.T.t) in
      let context := t in
      let key := (|I|).(INDEX.t) in
      let ipath (a : Set) := (|I|).(INDEX.ipath) a in
      let clear (__t_value : (|C|).(Raw_context.T.context))
        : Lwt.t Raw_context.root_context :=
        let= __t_value := (|C|).(Raw_context.T.remove_rec) __t_value nil in
        Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
      let fold_keys {A : Set}
        (__t_value : (|C|).(Raw_context.T.context)) (init : A)
        (f : (|I|).(INDEX.t) -> A -> Lwt.t A) : Lwt.t A :=
        let fix dig
          (i : (|Compare.Int|).(Compare.S.t)) (path : Raw_context.key) (acc : A)
          {struct i} : Lwt.t A :=
          if (|Compare.Int|).(Compare.S.op_lteq) i 0 then
            match (|I|).(INDEX.of_path) path with
            | None =>
              (* ❌ Assert instruction is not handled. *)
              assert (Lwt.t _) false
            | Some path => f path acc
            end
          else
            (|C|).(Raw_context.T.fold) __t_value path acc
              (fun k =>
                fun acc =>
                  match k with
                  | Context.Dir k => dig (Pervasives.op_minus i 1) k acc
                  | Context.Key _ => Lwt.__return acc
                  end) in
        dig (|I|).(INDEX.path_length) nil init in
      let keys (__t_value : (|C|).(Raw_context.T.context))
        : Lwt.t (list (|I|).(INDEX.t)) :=
        fold_keys __t_value (nil (A := key))
          (fun i => fun acc => Lwt.__return (cons i acc)) in
      let __list_value
        (__t_value : (|C|).(Raw_context.T.context)) (k : Raw_context.key)
        : Lwt.t (list Context.dir_or_key) :=
        (|C|).(Raw_context.T.fold) __t_value k nil
          (fun k => fun acc => Lwt.__return (cons k acc)) in
      let remove_rec
        (__t_value : (|C|).(Raw_context.T.context)) (k : (|I|).(INDEX.t))
        : Lwt.t (|C|).(Raw_context.T.context) :=
        (|C|).(Raw_context.T.remove_rec) __t_value ((|I|).(INDEX.to_path) k nil)
        in
      let copy
        (__t_value : (|C|).(Raw_context.T.context)) (from : (|I|).(INDEX.t))
        (to_ : (|I|).(INDEX.t))
        : Lwt.t (Error_monad.tzresult (|C|).(Raw_context.T.context)) :=
        (|C|).(Raw_context.T.copy) __t_value ((|I|).(INDEX.to_path) from nil)
          ((|I|).(INDEX.to_path) to_ nil) in
      let description :=
        Storage_description.register_indexed_subcontext
          (|C|).(Raw_context.T.description)
          (fun c => Error_monad.op_gtgteq (keys c) Error_monad.__return)
          ((|I|).(INDEX.args) tt) in
      let unpack := Storage_description.unpack ((|I|).(INDEX.args) tt) in
      let pack := Storage_description.pack ((|I|).(INDEX.args) tt) in
      let Raw_context :=
        ((let t := (|I|).(INDEX.ipath) (|C|).(Raw_context.T.t) in
        let context := t in
        let to_key (i : (|I|).(INDEX.t)) (k : list string) : list string :=
          (|I|).(INDEX.to_path) i k in
        let of_key {A : Set} (k : list A) : list A :=
          Misc.remove_elem_from_list (|I|).(INDEX.path_length) k in
        let mem
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) : Lwt.t bool :=
          let '(__t_value, i) := unpack c in
          (|C|).(Raw_context.T.mem) __t_value (to_key i k) in
        let dir_mem
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) : Lwt.t bool :=
          let '(__t_value, i) := unpack c in
          (|C|).(Raw_context.T.dir_mem) __t_value (to_key i k) in
        let get
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) : Lwt.t (Error_monad.tzresult Raw_context.value) :=
          let '(__t_value, i) := unpack c in
          (|C|).(Raw_context.T.get) __t_value (to_key i k) in
        let get_option
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) : Lwt.t (option Raw_context.value) :=
          let '(__t_value, i) := unpack c in
          (|C|).(Raw_context.T.get_option) __t_value (to_key i k) in
        let init
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) (v : Raw_context.value)
          : Lwt.t
            (Error_monad.tzresult
              ((|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))) :=
          let '(__t_value, i) := unpack c in
          let=? __t_value := (|C|).(Raw_context.T.init) __t_value (to_key i k) v
            in
          Error_monad.__return (pack __t_value i) in
        let set
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) (v : Raw_context.value)
          : Lwt.t
            (Error_monad.tzresult
              ((|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))) :=
          let '(__t_value, i) := unpack c in
          let=? __t_value := (|C|).(Raw_context.T.set) __t_value (to_key i k) v
            in
          Error_monad.__return (pack __t_value i) in
        let init_set
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) (v : Raw_context.value)
          : Lwt.t ((|I|).(INDEX.ipath) (|C|).(Raw_context.T.context)) :=
          let '(__t_value, i) := unpack c in
          let= __t_value :=
            (|C|).(Raw_context.T.init_set) __t_value (to_key i k) v in
          Lwt.__return (pack __t_value i) in
        let set_option
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) (v : option Raw_context.value)
          : Lwt.t ((|I|).(INDEX.ipath) (|C|).(Raw_context.T.context)) :=
          let '(__t_value, i) := unpack c in
          let= __t_value :=
            (|C|).(Raw_context.T.set_option) __t_value (to_key i k) v in
          Lwt.__return (pack __t_value i) in
        let delete
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string)
          : Lwt.t
            (Error_monad.tzresult
              ((|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))) :=
          let '(__t_value, i) := unpack c in
          let=? __t_value := (|C|).(Raw_context.T.delete) __t_value (to_key i k)
            in
          Error_monad.__return (pack __t_value i) in
        let remove
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string)
          : Lwt.t ((|I|).(INDEX.ipath) (|C|).(Raw_context.T.context)) :=
          let '(__t_value, i) := unpack c in
          let= __t_value := (|C|).(Raw_context.T.remove) __t_value (to_key i k)
            in
          Lwt.__return (pack __t_value i) in
        let remove_rec
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string)
          : Lwt.t ((|I|).(INDEX.ipath) (|C|).(Raw_context.T.context)) :=
          let '(__t_value, i) := unpack c in
          let= __t_value :=
            (|C|).(Raw_context.T.remove_rec) __t_value (to_key i k) in
          Lwt.__return (pack __t_value i) in
        let copy
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (from : list string) (to_ : list string)
          : Lwt.t
            (Error_monad.tzresult
              ((|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))) :=
          let '(__t_value, i) := unpack c in
          let=? __t_value :=
            (|C|).(Raw_context.T.copy) __t_value (to_key i from) (to_key i to_)
            in
          Error_monad.__return (pack __t_value i) in
        let fold {A : Set}
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) (init : A) (f : Context.dir_or_key -> A -> Lwt.t A)
          : Lwt.t A :=
          let '(__t_value, i) := unpack c in
          (|C|).(Raw_context.T.fold) __t_value (to_key i k) init
            (fun k => fun acc => f (map_key of_key k) acc) in
        let keys
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) : Lwt.t (list (list string)) :=
          let '(__t_value, i) := unpack c in
          Error_monad.op_gtpipeeq
            ((|C|).(Raw_context.T.keys) __t_value (to_key i k))
            (fun keys => List.map of_key keys) in
        let fold_keys {A : Set}
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) (init : A) (f : list string -> A -> Lwt.t A)
          : Lwt.t A :=
          let '(__t_value, i) := unpack c in
          (|C|).(Raw_context.T.fold_keys) __t_value (to_key i k) init
            (fun k => fun acc => f (of_key k) acc) in
        let project (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          : Raw_context.root_context :=
          let '(__t_value, _) := unpack c in
          (|C|).(Raw_context.T.project) __t_value in
        let absolute_key
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) : Raw_context.key :=
          let '(__t_value, i) := unpack c in
          (|C|).(Raw_context.T.absolute_key) __t_value (to_key i k) in
        let consume_gas
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (g : Gas_limit_repr.cost)
          : Error_monad.tzresult
            ((|I|).(INDEX.ipath) (|C|).(Raw_context.T.context)) :=
          let '(__t_value, i) := unpack c in
          let? __t_value := (|C|).(Raw_context.T.consume_gas) __t_value g in
          Error_monad.ok (pack __t_value i) in
        let check_enough_gas
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (g : Gas_limit_repr.cost) : Error_monad.tzresult unit :=
          let '(__t_value, _i) := unpack c in
          (|C|).(Raw_context.T.check_enough_gas) __t_value g in
        existT (A := unit) (fun _ => _) tt
          {|
            Raw_context.T.mem := mem;
            Raw_context.T.dir_mem := dir_mem;
            Raw_context.T.get := get;
            Raw_context.T.get_option := get_option;
            Raw_context.T.init := init;
            Raw_context.T.set := set;
            Raw_context.T.init_set := init_set;
            Raw_context.T.set_option := set_option;
            Raw_context.T.delete := delete;
            Raw_context.T.remove := remove;
            Raw_context.T.remove_rec := remove_rec;
            Raw_context.T.copy := copy;
            Raw_context.T.fold {_} := fold;
            Raw_context.T.keys := keys;
            Raw_context.T.fold_keys {_} := fold_keys;
            Raw_context.T.project := project;
            Raw_context.T.absolute_key := absolute_key;
            Raw_context.T.consume_gas := consume_gas;
            Raw_context.T.check_enough_gas := check_enough_gas;
            Raw_context.T.description := description
          |}) : {_ : unit & Raw_context.T.signature (ipath t)}) in
      let resolve
        (__t_value : (|C|).(Raw_context.T.context)) (prefix : list string)
        : Lwt.t (list (|I|).(INDEX.t)) :=
        let fix loop
          (i : (|Compare.Int|).(Compare.S.t)) (prefix : Raw_context.key)
          (function_parameter : list string) {struct i}
          : Lwt.t (list (|I|).(INDEX.t)) :=
          match
            (function_parameter,
              match function_parameter with
              | [] =>
                (|Compare.Int|).(Compare.S.op_eq) i (|I|).(INDEX.path_length)
              | _ => false
              end,
              match function_parameter with
              | cons d [] =>
                (|Compare.Int|).(Compare.S.op_eq) i
                  (Pervasives.op_minus (|I|).(INDEX.path_length) 1)
              | _ => false
              end) with
          | ([], true, _) =>
            match (|I|).(INDEX.of_path) prefix with
            | None =>
              (* ❌ Assert instruction is not handled. *)
              assert (Lwt.t (list (|I|).(INDEX.t))) false
            | Some path => Lwt.__return [ path ]
            end
          | ([], _, _) =>
            let= prefixes := __list_value __t_value prefix in
            Error_monad.op_gtpipeeq
              (Lwt_list.map_s
                (fun function_parameter =>
                  match function_parameter with
                  | (Context.Key prefix | Context.Dir prefix) =>
                    loop (Pervasives.op_plus i 1) prefix nil
                  end) prefixes) List.flatten
          | (cons d [], _, true) =>
            (* ❌ Sequences of instructions are ignored (operator ";") *)
            (* ❌ instruction_sequence ";" *)
            let= prefixes := __list_value __t_value prefix in
            Error_monad.op_gtpipeeq
              (Lwt_list.map_s
                (fun function_parameter =>
                  match function_parameter with
                  | (Context.Key prefix | Context.Dir prefix) =>
                    match Misc.remove_prefix d (List.hd (List.rev prefix)) with
                    | None => Lwt.return_nil
                    | Some _ => loop (Pervasives.op_plus i 1) prefix nil
                    end
                  end) prefixes) List.flatten
          | (cons "" ds, _, _) =>
            let= prefixes := __list_value __t_value prefix in
            Error_monad.op_gtpipeeq
              (Lwt_list.map_s
                (fun function_parameter =>
                  match function_parameter with
                  | (Context.Key prefix | Context.Dir prefix) =>
                    loop (Pervasives.op_plus i 1) prefix ds
                  end) prefixes) List.flatten
          | (cons d ds, _, _) =>
            (* ❌ Sequences of instructions are ignored (operator ";") *)
            (* ❌ instruction_sequence ";" *)
            let= function_parameter :=
              (|C|).(Raw_context.T.dir_mem) __t_value
                (Pervasives.op_at prefix [ d ]) in
            match function_parameter with
            | true =>
              loop (Pervasives.op_plus i 1) (Pervasives.op_at prefix [ d ]) ds
            | false => Lwt.return_nil
            end
          end in
        loop 0 nil prefix in
      let Make_set :=
        fun (R : {_ : unit & REGISTER.signature}) =>
          fun (N : {_ : unit & NAME.signature}) =>
            ((let t := (|C|).(Raw_context.T.t) in
            let context := t in
            let elt := (|I|).(INDEX.t) in
            let inited := MBytes.of_string "inited" in
            let mem (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t bool :=
              (|Raw_context|).(Raw_context.T.mem) (pack s i)
                (|N|).(Storage_sigs.NAME.name) in
            let add (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t Raw_context.root_context :=
              let= c :=
                (|Raw_context|).(Raw_context.T.init_set) (pack s i)
                  (|N|).(Storage_sigs.NAME.name) inited in
              let '(s, _) := unpack c in
              Lwt.__return ((|C|).(Raw_context.T.project) s) in
            let del (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t Raw_context.root_context :=
              let= c :=
                (|Raw_context|).(Raw_context.T.remove) (pack s i)
                  (|N|).(Storage_sigs.NAME.name) in
              let '(s, _) := unpack c in
              Lwt.__return ((|C|).(Raw_context.T.project) s) in
            let set
              (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              (function_parameter : bool) : Lwt.t Raw_context.root_context :=
              match function_parameter with
              | true => add s i
              | false => del s i
              end in
            let clear (s : (|C|).(Raw_context.T.context))
              : Lwt.t Raw_context.root_context :=
              let= __t_value :=
                fold_keys s s
                  (fun i =>
                    fun s =>
                      let= c :=
                        (|Raw_context|).(Raw_context.T.remove) (pack s i)
                          (|N|).(Storage_sigs.NAME.name) in
                      let '(s, _) := unpack c in
                      Lwt.__return s) in
              Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
            let fold {A : Set}
              (s : (|C|).(Raw_context.T.context)) (init : A)
              (f : (|I|).(INDEX.t) -> A -> Lwt.t A) : Lwt.t A :=
              fold_keys s init
                (fun i =>
                  fun acc =>
                    let= function_parameter := mem s i in
                    match function_parameter with
                    | true => f i acc
                    | false => Lwt.__return acc
                    end) in
            let elements (s : (|C|).(Raw_context.T.context))
              : Lwt.t (list (|I|).(INDEX.t)) :=
              fold s (nil (A := elt))
                (fun __p_value => fun acc => Lwt.__return (cons __p_value acc))
              in
            (* ❌ top_level_evaluation *)
            existT (A := unit) (fun _ => _) tt
              {|
                Storage_sigs.Data_set_storage.mem := mem;
                Storage_sigs.Data_set_storage.add := add;
                Storage_sigs.Data_set_storage.del := del;
                Storage_sigs.Data_set_storage.set := set;
                Storage_sigs.Data_set_storage.elements := elements;
                Storage_sigs.Data_set_storage.fold {_} := fold;
                Storage_sigs.Data_set_storage.clear := clear
              |}) : {_ : unit & Data_set_storage.signature t key}) in
      let Make_map :=
        fun (N : {_ : unit & NAME.signature}) =>
          fun (V : {t : Set & VALUE.signature t}) =>
            ((let tag_Non_iterable_indexed_data_storage := tt in
            let t := (|C|).(Raw_context.T.t) in
            let context := t in
            let key := (|I|).(INDEX.t) in
            let value := (|V|).(Storage_sigs.VALUE.t) in
            let Encoder := Make_encoder (existT (A := Set) _ _ (|V|)) in
            let of_bytes := (|Encoder|).(ENCODER.of_bytes) in
            let to_bytes := (|Encoder|).(ENCODER.to_bytes) in
            let mem (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t bool :=
              (|Raw_context|).(Raw_context.T.mem) (pack s i)
                (|N|).(Storage_sigs.NAME.name) in
            let get (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t (Error_monad.tzresult (|V|).(Storage_sigs.VALUE.t)) :=
              let=? __b_value :=
                (|Raw_context|).(Raw_context.T.get) (pack s i)
                  (|N|).(Storage_sigs.NAME.name) in
              let __key_value :=
                (|Raw_context|).(Raw_context.T.absolute_key) (pack s i)
                  (|N|).(Storage_sigs.NAME.name) in
              Lwt.__return (of_bytes __key_value __b_value) in
            let get_option
              (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t
                (Error_monad.tzresult (option (|V|).(Storage_sigs.VALUE.t))) :=
              let= function_parameter :=
                (|Raw_context|).(Raw_context.T.get_option) (pack s i)
                  (|N|).(Storage_sigs.NAME.name) in
              match function_parameter with
              | None => Error_monad.return_none
              | Some __b_value =>
                let __key_value :=
                  (|Raw_context|).(Raw_context.T.absolute_key) (pack s i)
                    (|N|).(Storage_sigs.NAME.name) in
                match of_bytes __key_value __b_value with
                | Pervasives.Ok v => Error_monad.return_some v
                | Pervasives.Error __error_value =>
                  Lwt.__return (Pervasives.Error __error_value)
                end
              end in
            let set
              (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              (v : (|V|).(Storage_sigs.VALUE.t))
              : Lwt.t (Error_monad.tzresult Raw_context.root_context) :=
              let=? c :=
                (|Raw_context|).(Raw_context.T.set) (pack s i)
                  (|N|).(Storage_sigs.NAME.name) (to_bytes v) in
              let '(s, _) := unpack c in
              Error_monad.__return ((|C|).(Raw_context.T.project) s) in
            let init
              (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              (v : (|V|).(Storage_sigs.VALUE.t))
              : Lwt.t (Error_monad.tzresult Raw_context.root_context) :=
              let=? c :=
                (|Raw_context|).(Raw_context.T.init) (pack s i)
                  (|N|).(Storage_sigs.NAME.name) (to_bytes v) in
              let '(s, _) := unpack c in
              Error_monad.__return ((|C|).(Raw_context.T.project) s) in
            let init_set
              (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              (v : (|V|).(Storage_sigs.VALUE.t))
              : Lwt.t Raw_context.root_context :=
              let= c :=
                (|Raw_context|).(Raw_context.T.init_set) (pack s i)
                  (|N|).(Storage_sigs.NAME.name) (to_bytes v) in
              let '(s, _) := unpack c in
              Lwt.__return ((|C|).(Raw_context.T.project) s) in
            let set_option
              (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              (v : option (|V|).(Storage_sigs.VALUE.t))
              : Lwt.t Raw_context.root_context :=
              let= c :=
                (|Raw_context|).(Raw_context.T.set_option) (pack s i)
                  (|N|).(Storage_sigs.NAME.name) (Option.map to_bytes v) in
              let '(s, _) := unpack c in
              Lwt.__return ((|C|).(Raw_context.T.project) s) in
            let remove (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t Raw_context.root_context :=
              let= c :=
                (|Raw_context|).(Raw_context.T.remove) (pack s i)
                  (|N|).(Storage_sigs.NAME.name) in
              let '(s, _) := unpack c in
              Lwt.__return ((|C|).(Raw_context.T.project) s) in
            let delete (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t (Error_monad.tzresult Raw_context.root_context) :=
              let=? c :=
                (|Raw_context|).(Raw_context.T.delete) (pack s i)
                  (|N|).(Storage_sigs.NAME.name) in
              let '(s, _) := unpack c in
              Error_monad.__return ((|C|).(Raw_context.T.project) s) in
            let clear (s : (|C|).(Raw_context.T.context))
              : Lwt.t Raw_context.root_context :=
              let= __t_value :=
                fold_keys s s
                  (fun i =>
                    fun s =>
                      let= c :=
                        (|Raw_context|).(Raw_context.T.remove) (pack s i)
                          (|N|).(Storage_sigs.NAME.name) in
                      let '(s, _) := unpack c in
                      Lwt.__return s) in
              Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
            let fold {A : Set}
              (s : (|C|).(Raw_context.T.context)) (init : A)
              (f :
                (|I|).(INDEX.t) -> (|V|).(Storage_sigs.VALUE.t) -> A -> Lwt.t A)
              : Lwt.t A :=
              fold_keys s init
                (fun i =>
                  fun acc =>
                    let= function_parameter := get s i in
                    match function_parameter with
                    | Pervasives.Error _ => Lwt.__return acc
                    | Pervasives.Ok v => f i v acc
                    end) in
            let bindings (s : (|C|).(Raw_context.T.context))
              : Lwt.t (list ((|I|).(INDEX.t) * (|V|).(Storage_sigs.VALUE.t))) :=
              fold s (nil (A := key * value))
                (fun __p_value =>
                  fun v => fun acc => Lwt.__return (cons (__p_value, v) acc)) in
            let fold_keys {A : Set}
              (s : (|C|).(Raw_context.T.context)) (init : A)
              (f : (|I|).(INDEX.t) -> A -> Lwt.t A) : Lwt.t A :=
              fold_keys s init
                (fun i =>
                  fun acc =>
                    let= function_parameter := mem s i in
                    match function_parameter with
                    | false => Lwt.__return acc
                    | true => f i acc
                    end) in
            let keys (s : (|C|).(Raw_context.T.context))
              : Lwt.t (list (|I|).(INDEX.t)) :=
              fold_keys s (nil (A := key))
                (fun __p_value => fun acc => Lwt.__return (cons __p_value acc))
              in
            (* ❌ top_level_evaluation *)
            existT (A := unit) (fun _ => _) tt
              {|
                Storage_sigs.Indexed_data_storage.tag_Non_iterable_indexed_data_storage :=
                  tag_Non_iterable_indexed_data_storage;
                Storage_sigs.Indexed_data_storage.mem := mem;
                Storage_sigs.Indexed_data_storage.get := get;
                Storage_sigs.Indexed_data_storage.get_option := get_option;
                Storage_sigs.Indexed_data_storage.set := set;
                Storage_sigs.Indexed_data_storage.init := init;
                Storage_sigs.Indexed_data_storage.init_set := init_set;
                Storage_sigs.Indexed_data_storage.set_option := set_option;
                Storage_sigs.Indexed_data_storage.delete := delete;
                Storage_sigs.Indexed_data_storage.remove := remove;
                Storage_sigs.Indexed_data_storage.clear := clear;
                Storage_sigs.Indexed_data_storage.keys := keys;
                Storage_sigs.Indexed_data_storage.bindings := bindings;
                Storage_sigs.Indexed_data_storage.fold {_} := fold;
                Storage_sigs.Indexed_data_storage.fold_keys {_} := fold_keys
              |})
              :
                {_ : unit &
                  Indexed_data_storage.signature t key
                    (|V|).(Storage_sigs.VALUE.t)}) in
      let Make_carbonated_map :=
        fun (N : {_ : unit & NAME.signature}) =>
          fun (V : {t : Set & VALUE.signature t}) =>
            ((let tag_Non_iterable_indexed_carbonated_data_storage := tt in
            let t := (|C|).(Raw_context.T.t) in
            let context := t in
            let key := (|I|).(INDEX.t) in
            let value := (|V|).(Storage_sigs.VALUE.t) in
            let Encoder := Make_encoder (existT (A := Set) _ _ (|V|)) in
            let of_bytes := (|Encoder|).(ENCODER.of_bytes) in
            let to_bytes := (|Encoder|).(ENCODER.to_bytes) in
            let len_name := cons len_name (|N|).(Storage_sigs.NAME.name) in
            let data_name := cons data_name (|N|).(Storage_sigs.NAME.name) in
            let consume_mem_gas (c : (|Raw_context|).(Raw_context.T.context))
              : Lwt.t
                (Error_monad.tzresult (|Raw_context|).(Raw_context.T.context)) :=
              Lwt.__return
                ((|Raw_context|).(Raw_context.T.consume_gas) c
                  (Gas_limit_repr.read_bytes_cost Z.zero)) in
            let existing_size (c : (|Raw_context|).(Raw_context.T.context))
              : Lwt.t (Error_monad.tzresult (int * bool)) :=
              let= function_parameter :=
                (|Raw_context|).(Raw_context.T.get_option) c len_name in
              match function_parameter with
              | None => Error_monad.__return (0, false)
              | Some len =>
                let=? len := decode_len_value len_name len in
                Error_monad.__return (len, true)
              end in
            let consume_read_gas
              (get :
                (|Raw_context|).(Raw_context.T.context) -> list string ->
                Lwt.t (Error_monad.tzresult MBytes.t))
              (c : (|Raw_context|).(Raw_context.T.context))
              : Lwt.t
                (Error_monad.tzresult (|Raw_context|).(Raw_context.T.context)) :=
              let=? len := get c len_name in
              let=? len := decode_len_value len_name len in
              Lwt.__return
                ((|Raw_context|).(Raw_context.T.consume_gas) c
                  (Gas_limit_repr.read_bytes_cost (Z.of_int len))) in
            let consume_write_gas {A : Set}
              (set :
                (|Raw_context|).(Raw_context.T.context) -> list string ->
                MBytes.t -> Lwt.t (Error_monad.tzresult A))
              (c : (|Raw_context|).(Raw_context.T.context))
              (v : (|V|).(Storage_sigs.VALUE.t))
              : Lwt.t (Error_monad.tzresult (A * MBytes.t)) :=
              let __bytes_value := to_bytes v in
              let len := MBytes.length __bytes_value in
              let=? c :=
                Lwt.__return
                  ((|Raw_context|).(Raw_context.T.consume_gas) c
                    (Gas_limit_repr.write_bytes_cost (Z.of_int len))) in
              let=? c := set c len_name (encode_len_value __bytes_value) in
              Error_monad.__return (c, __bytes_value) in
            let consume_remove_gas {A : Set}
              (del :
                (|Raw_context|).(Raw_context.T.context) -> list string ->
                Lwt.t (Error_monad.tzresult A))
              (c : (|Raw_context|).(Raw_context.T.context))
              : Lwt.t (Error_monad.tzresult A) :=
              let=? c :=
                Lwt.__return
                  ((|Raw_context|).(Raw_context.T.consume_gas) c
                    (Gas_limit_repr.write_bytes_cost Z.zero)) in
              del c len_name in
            let mem (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t (Error_monad.tzresult (Raw_context.root_context * bool)) :=
              let=? c := consume_mem_gas (pack s i) in
              let= res := (|Raw_context|).(Raw_context.T.mem) c data_name in
              Error_monad.__return
                (((|Raw_context|).(Raw_context.T.project) c), res) in
            let get (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t
                (Error_monad.tzresult
                  (Raw_context.root_context * (|V|).(Storage_sigs.VALUE.t))) :=
              let=? c :=
                consume_read_gas (|Raw_context|).(Raw_context.T.get) (pack s i)
                in
              let=? __b_value := (|Raw_context|).(Raw_context.T.get) c data_name
                in
              let __key_value :=
                (|Raw_context|).(Raw_context.T.absolute_key) c data_name in
              let=? v := Lwt.__return (of_bytes __key_value __b_value) in
              Error_monad.__return
                (((|Raw_context|).(Raw_context.T.project) c), v) in
            let get_option
              (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t
                (Error_monad.tzresult
                  (Raw_context.root_context *
                    option (|V|).(Storage_sigs.VALUE.t))) :=
              let=? c := consume_mem_gas (pack s i) in
              let '(s, _) := unpack c in
              let= __exists :=
                (|Raw_context|).(Raw_context.T.mem) (pack s i) data_name in
              if __exists then
                let=? '(s, v) := get s i in
                Error_monad.__return (s, (Some v))
              else
                Error_monad.__return (((|C|).(Raw_context.T.project) s), None)
              in
            let set
              (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              (v : (|V|).(Storage_sigs.VALUE.t))
              : Lwt.t (Error_monad.tzresult (Raw_context.root_context * int)) :=
              let=? '(prev_size, _) := existing_size (pack s i) in
              let=? '(c, __bytes_value) :=
                consume_write_gas (|Raw_context|).(Raw_context.T.set) (pack s i)
                  v in
              let=? c :=
                (|Raw_context|).(Raw_context.T.set) c data_name __bytes_value in
              let size_diff :=
                Pervasives.op_minus (MBytes.length __bytes_value) prev_size in
              Error_monad.__return
                (((|Raw_context|).(Raw_context.T.project) c), size_diff) in
            let init
              (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              (v : (|V|).(Storage_sigs.VALUE.t))
              : Lwt.t (Error_monad.tzresult (Raw_context.root_context * int)) :=
              let=? '(c, __bytes_value) :=
                consume_write_gas (|Raw_context|).(Raw_context.T.init)
                  (pack s i) v in
              let=? c :=
                (|Raw_context|).(Raw_context.T.init) c data_name __bytes_value
                in
              let size := MBytes.length __bytes_value in
              Error_monad.__return
                (((|Raw_context|).(Raw_context.T.project) c), size) in
            let init_set
              (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              (v : (|V|).(Storage_sigs.VALUE.t))
              : Lwt.t
                (Error_monad.tzresult (Raw_context.root_context * int * bool)) :=
              let init_set
                (c : (|Raw_context|).(Raw_context.T.context))
                (k : Raw_context.key) (v : Raw_context.value)
                : Lwt.t
                  (Error_monad.tzresult (|Raw_context|).(Raw_context.T.context)) :=
                Error_monad.op_gtgteq
                  ((|Raw_context|).(Raw_context.T.init_set) c k v)
                  Error_monad.__return in
              let=? '(prev_size, existed) := existing_size (pack s i) in
              let=? '(c, __bytes_value) :=
                consume_write_gas init_set (pack s i) v in
              let=? c := init_set c data_name __bytes_value in
              let size_diff :=
                Pervasives.op_minus (MBytes.length __bytes_value) prev_size in
              Error_monad.__return
                (((|Raw_context|).(Raw_context.T.project) c), size_diff, existed)
              in
            let remove (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t
                (Error_monad.tzresult (Raw_context.root_context * int * bool)) :=
              let remove
                (c : (|Raw_context|).(Raw_context.T.context))
                (k : Raw_context.key)
                : Lwt.t
                  (Error_monad.tzresult (|Raw_context|).(Raw_context.T.context)) :=
                Error_monad.op_gtgteq
                  ((|Raw_context|).(Raw_context.T.remove) c k)
                  Error_monad.__return in
              let=? '(prev_size, existed) := existing_size (pack s i) in
              let=? c := consume_remove_gas remove (pack s i) in
              let=? c := remove c data_name in
              Error_monad.__return
                (((|Raw_context|).(Raw_context.T.project) c), prev_size, existed)
              in
            let delete (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t (Error_monad.tzresult (Raw_context.root_context * int)) :=
              let=? '(prev_size, _) := existing_size (pack s i) in
              let=? c :=
                consume_remove_gas (|Raw_context|).(Raw_context.T.delete)
                  (pack s i) in
              let=? c := (|Raw_context|).(Raw_context.T.delete) c data_name in
              Error_monad.__return
                (((|Raw_context|).(Raw_context.T.project) c), prev_size) in
            let set_option
              (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              (v : option (|V|).(Storage_sigs.VALUE.t))
              : Lwt.t
                (Error_monad.tzresult (Raw_context.root_context * int * bool)) :=
              match v with
              | None => remove s i
              | Some v => init_set s i v
              end in
            (* ❌ top_level_evaluation *)
            existT (A := unit) (fun _ => _) tt
              {|
                Storage_sigs.Non_iterable_indexed_carbonated_data_storage.tag_Non_iterable_indexed_carbonated_data_storage :=
                  tag_Non_iterable_indexed_carbonated_data_storage;
                Storage_sigs.Non_iterable_indexed_carbonated_data_storage.mem :=
                  mem;
                Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get :=
                  get;
                Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get_option :=
                  get_option;
                Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set :=
                  set;
                Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init :=
                  init;
                Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init_set :=
                  init_set;
                Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set_option :=
                  set_option;
                Storage_sigs.Non_iterable_indexed_carbonated_data_storage.delete :=
                  delete;
                Storage_sigs.Non_iterable_indexed_carbonated_data_storage.remove :=
                  remove
              |})
              :
                {_ : unit &
                  Non_iterable_indexed_carbonated_data_storage.signature t key
                    (|V|).(Storage_sigs.VALUE.t)}) in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.Indexed_raw_context.clear := clear;
          Storage_sigs.Indexed_raw_context.fold_keys {_} := fold_keys;
          Storage_sigs.Indexed_raw_context.keys := keys;
          Storage_sigs.Indexed_raw_context.resolve := resolve;
          Storage_sigs.Indexed_raw_context.remove_rec := remove_rec;
          Storage_sigs.Indexed_raw_context.copy := copy;
          Storage_sigs.Indexed_raw_context.Make_set := Make_set;
          Storage_sigs.Indexed_raw_context.Make_map := Make_map;
          Storage_sigs.Indexed_raw_context.Make_carbonated_map :=
            Make_carbonated_map;
          Storage_sigs.Indexed_raw_context.Raw_context := (|Raw_context|)
        |})
        :
          {_ : unit &
            Indexed_raw_context.signature (|C|).(Raw_context.T.t)
              (|I|).(INDEX.t) (fun (a : Set) => (|I|).(INDEX.ipath) a)}).

Module WRAPPER.
  Record signature {t key : Set} : Set := {
    t := t;
    key := key;
    wrap : t -> key;
    unwrap : key -> option t;
  }.
  Arguments signature : clear implicits.
End WRAPPER.

Definition Wrap_indexed_data_storage :=
  fun
    (C :
      {'[t, key, value] : [Set ** Set ** Set] &
        Indexed_data_storage.signature t key value}) =>
    fun
      (K :
        {t : Set &
          WRAPPER.signature t (|C|).(Storage_sigs.Indexed_data_storage.key)}) =>
      ((let tag_Non_iterable_indexed_data_storage := tt in
      let t := (|C|).(Storage_sigs.Indexed_data_storage.t) in
      let context := (|C|).(Storage_sigs.Indexed_data_storage.t) in
      let key := (|K|).(WRAPPER.t) in
      let value := (|C|).(Storage_sigs.Indexed_data_storage.value) in
      let mem
        (ctxt : (|C|).(Storage_sigs.Indexed_data_storage.context))
        (k : (|K|).(WRAPPER.t)) : Lwt.t bool :=
        (|C|).(Storage_sigs.Indexed_data_storage.mem) ctxt
          ((|K|).(WRAPPER.wrap) k) in
      let get
        (ctxt : (|C|).(Storage_sigs.Indexed_data_storage.context))
        (k : (|K|).(WRAPPER.t))
        : Lwt.t
          (Error_monad.tzresult (|C|).(Storage_sigs.Indexed_data_storage.value)) :=
        (|C|).(Storage_sigs.Indexed_data_storage.get) ctxt
          ((|K|).(WRAPPER.wrap) k) in
      let get_option
        (ctxt : (|C|).(Storage_sigs.Indexed_data_storage.context))
        (k : (|K|).(WRAPPER.t))
        : Lwt.t
          (Error_monad.tzresult
            (option (|C|).(Storage_sigs.Indexed_data_storage.value))) :=
        (|C|).(Storage_sigs.Indexed_data_storage.get_option) ctxt
          ((|K|).(WRAPPER.wrap) k) in
      let set
        (ctxt : (|C|).(Storage_sigs.Indexed_data_storage.context))
        (k : (|K|).(WRAPPER.t))
        (v : (|C|).(Storage_sigs.Indexed_data_storage.value))
        : Lwt.t (Error_monad.tzresult Raw_context.t) :=
        (|C|).(Storage_sigs.Indexed_data_storage.set) ctxt
          ((|K|).(WRAPPER.wrap) k) v in
      let init
        (ctxt : (|C|).(Storage_sigs.Indexed_data_storage.context))
        (k : (|K|).(WRAPPER.t))
        (v : (|C|).(Storage_sigs.Indexed_data_storage.value))
        : Lwt.t (Error_monad.tzresult Raw_context.t) :=
        (|C|).(Storage_sigs.Indexed_data_storage.init) ctxt
          ((|K|).(WRAPPER.wrap) k) v in
      let init_set
        (ctxt : (|C|).(Storage_sigs.Indexed_data_storage.context))
        (k : (|K|).(WRAPPER.t))
        (v : (|C|).(Storage_sigs.Indexed_data_storage.value))
        : Lwt.t Raw_context.t :=
        (|C|).(Storage_sigs.Indexed_data_storage.init_set) ctxt
          ((|K|).(WRAPPER.wrap) k) v in
      let set_option
        (ctxt : (|C|).(Storage_sigs.Indexed_data_storage.context))
        (k : (|K|).(WRAPPER.t))
        (v : option (|C|).(Storage_sigs.Indexed_data_storage.value))
        : Lwt.t Raw_context.t :=
        (|C|).(Storage_sigs.Indexed_data_storage.set_option) ctxt
          ((|K|).(WRAPPER.wrap) k) v in
      let delete
        (ctxt : (|C|).(Storage_sigs.Indexed_data_storage.context))
        (k : (|K|).(WRAPPER.t)) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
        (|C|).(Storage_sigs.Indexed_data_storage.delete) ctxt
          ((|K|).(WRAPPER.wrap) k) in
      let remove
        (ctxt : (|C|).(Storage_sigs.Indexed_data_storage.context))
        (k : (|K|).(WRAPPER.t)) : Lwt.t Raw_context.t :=
        (|C|).(Storage_sigs.Indexed_data_storage.remove) ctxt
          ((|K|).(WRAPPER.wrap) k) in
      let clear (ctxt : (|C|).(Storage_sigs.Indexed_data_storage.context))
        : Lwt.t Raw_context.t :=
        (|C|).(Storage_sigs.Indexed_data_storage.clear) ctxt in
      let fold {A : Set}
        (ctxt : (|C|).(Storage_sigs.Indexed_data_storage.context)) (init : A)
        (f :
          (|K|).(WRAPPER.t) ->
          (|C|).(Storage_sigs.Indexed_data_storage.value) -> A -> Lwt.t A)
        : Lwt.t A :=
        (|C|).(Storage_sigs.Indexed_data_storage.fold) ctxt init
          (fun k =>
            fun v =>
              fun acc =>
                match (|K|).(WRAPPER.unwrap) k with
                | None => Lwt.__return acc
                | Some k => f k v acc
                end) in
      let bindings (s : (|C|).(Storage_sigs.Indexed_data_storage.context))
        : Lwt.t
          (list
            ((|K|).(WRAPPER.t) * (|C|).(Storage_sigs.Indexed_data_storage.value))) :=
        fold s (nil (A := key * value))
          (fun __p_value =>
            fun v => fun acc => Lwt.__return (cons (__p_value, v) acc)) in
      let fold_keys {A : Set}
        (s : (|C|).(Storage_sigs.Indexed_data_storage.context)) (init : A)
        (f : (|K|).(WRAPPER.t) -> A -> Lwt.t A) : Lwt.t A :=
        (|C|).(Storage_sigs.Indexed_data_storage.fold_keys) s init
          (fun k =>
            fun acc =>
              match (|K|).(WRAPPER.unwrap) k with
              | None => Lwt.__return acc
              | Some k => f k acc
              end) in
      let keys (s : (|C|).(Storage_sigs.Indexed_data_storage.context))
        : Lwt.t (list (|K|).(WRAPPER.t)) :=
        fold_keys s (nil (A := key))
          (fun __p_value => fun acc => Lwt.__return (cons __p_value acc)) in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.Indexed_data_storage.tag_Non_iterable_indexed_data_storage :=
            tag_Non_iterable_indexed_data_storage;
          Storage_sigs.Indexed_data_storage.mem := mem;
          Storage_sigs.Indexed_data_storage.get := get;
          Storage_sigs.Indexed_data_storage.get_option := get_option;
          Storage_sigs.Indexed_data_storage.set := set;
          Storage_sigs.Indexed_data_storage.init := init;
          Storage_sigs.Indexed_data_storage.init_set := init_set;
          Storage_sigs.Indexed_data_storage.set_option := set_option;
          Storage_sigs.Indexed_data_storage.delete := delete;
          Storage_sigs.Indexed_data_storage.remove := remove;
          Storage_sigs.Indexed_data_storage.clear := clear;
          Storage_sigs.Indexed_data_storage.keys := keys;
          Storage_sigs.Indexed_data_storage.bindings := bindings;
          Storage_sigs.Indexed_data_storage.fold {_} := fold;
          Storage_sigs.Indexed_data_storage.fold_keys {_} := fold_keys
        |})
        :
          {_ : unit &
            Indexed_data_storage.signature
              (|C|).(Storage_sigs.Indexed_data_storage.t) (|K|).(WRAPPER.t)
              (|C|).(Storage_sigs.Indexed_data_storage.value)}).
