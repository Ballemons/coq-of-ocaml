(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Contract_repr.
Require Tezos.Raw_context.
Require Tezos.Script_expr_hash.
Require Tezos.Script_repr.
Require Tezos.Tez_repr.

(* extensible_type_definition `error` *)

Parameter __exists :
  Raw_context.t -> Contract_repr.t -> Lwt.t (Error_monad.tzresult bool).

Parameter must_exist :
  Raw_context.t -> Contract_repr.t -> Lwt.t (Error_monad.tzresult unit).

Parameter allocated :
  Raw_context.t -> Contract_repr.t -> Lwt.t (Error_monad.tzresult bool).

Parameter must_be_allocated :
  Raw_context.t -> Contract_repr.t -> Lwt.t (Error_monad.tzresult unit).

Parameter __list_value : Raw_context.t -> Lwt.t (list Contract_repr.t).

Parameter check_counter_increment :
  Raw_context.t -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
  Z.t -> Lwt.t (Error_monad.tzresult unit).

Parameter increment_counter :
  Raw_context.t -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter get_manager_key :
  Raw_context.t -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
  Lwt.t (Error_monad.tzresult (|Signature.Public_key|).(S.SPublic_key.t)).

Parameter is_manager_key_revealed :
  Raw_context.t -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
  Lwt.t (Error_monad.tzresult bool).

Parameter reveal_manager_key :
  Raw_context.t -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
  (|Signature.Public_key|).(S.SPublic_key.t) ->
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter get_balance :
  Raw_context.t -> Contract_repr.t -> Lwt.t (Error_monad.tzresult Tez_repr.t).

Parameter get_counter :
  Raw_context.t -> (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
  Lwt.t (Error_monad.tzresult Z.t).

Parameter get_script_code :
  Raw_context.t -> Contract_repr.t ->
  Lwt.t (Error_monad.tzresult (Raw_context.t * option Script_repr.lazy_expr)).

Parameter get_script :
  Raw_context.t -> Contract_repr.t ->
  Lwt.t (Error_monad.tzresult (Raw_context.t * option Script_repr.t)).

Parameter get_storage :
  Raw_context.t -> Contract_repr.t ->
  Lwt.t (Error_monad.tzresult (Raw_context.t * option Script_repr.expr)).

Module ConstructorRecords_big_map_diff_item.
  Module big_map_diff_item.
    Module Update.
      Record record {big_map diff_key diff_key_hash diff_value : Set} : Set := Build {
        big_map : big_map;
        diff_key : diff_key;
        diff_key_hash : diff_key_hash;
        diff_value : diff_value }.
      Arguments record : clear implicits.
      Definition with_big_map
        {t_big_map t_diff_key t_diff_key_hash t_diff_value} big_map
        (r : record t_big_map t_diff_key t_diff_key_hash t_diff_value) :=
        Build t_big_map t_diff_key t_diff_key_hash t_diff_value big_map
          r.(diff_key) r.(diff_key_hash) r.(diff_value).
      Definition with_diff_key
        {t_big_map t_diff_key t_diff_key_hash t_diff_value} diff_key
        (r : record t_big_map t_diff_key t_diff_key_hash t_diff_value) :=
        Build t_big_map t_diff_key t_diff_key_hash t_diff_value r.(big_map)
          diff_key r.(diff_key_hash) r.(diff_value).
      Definition with_diff_key_hash
        {t_big_map t_diff_key t_diff_key_hash t_diff_value} diff_key_hash
        (r : record t_big_map t_diff_key t_diff_key_hash t_diff_value) :=
        Build t_big_map t_diff_key t_diff_key_hash t_diff_value r.(big_map)
          r.(diff_key) diff_key_hash r.(diff_value).
      Definition with_diff_value
        {t_big_map t_diff_key t_diff_key_hash t_diff_value} diff_value
        (r : record t_big_map t_diff_key t_diff_key_hash t_diff_value) :=
        Build t_big_map t_diff_key t_diff_key_hash t_diff_value r.(big_map)
          r.(diff_key) r.(diff_key_hash) diff_value.
    End Update.
    Definition Update_skeleton := Update.record.
    
    Module Alloc.
      Record record {big_map key_type value_type : Set} : Set := Build {
        big_map : big_map;
        key_type : key_type;
        value_type : value_type }.
      Arguments record : clear implicits.
      Definition with_big_map {t_big_map t_key_type t_value_type} big_map
        (r : record t_big_map t_key_type t_value_type) :=
        Build t_big_map t_key_type t_value_type big_map r.(key_type)
          r.(value_type).
      Definition with_key_type {t_big_map t_key_type t_value_type} key_type
        (r : record t_big_map t_key_type t_value_type) :=
        Build t_big_map t_key_type t_value_type r.(big_map) key_type
          r.(value_type).
      Definition with_value_type {t_big_map t_key_type t_value_type} value_type
        (r : record t_big_map t_key_type t_value_type) :=
        Build t_big_map t_key_type t_value_type r.(big_map) r.(key_type)
          value_type.
    End Alloc.
    Definition Alloc_skeleton := Alloc.record.
  End big_map_diff_item.
End ConstructorRecords_big_map_diff_item.
Import ConstructorRecords_big_map_diff_item.

Reserved Notation "'big_map_diff_item.Update".
Reserved Notation "'big_map_diff_item.Alloc".

Inductive big_map_diff_item : Set :=
| Update : 'big_map_diff_item.Update -> big_map_diff_item
| Clear : Z.t -> big_map_diff_item
| Copy : Z.t -> Z.t -> big_map_diff_item
| Alloc : 'big_map_diff_item.Alloc -> big_map_diff_item

where "'big_map_diff_item.Update" :=
  (big_map_diff_item.Update_skeleton Z.t Script_repr.expr Script_expr_hash.t
    (option Script_repr.expr))
and "'big_map_diff_item.Alloc" :=
  (big_map_diff_item.Alloc_skeleton Z.t Script_repr.expr Script_repr.expr).

Module big_map_diff_item.
  Include ConstructorRecords_big_map_diff_item.big_map_diff_item.
  Definition Update := 'big_map_diff_item.Update.
  Definition Alloc := 'big_map_diff_item.Alloc.
End big_map_diff_item.

Definition big_map_diff : Set := list big_map_diff_item.

Parameter big_map_diff_encoding : Data_encoding.t big_map_diff.

Parameter update_script_storage :
  Raw_context.t -> Contract_repr.t -> Script_repr.expr -> option big_map_diff ->
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter credit :
  Raw_context.t -> Contract_repr.t -> Tez_repr.t ->
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter spend :
  Raw_context.t -> Contract_repr.t -> Tez_repr.t ->
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter originate_raw :
  Raw_context.t -> option bool -> Contract_repr.t -> Tez_repr.t ->
  Script_repr.t * option big_map_diff ->
  option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter fresh_contract_from_current_nonce :
  Raw_context.t ->
  Lwt.t (Error_monad.tzresult (Raw_context.t * Contract_repr.t)).

Parameter originated_from_current_nonce :
  Raw_context.t -> Raw_context.t ->
  Lwt.t (Error_monad.tzresult (list Contract_repr.t)).

Parameter init : Raw_context.t -> Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter used_storage_space :
  Raw_context.t -> Contract_repr.t -> Lwt.t (Error_monad.tzresult Z.t).

Parameter paid_storage_space :
  Raw_context.t -> Contract_repr.t -> Lwt.t (Error_monad.tzresult Z.t).

Parameter set_paid_storage_space_and_return_fees_to_pay :
  Raw_context.t -> Contract_repr.t -> Z.t ->
  Lwt.t (Error_monad.tzresult (Z.t * Raw_context.t)).
