(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Unset Positivity Checking.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Constants_repr.
Require Tezos.Constants_storage.
Require Tezos.Contract_repr.
Require Tezos.Cycle_repr.
Require Tezos.Level_repr.
Require Tezos.Manager_repr.
Require Tezos.Misc.
Require Tezos.Raw_context.
Require Tezos.Roll_repr.
Require Tezos.Seed_repr.
Require Tezos.Seed_storage.
Require Tezos.Storage_mli. Module Storage := Storage_mli.
Require Tezos.Storage_sigs.
Require Tezos.Tez_repr.

Import Misc.

(* ❌ Structure item `typext` not handled. *)
(* type_extension *)

(* ❌ Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition get_contract_delegate
  (c : (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.context))
  (contract :
    (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t
    (Error_monad.tzresult
      (option
        (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.value))) :=
  (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.get_option) c
    contract.

Definition delegate_pubkey
  (ctxt :
    (|Storage.Contract.Manager|).(Storage_sigs.Indexed_data_storage.context))
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.tzresult (|Signature.Public_key|).(S.SPublic_key.t)) :=
  Error_monad.op_gtgteqquestion
    ((|Storage.Contract.Manager|).(Storage_sigs.Indexed_data_storage.get_option)
      ctxt (Contract_repr.implicit_contract delegate))
    (fun function_parameter =>
      match function_parameter with
      | (None | Some (Manager_repr.Hash _)) =>
        Error_monad.fail extensible_type_value
      | Some (Manager_repr.Public_key pk) => Error_monad.__return pk
      end).

Definition clear_cycle
  (c :
    (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.context))
  (cycle :
    (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Error_monad.op_gtgteqquestion
    ((|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.get)
      c cycle)
    (fun index =>
      Error_monad.op_gtgteqquestion
        ((|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.delete)
          c cycle)
        (fun c =>
          Error_monad.op_gtgteqquestion
            ((|Storage.Roll.Last_for_snapshot|).(Storage_sigs.Indexed_data_storage.delete)
              (c, cycle) index)
            (fun c =>
              Error_monad.op_gtgteq
                ((|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.delete_snapshot)
                  c (cycle, index)) (fun c => Error_monad.__return c)))).

Definition fold {A : Set}
  (ctxt : (|Storage.Roll.Next|).(Storage_sigs.Single_data_storage.context))
  (f :
    Roll_repr.roll ->
    (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.value)
    -> A -> Lwt.t (Error_monad.tzresult A)) (init : A)
  : Lwt.t (Error_monad.tzresult A) :=
  Error_monad.op_gtgteqquestion
    ((|Storage.Roll.Next|).(Storage_sigs.Single_data_storage.get) ctxt)
    (fun last =>
      let fix loop
        (ctxt :
          (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.context))
        (roll : Roll_repr.roll) (acc : Lwt.t (Error_monad.tzresult A))
        {struct ctxt} : Lwt.t (Error_monad.tzresult A) :=
        Error_monad.op_gtgteqquestion acc
          (fun acc =>
            if Roll_repr.op_eq roll last then
              Error_monad.__return acc
            else
              Error_monad.op_gtgteqquestion
                ((|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.get_option)
                  ctxt roll)
                (fun function_parameter =>
                  match function_parameter with
                  | None =>
                    loop ctxt (Roll_repr.succ roll) (Error_monad.__return acc)
                  | Some delegate =>
                    loop ctxt (Roll_repr.succ roll) (f roll delegate acc)
                  end)) in
      loop ctxt Roll_repr.first (Error_monad.__return init)).

Definition snapshot_rolls_for_cycle
  (ctxt :
    (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.context))
  (cycle :
    (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Error_monad.op_gtgteqquestion
    ((|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.get)
      ctxt cycle)
    (fun index =>
      Error_monad.op_gtgteqquestion
        ((|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.set)
          ctxt cycle (Pervasives.op_plus index 1))
        (fun ctxt =>
          Error_monad.op_gtgteqquestion
            ((|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.__snapshot_value)
              ctxt (cycle, index))
            (fun ctxt =>
              Error_monad.op_gtgteqquestion
                ((|Storage.Roll.Next|).(Storage_sigs.Single_data_storage.get)
                  ctxt)
                (fun last =>
                  Error_monad.op_gtgteqquestion
                    ((|Storage.Roll.Last_for_snapshot|).(Storage_sigs.Indexed_data_storage.init)
                      (ctxt, cycle) index last)
                    (fun ctxt => Error_monad.__return ctxt))))).

Definition freeze_rolls_for_cycle
  (ctxt :
    (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.context))
  (cycle :
    (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t
    (Error_monad.tzresult
      (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.context)) :=
  Error_monad.op_gtgteqquestion
    ((|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.get)
      ctxt cycle)
    (fun max_index =>
      Error_monad.op_gtgteqquestion (Storage.Seed.For_cycle.get ctxt cycle)
        (fun __seed_value =>
          let rd :=
            Seed_repr.initialize_new __seed_value
              [ MBytes.of_string "roll_snapshot" ] in
          let seq :=
            Seed_repr.__sequence_value rd
              (* ❌ Constant of type int32 is converted to int *)
              0 in
          let selected_index :=
            Pervasives.op_pipegt
              (Pervasives.op_pipegt
                (Seed_repr.take_int32 seq (Int32.of_int max_index))
                Pervasives.fst) Int32.to_int in
          Error_monad.op_gtgteqquestion
            ((|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.set)
              ctxt cycle selected_index)
            (fun ctxt =>
              Error_monad.op_gtgteqquestion
                (Error_monad.fold_left_s
                  (fun ctxt =>
                    fun index =>
                      if (|Compare.Int|).(Compare.S.op_eq) index selected_index
                        then
                        Error_monad.__return ctxt
                      else
                        Error_monad.op_gtgteq
                          ((|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.delete_snapshot)
                            ctxt (cycle, index))
                          (fun ctxt =>
                            Error_monad.op_gtgteqquestion
                              ((|Storage.Roll.Last_for_snapshot|).(Storage_sigs.Indexed_data_storage.delete)
                                (ctxt, cycle) index)
                              (fun ctxt => Error_monad.__return ctxt))) ctxt
                  (Misc.op_minusminusgt 0 (Pervasives.op_minus max_index 1)))
                (fun ctxt => Error_monad.__return ctxt)))).

Module Random.
  Definition int32_to_bytes (i : int32) : MBytes.t :=
    let b := MBytes.create 4 in
    (* ❌ Sequences of instructions are ignored (operator ";") *)
    (* ❌ instruction_sequence ";" *)
    b.
  
  Definition level_random
    (__seed_value : Seed_repr.seed) (use : string) (level : Level_repr.t)
    : Seed_repr.t :=
    let position := level.(Level_repr.t.cycle_position) in
    Seed_repr.initialize_new __seed_value
      [
        MBytes.of_string
          (Pervasives.op_caret "level " (Pervasives.op_caret use ":"));
        int32_to_bytes position
      ].
  
  Definition owner
    (c : Raw_context.t) (kind : string) (level : Level_repr.t) (offset : Z)
    : Lwt.t
      (Error_monad.tzresult
        (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.Snapshot).(Storage_sigs.Indexed_data_storage.value)) :=
    let cycle := level.(Level_repr.t.cycle) in
    Error_monad.op_gtgteqquestion (Seed_storage.for_cycle c cycle)
      (fun random_seed =>
        let rd := level_random random_seed kind level in
        let __sequence_value :=
          Seed_repr.__sequence_value rd (Int32.of_int offset) in
        Error_monad.op_gtgteqquestion
          ((|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.get)
            c cycle)
          (fun index =>
            Error_monad.op_gtgteqquestion
              ((|Storage.Roll.Last_for_snapshot|).(Storage_sigs.Indexed_data_storage.get)
                (c, cycle) index)
              (fun bound =>
                let fix loop (__sequence_value : Seed_repr.sequence)
                  {struct __sequence_value}
                  : Lwt.t
                    (Error_monad.tzresult
                      (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.Snapshot).(Storage_sigs.Indexed_data_storage.value)) :=
                  let '(roll, __sequence_value) :=
                    Roll_repr.random __sequence_value bound in
                  Error_monad.op_gtgteqquestion
                    ((|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.Snapshot).(Storage_sigs.Indexed_data_storage.get_option)
                      c ((cycle, index), roll))
                    (fun function_parameter =>
                      match function_parameter with
                      | None => loop __sequence_value
                      | Some delegate => Error_monad.__return delegate
                      end) in
                Error_monad.op_gtgteq
                  ((|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.snapshot_exists)
                    c (cycle, index))
                  (fun snapshot_exists =>
                    Error_monad.op_gtgteqquestion
                      (Error_monad.fail_unless snapshot_exists
                        extensible_type_value)
                      (fun function_parameter =>
                        let '_ := function_parameter in
                        loop __sequence_value))))).
End Random.

Definition baking_rights_owner
  (c : Raw_context.t) (level : Level_repr.t) (priority : Z)
  : Lwt.t
    (Error_monad.tzresult
      (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.Snapshot).(Storage_sigs.Indexed_data_storage.value)) :=
  Random.owner c "baking" level priority.

Definition endorsement_rights_owner
  (c : Raw_context.t) (level : Level_repr.t) (slot : Z)
  : Lwt.t
    (Error_monad.tzresult
      (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.Snapshot).(Storage_sigs.Indexed_data_storage.value)) :=
  Random.owner c "endorsement" level slot.

Definition traverse_rolls
  (ctxt : (|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.context))
  (head : (|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.value))
  : Lwt.t
    (Error_monad.tzresult
      (list (|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.value))) :=
  let fix loop
    (acc :
      list (|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.value))
    (roll : (|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.key))
    {struct acc}
    : Lwt.t
      (Error_monad.tzresult
        (list
          (|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.value))) :=
    Error_monad.op_gtgteqquestion
      ((|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.get_option)
        ctxt roll)
      (fun function_parameter =>
        match function_parameter with
        | None => Error_monad.__return (List.rev acc)
        | Some next => loop (cons next acc) next
        end) in
  loop [ head ] head.

Definition get_rolls
  (ctxt :
    (|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.context))
  (delegate :
    (|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t
    (Error_monad.tzresult
      (list (|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.value))) :=
  Error_monad.op_gtgteqquestion
    ((|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.get_option)
      ctxt delegate)
    (fun function_parameter =>
      match function_parameter with
      | None => Error_monad.return_nil
      | Some head_roll => traverse_rolls ctxt head_roll
      end).

Definition count_rolls
  (ctxt :
    (|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.context))
  (delegate :
    (|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t (Error_monad.tzresult Z) :=
  Error_monad.op_gtgteqquestion
    ((|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.get_option)
      ctxt delegate)
    (fun function_parameter =>
      match function_parameter with
      | None => Error_monad.__return 0
      | Some head_roll =>
        let fix loop
          (acc : Z)
          (roll :
            (|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.key))
          {struct acc} : Lwt.t (Error_monad.tzresult Z) :=
          Error_monad.op_gtgteqquestion
            ((|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.get_option)
              ctxt roll)
            (fun function_parameter =>
              match function_parameter with
              | None => Error_monad.__return acc
              | Some next => loop (Pervasives.succ acc) next
              end) in
        loop 1 head_roll
      end).

Definition get_change
  (c :
    (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.context))
  (delegate :
    (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t (Error_monad.tzresult Tez_repr.t) :=
  Error_monad.op_gtgteqquestion
    ((|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.get_option)
      c delegate)
    (fun function_parameter =>
      match function_parameter with
      | None => Error_monad.__return Tez_repr.zero
      | Some change => Error_monad.__return change
      end).

Module Delegate.
  Definition fresh_roll
    (c : (|Storage.Roll.Next|).(Storage_sigs.Single_data_storage.context))
    : Lwt.t
      (Error_monad.tzresult
        ((|Storage.Roll.Next|).(Storage_sigs.Single_data_storage.value) *
          Raw_context.t)) :=
    Error_monad.op_gtgteqquestion
      ((|Storage.Roll.Next|).(Storage_sigs.Single_data_storage.get) c)
      (fun roll =>
        Error_monad.op_gtgteqquestion
          ((|Storage.Roll.Next|).(Storage_sigs.Single_data_storage.set) c
            (Roll_repr.succ roll)) (fun c => Error_monad.__return (roll, c))).
  
  Definition get_limbo_roll
    (c : (|Storage.Roll.Limbo|).(Storage_sigs.Single_data_storage.context))
    : Lwt.t
      (Error_monad.tzresult
        ((|Storage.Roll.Next|).(Storage_sigs.Single_data_storage.value) *
          Raw_context.t)) :=
    Error_monad.op_gtgteqquestion
      ((|Storage.Roll.Limbo|).(Storage_sigs.Single_data_storage.get_option) c)
      (fun function_parameter =>
        match function_parameter with
        | None =>
          Error_monad.op_gtgteqquestion (fresh_roll c)
            (fun function_parameter =>
              let '(roll, c) := function_parameter in
              Error_monad.op_gtgteqquestion
                ((|Storage.Roll.Limbo|).(Storage_sigs.Single_data_storage.init)
                  c roll) (fun c => Error_monad.__return (roll, c)))
        | Some roll => Error_monad.__return (roll, c)
        end).
  
  Definition consume_roll_change
    (c : Raw_context.context)
    (delegate :
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.key))
    : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    let tokens_per_roll := Constants_storage.tokens_per_roll c in
    Error_monad.op_gtgteqquestion
      ((|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.get)
        c delegate)
      (fun change =>
        Error_monad.op_gtgteqquestion
          (Error_monad.trace extensible_type_value
            (Lwt.__return (Tez_repr.op_minusquestion change tokens_per_roll)))
          (fun new_change =>
            (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.set)
              c delegate new_change)).
  
  Definition recover_roll_change
    (c : Raw_context.context)
    (delegate :
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.key))
    : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    let tokens_per_roll := Constants_storage.tokens_per_roll c in
    Error_monad.op_gtgteqquestion
      ((|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.get)
        c delegate)
      (fun change =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Tez_repr.op_plusquestion change tokens_per_roll))
          (fun new_change =>
            (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.set)
              c delegate new_change)).
  
  Definition pop_roll_from_delegate
    (c : Raw_context.context)
    (delegate :
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.key))
    : Lwt.t
      (Error_monad.tzresult
        ((|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.value)
          * Raw_context.t)) :=
    Error_monad.op_gtgteqquestion (recover_roll_change c delegate)
      (fun c =>
        Error_monad.op_gtgteqquestion
          ((|Storage.Roll.Limbo|).(Storage_sigs.Single_data_storage.get_option)
            c)
          (fun limbo_head =>
            Error_monad.op_gtgteqquestion
              ((|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.get_option)
                c delegate)
              (fun function_parameter =>
                match function_parameter with
                | None => Error_monad.fail extensible_type_value
                | Some roll =>
                  Error_monad.op_gtgteqquestion
                    ((|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.delete)
                      c roll)
                    (fun c =>
                      Error_monad.op_gtgteqquestion
                        ((|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.get_option)
                          c roll)
                        (fun successor_roll =>
                          Error_monad.op_gtgteq
                            ((|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.set_option)
                              c delegate successor_roll)
                            (fun c =>
                              Error_monad.op_gtgteq
                                ((|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.set_option)
                                  c roll limbo_head)
                                (fun c =>
                                  Error_monad.op_gtgteq
                                    ((|Storage.Roll.Limbo|).(Storage_sigs.Single_data_storage.init_set)
                                      c roll)
                                    (fun c => Error_monad.__return (roll, c))))))
                end))).
  
  Definition create_roll_in_delegate
    (c : Raw_context.context)
    (delegate :
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.key))
    (delegate_pk :
      (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.value))
    : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    Error_monad.op_gtgteqquestion (consume_roll_change c delegate)
      (fun c =>
        Error_monad.op_gtgteqquestion
          ((|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.get_option)
            c delegate)
          (fun delegate_head =>
            Error_monad.op_gtgteqquestion (get_limbo_roll c)
              (fun function_parameter =>
                let '(roll, c) := function_parameter in
                Error_monad.op_gtgteqquestion
                  ((|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.init)
                    c roll delegate_pk)
                  (fun c =>
                    Error_monad.op_gtgteqquestion
                      ((|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.get_option)
                        c roll)
                      (fun limbo_successor =>
                        Error_monad.op_gtgteq
                          ((|Storage.Roll.Limbo|).(Storage_sigs.Single_data_storage.set_option)
                            c limbo_successor)
                          (fun c =>
                            Error_monad.op_gtgteq
                              ((|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.set_option)
                                c roll delegate_head)
                              (fun c =>
                                Error_monad.op_gtgteq
                                  ((|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.init_set)
                                    c delegate roll)
                                  (fun c => Error_monad.__return c)))))))).
  
  Definition ensure_inited
    (c :
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.context))
    (delegate :
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.key))
    : Lwt.t
      (Error_monad.tzresult
        (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.context)) :=
    Error_monad.op_gtgteq
      ((|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.mem)
        c delegate)
      (fun function_parameter =>
        match function_parameter with
        | true => Error_monad.__return c
        | false =>
          (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.init)
            c delegate Tez_repr.zero
        end).
  
  Definition is_inactive
    (c :
      (|Storage.Contract.Inactive_delegate|).(Storage_sigs.Data_set_storage.context))
    (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
    : Lwt.t (Error_monad.tzresult bool) :=
    Error_monad.op_gtgteq
      ((|Storage.Contract.Inactive_delegate|).(Storage_sigs.Data_set_storage.mem)
        c (Contract_repr.implicit_contract delegate))
      (fun inactive =>
        if inactive then
          Error_monad.__return inactive
        else
          Error_monad.op_gtgteqquestion
            ((|Storage.Contract.Delegate_desactivation|).(Storage_sigs.Indexed_data_storage.get_option)
              c (Contract_repr.implicit_contract delegate))
            (fun function_parameter =>
              match function_parameter with
              | Some last_active_cycle =>
                let '{| Level_repr.t.cycle := current_cycle |} :=
                  Raw_context.current_level c in
                Error_monad.__return
                  (Cycle_repr.op_lt last_active_cycle current_cycle)
              | None => Error_monad.return_false
              end)).
  
  Definition add_amount
    (c :
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.context))
    (delegate :
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.key))
    (amount : Tez_repr.t) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    Error_monad.op_gtgteqquestion (ensure_inited c delegate)
      (fun c =>
        let tokens_per_roll := Constants_storage.tokens_per_roll c in
        Error_monad.op_gtgteqquestion
          ((|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.get)
            c delegate)
          (fun change =>
            Error_monad.op_gtgteqquestion
              (Lwt.__return (Tez_repr.op_plusquestion amount change))
              (fun change =>
                Error_monad.op_gtgteqquestion
                  ((|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.set)
                    c delegate change)
                  (fun c =>
                    Error_monad.op_gtgteqquestion (delegate_pubkey c delegate)
                      (fun delegate_pk =>
                        let fix loop
                          (c : Raw_context.context) (change : Tez_repr.t)
                          {struct c}
                          : Lwt.t (Error_monad.tzresult Raw_context.context) :=
                          if Tez_repr.op_lt change tokens_per_roll then
                            Error_monad.__return c
                          else
                            Error_monad.op_gtgteqquestion
                              (Lwt.__return
                                (Tez_repr.op_minusquestion change
                                  tokens_per_roll))
                              (fun change =>
                                Error_monad.op_gtgteqquestion
                                  (create_roll_in_delegate c delegate
                                    delegate_pk) (fun c => loop c change)) in
                        Error_monad.op_gtgteqquestion (is_inactive c delegate)
                          (fun inactive =>
                            if inactive then
                              Error_monad.__return c
                            else
                              Error_monad.op_gtgteqquestion (loop c change)
                                (fun c =>
                                  Error_monad.op_gtgteqquestion
                                    ((|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.get_option)
                                      c delegate)
                                    (fun rolls =>
                                      match rolls with
                                      | None => Error_monad.__return c
                                      | Some _ =>
                                        Error_monad.op_gtgteq
                                          ((|Storage.Active_delegates_with_rolls|).(Storage_sigs.Data_set_storage.add)
                                            c delegate)
                                          (fun c => Error_monad.__return c)
                                      end)))))))).
  
  Definition remove_amount
    (c : Raw_context.context)
    (delegate :
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.key))
    (amount : Tez_repr.t) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    let tokens_per_roll := Constants_storage.tokens_per_roll c in
    let fix loop (c : Raw_context.context) (change : Tez_repr.t) {struct c}
      : Lwt.t (Error_monad.tzresult (Raw_context.context * Tez_repr.t)) :=
      if Tez_repr.op_lteq amount change then
        Error_monad.__return (c, change)
      else
        Error_monad.op_gtgteqquestion (pop_roll_from_delegate c delegate)
          (fun function_parameter =>
            let '(_, c) := function_parameter in
            Error_monad.op_gtgteqquestion
              (Lwt.__return (Tez_repr.op_plusquestion change tokens_per_roll))
              (fun change => loop c change)) in
    Error_monad.op_gtgteqquestion
      ((|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.get)
        c delegate)
      (fun change =>
        Error_monad.op_gtgteqquestion (is_inactive c delegate)
          (fun inactive =>
            Error_monad.op_gtgteqquestion
              (if inactive then
                Error_monad.__return (c, change)
              else
                Error_monad.op_gtgteqquestion (loop c change)
                  (fun function_parameter =>
                    let '(c, change) := function_parameter in
                    Error_monad.op_gtgteqquestion
                      ((|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.get_option)
                        c delegate)
                      (fun rolls =>
                        match rolls with
                        | None =>
                          Error_monad.op_gtgteq
                            ((|Storage.Active_delegates_with_rolls|).(Storage_sigs.Data_set_storage.del)
                              c delegate)
                            (fun c => Error_monad.__return (c, change))
                        | Some _ => Error_monad.__return (c, change)
                        end)))
              (fun function_parameter =>
                let '(c, change) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Lwt.__return (Tez_repr.op_minusquestion change amount))
                  (fun change =>
                    (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.set)
                      c delegate change)))).
  
  Definition set_inactive
    (ctxt :
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.context))
    (delegate :
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.key))
    : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    Error_monad.op_gtgteqquestion (ensure_inited ctxt delegate)
      (fun ctxt =>
        let tokens_per_roll := Constants_storage.tokens_per_roll ctxt in
        Error_monad.op_gtgteqquestion
          ((|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.get)
            ctxt delegate)
          (fun change =>
            Error_monad.op_gtgteq
              ((|Storage.Contract.Inactive_delegate|).(Storage_sigs.Data_set_storage.add)
                ctxt (Contract_repr.implicit_contract delegate))
              (fun ctxt =>
                Error_monad.op_gtgteq
                  ((|Storage.Active_delegates_with_rolls|).(Storage_sigs.Data_set_storage.del)
                    ctxt delegate)
                  (fun ctxt =>
                    let fix loop
                      (ctxt :
                        (|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.context))
                      (change : Tez_repr.t) {struct ctxt}
                      : Lwt.t
                        (Error_monad.tzresult
                          ((|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.context)
                            * Tez_repr.t)) :=
                      Error_monad.op_gtgteqquestion
                        ((|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.get_option)
                          ctxt delegate)
                        (fun function_parameter =>
                          match function_parameter with
                          | None => Error_monad.__return (ctxt, change)
                          | Some _roll =>
                            Error_monad.op_gtgteqquestion
                              (pop_roll_from_delegate ctxt delegate)
                              (fun function_parameter =>
                                let '(_, ctxt) := function_parameter in
                                Error_monad.op_gtgteqquestion
                                  (Lwt.__return
                                    (Tez_repr.op_plusquestion change
                                      tokens_per_roll))
                                  (fun change => loop ctxt change))
                          end) in
                    Error_monad.op_gtgteqquestion (loop ctxt change)
                      (fun function_parameter =>
                        let '(ctxt, change) := function_parameter in
                        Error_monad.op_gtgteqquestion
                          ((|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.set)
                            ctxt delegate change)
                          (fun ctxt => Error_monad.__return ctxt)))))).
  
  Definition set_active
    (ctxt :
      (|Storage.Contract.Inactive_delegate|).(Storage_sigs.Data_set_storage.context))
    (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
    : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    Error_monad.op_gtgteqquestion (is_inactive ctxt delegate)
      (fun inactive =>
        let current_cycle :=
          (Raw_context.current_level ctxt).(Level_repr.t.cycle) in
        let preserved_cycles := Constants_storage.preserved_cycles ctxt in
        Error_monad.op_gtgteqquestion
          ((|Storage.Contract.Delegate_desactivation|).(Storage_sigs.Indexed_data_storage.get_option)
            ctxt (Contract_repr.implicit_contract delegate))
          (fun current_expiration =>
            let expiration :=
              match current_expiration with
              | None =>
                Cycle_repr.add current_cycle
                  (Pervasives.op_plus 1 (Pervasives.op_star 2 preserved_cycles))
              | Some current_expiration =>
                let delay :=
                  if inactive then
                    Pervasives.op_plus 1 (Pervasives.op_star 2 preserved_cycles)
                  else
                    Pervasives.op_plus 1 preserved_cycles in
                let updated := Cycle_repr.add current_cycle delay in
                Cycle_repr.max current_expiration updated
              end in
            Error_monad.op_gtgteq
              ((|Storage.Contract.Delegate_desactivation|).(Storage_sigs.Indexed_data_storage.init_set)
                ctxt (Contract_repr.implicit_contract delegate) expiration)
              (fun ctxt =>
                if Pervasives.not inactive then
                  Error_monad.__return ctxt
                else
                  Error_monad.op_gtgteqquestion (ensure_inited ctxt delegate)
                    (fun ctxt =>
                      let tokens_per_roll :=
                        Constants_storage.tokens_per_roll ctxt in
                      Error_monad.op_gtgteqquestion
                        ((|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.get)
                          ctxt delegate)
                        (fun change =>
                          Error_monad.op_gtgteq
                            ((|Storage.Contract.Inactive_delegate|).(Storage_sigs.Data_set_storage.del)
                              ctxt (Contract_repr.implicit_contract delegate))
                            (fun ctxt =>
                              Error_monad.op_gtgteqquestion
                                (delegate_pubkey ctxt delegate)
                                (fun delegate_pk =>
                                  let fix loop
                                    (ctxt : Raw_context.context)
                                    (change : Tez_repr.t) {struct ctxt}
                                    : Lwt.t
                                      (Error_monad.tzresult Raw_context.context) :=
                                    if Tez_repr.op_lt change tokens_per_roll
                                      then
                                      Error_monad.__return ctxt
                                    else
                                      Error_monad.op_gtgteqquestion
                                        (Lwt.__return
                                          (Tez_repr.op_minusquestion change
                                            tokens_per_roll))
                                        (fun change =>
                                          Error_monad.op_gtgteqquestion
                                            (create_roll_in_delegate ctxt
                                              delegate delegate_pk)
                                            (fun ctxt => loop ctxt change)) in
                                  Error_monad.op_gtgteqquestion
                                    (loop ctxt change)
                                    (fun ctxt =>
                                      Error_monad.op_gtgteqquestion
                                        ((|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.get_option)
                                          ctxt delegate)
                                        (fun rolls =>
                                          match rolls with
                                          | None => Error_monad.__return ctxt
                                          | Some _ =>
                                            Error_monad.op_gtgteq
                                              ((|Storage.Active_delegates_with_rolls|).(Storage_sigs.Data_set_storage.add)
                                                ctxt delegate)
                                              (fun ctxt =>
                                                Error_monad.__return ctxt)
                                          end))))))))).
End Delegate.

Module Contract.
  Definition add_amount
    (c :
      (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.context))
    (contract :
      (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.key))
    (amount : Tez_repr.t)
    : Lwt.t
      (Error_monad.tzresult
        (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.context)) :=
    Error_monad.op_gtgteqquestion (get_contract_delegate c contract)
      (fun function_parameter =>
        match function_parameter with
        | None => Error_monad.__return c
        | Some delegate => Delegate.add_amount c delegate amount
        end).
  
  Definition remove_amount
    (c :
      (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.context))
    (contract :
      (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.key))
    (amount : Tez_repr.t)
    : Lwt.t
      (Error_monad.tzresult
        (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.context)) :=
    Error_monad.op_gtgteqquestion (get_contract_delegate c contract)
      (fun function_parameter =>
        match function_parameter with
        | None => Error_monad.__return c
        | Some delegate => Delegate.remove_amount c delegate amount
        end).
End Contract.

Definition init
  (ctxt : (|Storage.Roll.Next|).(Storage_sigs.Single_data_storage.context))
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  (|Storage.Roll.Next|).(Storage_sigs.Single_data_storage.init) ctxt
    Roll_repr.first.

Definition init_first_cycles (ctxt : Raw_context.context)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let preserved := Constants_storage.preserved_cycles ctxt in
  Error_monad.op_gtgteqquestion
    (List.fold_left
      (fun ctxt =>
        fun c =>
          Error_monad.op_gtgteqquestion ctxt
            (fun ctxt =>
              let cycle := Cycle_repr.of_int32_exn (Int32.of_int c) in
              Error_monad.op_gtgteqquestion
                ((|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.init)
                  ctxt cycle 0)
                (fun ctxt =>
                  Error_monad.op_gtgteqquestion
                    (snapshot_rolls_for_cycle ctxt cycle)
                    (fun ctxt => freeze_rolls_for_cycle ctxt cycle))))
      (Error_monad.__return ctxt) (Misc.op_minusminusgt 0 preserved))
    (fun ctxt =>
      let cycle :=
        Cycle_repr.of_int32_exn (Int32.of_int (Pervasives.op_plus preserved 1))
        in
      Error_monad.op_gtgteqquestion
        ((|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.init)
          ctxt cycle 0)
        (fun ctxt =>
          Error_monad.op_gtgteqquestion (snapshot_rolls_for_cycle ctxt cycle)
            (fun ctxt =>
              let cycle :=
                Cycle_repr.of_int32_exn
                  (Int32.of_int (Pervasives.op_plus preserved 2)) in
              Error_monad.op_gtgteqquestion
                ((|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.init)
                  ctxt cycle 0) (fun ctxt => Error_monad.__return ctxt)))).

Definition snapshot_rolls (ctxt : Raw_context.context)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let current_level := Raw_context.current_level ctxt in
  let preserved := Constants_storage.preserved_cycles ctxt in
  let cycle :=
    Cycle_repr.add current_level.(Level_repr.t.cycle)
      (Pervasives.op_plus preserved 2) in
  snapshot_rolls_for_cycle ctxt cycle.

Definition cycle_end
  (ctxt : Raw_context.context) (last_cycle : Cycle_repr.cycle)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let preserved := Constants_storage.preserved_cycles ctxt in
  Error_monad.op_gtgteqquestion
    match Cycle_repr.sub last_cycle preserved with
    | None => Error_monad.__return ctxt
    | Some cleared_cycle => clear_cycle ctxt cleared_cycle
    end
    (fun ctxt =>
      let frozen_roll_cycle :=
        Cycle_repr.add last_cycle (Pervasives.op_plus preserved 1) in
      Error_monad.op_gtgteqquestion
        (freeze_rolls_for_cycle ctxt frozen_roll_cycle)
        (fun ctxt =>
          Error_monad.op_gtgteqquestion
            ((|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.init)
              ctxt (Cycle_repr.succ (Cycle_repr.succ frozen_roll_cycle)) 0)
            (fun ctxt => Error_monad.__return ctxt))).

Definition update_tokens_per_roll
  (ctxt : Raw_context.context) (new_tokens_per_roll : Tez_repr.t)
  : Lwt.t (Error_monad.tzresult Raw_context.context) :=
  let constants := Raw_context.constants ctxt in
  let old_tokens_per_roll :=
    constants.(Constants_repr.parametric.tokens_per_roll) in
  Error_monad.op_gtgteq
    (Raw_context.patch_constants ctxt
      (fun constants =>
        Constants_repr.parametric.with_tokens_per_roll new_tokens_per_roll
          constants))
    (fun ctxt =>
      let decrease := Tez_repr.op_lt new_tokens_per_roll old_tokens_per_roll in
      Error_monad.op_gtgteqquestion
        (if decrease then
          Lwt.__return
            (Tez_repr.op_minusquestion old_tokens_per_roll new_tokens_per_roll)
        else
          Lwt.__return
            (Tez_repr.op_minusquestion new_tokens_per_roll old_tokens_per_roll))
        (fun abs_diff =>
          (|Storage.Delegates|).(Storage_sigs.Data_set_storage.fold) ctxt
            (Pervasives.Ok ctxt)
            (fun pkh =>
              fun ctxt =>
                Error_monad.op_gtgteqquestion (Lwt.__return ctxt)
                  (fun ctxt =>
                    Error_monad.op_gtgteqquestion (count_rolls ctxt pkh)
                      (fun rolls =>
                        Error_monad.op_gtgteqquestion
                          (Lwt.__return
                            (Tez_repr.op_starquestion abs_diff
                              (Int64.of_int rolls)))
                          (fun amount =>
                            if decrease then
                              Delegate.add_amount ctxt pkh amount
                            else
                              Delegate.remove_amount ctxt pkh amount)))))).
