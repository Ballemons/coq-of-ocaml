(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Unset Positivity Checking.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Contract_repr.
Require Tezos.Cycle_repr.
Require Tezos.Gas_limit_repr.
Require Tezos.Level_repr.
Require Tezos.Manager_repr.
Require Tezos.Misc.
Require Tezos.Nonce_hash.
Require Tezos.Raw_context.
Require Tezos.Raw_level_repr.
Require Tezos.Roll_repr.
Require Tezos.Script_expr_hash.
Require Tezos.Script_repr.
Require Tezos.Seed_repr.
Require Tezos.Storage_description.
Require Tezos.Storage_functors_mli. Module Storage_functors := Storage_functors_mli.
Require Tezos.Storage_sigs.
Require Tezos.Tez_repr.
Require Tezos.Vote_repr.
Require Tezos.Voting_period_repr.

Import Storage_functors.

Definition Int :=
  let t : Set := int in
  let encoding := Data_encoding.uint16 in
  existT (A := unit) (fun _ => _) tt
    {|
      Storage_sigs.VALUE.encoding := encoding
    |}.

Definition Int32 :=
  let t : Set := Int32.t in
  let encoding := Data_encoding.__int32_value in
  existT (A := unit) (fun _ => _) tt
    {|
      Storage_sigs.VALUE.encoding := encoding
    |}.

Definition Z_value :=
  let t : Set := Z.t in
  let encoding := Data_encoding.z in
  existT (A := unit) (fun _ => _) tt
    {|
      Storage_sigs.VALUE.encoding := encoding
    |}.

Definition Int_index :=
  let t : Set := int in
  let path_length := 1 in
  let to_path (c : int) (l : list string) : list string :=
    cons (Pervasives.string_of_int c) l in
  let of_path (function_parameter : list string) : option int :=
    match function_parameter with
    | ([] | cons _ (cons _ _)) => None
    | cons c [] => Pervasives.int_of_string_opt c
    end in
  let ipath (a : Set) : Set := a * t in
  let args (function_parameter : unit) : Storage_description.args :=
    let '_ := function_parameter in
    Storage_description.One
      {| Storage_description.args.One.rpc_arg := RPC_arg.__int_value;
        Storage_description.args.One.encoding := Data_encoding.int31;
        Storage_description.args.One.compare :=
          (|Compare.Int|).(Compare.S.compare) |} in
  existT (A := unit) (fun _ => _) tt
    {|
      Storage_functors.INDEX.path_length := path_length;
      Storage_functors.INDEX.to_path := to_path;
      Storage_functors.INDEX.of_path := of_path;
      Storage_functors.INDEX.args := args
    |}.

Definition Make_index :=
  fun (H : {t : Set & Storage_description.INDEX.signature t}) =>
    ((let t := (|H|).(Storage_description.INDEX.t) in
    let path_length := (|H|).(Storage_description.INDEX.path_length) in
    let to_path := (|H|).(Storage_description.INDEX.to_path) in
    let of_path := (|H|).(Storage_description.INDEX.of_path) in
    let rpc_arg := (|H|).(Storage_description.INDEX.rpc_arg) in
    let encoding := (|H|).(Storage_description.INDEX.encoding) in
    let compare := (|H|).(Storage_description.INDEX.compare) in
    let ipath (a : Set) : Set := a * t in
    let args (function_parameter : unit) : Storage_description.args :=
      let '_ := function_parameter in
      Storage_description.One
        {| Storage_description.args.One.rpc_arg := rpc_arg;
          Storage_description.args.One.encoding := encoding;
          Storage_description.args.One.compare := compare |} in
    existT (A := unit) (fun _ => _) tt
      {|
        Storage_functors.INDEX.path_length := path_length;
        Storage_functors.INDEX.to_path := to_path;
        Storage_functors.INDEX.of_path := of_path;
        Storage_functors.INDEX.args := args
      |})
      :
        {_ : unit &
          INDEX.signature (|H|).(Storage_description.INDEX.t)
            (fun (a : Set) => a * (|H|).(Storage_description.INDEX.t))}).

Definition Block_priority :=
  (((Storage_functors.Make_single_data_storage
    (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
    (existT (A := Set) _ _
      {|
        Raw_context.T.mem := Raw_context.mem;
        Raw_context.T.dir_mem := Raw_context.dir_mem;
        Raw_context.T.get := Raw_context.get;
        Raw_context.T.get_option := Raw_context.get_option;
        Raw_context.T.init := Raw_context.init;
        Raw_context.T.set := Raw_context.set;
        Raw_context.T.init_set := Raw_context.init_set;
        Raw_context.T.set_option := Raw_context.set_option;
        Raw_context.T.delete := Raw_context.delete;
        Raw_context.T.remove := Raw_context.remove;
        Raw_context.T.remove_rec := Raw_context.remove_rec;
        Raw_context.T.copy := Raw_context.copy;
        Raw_context.T.fold {_} := Raw_context.fold;
        Raw_context.T.keys := Raw_context.keys;
        Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
        Raw_context.T.project := Raw_context.project;
        Raw_context.T.absolute_key := Raw_context.absolute_key;
        Raw_context.T.consume_gas := Raw_context.consume_gas;
        Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
        Raw_context.T.description := Raw_context.description
      |}))
    (let name := [ "block_priority" ] in
    existT (A := unit) (fun _ => _) tt
      {|
        Storage_sigs.NAME.name := name
      |})) (existT (A := Set) _ _ (|Int|)).

Module Contract.
  Definition Raw_context :=
    ((Storage_functors.Make_subcontext
      (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _
        {|
          Raw_context.T.mem := Raw_context.mem;
          Raw_context.T.dir_mem := Raw_context.dir_mem;
          Raw_context.T.get := Raw_context.get;
          Raw_context.T.get_option := Raw_context.get_option;
          Raw_context.T.init := Raw_context.init;
          Raw_context.T.set := Raw_context.set;
          Raw_context.T.init_set := Raw_context.init_set;
          Raw_context.T.set_option := Raw_context.set_option;
          Raw_context.T.delete := Raw_context.delete;
          Raw_context.T.remove := Raw_context.remove;
          Raw_context.T.remove_rec := Raw_context.remove_rec;
          Raw_context.T.copy := Raw_context.copy;
          Raw_context.T.fold {_} := Raw_context.fold;
          Raw_context.T.keys := Raw_context.keys;
          Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
          Raw_context.T.project := Raw_context.project;
          Raw_context.T.absolute_key := Raw_context.absolute_key;
          Raw_context.T.consume_gas := Raw_context.consume_gas;
          Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
          Raw_context.T.description := Raw_context.description
        |}))
      (let name := [ "contracts" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}).
  
  Definition Global_counter :=
    (((Storage_functors.Make_single_data_storage
      (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _ (|Raw_context|)))
      (let name := [ "global_counter" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |})) (existT (A := Set) _ _ (|Z_value|)).
  
  Definition Indexed_context :=
    (Storage_functors.Make_indexed_subcontext
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _ (|Raw_context|)))
          (let name := [ "index" ] in
          existT (A := unit) (fun _ => _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index (existT (A := Set) _ _ (|Contract_repr.Index|)) in
      existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)).
  
  Definition fold {A : Set}
    : (|Indexed_context|).(Storage_sigs.Indexed_raw_context.context) -> A ->
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.key) -> A -> Lwt.t A)
    -> Lwt.t A :=
    (|Indexed_context|).(Storage_sigs.Indexed_raw_context.fold_keys).
  
  Definition __list_value
    : (|Indexed_context|).(Storage_sigs.Indexed_raw_context.context) ->
    Lwt.t (list (|Indexed_context|).(Storage_sigs.Indexed_raw_context.key)) :=
    (|Indexed_context|).(Storage_sigs.Indexed_raw_context.keys).
  
  Definition Balance :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "balance" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Tez_repr.encoding
        |}).
  
  Definition Frozen_balance_index :=
    (Storage_functors.Make_indexed_subcontext
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _
            (|Indexed_context|).(Storage_sigs.Indexed_raw_context.Raw_context)))
          (let name := [ "frozen_balance" ] in
          existT (A := unit) (fun _ => _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index (existT (A := Set) _ _ (|Cycle_repr.Index|)) in
      existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)).
  
  Definition Frozen_deposits :=
    ((|Frozen_balance_index|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "deposits" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Tez_repr.encoding
        |}).
  
  Definition Frozen_fees :=
    ((|Frozen_balance_index|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "fees" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Tez_repr.encoding
        |}).
  
  Definition Frozen_rewards :=
    ((|Frozen_balance_index|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "rewards" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Tez_repr.encoding
        |}).
  
  Definition Manager :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "manager" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |})) (existT (A := Set) _ _ Manager_repr).
  
  Definition Delegate :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "delegate" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding :=
            (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding)
        |}).
  
  Definition Inactive_delegate :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_set)
      (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
      (let name := [ "inactive_delegate" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}).
  
  Definition Delegate_desactivation :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "delegate_desactivation" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Cycle_repr.encoding
        |}).
  
  Definition Delegated :=
    (Storage_functors.Make_data_set_storage
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _
            (|Indexed_context|).(Storage_sigs.Indexed_raw_context.Raw_context)))
          (let name := [ "delegated" ] in
          existT (A := unit) (fun _ => _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index (existT (A := Set) _ _ (|Contract_repr.Index|)) in
      existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)).
  
  Definition Counter :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "counter" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |})) (existT (A := Set) _ _ (|Z_value|)).
  
  Definition Make_carbonated_map_expr :=
    fun (N : {_ : unit & Storage_sigs.NAME.signature}) =>
      ((let I :=
        ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_carbonated_map)
          (existT (A := unit) (fun _ => _) tt (|N|)))
          (let t : Set := Script_repr.lazy_expr in
          let encoding := Script_repr.lazy_expr_encoding in
          existT (A := Set) _ _
            {|
              Storage_sigs.VALUE.encoding := encoding
            |}) in
      let tag_Non_iterable_indexed_carbonated_data_storage := tt in
      let context : Set :=
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context)
        in
      let key : Set :=
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key) in
      let value : Set :=
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value)
        in
      let mem :=
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.mem) in
      let delete :=
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.delete)
        in
      let remove :=
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.remove)
        in
      let consume_deserialize_gas
        (ctxt : (|Raw_context|).(Raw_context.T.context))
        (value : Script_repr.lazy_expr)
        : Lwt.t (Error_monad.tzresult (|Raw_context|).(Raw_context.T.context)) :=
        Lwt.__return
          (let? '_ :=
            (|Raw_context|).(Raw_context.T.check_enough_gas) ctxt
              (Script_repr.minimal_deserialize_cost value) in
          let? '(_value, value_cost) := Script_repr.force_decode value in
          (|Raw_context|).(Raw_context.T.consume_gas) ctxt value_cost) in
      let consume_serialize_gas
        (ctxt : (|Raw_context|).(Raw_context.T.context))
        (value : Script_repr.lazy_expr)
        : Lwt.t (Error_monad.tzresult (|Raw_context|).(Raw_context.T.context)) :=
        Lwt.__return
          (let? '(_value, value_cost) := Script_repr.force_bytes value in
          (|Raw_context|).(Raw_context.T.consume_gas) ctxt value_cost) in
      let get
        (ctxt :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context))
        (contract :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
        : Lwt.t
          (Error_monad.tzresult
            ((|Raw_context|).(Raw_context.T.context) *
              (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value))) :=
        let=? '(ctxt, value) :=
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get)
            ctxt contract in
        Error_monad.op_gtgtpipequestion (consume_deserialize_gas ctxt value)
          (fun ctxt => (ctxt, value)) in
      let get_option
        (ctxt :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context))
        (contract :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
        : Lwt.t
          (Error_monad.tzresult
            (Raw_context.t *
              option
                (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value))) :=
        let=? '(ctxt, value_opt) :=
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get_option)
            ctxt contract in
        match value_opt with
        | None => Error_monad.__return (ctxt, None)
        | Some value =>
          Error_monad.op_gtgtpipequestion (consume_deserialize_gas ctxt value)
            (fun ctxt => (ctxt, value_opt))
        end in
      let set
        (ctxt : (|Raw_context|).(Raw_context.T.context))
        (contract :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
        (value : Script_repr.lazy_expr)
        : Lwt.t (Error_monad.tzresult (Raw_context.t * int)) :=
        let=? ctxt := consume_serialize_gas ctxt value in
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set)
          ctxt contract value in
      let set_option
        (ctxt :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context))
        (contract :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
        (value_opt :
          option
            (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value))
        : Lwt.t (Error_monad.tzresult (Raw_context.t * int * bool)) :=
        match value_opt with
        | None =>
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set_option)
            ctxt contract None
        | Some value =>
          let=? ctxt := consume_serialize_gas ctxt value in
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set_option)
            ctxt contract value_opt
        end in
      let init
        (ctxt : (|Raw_context|).(Raw_context.T.context))
        (contract :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
        (value : Script_repr.lazy_expr)
        : Lwt.t (Error_monad.tzresult (Raw_context.t * int)) :=
        let=? ctxt := consume_serialize_gas ctxt value in
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init)
          ctxt contract value in
      let init_set
        (ctxt : (|Raw_context|).(Raw_context.T.context))
        (contract :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
        (value : Script_repr.lazy_expr)
        : Lwt.t (Error_monad.tzresult (Raw_context.t * int * bool)) :=
        let=? ctxt := consume_serialize_gas ctxt value in
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init_set)
          ctxt contract value in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.tag_Non_iterable_indexed_carbonated_data_storage :=
            tag_Non_iterable_indexed_carbonated_data_storage;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.mem := mem;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get := get;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get_option :=
            get_option;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set := set;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init := init;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init_set :=
            init_set;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set_option :=
            set_option;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.delete :=
            delete;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.remove :=
            remove
        |})
        :
          {_ : unit &
            Storage_sigs.Non_iterable_indexed_carbonated_data_storage.signature
              (|Raw_context|).(Raw_context.T.t) Contract_repr.t
              Script_repr.lazy_expr}).
  
  Definition Code :=
    Make_carbonated_map_expr
      (let name := [ "code" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}).
  
  Definition Storage :=
    Make_carbonated_map_expr
      (let name := [ "storage" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}).
  
  Definition Paid_storage_space :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "paid_bytes" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |})) (existT (A := Set) _ _ (|Z_value|)).
  
  Definition Used_storage_space :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "used_bytes" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |})) (existT (A := Set) _ _ (|Z_value|)).
  
  Definition Roll_list :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "roll_list" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Roll_repr.encoding
        |}).
  
  Definition Change :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "change" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Tez_repr.encoding
        |}).
End Contract.

Module Big_map.
  Definition Raw_context :=
    ((Storage_functors.Make_subcontext
      (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _
        {|
          Raw_context.T.mem := Raw_context.mem;
          Raw_context.T.dir_mem := Raw_context.dir_mem;
          Raw_context.T.get := Raw_context.get;
          Raw_context.T.get_option := Raw_context.get_option;
          Raw_context.T.init := Raw_context.init;
          Raw_context.T.set := Raw_context.set;
          Raw_context.T.init_set := Raw_context.init_set;
          Raw_context.T.set_option := Raw_context.set_option;
          Raw_context.T.delete := Raw_context.delete;
          Raw_context.T.remove := Raw_context.remove;
          Raw_context.T.remove_rec := Raw_context.remove_rec;
          Raw_context.T.copy := Raw_context.copy;
          Raw_context.T.fold {_} := Raw_context.fold;
          Raw_context.T.keys := Raw_context.keys;
          Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
          Raw_context.T.project := Raw_context.project;
          Raw_context.T.absolute_key := Raw_context.absolute_key;
          Raw_context.T.consume_gas := Raw_context.consume_gas;
          Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
          Raw_context.T.description := Raw_context.description
        |}))
      (let name := [ "big_maps" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}).
  
  Module Next.
    Definition Single_data_storage :=
      (((Storage_functors.Make_single_data_storage
        (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
        (existT (A := Set) _ _ (|Raw_context|)))
        (let name := [ "next" ] in
        existT (A := unit) (fun _ => _) tt
          {|
            Storage_sigs.NAME.name := name
          |})) (existT (A := Set) _ _ (|Z_value|)).
    
    Definition tag_Single_data_storage :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.tag_Single_data_storage).
    
    Definition t :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.t).
    
    Definition context :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.context).
    
    Definition value :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.value).
    
    Definition mem :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.mem).
    
    Definition get :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.get).
    
    Definition get_option :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.get_option).
    
    Definition init :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.init).
    
    Definition set :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.set).
    
    Definition init_set :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.init_set).
    
    Definition set_option :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.set_option).
    
    Definition delete :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.delete).
    
    Definition remove :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.remove).
    
    Definition incr (ctxt : context)
      : Lwt.t (Error_monad.tzresult (Raw_context.t * value)) :=
      let=? i := get ctxt in
      let=? ctxt := set ctxt (Z.succ i) in
      Error_monad.__return (ctxt, i).
    
    Definition init (ctxt : context)
      : Lwt.t (Error_monad.tzresult Raw_context.t) := init ctxt Z.zero.
  End Next.
  
  Definition Index :=
    let t : Set := Z.t in
    let rpc_arg :=
      let construct := Z.to_string in
      let destruct (__hash_value : string) : Pervasives.result Z.t string :=
        let 'id := Z.of_string __hash_value in
        Pervasives.Ok id in
      RPC_arg.make (Some "A big map identifier") "big_map_id" destruct construct
        tt in
    let encoding :=
      Data_encoding.def "big_map_id" (Some "Big map identifier")
        (Some "A big map identifier") (|Z_value|).(Storage_sigs.VALUE.encoding)
      in
    let compare := (|Compare.Z|).(Compare.S.compare) in
    let path_length := 7 in
    let to_path (c : Z.t) (l : list string) : list string :=
      let raw_key := Data_encoding.Binary.to_bytes_exn encoding c in
      let 'MBytes.Hex index_key := MBytes.to_hex (Raw_hashes.blake2b raw_key) in
      cons (String.sub index_key 0 2)
        (cons (String.sub index_key 2 2)
          (cons (String.sub index_key 4 2)
            (cons (String.sub index_key 6 2)
              (cons (String.sub index_key 8 2)
                (cons (String.sub index_key 10 2) (cons (Z.to_string c) l))))))
      in
    let of_path (function_parameter : list (|Compare.String|).(Compare.S.t))
      : option Z.t :=
      match function_parameter with
      |
        ([] | cons _ [] | cons _ (cons _ []) | cons _ (cons _ (cons _ [])) |
        cons _ (cons _ (cons _ (cons _ []))) |
        cons _ (cons _ (cons _ (cons _ (cons _ [])))) |
        cons _ (cons _ (cons _ (cons _ (cons _ (cons _ []))))) |
        cons _ (cons _ (cons _ (cons _ (cons _ (cons _ (cons _ (cons _ _))))))))
        => None
      |
        cons index1
          (cons index2
            (cons index3
              (cons index4 (cons index5 (cons index6 (cons __key_value []))))))
        =>
        let c := Z.of_string __key_value in
        let raw_key := Data_encoding.Binary.to_bytes_exn encoding c in
        let 'MBytes.Hex index_key := MBytes.to_hex (Raw_hashes.blake2b raw_key)
          in
        (* ❌ Sequences of instructions are ignored (operator ";") *)
        (* ❌ instruction_sequence ";" *)
        (* ❌ Sequences of instructions are ignored (operator ";") *)
        (* ❌ instruction_sequence ";" *)
        (* ❌ Sequences of instructions are ignored (operator ";") *)
        (* ❌ instruction_sequence ";" *)
        (* ❌ Sequences of instructions are ignored (operator ";") *)
        (* ❌ instruction_sequence ";" *)
        (* ❌ Sequences of instructions are ignored (operator ";") *)
        (* ❌ instruction_sequence ";" *)
        (* ❌ Sequences of instructions are ignored (operator ";") *)
        (* ❌ instruction_sequence ";" *)
        Some c
      end in
    existT (A := unit) (fun _ => _) tt
      {|
        Storage_description.INDEX.rpc_arg := rpc_arg;
        Storage_description.INDEX.encoding := encoding;
        Storage_description.INDEX.compare := compare;
        Storage_description.INDEX.path_length := path_length;
        Storage_description.INDEX.to_path := to_path;
        Storage_description.INDEX.of_path := of_path
      |}.
  
  Definition Indexed_context :=
    (Storage_functors.Make_indexed_subcontext
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _ (|Raw_context|)))
          (let name := [ "index" ] in
          existT (A := unit) (fun _ => _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result := Make_index (existT (A := Set) _ _ (|Index|)) in
      existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)).
  
  Definition rpc_arg : RPC_arg.arg Z.t :=
    (|Index|).(Storage_description.INDEX.rpc_arg).
  
  Definition fold {A : Set}
    : (|Indexed_context|).(Storage_sigs.Indexed_raw_context.context) -> A ->
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.key) -> A -> Lwt.t A)
    -> Lwt.t A :=
    (|Indexed_context|).(Storage_sigs.Indexed_raw_context.fold_keys).
  
  Definition __list_value
    : (|Indexed_context|).(Storage_sigs.Indexed_raw_context.context) ->
    Lwt.t (list (|Indexed_context|).(Storage_sigs.Indexed_raw_context.key)) :=
    (|Indexed_context|).(Storage_sigs.Indexed_raw_context.keys).
  
  Definition remove_rec
    (ctxt : (|Indexed_context|).(Storage_sigs.Indexed_raw_context.context))
    (n : (|Indexed_context|).(Storage_sigs.Indexed_raw_context.key))
    : Lwt.t (|Indexed_context|).(Storage_sigs.Indexed_raw_context.context) :=
    (|Indexed_context|).(Storage_sigs.Indexed_raw_context.remove_rec) ctxt n.
  
  Definition copy
    (ctxt : (|Indexed_context|).(Storage_sigs.Indexed_raw_context.context))
    (from : (|Indexed_context|).(Storage_sigs.Indexed_raw_context.key))
    (to_ : (|Indexed_context|).(Storage_sigs.Indexed_raw_context.key))
    : Lwt.t
      (Error_monad.tzresult
        (|Indexed_context|).(Storage_sigs.Indexed_raw_context.context)) :=
    (|Indexed_context|).(Storage_sigs.Indexed_raw_context.copy) ctxt from to_.
  
  Definition key : Set := (|Raw_context|).(Raw_context.T.t) * Z.t.
  
  Definition Total_bytes :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "total_bytes" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |})) (existT (A := Set) _ _ (|Z_value|)).
  
  Definition Key_type :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "key_type" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (let t : Set := Script_repr.expr in
      let encoding := Script_repr.expr_encoding in
      existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
        |}).
  
  Definition Value_type :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "value_type" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (let t : Set := Script_repr.expr in
      let encoding := Script_repr.expr_encoding in
      existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
        |}).
  
  Module Contents.
    Definition I :=
      ((Storage_functors.Make_indexed_carbonated_data_storage
        (let functor_result :=
          ((Storage_functors.Make_subcontext
            (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
            (existT (A := Set) _ _
              (|Indexed_context|).(Storage_sigs.Indexed_raw_context.Raw_context)))
            (let name := [ "contents" ] in
            existT (A := unit) (fun _ => _) tt
              {|
                Storage_sigs.NAME.name := name
              |}) in
        existT (A := Set) _ _ (|functor_result|)))
        (let functor_result :=
          Make_index
            (existT (A := Set) _ _
              {|
                Storage_description.INDEX.path_length :=
                  Script_expr_hash.path_length;
                Storage_description.INDEX.to_path := Script_expr_hash.to_path;
                Storage_description.INDEX.of_path := Script_expr_hash.of_path;
                Storage_description.INDEX.rpc_arg := Script_expr_hash.rpc_arg;
                Storage_description.INDEX.encoding := Script_expr_hash.encoding;
                Storage_description.INDEX.compare := Script_expr_hash.compare
              |}) in
        existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)))
        (let t : Set := Script_repr.expr in
        let encoding := Script_repr.expr_encoding in
        existT (A := Set) _ _
          {|
            Storage_sigs.VALUE.encoding := encoding
          |}).
    
    Definition tag_Non_iterable_indexed_carbonated_data_storage : unit := tt.
    
    Definition context : Set :=
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context).
    
    Definition key : Set :=
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key).
    
    Definition value : Set :=
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value).
    
    Definition mem
      : (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context)
      ->
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key) ->
      Lwt.t (Error_monad.tzresult (Raw_context.t * bool)) :=
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.mem).
    
    Definition delete
      : (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context)
      ->
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key) ->
      Lwt.t (Error_monad.tzresult (Raw_context.t * int)) :=
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.delete).
    
    Definition remove
      : (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context)
      ->
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key) ->
      Lwt.t (Error_monad.tzresult (Raw_context.t * int * bool)) :=
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.remove).
    
    Definition set
      : (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context)
      ->
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key) ->
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value) ->
      Lwt.t (Error_monad.tzresult (Raw_context.t * int)) :=
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set).
    
    Definition set_option
      : (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context)
      ->
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key) ->
      option
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value)
      -> Lwt.t (Error_monad.tzresult (Raw_context.t * int * bool)) :=
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set_option).
    
    Definition init
      : (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context)
      ->
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key) ->
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value) ->
      Lwt.t (Error_monad.tzresult (Raw_context.t * int)) :=
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init).
    
    Definition init_set
      : (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context)
      ->
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key) ->
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value) ->
      Lwt.t (Error_monad.tzresult (Raw_context.t * int * bool)) :=
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init_set).
    
    Definition consume_deserialize_gas
      (ctxt : (|Raw_context|).(Raw_context.T.context))
      (value : Script_repr.expr)
      : Lwt.t (Error_monad.tzresult (|Raw_context|).(Raw_context.T.context)) :=
      Lwt.__return
        ((|Raw_context|).(Raw_context.T.consume_gas) ctxt
          (Script_repr.deserialized_cost value)).
    
    Definition get
      (ctxt :
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context))
      (contract :
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
      : Lwt.t
        (Error_monad.tzresult
          ((|Raw_context|).(Raw_context.T.context) *
            (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value))) :=
      let=? '(ctxt, value) :=
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get)
          ctxt contract in
      Error_monad.op_gtgtpipequestion (consume_deserialize_gas ctxt value)
        (fun ctxt => (ctxt, value)).
    
    Definition get_option
      (ctxt :
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context))
      (contract :
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
      : Lwt.t
        (Error_monad.tzresult
          (Raw_context.t *
            option
              (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value))) :=
      let=? '(ctxt, value_opt) :=
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get_option)
          ctxt contract in
      match value_opt with
      | None => Error_monad.__return (ctxt, None)
      | Some value =>
        Error_monad.op_gtgtpipequestion (consume_deserialize_gas ctxt value)
          (fun ctxt => (ctxt, value_opt))
      end.
  End Contents.
End Big_map.

Definition Delegates :=
  (Storage_functors.Make_data_set_storage
    (let functor_result :=
      ((Storage_functors.Make_subcontext
        (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
        (existT (A := Set) _ _
          {|
            Raw_context.T.mem := Raw_context.mem;
            Raw_context.T.dir_mem := Raw_context.dir_mem;
            Raw_context.T.get := Raw_context.get;
            Raw_context.T.get_option := Raw_context.get_option;
            Raw_context.T.init := Raw_context.init;
            Raw_context.T.set := Raw_context.set;
            Raw_context.T.init_set := Raw_context.init_set;
            Raw_context.T.set_option := Raw_context.set_option;
            Raw_context.T.delete := Raw_context.delete;
            Raw_context.T.remove := Raw_context.remove;
            Raw_context.T.remove_rec := Raw_context.remove_rec;
            Raw_context.T.copy := Raw_context.copy;
            Raw_context.T.fold {_} := Raw_context.fold;
            Raw_context.T.keys := Raw_context.keys;
            Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
            Raw_context.T.project := Raw_context.project;
            Raw_context.T.absolute_key := Raw_context.absolute_key;
            Raw_context.T.consume_gas := Raw_context.consume_gas;
            Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
            Raw_context.T.description := Raw_context.description
          |}))
        (let name := [ "delegates" ] in
        existT (A := unit) (fun _ => _) tt
          {|
            Storage_sigs.NAME.name := name
          |}) in
    existT (A := Set) _ _ (|functor_result|)))
    (let functor_result :=
      Make_index
        (existT (A := Set) _ _
          {|
            Storage_description.INDEX.path_length :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.path_length);
            Storage_description.INDEX.to_path :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.to_path);
            Storage_description.INDEX.of_path :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.of_path);
            Storage_description.INDEX.rpc_arg :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.rpc_arg);
            Storage_description.INDEX.encoding :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding);
            Storage_description.INDEX.compare :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.compare)
          |}) in
    existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)).

Definition Active_delegates_with_rolls :=
  (Storage_functors.Make_data_set_storage
    (let functor_result :=
      ((Storage_functors.Make_subcontext
        (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
        (existT (A := Set) _ _
          {|
            Raw_context.T.mem := Raw_context.mem;
            Raw_context.T.dir_mem := Raw_context.dir_mem;
            Raw_context.T.get := Raw_context.get;
            Raw_context.T.get_option := Raw_context.get_option;
            Raw_context.T.init := Raw_context.init;
            Raw_context.T.set := Raw_context.set;
            Raw_context.T.init_set := Raw_context.init_set;
            Raw_context.T.set_option := Raw_context.set_option;
            Raw_context.T.delete := Raw_context.delete;
            Raw_context.T.remove := Raw_context.remove;
            Raw_context.T.remove_rec := Raw_context.remove_rec;
            Raw_context.T.copy := Raw_context.copy;
            Raw_context.T.fold {_} := Raw_context.fold;
            Raw_context.T.keys := Raw_context.keys;
            Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
            Raw_context.T.project := Raw_context.project;
            Raw_context.T.absolute_key := Raw_context.absolute_key;
            Raw_context.T.consume_gas := Raw_context.consume_gas;
            Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
            Raw_context.T.description := Raw_context.description
          |}))
        (let name := [ "active_delegates_with_rolls" ] in
        existT (A := unit) (fun _ => _) tt
          {|
            Storage_sigs.NAME.name := name
          |}) in
    existT (A := Set) _ _ (|functor_result|)))
    (let functor_result :=
      Make_index
        (existT (A := Set) _ _
          {|
            Storage_description.INDEX.path_length :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.path_length);
            Storage_description.INDEX.to_path :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.to_path);
            Storage_description.INDEX.of_path :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.of_path);
            Storage_description.INDEX.rpc_arg :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.rpc_arg);
            Storage_description.INDEX.encoding :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding);
            Storage_description.INDEX.compare :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.compare)
          |}) in
    existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)).

Definition Delegates_with_frozen_balance_index :=
  (Storage_functors.Make_indexed_subcontext
    (let functor_result :=
      ((Storage_functors.Make_subcontext
        (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
        (existT (A := Set) _ _
          {|
            Raw_context.T.mem := Raw_context.mem;
            Raw_context.T.dir_mem := Raw_context.dir_mem;
            Raw_context.T.get := Raw_context.get;
            Raw_context.T.get_option := Raw_context.get_option;
            Raw_context.T.init := Raw_context.init;
            Raw_context.T.set := Raw_context.set;
            Raw_context.T.init_set := Raw_context.init_set;
            Raw_context.T.set_option := Raw_context.set_option;
            Raw_context.T.delete := Raw_context.delete;
            Raw_context.T.remove := Raw_context.remove;
            Raw_context.T.remove_rec := Raw_context.remove_rec;
            Raw_context.T.copy := Raw_context.copy;
            Raw_context.T.fold {_} := Raw_context.fold;
            Raw_context.T.keys := Raw_context.keys;
            Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
            Raw_context.T.project := Raw_context.project;
            Raw_context.T.absolute_key := Raw_context.absolute_key;
            Raw_context.T.consume_gas := Raw_context.consume_gas;
            Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
            Raw_context.T.description := Raw_context.description
          |}))
        (let name := [ "delegates_with_frozen_balance" ] in
        existT (A := unit) (fun _ => _) tt
          {|
            Storage_sigs.NAME.name := name
          |}) in
    existT (A := Set) _ _ (|functor_result|)))
    (let functor_result :=
      Make_index (existT (A := Set) _ _ (|Cycle_repr.Index|)) in
    existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)).

Definition Delegates_with_frozen_balance :=
  (Storage_functors.Make_data_set_storage
    (existT (A := Set) _ _
      (|Delegates_with_frozen_balance_index|).(Storage_sigs.Indexed_raw_context.Raw_context)))
    (let functor_result :=
      Make_index
        (existT (A := Set) _ _
          {|
            Storage_description.INDEX.path_length :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.path_length);
            Storage_description.INDEX.to_path :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.to_path);
            Storage_description.INDEX.of_path :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.of_path);
            Storage_description.INDEX.rpc_arg :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.rpc_arg);
            Storage_description.INDEX.encoding :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding);
            Storage_description.INDEX.compare :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.compare)
          |}) in
    existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)).

Module Cycle.
  Definition Indexed_context :=
    (Storage_functors.Make_indexed_subcontext
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _
            {|
              Raw_context.T.mem := Raw_context.mem;
              Raw_context.T.dir_mem := Raw_context.dir_mem;
              Raw_context.T.get := Raw_context.get;
              Raw_context.T.get_option := Raw_context.get_option;
              Raw_context.T.init := Raw_context.init;
              Raw_context.T.set := Raw_context.set;
              Raw_context.T.init_set := Raw_context.init_set;
              Raw_context.T.set_option := Raw_context.set_option;
              Raw_context.T.delete := Raw_context.delete;
              Raw_context.T.remove := Raw_context.remove;
              Raw_context.T.remove_rec := Raw_context.remove_rec;
              Raw_context.T.copy := Raw_context.copy;
              Raw_context.T.fold {_} := Raw_context.fold;
              Raw_context.T.keys := Raw_context.keys;
              Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
              Raw_context.T.project := Raw_context.project;
              Raw_context.T.absolute_key := Raw_context.absolute_key;
              Raw_context.T.consume_gas := Raw_context.consume_gas;
              Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
              Raw_context.T.description := Raw_context.description
            |}))
          (let name := [ "cycle" ] in
          existT (A := unit) (fun _ => _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index (existT (A := Set) _ _ (|Cycle_repr.Index|)) in
      existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)).
  
  Definition Last_roll :=
    ((Storage_functors.Make_indexed_data_storage
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _
            (|Indexed_context|).(Storage_sigs.Indexed_raw_context.Raw_context)))
          (let name := [ "last_roll" ] in
          existT (A := unit) (fun _ => _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (existT (A := [Set ** Set -> Set]) _ [_, _] (|Int_index|)))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Roll_repr.encoding
        |}).
  
  Definition Roll_snapshot :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "roll_snapshot" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |})) (existT (A := Set) _ _ (|Int|)).
  
  Module unrevealed_nonce.
    Record record : Set := Build {
      nonce_hash : Nonce_hash.t;
      delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t);
      rewards : Tez_repr.t;
      fees : Tez_repr.t }.
    Definition with_nonce_hash nonce_hash (r : record) :=
      Build nonce_hash r.(delegate) r.(rewards) r.(fees).
    Definition with_delegate delegate (r : record) :=
      Build r.(nonce_hash) delegate r.(rewards) r.(fees).
    Definition with_rewards rewards (r : record) :=
      Build r.(nonce_hash) r.(delegate) rewards r.(fees).
    Definition with_fees fees (r : record) :=
      Build r.(nonce_hash) r.(delegate) r.(rewards) fees.
  End unrevealed_nonce.
  Definition unrevealed_nonce := unrevealed_nonce.record.
  
  Inductive nonce_status : Set :=
  | Unrevealed : unrevealed_nonce -> nonce_status
  | Revealed : Seed_repr.nonce -> nonce_status.
  
  Definition nonce_status_encoding : Data_encoding.encoding nonce_status :=
    Data_encoding.union None
      [
        Data_encoding.__case_value "Unrevealed" None (Data_encoding.Tag 0)
          (Data_encoding.tup4 Nonce_hash.encoding
            (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding)
            Tez_repr.encoding Tez_repr.encoding)
          (fun function_parameter =>
            match function_parameter with
            |
              Unrevealed {|
                unrevealed_nonce.nonce_hash := nonce_hash;
                  unrevealed_nonce.delegate := delegate;
                  unrevealed_nonce.rewards := rewards;
                  unrevealed_nonce.fees := fees
                  |} =>
              Some (nonce_hash, delegate, rewards, fees)
            | _ => None
            end)
          (fun function_parameter =>
            let '(nonce_hash, delegate, rewards, fees) :=
              function_parameter in
            Unrevealed
              {| unrevealed_nonce.nonce_hash := nonce_hash;
                unrevealed_nonce.delegate := delegate;
                unrevealed_nonce.rewards := rewards;
                unrevealed_nonce.fees := fees |});
        Data_encoding.__case_value "Revealed" None (Data_encoding.Tag 1)
          Seed_repr.nonce_encoding
          (fun function_parameter =>
            match function_parameter with
            | Revealed __nonce_value => Some __nonce_value
            | _ => None
            end) (fun __nonce_value => Revealed __nonce_value)
      ].
  
  Definition Nonce :=
    ((Storage_functors.Make_indexed_data_storage
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _
            (|Indexed_context|).(Storage_sigs.Indexed_raw_context.Raw_context)))
          (let name := [ "nonces" ] in
          existT (A := unit) (fun _ => _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index (existT (A := Set) _ _ (|Raw_level_repr.Index|)) in
      existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)))
      (let t : Set := nonce_status in
      let encoding := nonce_status_encoding in
      existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
        |}).
  
  Definition Seed :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "random_seed" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (let t : Set := Seed_repr.seed in
      let encoding := Seed_repr.seed_encoding in
      existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
        |}).
End Cycle.

Module Roll.
  Definition Raw_context :=
    ((Storage_functors.Make_subcontext
      (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _
        {|
          Raw_context.T.mem := Raw_context.mem;
          Raw_context.T.dir_mem := Raw_context.dir_mem;
          Raw_context.T.get := Raw_context.get;
          Raw_context.T.get_option := Raw_context.get_option;
          Raw_context.T.init := Raw_context.init;
          Raw_context.T.set := Raw_context.set;
          Raw_context.T.init_set := Raw_context.init_set;
          Raw_context.T.set_option := Raw_context.set_option;
          Raw_context.T.delete := Raw_context.delete;
          Raw_context.T.remove := Raw_context.remove;
          Raw_context.T.remove_rec := Raw_context.remove_rec;
          Raw_context.T.copy := Raw_context.copy;
          Raw_context.T.fold {_} := Raw_context.fold;
          Raw_context.T.keys := Raw_context.keys;
          Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
          Raw_context.T.project := Raw_context.project;
          Raw_context.T.absolute_key := Raw_context.absolute_key;
          Raw_context.T.consume_gas := Raw_context.consume_gas;
          Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
          Raw_context.T.description := Raw_context.description
        |}))
      (let name := [ "rolls" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}).
  
  Definition Indexed_context :=
    (Storage_functors.Make_indexed_subcontext
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _ (|Raw_context|)))
          (let name := [ "index" ] in
          existT (A := unit) (fun _ => _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index (existT (A := Set) _ _ (|Roll_repr.Index|)) in
      existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)).
  
  Definition Next :=
    (((Storage_functors.Make_single_data_storage
      (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _ (|Raw_context|)))
      (let name := [ "next" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Roll_repr.encoding
        |}).
  
  Definition Limbo :=
    (((Storage_functors.Make_single_data_storage
      (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _ (|Raw_context|)))
      (let name := [ "limbo" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Roll_repr.encoding
        |}).
  
  Definition Delegate_roll_list :=
    (Storage_functors.Wrap_indexed_data_storage
      (existT (A := [Set ** Set ** Set]) _ [_, _, _] (|Contract.Roll_list|)))
      (let t : Set := (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) in
      let wrap := Contract_repr.implicit_contract in
      let unwrap := Contract_repr.is_implicit in
      existT (A := Set) _ _
        {|
          Storage_functors.WRAPPER.wrap := wrap;
          Storage_functors.WRAPPER.unwrap := unwrap
        |}).
  
  Definition Successor :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ "successor" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Roll_repr.encoding
        |}).
  
  Definition Delegate_change :=
    (Storage_functors.Wrap_indexed_data_storage
      (existT (A := [Set ** Set ** Set]) _ [_, _, _] (|Contract.Change|)))
      (let t : Set := (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) in
      let wrap := Contract_repr.implicit_contract in
      let unwrap := Contract_repr.is_implicit in
      existT (A := Set) _ _
        {|
          Storage_functors.WRAPPER.wrap := wrap;
          Storage_functors.WRAPPER.unwrap := unwrap
        |}).
  
  Module Snapshoted_owner_index.
    Definition t : Set := Cycle_repr.t * int.
    
    Definition path_length : int :=
      Pervasives.op_plus
        (|Cycle_repr.Index|).(Storage_description.INDEX.path_length) 1.
    
    Definition to_path
      (function_parameter :
        (|Cycle_repr.Index|).(Storage_description.INDEX.t) * int)
      : list string -> list string :=
      let '(c, n) := function_parameter in
      fun s =>
        (|Cycle_repr.Index|).(Storage_description.INDEX.to_path) c
          (cons (Pervasives.string_of_int n) s).
    
    Definition of_path (l : list string)
      : option ((|Cycle_repr.Index|).(Storage_description.INDEX.t) * int) :=
      match
        Misc.take (|Cycle_repr.Index|).(Storage_description.INDEX.path_length) l
        with
      | (None | Some (_, ([] | cons _ (cons _ _)))) => None
      | Some (l1, cons l2 []) =>
        match
          (((|Cycle_repr.Index|).(Storage_description.INDEX.of_path) l1),
            (Pervasives.int_of_string_opt l2)) with
        | ((None, _) | (_, None)) => None
        | (Some c, Some i) => Some (c, i)
        end
      end.
    
    Definition ipath (a : Set) : Set := (a * Cycle_repr.t) * int.
    
    Definition left_args : Storage_description.args :=
      Storage_description.One
        {| Storage_description.args.One.rpc_arg := Cycle_repr.rpc_arg;
          Storage_description.args.One.encoding := Cycle_repr.encoding;
          Storage_description.args.One.compare := Cycle_repr.compare |}.
    
    Definition right_args : Storage_description.args :=
      Storage_description.One
        {| Storage_description.args.One.rpc_arg := RPC_arg.__int_value;
          Storage_description.args.One.encoding := Data_encoding.int31;
          Storage_description.args.One.compare :=
            (|Compare.Int|).(Compare.S.compare) |}.
    
    Definition args (function_parameter : unit) : Storage_description.args :=
      let '_ := function_parameter in
      Storage_description.Pair left_args right_args.
  End Snapshoted_owner_index.
  
  Definition Owner :=
    (((Storage_functors.Make_indexed_data_snapshotable_storage
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _ (|Raw_context|)))
          (let name := [ "owner" ] in
          existT (A := unit) (fun _ => _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (existT (A := [Set ** Set -> Set]) _ [_, _]
        {|
          Storage_functors.INDEX.path_length :=
            Snapshoted_owner_index.path_length;
          Storage_functors.INDEX.to_path := Snapshoted_owner_index.to_path;
          Storage_functors.INDEX.of_path := Snapshoted_owner_index.of_path;
          Storage_functors.INDEX.args := Snapshoted_owner_index.args
        |}))
      (let functor_result :=
        Make_index (existT (A := Set) _ _ (|Roll_repr.Index|)) in
      existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding :=
            (|Signature.Public_key|).(S.SPublic_key.encoding)
        |}).
  
  Definition Snapshot_for_cycle := Cycle.Roll_snapshot.
  
  Definition Last_for_snapshot := Cycle.Last_roll.
  
  Definition clear
    : (|Indexed_context|).(Storage_sigs.Indexed_raw_context.context) ->
    Lwt.t Raw_context.t :=
    (|Indexed_context|).(Storage_sigs.Indexed_raw_context.clear).
End Roll.

Module Vote.
  Definition Raw_context :=
    ((Storage_functors.Make_subcontext
      (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _
        {|
          Raw_context.T.mem := Raw_context.mem;
          Raw_context.T.dir_mem := Raw_context.dir_mem;
          Raw_context.T.get := Raw_context.get;
          Raw_context.T.get_option := Raw_context.get_option;
          Raw_context.T.init := Raw_context.init;
          Raw_context.T.set := Raw_context.set;
          Raw_context.T.init_set := Raw_context.init_set;
          Raw_context.T.set_option := Raw_context.set_option;
          Raw_context.T.delete := Raw_context.delete;
          Raw_context.T.remove := Raw_context.remove;
          Raw_context.T.remove_rec := Raw_context.remove_rec;
          Raw_context.T.copy := Raw_context.copy;
          Raw_context.T.fold {_} := Raw_context.fold;
          Raw_context.T.keys := Raw_context.keys;
          Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
          Raw_context.T.project := Raw_context.project;
          Raw_context.T.absolute_key := Raw_context.absolute_key;
          Raw_context.T.consume_gas := Raw_context.consume_gas;
          Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
          Raw_context.T.description := Raw_context.description
        |}))
      (let name := [ "votes" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}).
  
  Definition Current_period_kind :=
    (((Storage_functors.Make_single_data_storage
      (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _ (|Raw_context|)))
      (let name := [ "current_period_kind" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (let t : Set := Voting_period_repr.kind in
      let encoding := Voting_period_repr.kind_encoding in
      existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
        |}).
  
  Definition Participation_ema :=
    (((Storage_functors.Make_single_data_storage
      (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _ (|Raw_context|)))
      (let name := [ "participation_ema" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |})) (existT (A := Set) _ _ (|Int32|)).
  
  Definition Current_proposal :=
    (((Storage_functors.Make_single_data_storage
      (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _ (|Raw_context|)))
      (let name := [ "current_proposal" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := (|Protocol_hash|).(S.HASH.encoding)
        |}).
  
  Definition Listings_size :=
    (((Storage_functors.Make_single_data_storage
      (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _ (|Raw_context|)))
      (let name := [ "listings_size" ] in
      existT (A := unit) (fun _ => _) tt
        {|
          Storage_sigs.NAME.name := name
        |})) (existT (A := Set) _ _ (|Int32|)).
  
  Definition Listings :=
    ((Storage_functors.Make_indexed_data_storage
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _ (|Raw_context|)))
          (let name := [ "listings" ] in
          existT (A := unit) (fun _ => _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index
          (existT (A := Set) _ _
            {|
              Storage_description.INDEX.path_length :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.path_length);
              Storage_description.INDEX.to_path :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.to_path);
              Storage_description.INDEX.of_path :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.of_path);
              Storage_description.INDEX.rpc_arg :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.rpc_arg);
              Storage_description.INDEX.encoding :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding);
              Storage_description.INDEX.compare :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.compare)
            |}) in
      existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)))
      (existT (A := Set) _ _ (|Int32|)).
  
  Definition Proposals :=
    (Storage_functors.Make_data_set_storage
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _ (|Raw_context|)))
          (let name := [ "proposals" ] in
          existT (A := unit) (fun _ => _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        (Storage_functors.Pair
          (let functor_result :=
            Make_index
              (existT (A := Set) _ _
                {|
                  Storage_description.INDEX.path_length :=
                    (|Protocol_hash|).(S.HASH.path_length);
                  Storage_description.INDEX.to_path :=
                    (|Protocol_hash|).(S.HASH.to_path);
                  Storage_description.INDEX.of_path :=
                    (|Protocol_hash|).(S.HASH.of_path);
                  Storage_description.INDEX.rpc_arg :=
                    (|Protocol_hash|).(S.HASH.rpc_arg);
                  Storage_description.INDEX.encoding :=
                    (|Protocol_hash|).(S.HASH.encoding);
                  Storage_description.INDEX.compare :=
                    (|Protocol_hash|).(S.HASH.compare)
                |}) in
          existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)))
          (let functor_result :=
            Make_index
              (existT (A := Set) _ _
                {|
                  Storage_description.INDEX.path_length :=
                    (|Signature.Public_key_hash|).(S.SPublic_key_hash.path_length);
                  Storage_description.INDEX.to_path :=
                    (|Signature.Public_key_hash|).(S.SPublic_key_hash.to_path);
                  Storage_description.INDEX.of_path :=
                    (|Signature.Public_key_hash|).(S.SPublic_key_hash.of_path);
                  Storage_description.INDEX.rpc_arg :=
                    (|Signature.Public_key_hash|).(S.SPublic_key_hash.rpc_arg);
                  Storage_description.INDEX.encoding :=
                    (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding);
                  Storage_description.INDEX.compare :=
                    (|Signature.Public_key_hash|).(S.SPublic_key_hash.compare)
                |}) in
          existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)) in
      existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)).
  
  Definition Proposals_count :=
    ((Storage_functors.Make_indexed_data_storage
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _ (|Raw_context|)))
          (let name := [ "proposals_count" ] in
          existT (A := unit) (fun _ => _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index
          (existT (A := Set) _ _
            {|
              Storage_description.INDEX.path_length :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.path_length);
              Storage_description.INDEX.to_path :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.to_path);
              Storage_description.INDEX.of_path :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.of_path);
              Storage_description.INDEX.rpc_arg :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.rpc_arg);
              Storage_description.INDEX.encoding :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding);
              Storage_description.INDEX.compare :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.compare)
            |}) in
      existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)))
      (existT (A := Set) _ _ (|Int|)).
  
  Definition Ballots :=
    ((Storage_functors.Make_indexed_data_storage
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _ (|Raw_context|)))
          (let name := [ "ballots" ] in
          existT (A := unit) (fun _ => _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index
          (existT (A := Set) _ _
            {|
              Storage_description.INDEX.path_length :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.path_length);
              Storage_description.INDEX.to_path :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.to_path);
              Storage_description.INDEX.of_path :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.of_path);
              Storage_description.INDEX.rpc_arg :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.rpc_arg);
              Storage_description.INDEX.encoding :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding);
              Storage_description.INDEX.compare :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.compare)
            |}) in
      existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)))
      (let t : Set := Vote_repr.ballot in
      let encoding := Vote_repr.ballot_encoding in
      existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
        |}).
End Vote.

Module Seed.
  Module unrevealed_nonce.
    Record record : Set := Build {
      nonce_hash : Nonce_hash.t;
      delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t);
      rewards : Tez_repr.t;
      fees : Tez_repr.t }.
    Definition with_nonce_hash nonce_hash (r : record) :=
      Build nonce_hash r.(delegate) r.(rewards) r.(fees).
    Definition with_delegate delegate (r : record) :=
      Build r.(nonce_hash) delegate r.(rewards) r.(fees).
    Definition with_rewards rewards (r : record) :=
      Build r.(nonce_hash) r.(delegate) rewards r.(fees).
    Definition with_fees fees (r : record) :=
      Build r.(nonce_hash) r.(delegate) r.(rewards) fees.
  End unrevealed_nonce.
  Definition unrevealed_nonce := unrevealed_nonce.record.
  
  Inductive nonce_status : Set :=
  | Unrevealed : unrevealed_nonce -> nonce_status
  | Revealed : Seed_repr.nonce -> nonce_status.
  
  Definition Nonce :=
    (* ❌ open *)
    let tag_Non_iterable_indexed_data_storage := tt in
    let context : Set := Raw_context.t in
    let mem
      (ctxt : (|Cycle.Indexed_context|).(Storage_sigs.Indexed_raw_context.t))
      (l : Level_repr.t) : Lwt.t bool :=
      (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.mem)
        (ctxt, l.(Level_repr.t.cycle)) l.(Level_repr.t.level) in
    let get
      (ctxt : (|Cycle.Indexed_context|).(Storage_sigs.Indexed_raw_context.t))
      (l : Level_repr.t)
      : Lwt.t
        (Error_monad.tzresult
          (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.value)) :=
      (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.get)
        (ctxt, l.(Level_repr.t.cycle)) l.(Level_repr.t.level) in
    let get_option
      (ctxt : (|Cycle.Indexed_context|).(Storage_sigs.Indexed_raw_context.t))
      (l : Level_repr.t)
      : Lwt.t
        (Error_monad.tzresult
          (option (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.value))) :=
      (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.get_option)
        (ctxt, l.(Level_repr.t.cycle)) l.(Level_repr.t.level) in
    let set
      (ctxt : (|Cycle.Indexed_context|).(Storage_sigs.Indexed_raw_context.t))
      (l : Level_repr.t)
      (v : (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.value))
      : Lwt.t (Error_monad.tzresult Raw_context.t) :=
      (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.set)
        (ctxt, l.(Level_repr.t.cycle)) l.(Level_repr.t.level) v in
    let init
      (ctxt : (|Cycle.Indexed_context|).(Storage_sigs.Indexed_raw_context.t))
      (l : Level_repr.t)
      (v : (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.value))
      : Lwt.t (Error_monad.tzresult Raw_context.t) :=
      (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.init)
        (ctxt, l.(Level_repr.t.cycle)) l.(Level_repr.t.level) v in
    let init_set
      (ctxt : (|Cycle.Indexed_context|).(Storage_sigs.Indexed_raw_context.t))
      (l : Level_repr.t)
      (v : (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.value))
      : Lwt.t Raw_context.t :=
      (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.init_set)
        (ctxt, l.(Level_repr.t.cycle)) l.(Level_repr.t.level) v in
    let set_option
      (ctxt : (|Cycle.Indexed_context|).(Storage_sigs.Indexed_raw_context.t))
      (l : Level_repr.t)
      (v : option (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.value))
      : Lwt.t Raw_context.t :=
      (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.set_option)
        (ctxt, l.(Level_repr.t.cycle)) l.(Level_repr.t.level) v in
    let delete
      (ctxt : (|Cycle.Indexed_context|).(Storage_sigs.Indexed_raw_context.t))
      (l : Level_repr.t) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
      (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.delete)
        (ctxt, l.(Level_repr.t.cycle)) l.(Level_repr.t.level) in
    let remove
      (ctxt : (|Cycle.Indexed_context|).(Storage_sigs.Indexed_raw_context.t))
      (l : Level_repr.t) : Lwt.t Raw_context.t :=
      (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.remove)
        (ctxt, l.(Level_repr.t.cycle)) l.(Level_repr.t.level) in
    existT (A := unit) (fun _ => _) tt
      {|
        Storage_sigs.Non_iterable_indexed_data_storage.tag_Non_iterable_indexed_data_storage :=
          tag_Non_iterable_indexed_data_storage;
        Storage_sigs.Non_iterable_indexed_data_storage.mem := mem;
        Storage_sigs.Non_iterable_indexed_data_storage.get := get;
        Storage_sigs.Non_iterable_indexed_data_storage.get_option := get_option;
        Storage_sigs.Non_iterable_indexed_data_storage.set := set;
        Storage_sigs.Non_iterable_indexed_data_storage.init := init;
        Storage_sigs.Non_iterable_indexed_data_storage.init_set := init_set;
        Storage_sigs.Non_iterable_indexed_data_storage.set_option := set_option;
        Storage_sigs.Non_iterable_indexed_data_storage.delete := delete;
        Storage_sigs.Non_iterable_indexed_data_storage.remove := remove
      |}.
  
  Definition For_cycle := Cycle.Seed.
End Seed.

Definition Commitments :=
  ((Storage_functors.Make_indexed_data_storage
    (let functor_result :=
      ((Storage_functors.Make_subcontext
        (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
        (existT (A := Set) _ _
          {|
            Raw_context.T.mem := Raw_context.mem;
            Raw_context.T.dir_mem := Raw_context.dir_mem;
            Raw_context.T.get := Raw_context.get;
            Raw_context.T.get_option := Raw_context.get_option;
            Raw_context.T.init := Raw_context.init;
            Raw_context.T.set := Raw_context.set;
            Raw_context.T.init_set := Raw_context.init_set;
            Raw_context.T.set_option := Raw_context.set_option;
            Raw_context.T.delete := Raw_context.delete;
            Raw_context.T.remove := Raw_context.remove;
            Raw_context.T.remove_rec := Raw_context.remove_rec;
            Raw_context.T.copy := Raw_context.copy;
            Raw_context.T.fold {_} := Raw_context.fold;
            Raw_context.T.keys := Raw_context.keys;
            Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
            Raw_context.T.project := Raw_context.project;
            Raw_context.T.absolute_key := Raw_context.absolute_key;
            Raw_context.T.consume_gas := Raw_context.consume_gas;
            Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
            Raw_context.T.description := Raw_context.description
          |}))
        (let name := [ "commitments" ] in
        existT (A := unit) (fun _ => _) tt
          {|
            Storage_sigs.NAME.name := name
          |}) in
    existT (A := Set) _ _ (|functor_result|)))
    (let functor_result :=
      Make_index (existT (A := Set) _ _ (|Blinded_public_key_hash.Index|)) in
    existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)))
    (existT (A := Set) _ _
      {|
        Storage_sigs.VALUE.encoding := Tez_repr.encoding
      |}).

Module Ramp_up.
  Definition Rewards :=
    ((Storage_functors.Make_indexed_data_storage
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _
            {|
              Raw_context.T.mem := Raw_context.mem;
              Raw_context.T.dir_mem := Raw_context.dir_mem;
              Raw_context.T.get := Raw_context.get;
              Raw_context.T.get_option := Raw_context.get_option;
              Raw_context.T.init := Raw_context.init;
              Raw_context.T.set := Raw_context.set;
              Raw_context.T.init_set := Raw_context.init_set;
              Raw_context.T.set_option := Raw_context.set_option;
              Raw_context.T.delete := Raw_context.delete;
              Raw_context.T.remove := Raw_context.remove;
              Raw_context.T.remove_rec := Raw_context.remove_rec;
              Raw_context.T.copy := Raw_context.copy;
              Raw_context.T.fold {_} := Raw_context.fold;
              Raw_context.T.keys := Raw_context.keys;
              Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
              Raw_context.T.project := Raw_context.project;
              Raw_context.T.absolute_key := Raw_context.absolute_key;
              Raw_context.T.consume_gas := Raw_context.consume_gas;
              Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
              Raw_context.T.description := Raw_context.description
            |}))
          (let name := [ "ramp_up"; "rewards" ] in
          existT (A := unit) (fun _ => _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index (existT (A := Set) _ _ (|Cycle_repr.Index|)) in
      existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)))
      (let t : Set := Tez_repr.t * Tez_repr.t in
      let encoding := Data_encoding.tup2 Tez_repr.encoding Tez_repr.encoding in
      existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
        |}).
  
  Definition Security_deposits :=
    ((Storage_functors.Make_indexed_data_storage
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ => _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _
            {|
              Raw_context.T.mem := Raw_context.mem;
              Raw_context.T.dir_mem := Raw_context.dir_mem;
              Raw_context.T.get := Raw_context.get;
              Raw_context.T.get_option := Raw_context.get_option;
              Raw_context.T.init := Raw_context.init;
              Raw_context.T.set := Raw_context.set;
              Raw_context.T.init_set := Raw_context.init_set;
              Raw_context.T.set_option := Raw_context.set_option;
              Raw_context.T.delete := Raw_context.delete;
              Raw_context.T.remove := Raw_context.remove;
              Raw_context.T.remove_rec := Raw_context.remove_rec;
              Raw_context.T.copy := Raw_context.copy;
              Raw_context.T.fold {_} := Raw_context.fold;
              Raw_context.T.keys := Raw_context.keys;
              Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
              Raw_context.T.project := Raw_context.project;
              Raw_context.T.absolute_key := Raw_context.absolute_key;
              Raw_context.T.consume_gas := Raw_context.consume_gas;
              Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
              Raw_context.T.description := Raw_context.description
            |}))
          (let name := [ "ramp_up"; "deposits" ] in
          existT (A := unit) (fun _ => _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index (existT (A := Set) _ _ (|Cycle_repr.Index|)) in
      existT (A := [Set ** Set -> Set]) _ [_, _] (|functor_result|)))
      (let t : Set := Tez_repr.t * Tez_repr.t in
      let encoding := Data_encoding.tup2 Tez_repr.encoding Tez_repr.encoding in
      existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
        |}).
End Ramp_up.
