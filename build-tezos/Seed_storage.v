(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Unset Positivity Checking.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Constants_storage.
Require Tezos.Cycle_repr.
Require Tezos.Level_repr.
Require Tezos.Level_storage.
Require Tezos.Misc.
Require Tezos.Raw_context.
Require Tezos.Seed_repr.
Require Tezos.Storage_mli. Module Storage := Storage_mli.
Require Tezos.Storage_sigs.

Import Misc.

(* ❌ Structure item `typext` not handled. *)
(* type_extension *)

(* ❌ Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition compute_for_cycle
  (c : Raw_context.t) (revealed : Cycle_repr.t) (cycle : Cycle_repr.cycle)
  : Lwt.t
    (Error_monad.tzresult (Raw_context.t * list Storage.Seed.unrevealed_nonce)) :=
  match Cycle_repr.pred cycle with
  | None =>
    (* ❌ Assert instruction is not handled. *)
    assert
      (Lwt.t
        (Error_monad.tzresult
          (Raw_context.t * list Storage.Seed.unrevealed_nonce))) false
  | Some previous_cycle =>
    let levels := Level_storage.levels_with_commitments_in_cycle c revealed in
    let combine
      (function_parameter :
        (|Storage.Seed.Nonce|).(Storage_sigs.Non_iterable_indexed_data_storage.context)
          * Seed_repr.seed * list Storage.Seed.unrevealed_nonce)
      : Level_repr.t ->
      Lwt.t
        (Error_monad.tzresult
          (Raw_context.t * Seed_repr.seed * list Storage.Seed.unrevealed_nonce)) :=
      let '(c, random_seed, unrevealed) := function_parameter in
      fun level =>
        let=? function_parameter :=
          (|Storage.Seed.Nonce|).(Storage_sigs.Non_iterable_indexed_data_storage.get)
            c level in
        match function_parameter with
        | Storage.Seed.Revealed __nonce_value =>
          let=? c :=
            (|Storage.Seed.Nonce|).(Storage_sigs.Non_iterable_indexed_data_storage.delete)
              c level in
          Error_monad.__return
            (c, (Seed_repr.__nonce_value random_seed __nonce_value), unrevealed)
        | Storage.Seed.Unrevealed u =>
          let=? c :=
            (|Storage.Seed.Nonce|).(Storage_sigs.Non_iterable_indexed_data_storage.delete)
              c level in
          Error_monad.__return (c, random_seed, (cons u unrevealed))
        end in
    let=? prev_seed := Storage.Seed.For_cycle.get c previous_cycle in
    let __seed_value := Seed_repr.deterministic_seed prev_seed in
    let=? '(c, __seed_value, unrevealed) :=
      Error_monad.fold_left_s combine (c, __seed_value, nil) levels in
    let=? c := Storage.Seed.For_cycle.init c cycle __seed_value in
    Error_monad.__return (c, unrevealed)
  end.

Definition for_cycle (ctxt : Raw_context.context) (cycle : Cycle_repr.t)
  : Lwt.t (Error_monad.tzresult Seed_repr.seed) :=
  let preserved := Constants_storage.preserved_cycles ctxt in
  let current_level := Level_storage.current ctxt in
  let current_cycle := current_level.(Level_repr.t.cycle) in
  let latest :=
    if Cycle_repr.op_eq current_cycle Cycle_repr.root then
      Cycle_repr.add current_cycle (Pervasives.op_plus preserved 1)
    else
      Cycle_repr.add current_cycle preserved in
  let oldest :=
    match Cycle_repr.sub current_cycle preserved with
    | None => Cycle_repr.root
    | Some oldest => oldest
    end in
  let=? '_ :=
    Error_monad.fail_unless
      (Pervasives.op_andand (Cycle_repr.op_lteq oldest cycle)
        (Cycle_repr.op_lteq cycle latest)) extensible_type_value in
  Storage.Seed.For_cycle.get ctxt cycle.

Definition clear_cycle (c : Raw_context.t) (cycle : Cycle_repr.t)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Storage.Seed.For_cycle.delete c cycle.

Definition init (ctxt : Raw_context.context)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let preserved := Constants_storage.preserved_cycles ctxt in
  List.fold_left2
    (fun ctxt =>
      fun c =>
        fun __seed_value =>
          let=? ctxt := ctxt in
          let cycle := Cycle_repr.of_int32_exn (Int32.of_int c) in
          Storage.Seed.For_cycle.init ctxt cycle __seed_value)
    (Error_monad.__return ctxt)
    (Misc.op_minusminusgt 0 (Pervasives.op_plus preserved 1))
    (Seed_repr.initial_seeds (Pervasives.op_plus preserved 2)).

Definition cycle_end
  (ctxt : Raw_context.context) (last_cycle : Cycle_repr.cycle)
  : Lwt.t
    (Error_monad.tzresult
      (Raw_context.context * list Storage.Seed.unrevealed_nonce)) :=
  let preserved := Constants_storage.preserved_cycles ctxt in
  let=? ctxt :=
    match Cycle_repr.sub last_cycle preserved with
    | None => Error_monad.__return ctxt
    | Some cleared_cycle => clear_cycle ctxt cleared_cycle
    end in
  match Cycle_repr.pred last_cycle with
  | None => Error_monad.__return (ctxt, nil)
  | Some revealed =>
    let inited_seed_cycle :=
      Cycle_repr.add last_cycle (Pervasives.op_plus preserved 1) in
    compute_for_cycle ctxt revealed inited_seed_cycle
  end.
