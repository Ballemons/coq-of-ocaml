(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Unset Positivity Checking.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Constants_storage.
Require Tezos.Cycle_repr.
Require Tezos.Level_repr.
Require Tezos.Level_storage.
Require Tezos.Misc.
Require Tezos.Raw_context.
Require Tezos.Seed_repr.
Require Tezos.Storage_mli. Module Storage := Storage_mli.

Import Misc.

(* ❌ Structure item `typext` not handled. *)
(* type_extension *)

(* ❌ Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition compute_for_cycle
  (c : Raw_context.t) (revealed : Cycle_repr.t) (cycle : Cycle_repr.cycle)
  : Lwt.t
    (Error_monad.tzresult (Raw_context.t * list Storage.Seed.unrevealed_nonce)) :=
  match Cycle_repr.pred cycle with
  | None =>
    (* ❌ Assert instruction is not handled. *)
    assert false
  | Some previous_cycle =>
    let levels := Level_storage.levels_with_commitments_in_cycle c revealed in
    let combine
      (function_parameter :
        Storage.Seed.Nonce.context * Seed_repr.seed *
          list Storage.Seed.unrevealed_nonce)
      : Level_repr.t ->
      Lwt.t
        (Error_monad.tzresult
          (Raw_context.t * Seed_repr.seed * list Storage.Seed.unrevealed_nonce)) :=
      let '(c, random_seed, unrevealed) := function_parameter in
      fun level =>
        Error_monad.op_gtgteqquestion (Storage.Seed.Nonce.get c level)
          (fun function_parameter =>
            match function_parameter with
            | Storage.Seed.Revealed __nonce_value =>
              Error_monad.op_gtgteqquestion (Storage.Seed.Nonce.delete c level)
                (fun c =>
                  Error_monad.__return
                    (c, (Seed_repr.__nonce_value random_seed __nonce_value),
                      unrevealed))
            | Storage.Seed.Unrevealed u =>
              Error_monad.op_gtgteqquestion (Storage.Seed.Nonce.delete c level)
                (fun c =>
                  Error_monad.__return (c, random_seed, (cons u unrevealed)))
            end) in
    Error_monad.op_gtgteqquestion (Storage.Seed.For_cycle.get c previous_cycle)
      (fun prev_seed =>
        let __seed_value := Seed_repr.deterministic_seed prev_seed in
        Error_monad.op_gtgteqquestion
          (Error_monad.fold_left_s combine (c, __seed_value, nil) levels)
          (fun function_parameter =>
            let '(c, __seed_value, unrevealed) := function_parameter in
            Error_monad.op_gtgteqquestion
              (Storage.Seed.For_cycle.init c cycle __seed_value)
              (fun c => Error_monad.__return (c, unrevealed))))
  end.

Definition for_cycle (ctxt : Raw_context.context) (cycle : Cycle_repr.t)
  : Lwt.t (Error_monad.tzresult Seed_repr.seed) :=
  let preserved := Constants_storage.preserved_cycles ctxt in
  let current_level := Level_storage.current ctxt in
  let current_cycle := current_level.(Level_repr.t.cycle) in
  let latest :=
    if Cycle_repr.op_eq current_cycle Cycle_repr.root then
      Cycle_repr.add current_cycle (Pervasives.op_plus preserved 1)
    else
      Cycle_repr.add current_cycle preserved in
  let oldest :=
    match Cycle_repr.sub current_cycle preserved with
    | None => Cycle_repr.root
    | Some oldest => oldest
    end in
  Error_monad.op_gtgteqquestion
    (Error_monad.fail_unless
      (Pervasives.op_andand (Cycle_repr.op_lteq oldest cycle)
        (Cycle_repr.op_lteq cycle latest)) extensible_type_value)
    (fun function_parameter =>
      let '_ := function_parameter in
      Storage.Seed.For_cycle.get ctxt cycle).

Definition clear_cycle (c : Raw_context.t) (cycle : Cycle_repr.t)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Storage.Seed.For_cycle.delete c cycle.

Definition init (ctxt : Raw_context.context)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let preserved := Constants_storage.preserved_cycles ctxt in
  List.fold_left2
    (fun ctxt =>
      fun c =>
        fun __seed_value =>
          Error_monad.op_gtgteqquestion ctxt
            (fun ctxt =>
              let cycle := Cycle_repr.of_int32_exn (Int32.of_int c) in
              Storage.Seed.For_cycle.init ctxt cycle __seed_value))
    (Error_monad.__return ctxt)
    (Misc.op_minusminusgt 0 (Pervasives.op_plus preserved 1))
    (Seed_repr.initial_seeds (Pervasives.op_plus preserved 2)).

Definition cycle_end
  (ctxt : Raw_context.context) (last_cycle : Cycle_repr.cycle)
  : Lwt.t
    (Error_monad.tzresult
      (Raw_context.context * list Storage.Seed.unrevealed_nonce)) :=
  let preserved := Constants_storage.preserved_cycles ctxt in
  Error_monad.op_gtgteqquestion
    match Cycle_repr.sub last_cycle preserved with
    | None => Error_monad.__return ctxt
    | Some cleared_cycle => clear_cycle ctxt cleared_cycle
    end
    (fun ctxt =>
      match Cycle_repr.pred last_cycle with
      | None => Error_monad.__return (ctxt, nil)
      | Some revealed =>
        let inited_seed_cycle :=
          Cycle_repr.add last_cycle (Pervasives.op_plus preserved 1) in
        compute_for_cycle ctxt revealed inited_seed_cycle
      end).
