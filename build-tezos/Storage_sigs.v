(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Raw_context.

Definition depend_on_me (function_parameter : unit) : unit :=
  let '_ := function_parameter in
  tt.

Module Single_data_storage.
  Record signature {t value : Set} : Set := {
    tag_Single_data_storage : unit;
    t := t;
    context := t;
    value := value;
    mem : context -> Lwt.t bool;
    get : context -> Lwt.t (Error_monad.tzresult value);
    get_option : context -> Lwt.t (Error_monad.tzresult (option value));
    init : context -> value -> Lwt.t (Error_monad.tzresult Raw_context.t);
    set : context -> value -> Lwt.t (Error_monad.tzresult Raw_context.t);
    init_set : context -> value -> Lwt.t Raw_context.t;
    set_option : context -> option value -> Lwt.t Raw_context.t;
    delete : context -> Lwt.t (Error_monad.tzresult Raw_context.t);
    remove : context -> Lwt.t Raw_context.t;
  }.
  Arguments signature : clear implicits.
End Single_data_storage.

Module Single_carbonated_data_storage.
  Record signature {t value : Set} : Set := {
    tag_Single_carbonated_data_storage : unit;
    t := t;
    context := t;
    value := value;
    mem : context -> Lwt.t (Error_monad.tzresult (Raw_context.t * bool));
    get : context -> Lwt.t (Error_monad.tzresult (Raw_context.t * value));
    get_option :
      context -> Lwt.t (Error_monad.tzresult (Raw_context.t * option value));
    init :
      context -> value -> Lwt.t (Error_monad.tzresult (Raw_context.t * int));
    set :
      context -> value -> Lwt.t (Error_monad.tzresult (Raw_context.t * int));
    init_set :
      context -> value ->
      Lwt.t (Error_monad.tzresult (Raw_context.t * int * bool));
    set_option :
      context -> option value ->
      Lwt.t (Error_monad.tzresult (Raw_context.t * int * bool));
    delete : context -> Lwt.t (Error_monad.tzresult (Raw_context.t * int));
    remove :
      context -> Lwt.t (Error_monad.tzresult (Raw_context.t * int * bool));
  }.
  Arguments signature : clear implicits.
End Single_carbonated_data_storage.

Module Non_iterable_indexed_data_storage.
  Record signature {t key value : Set} : Set := {
    tag_Non_iterable_indexed_data_storage : unit;
    t := t;
    context := t;
    key := key;
    value := value;
    mem : context -> key -> Lwt.t bool;
    get : context -> key -> Lwt.t (Error_monad.tzresult value);
    get_option : context -> key -> Lwt.t (Error_monad.tzresult (option value));
    set : context -> key -> value -> Lwt.t (Error_monad.tzresult Raw_context.t);
    init :
      context -> key -> value -> Lwt.t (Error_monad.tzresult Raw_context.t);
    init_set : context -> key -> value -> Lwt.t Raw_context.t;
    set_option : context -> key -> option value -> Lwt.t Raw_context.t;
    delete : context -> key -> Lwt.t (Error_monad.tzresult Raw_context.t);
    remove : context -> key -> Lwt.t Raw_context.t;
  }.
  Arguments signature : clear implicits.
End Non_iterable_indexed_data_storage.

Module Non_iterable_indexed_carbonated_data_storage.
  Record signature {t key value : Set} : Set := {
    tag_Non_iterable_indexed_carbonated_data_storage : unit;
    t := t;
    context := t;
    key := key;
    value := value;
    mem : context -> key -> Lwt.t (Error_monad.tzresult (Raw_context.t * bool));
    get :
      context -> key -> Lwt.t (Error_monad.tzresult (Raw_context.t * value));
    get_option :
      context -> key ->
      Lwt.t (Error_monad.tzresult (Raw_context.t * option value));
    set :
      context -> key -> value ->
      Lwt.t (Error_monad.tzresult (Raw_context.t * int));
    init :
      context -> key -> value ->
      Lwt.t (Error_monad.tzresult (Raw_context.t * int));
    init_set :
      context -> key -> value ->
      Lwt.t (Error_monad.tzresult (Raw_context.t * int * bool));
    set_option :
      context -> key -> option value ->
      Lwt.t (Error_monad.tzresult (Raw_context.t * int * bool));
    delete :
      context -> key -> Lwt.t (Error_monad.tzresult (Raw_context.t * int));
    remove :
      context -> key ->
      Lwt.t (Error_monad.tzresult (Raw_context.t * int * bool));
  }.
  Arguments signature : clear implicits.
End Non_iterable_indexed_carbonated_data_storage.

Module Indexed_data_storage.
  Record signature {t key value : Set} : Set := {
    tag_Non_iterable_indexed_data_storage : unit;
    t := t;
    context := t;
    key := key;
    value := value;
    mem : context -> key -> Lwt.t bool;
    get : context -> key -> Lwt.t (Error_monad.tzresult value);
    get_option : context -> key -> Lwt.t (Error_monad.tzresult (option value));
    set : context -> key -> value -> Lwt.t (Error_monad.tzresult Raw_context.t);
    init :
      context -> key -> value -> Lwt.t (Error_monad.tzresult Raw_context.t);
    init_set : context -> key -> value -> Lwt.t Raw_context.t;
    set_option : context -> key -> option value -> Lwt.t Raw_context.t;
    delete : context -> key -> Lwt.t (Error_monad.tzresult Raw_context.t);
    remove : context -> key -> Lwt.t Raw_context.t;
    clear : context -> Lwt.t Raw_context.t;
    keys : context -> Lwt.t (list key);
    bindings : context -> Lwt.t (list (key * value));
    fold : forall {a : Set},
      context -> a -> (key -> value -> a -> Lwt.t a) -> Lwt.t a;
    fold_keys : forall {a : Set},
      context -> a -> (key -> a -> Lwt.t a) -> Lwt.t a;
  }.
  Arguments signature : clear implicits.
End Indexed_data_storage.

Module Indexed_data_snapshotable_storage.
  Record signature {snapshot key t value : Set} : Set := {
    snapshot := snapshot;
    key := key;
    tag_Non_iterable_indexed_data_storage : unit;
    t := t;
    context := t;
    value := value;
    mem : context -> key -> Lwt.t bool;
    get : context -> key -> Lwt.t (Error_monad.tzresult value);
    get_option : context -> key -> Lwt.t (Error_monad.tzresult (option value));
    set : context -> key -> value -> Lwt.t (Error_monad.tzresult Raw_context.t);
    init :
      context -> key -> value -> Lwt.t (Error_monad.tzresult Raw_context.t);
    init_set : context -> key -> value -> Lwt.t Raw_context.t;
    set_option : context -> key -> option value -> Lwt.t Raw_context.t;
    delete : context -> key -> Lwt.t (Error_monad.tzresult Raw_context.t);
    remove : context -> key -> Lwt.t Raw_context.t;
    clear : context -> Lwt.t Raw_context.t;
    keys : context -> Lwt.t (list key);
    bindings : context -> Lwt.t (list (key * value));
    fold : forall {a : Set},
      context -> a -> (key -> value -> a -> Lwt.t a) -> Lwt.t a;
    fold_keys : forall {a : Set},
      context -> a -> (key -> a -> Lwt.t a) -> Lwt.t a;
    Snapshot : Indexed_data_storage.signature t (snapshot * key) value;
    snapshot_exists : context -> snapshot -> Lwt.t bool;
    __snapshot_value :
      context -> snapshot -> Lwt.t (Error_monad.tzresult Raw_context.t);
    delete_snapshot : context -> snapshot -> Lwt.t Raw_context.t;
  }.
  Arguments signature : clear implicits.
End Indexed_data_snapshotable_storage.

Module Data_set_storage.
  Record signature {t elt : Set} : Set := {
    t := t;
    context := t;
    elt := elt;
    mem : context -> elt -> Lwt.t bool;
    add : context -> elt -> Lwt.t Raw_context.t;
    del : context -> elt -> Lwt.t Raw_context.t;
    set : context -> elt -> bool -> Lwt.t Raw_context.t;
    elements : context -> Lwt.t (list elt);
    fold : forall {a : Set}, context -> a -> (elt -> a -> Lwt.t a) -> Lwt.t a;
    clear : context -> Lwt.t Raw_context.t;
  }.
  Arguments signature : clear implicits.
End Data_set_storage.

Module NAME.
  Record signature : Set := {
    name : Raw_context.key;
  }.
End NAME.

Module VALUE.
  Record signature {t : Set} : Set := {
    t := t;
    encoding : Data_encoding.t t;
  }.
  Arguments signature : clear implicits.
End VALUE.

Module REGISTER.
  Record signature : Set := {
    ghost : bool;
  }.
End REGISTER.

Module Indexed_raw_context.
  Record signature {t key : Set} {ipath : Set -> Set} : Set := {
    t := t;
    context := t;
    key := key;
    ipath := ipath;
    clear : context -> Lwt.t Raw_context.t;
    fold_keys : forall {a : Set},
      context -> a -> (key -> a -> Lwt.t a) -> Lwt.t a;
    keys : context -> Lwt.t (list key);
    resolve : context -> list string -> Lwt.t (list key);
    remove_rec : context -> key -> Lwt.t context;
    copy : context -> key -> key -> Lwt.t (Error_monad.tzresult context);
    Make_set :
      forall (R : {_ : unit & REGISTER.signature}),
        (forall (N : {_ : unit & NAME.signature}),
          {_ : unit & Data_set_storage.signature t key});
    Make_map :
      forall (N : {_ : unit & NAME.signature}),
        (forall (V : {t : Set & VALUE.signature t}),
          {_ : unit & Indexed_data_storage.signature t key (|V|).(VALUE.t)});
    Make_carbonated_map :
      forall (N : {_ : unit & NAME.signature}),
        (forall (V : {t : Set & VALUE.signature t}),
          {_ : unit &
            Non_iterable_indexed_carbonated_data_storage.signature t key
              (|V|).(VALUE.t)});
    Raw_context : Raw_context.T.signature (ipath t);
  }.
  Arguments signature : clear implicits.
End Indexed_raw_context.
