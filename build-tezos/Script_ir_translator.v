(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Unset Positivity Checking.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Michelson_v1_gas.
Require Tezos.Script_expr_hash.
Require Tezos.Script_ir_annot.
Require Tezos.Script_tc_errors.
Require Tezos.Script_typed_ir.

Import Alpha_context.

Import Micheline.

Import Alpha_context.Script.

Import Script_typed_ir.

Import Script_tc_errors.

Import Script_ir_annot.

Module Typecheck_costs := Michelson_v1_gas.Cost_of.Typechecking.

Module Unparse_costs := Michelson_v1_gas.Cost_of.Unparse.

Inductive ex_comparable_ty : Set :=
| Ex_comparable_ty : Script_typed_ir.comparable_ty -> ex_comparable_ty.

Inductive ex_ty : Set :=
| Ex_ty : Script_typed_ir.ty -> ex_ty.

Inductive ex_stack_ty : Set :=
| Ex_stack_ty : Script_typed_ir.stack_ty -> ex_stack_ty.

Module ConstructorRecordNotations_tc_context.
  Module tc_context.
    Module Toplevel.
      Record record {storage_type param_type root_name
        legacy_create_contract_literal : Set} : Set := {
        storage_type : storage_type;
        param_type : param_type;
        root_name : root_name;
        legacy_create_contract_literal : legacy_create_contract_literal }.
      Arguments record : clear implicits.
    End Toplevel.
    Definition Toplevel_skeleton := Toplevel.record.
  End tc_context.
End ConstructorRecordNotations_tc_context.
Import ConstructorRecordNotations_tc_context.

Reserved Notation "'tc_context.Toplevel".

Inductive tc_context : Set :=
| Lambda : tc_context
| Dip : Script_typed_ir.stack_ty -> tc_context -> tc_context
| Toplevel : 'tc_context.Toplevel -> tc_context

where "'tc_context.Toplevel" :=
  (tc_context.Toplevel_skeleton Script_typed_ir.ty Script_typed_ir.ty
    (option string) bool).

Module tc_context.
  Include ConstructorRecordNotations_tc_context.tc_context.
  Definition Toplevel := 'tc_context.Toplevel.
End tc_context.

Inductive unparsing_mode : Set :=
| Optimized : unparsing_mode
| Readable : unparsing_mode.

Definition type_logger : Set :=
  int -> list (Alpha_context.Script.expr * Alpha_context.Script.annot) ->
  list (Alpha_context.Script.expr * Alpha_context.Script.annot) -> unit.

Definition add_dip
  (ty : Script_typed_ir.ty) (annot : option Script_typed_ir.var_annot)
  (prev : tc_context) : tc_context :=
  match prev with
  | (Lambda | Toplevel _) =>
    Dip (Script_typed_ir.Item_t ty Script_typed_ir.Empty_t annot) prev
  | Dip __stack_value _ =>
    Dip (Script_typed_ir.Item_t ty __stack_value annot) prev
  end.

Fixpoint comparable_type_size (ty : Script_typed_ir.comparable_struct)
  {struct ty} : int :=
  match ty with
  | Script_typed_ir.Int_key _ => 1
  | Script_typed_ir.Nat_key _ => 1
  | Script_typed_ir.String_key _ => 1
  | Script_typed_ir.Bytes_key _ => 1
  | Script_typed_ir.Mutez_key _ => 1
  | Script_typed_ir.Bool_key _ => 1
  | Script_typed_ir.Key_hash_key _ => 1
  | Script_typed_ir.Timestamp_key _ => 1
  | Script_typed_ir.Address_key _ => 1
  | Script_typed_ir.Pair_key _ (__t_value, _) _ =>
    Pervasives.op_plus 1 (comparable_type_size __t_value)
  end.

Fixpoint type_size (ty : Script_typed_ir.ty) {struct ty} : int :=
  match ty with
  | Script_typed_ir.Unit_t _ => 1
  | Script_typed_ir.Int_t _ => 1
  | Script_typed_ir.Nat_t _ => 1
  | Script_typed_ir.Signature_t _ => 1
  | Script_typed_ir.Bytes_t _ => 1
  | Script_typed_ir.String_t _ => 1
  | Script_typed_ir.Mutez_t _ => 1
  | Script_typed_ir.Key_hash_t _ => 1
  | Script_typed_ir.Key_t _ => 1
  | Script_typed_ir.Timestamp_t _ => 1
  | Script_typed_ir.Address_t _ => 1
  | Script_typed_ir.Bool_t _ => 1
  | Script_typed_ir.Operation_t _ => 1
  | Script_typed_ir.Pair_t (l, _, _) (__r_value, _, _) _ _ =>
    Pervasives.op_plus (Pervasives.op_plus 1 (type_size l))
      (type_size __r_value)
  | Script_typed_ir.Union_t (l, _) (__r_value, _) _ _ =>
    Pervasives.op_plus (Pervasives.op_plus 1 (type_size l))
      (type_size __r_value)
  | Script_typed_ir.Lambda_t arg ret _ =>
    Pervasives.op_plus (Pervasives.op_plus 1 (type_size arg)) (type_size ret)
  | Script_typed_ir.Option_t __t_value _ _ =>
    Pervasives.op_plus 1 (type_size __t_value)
  | Script_typed_ir.List_t __t_value _ _ =>
    Pervasives.op_plus 1 (type_size __t_value)
  | Script_typed_ir.Set_t k _ => Pervasives.op_plus 1 (comparable_type_size k)
  | Script_typed_ir.Map_t k v _ _ =>
    Pervasives.op_plus (Pervasives.op_plus 1 (comparable_type_size k))
      (type_size v)
  | Script_typed_ir.Big_map_t k v _ =>
    Pervasives.op_plus (Pervasives.op_plus 1 (comparable_type_size k))
      (type_size v)
  | Script_typed_ir.Contract_t arg _ => Pervasives.op_plus 1 (type_size arg)
  | Script_typed_ir.Chain_id_t _ => 1
  end.

Fixpoint type_size_of_stack_head
  (__stack_value : Script_typed_ir.stack_ty) (up_to : int)
  {struct __stack_value} : int :=
  match __stack_value with
  | Script_typed_ir.Empty_t => 0
  | Script_typed_ir.Item_t head tail _annot =>
    if (|Compare.Int|).(Compare.S.op_gt) up_to 0 then
      (|Compare.Int|).(Compare.S.max) (type_size head)
        (type_size_of_stack_head tail (Pervasives.op_minus up_to 1))
    else
      0
  end.

Definition number_of_generated_growing_types
  (function_parameter : Script_typed_ir.instr) : int :=
  match function_parameter with
  | Script_typed_ir.Drop => 0
  | Script_typed_ir.Dup => 0
  | Script_typed_ir.Swap => 0
  | Script_typed_ir.Const _ => 1
  | Script_typed_ir.Cons_pair => 1
  | Script_typed_ir.Car => 0
  | Script_typed_ir.Cdr => 0
  | Script_typed_ir.Cons_some => 1
  | Script_typed_ir.Cons_none _ => 1
  | Script_typed_ir.If_none _ _ => 0
  | Script_typed_ir.Left => 0
  | Script_typed_ir.Right => 0
  | Script_typed_ir.If_left _ _ => 0
  | Script_typed_ir.Cons_list => 1
  | Script_typed_ir.Nil => 1
  | Script_typed_ir.If_cons _ _ => 0
  | Script_typed_ir.List_map _ => 1
  | Script_typed_ir.List_size => 0
  | Script_typed_ir.List_iter _ => 1
  | Script_typed_ir.Empty_set _ => 1
  | Script_typed_ir.Set_iter _ => 0
  | Script_typed_ir.Set_mem => 0
  | Script_typed_ir.Set_update => 0
  | Script_typed_ir.Set_size => 0
  | Script_typed_ir.Empty_map _ _ => 1
  | Script_typed_ir.Map_map _ => 1
  | Script_typed_ir.Map_iter _ => 1
  | Script_typed_ir.Map_mem => 0
  | Script_typed_ir.Map_get => 0
  | Script_typed_ir.Map_update => 0
  | Script_typed_ir.Map_size => 0
  | Script_typed_ir.Empty_big_map _ _ => 1
  | Script_typed_ir.Big_map_get => 0
  | Script_typed_ir.Big_map_update => 0
  | Script_typed_ir.Big_map_mem => 0
  | Script_typed_ir.Concat_string => 0
  | Script_typed_ir.Concat_string_pair => 0
  | Script_typed_ir.Slice_string => 0
  | Script_typed_ir.String_size => 0
  | Script_typed_ir.Concat_bytes => 0
  | Script_typed_ir.Concat_bytes_pair => 0
  | Script_typed_ir.Slice_bytes => 0
  | Script_typed_ir.Bytes_size => 0
  | Script_typed_ir.Add_seconds_to_timestamp => 0
  | Script_typed_ir.Add_timestamp_to_seconds => 0
  | Script_typed_ir.Sub_timestamp_seconds => 0
  | Script_typed_ir.Diff_timestamps => 0
  | Script_typed_ir.Add_tez => 0
  | Script_typed_ir.Sub_tez => 0
  | Script_typed_ir.Mul_teznat => 0
  | Script_typed_ir.Mul_nattez => 0
  | Script_typed_ir.Ediv_teznat => 0
  | Script_typed_ir.Ediv_tez => 0
  | Script_typed_ir.Or => 0
  | Script_typed_ir.And => 0
  | Script_typed_ir.Xor => 0
  | Script_typed_ir.Not => 0
  | Script_typed_ir.Is_nat => 0
  | Script_typed_ir.Neg_nat => 0
  | Script_typed_ir.Neg_int => 0
  | Script_typed_ir.Abs_int => 0
  | Script_typed_ir.Int_nat => 0
  | Script_typed_ir.Add_intint => 0
  | Script_typed_ir.Add_intnat => 0
  | Script_typed_ir.Add_natint => 0
  | Script_typed_ir.Add_natnat => 0
  | Script_typed_ir.Sub_int => 0
  | Script_typed_ir.Mul_intint => 0
  | Script_typed_ir.Mul_intnat => 0
  | Script_typed_ir.Mul_natint => 0
  | Script_typed_ir.Mul_natnat => 0
  | Script_typed_ir.Ediv_intint => 0
  | Script_typed_ir.Ediv_intnat => 0
  | Script_typed_ir.Ediv_natint => 0
  | Script_typed_ir.Ediv_natnat => 0
  | Script_typed_ir.Lsl_nat => 0
  | Script_typed_ir.Lsr_nat => 0
  | Script_typed_ir.Or_nat => 0
  | Script_typed_ir.And_nat => 0
  | Script_typed_ir.And_int_nat => 0
  | Script_typed_ir.Xor_nat => 0
  | Script_typed_ir.Not_nat => 0
  | Script_typed_ir.Not_int => 0
  | Script_typed_ir.Seq _ _ => 0
  | Script_typed_ir.If _ _ => 0
  | Script_typed_ir.Loop _ => 0
  | Script_typed_ir.Loop_left _ => 0
  | Script_typed_ir.Dip _ => 0
  | Script_typed_ir.Exec => 0
  | Script_typed_ir.Apply _ => 0
  | Script_typed_ir.Lambda _ => 1
  | Script_typed_ir.Failwith _ => 1
  | Script_typed_ir.Nop => 0
  | Script_typed_ir.Compare _ => 1
  | Script_typed_ir.Eq => 0
  | Script_typed_ir.Neq => 0
  | Script_typed_ir.Lt => 0
  | Script_typed_ir.Gt => 0
  | Script_typed_ir.Le => 0
  | Script_typed_ir.Ge => 0
  | Script_typed_ir.Address => 0
  | Script_typed_ir.Contract _ _ => 1
  | Script_typed_ir.Transfer_tokens => 1
  | Script_typed_ir.Create_account => 0
  | Script_typed_ir.Implicit_account => 0
  | Script_typed_ir.Create_contract _ _ _ _ => 1
  | Script_typed_ir.Create_contract_2 _ _ _ _ => 1
  | Script_typed_ir.Now => 0
  | Script_typed_ir.Balance => 0
  | Script_typed_ir.Check_signature => 0
  | Script_typed_ir.Hash_key => 0
  | Script_typed_ir.Blake2b => 0
  | Script_typed_ir.Sha256 => 0
  | Script_typed_ir.Sha512 => 0
  | Script_typed_ir.Steps_to_quota => 0
  | Script_typed_ir.Source => 0
  | Script_typed_ir.Sender => 0
  | Script_typed_ir.Self _ _ => 1
  | Script_typed_ir.Amount => 0
  | Script_typed_ir.Set_delegate => 0
  | Script_typed_ir.Pack _ => 0
  | Script_typed_ir.Unpack _ => 1
  | Script_typed_ir.Dig _ _ => 0
  | Script_typed_ir.Dug _ _ => 0
  | Script_typed_ir.Dipn _ _ _ => 0
  | Script_typed_ir.Dropn _ _ => 0
  | Script_typed_ir.ChainId => 0
  end.

Definition location {A B : Set} (function_parameter : Micheline.node A B) : A :=
  match function_parameter with
  |
    (Micheline.Prim loc _ _ _ | Micheline.Int loc _ | Micheline.String loc _ |
    Micheline.Bytes loc _ | Micheline.Seq loc _) => loc
  end.

Definition kind {A B : Set} (function_parameter : Micheline.node A B)
  : Script_tc_errors.kind :=
  match function_parameter with
  | Micheline.Int _ _ => Script_tc_errors.Int_kind
  | Micheline.String _ _ => Script_tc_errors.String_kind
  | Micheline.Bytes _ _ => Script_tc_errors.Bytes_kind
  | Micheline.Prim _ _ _ _ => Script_tc_errors.Prim_kind
  | Micheline.Seq _ _ => Script_tc_errors.Seq_kind
  end.

Definition namespace (function_parameter : Alpha_context.Script.prim)
  : Script_tc_errors.namespace :=
  match function_parameter with
  |
    (Alpha_context.Script.K_parameter | Alpha_context.Script.K_storage |
    Alpha_context.Script.K_code) => Script_tc_errors.Keyword_namespace
  |
    (Alpha_context.Script.D_False | Alpha_context.Script.D_Elt |
    Alpha_context.Script.D_Left | Alpha_context.Script.D_None |
    Alpha_context.Script.D_Pair | Alpha_context.Script.D_Right |
    Alpha_context.Script.D_Some | Alpha_context.Script.D_True |
    Alpha_context.Script.D_Unit) => Script_tc_errors.Constant_namespace
  |
    (Alpha_context.Script.I_PACK | Alpha_context.Script.I_UNPACK |
    Alpha_context.Script.I_BLAKE2B | Alpha_context.Script.I_SHA256 |
    Alpha_context.Script.I_SHA512 | Alpha_context.Script.I_ABS |
    Alpha_context.Script.I_ADD | Alpha_context.Script.I_AMOUNT |
    Alpha_context.Script.I_AND | Alpha_context.Script.I_BALANCE |
    Alpha_context.Script.I_CAR | Alpha_context.Script.I_CDR |
    Alpha_context.Script.I_CHAIN_ID | Alpha_context.Script.I_CHECK_SIGNATURE |
    Alpha_context.Script.I_COMPARE | Alpha_context.Script.I_CONCAT |
    Alpha_context.Script.I_CONS | Alpha_context.Script.I_CREATE_ACCOUNT |
    Alpha_context.Script.I_CREATE_CONTRACT |
    Alpha_context.Script.I_IMPLICIT_ACCOUNT | Alpha_context.Script.I_DIP |
    Alpha_context.Script.I_DROP | Alpha_context.Script.I_DUP |
    Alpha_context.Script.I_EDIV | Alpha_context.Script.I_EMPTY_BIG_MAP |
    Alpha_context.Script.I_EMPTY_MAP | Alpha_context.Script.I_EMPTY_SET |
    Alpha_context.Script.I_EQ | Alpha_context.Script.I_EXEC |
    Alpha_context.Script.I_APPLY | Alpha_context.Script.I_FAILWITH |
    Alpha_context.Script.I_GE | Alpha_context.Script.I_GET |
    Alpha_context.Script.I_GT | Alpha_context.Script.I_HASH_KEY |
    Alpha_context.Script.I_IF | Alpha_context.Script.I_IF_CONS |
    Alpha_context.Script.I_IF_LEFT | Alpha_context.Script.I_IF_NONE |
    Alpha_context.Script.I_INT | Alpha_context.Script.I_LAMBDA |
    Alpha_context.Script.I_LE | Alpha_context.Script.I_LEFT |
    Alpha_context.Script.I_LOOP | Alpha_context.Script.I_LSL |
    Alpha_context.Script.I_LSR | Alpha_context.Script.I_LT |
    Alpha_context.Script.I_MAP | Alpha_context.Script.I_MEM |
    Alpha_context.Script.I_MUL | Alpha_context.Script.I_NEG |
    Alpha_context.Script.I_NEQ | Alpha_context.Script.I_NIL |
    Alpha_context.Script.I_NONE | Alpha_context.Script.I_NOT |
    Alpha_context.Script.I_NOW | Alpha_context.Script.I_OR |
    Alpha_context.Script.I_PAIR | Alpha_context.Script.I_PUSH |
    Alpha_context.Script.I_RIGHT | Alpha_context.Script.I_SIZE |
    Alpha_context.Script.I_SOME | Alpha_context.Script.I_SOURCE |
    Alpha_context.Script.I_SENDER | Alpha_context.Script.I_SELF |
    Alpha_context.Script.I_SLICE | Alpha_context.Script.I_STEPS_TO_QUOTA |
    Alpha_context.Script.I_SUB | Alpha_context.Script.I_SWAP |
    Alpha_context.Script.I_TRANSFER_TOKENS | Alpha_context.Script.I_SET_DELEGATE
    | Alpha_context.Script.I_UNIT | Alpha_context.Script.I_UPDATE |
    Alpha_context.Script.I_XOR | Alpha_context.Script.I_ITER |
    Alpha_context.Script.I_LOOP_LEFT | Alpha_context.Script.I_ADDRESS |
    Alpha_context.Script.I_CONTRACT | Alpha_context.Script.I_ISNAT |
    Alpha_context.Script.I_CAST | Alpha_context.Script.I_RENAME |
    Alpha_context.Script.I_DIG | Alpha_context.Script.I_DUG) =>
    Script_tc_errors.Instr_namespace
  |
    (Alpha_context.Script.T_bool | Alpha_context.Script.T_contract |
    Alpha_context.Script.T_int | Alpha_context.Script.T_key |
    Alpha_context.Script.T_key_hash | Alpha_context.Script.T_lambda |
    Alpha_context.Script.T_list | Alpha_context.Script.T_map |
    Alpha_context.Script.T_big_map | Alpha_context.Script.T_nat |
    Alpha_context.Script.T_option | Alpha_context.Script.T_or |
    Alpha_context.Script.T_pair | Alpha_context.Script.T_set |
    Alpha_context.Script.T_signature | Alpha_context.Script.T_string |
    Alpha_context.Script.T_bytes | Alpha_context.Script.T_mutez |
    Alpha_context.Script.T_timestamp | Alpha_context.Script.T_unit |
    Alpha_context.Script.T_operation | Alpha_context.Script.T_address |
    Alpha_context.Script.T_chain_id) => Script_tc_errors.Type_namespace
  end.

Definition unexpected
  (expr : Micheline.node Alpha_context.Script.location Alpha_context.Script.prim)
  (exp_kinds : list Script_tc_errors.kind) (exp_ns : Script_tc_errors.namespace)
  (exp_prims : list Alpha_context.Script.prim) : Error_monad.__error :=
  match expr with
  | Micheline.Int loc _ => extensible_type_value
  | Micheline.String loc _ => extensible_type_value
  | Micheline.Bytes loc _ => extensible_type_value
  | Micheline.Seq loc _ => extensible_type_value
  | Micheline.Prim loc name _ _ =>
    match ((namespace name), exp_ns) with
    |
      ((Script_tc_errors.Type_namespace, Script_tc_errors.Type_namespace) |
      (Script_tc_errors.Instr_namespace, Script_tc_errors.Instr_namespace) |
      (Script_tc_errors.Constant_namespace, Script_tc_errors.Constant_namespace))
      => extensible_type_value
    | (ns, _) => extensible_type_value
    end
  end.

Definition check_kind {A : Set}
  (kinds : list Script_tc_errors.kind)
  (expr : Micheline.node Alpha_context.Script.location A)
  : Lwt.t (Error_monad.tzresult unit) :=
  let kind := kind expr in
  if List.mem kind kinds then
    Error_monad.return_unit
  else
    let loc := location expr in
    Error_monad.fail extensible_type_value.

Definition wrap_compare {A B : Set}
  (compare : A -> B -> (|Compare.Int|).(Compare.S.t)) (__a_value : A)
  (__b_value : B) : int :=
  let res := compare __a_value __b_value in
  if (|Compare.Int|).(Compare.S.op_eq) res 0 then
    0
  else
    if (|Compare.Int|).(Compare.S.op_gt) res 0 then
      1
    else
      (-1).

Fixpoint compare_comparable {a : Set} (kind : Script_typed_ir.comparable_struct)
  {struct kind} : a -> a -> int :=
  match kind with
  | Script_typed_ir.String_key _ =>
    wrap_compare (|Compare.String|).(Compare.S.compare)
  | Script_typed_ir.Bool_key _ =>
    wrap_compare (|Compare.Bool|).(Compare.S.compare)
  | Script_typed_ir.Mutez_key _ => wrap_compare Alpha_context.Tez.compare
  | Script_typed_ir.Key_hash_key _ =>
    wrap_compare (|Signature.Public_key_hash|).(S.SPublic_key_hash.compare)
  | Script_typed_ir.Int_key _ => wrap_compare Alpha_context.Script_int.compare
  | Script_typed_ir.Nat_key _ => wrap_compare Alpha_context.Script_int.compare
  | Script_typed_ir.Timestamp_key _ =>
    wrap_compare Alpha_context.Script_timestamp.compare
  | Script_typed_ir.Address_key _ =>
    wrap_compare
      (fun function_parameter =>
        let '(x, ex) := function_parameter in
        fun function_parameter =>
          let '(y, ey) := function_parameter in
          let lres := Alpha_context.Contract.compare x y in
          if (|Compare.Int|).(Compare.S.op_eq) lres 0 then
            (|Compare.String|).(Compare.S.compare) ex ey
          else
            lres)
  | Script_typed_ir.Bytes_key _ => wrap_compare MBytes.compare
  | Script_typed_ir.Pair_key (tl, _) (tr, _) _ =>
    fun function_parameter =>
      let '(lx, rx) := function_parameter in
      fun function_parameter =>
        let '(ly, ry) := function_parameter in
        let lres := compare_comparable tl lx ly in
        if (|Compare.Int|).(Compare.S.op_eq) lres 0 then
          compare_comparable tr rx ry
        else
          lres
  end.

Definition empty_set {a : Set} (ty : Script_typed_ir.comparable_ty)
  : Script_typed_ir.set a :=
  let OPS :=
    __Set.Make
      (let t : Set := a in
      let compare := compare_comparable ty in
      existT (A := Set) _ _
        {|
          Compare.COMPARABLE.compare := compare
        |}) in
  (pack
    (let elt : Set := a in
    let elt_ty := ty in
    let OPS := existT (A := unit) (fun _ => _) tt (|OPS|) in
    let boxed := (|OPS|).(S.SET.empty) in
    let size := 0 in
    existT (A := Set) _ _
      {|
        Script_typed_ir.Boxed_set.elt_ty := elt_ty;
        Script_typed_ir.Boxed_set.OPS := (|OPS|);
        Script_typed_ir.Boxed_set.boxed := boxed;
        Script_typed_ir.Boxed_set.size := size
      |})).

Definition set_update {a : Set}
  (v : a) (__b_value : bool) (Box : Script_typed_ir.set a)
  : Script_typed_ir.set a :=
  let 'existS _ _ Box := Box in
  (pack
    (let elt : Set := a in
    let elt_ty := Box.(Script_typed_ir.Boxed_set.elt_ty) in
    let OPS :=
      existT (A := unit) (fun _ => _) tt Box.(Script_typed_ir.Boxed_set.OPS) in
    let boxed :=
      if __b_value then
        Box.(Script_typed_ir.Boxed_set.OPS).(S.SET.add) v
          Box.(Script_typed_ir.Boxed_set.boxed)
      else
        Box.(Script_typed_ir.Boxed_set.OPS).(S.SET.remove) v
          Box.(Script_typed_ir.Boxed_set.boxed) in
    let size :=
      let mem :=
        Box.(Script_typed_ir.Boxed_set.OPS).(S.SET.mem) v
          Box.(Script_typed_ir.Boxed_set.boxed) in
      if mem then
        if __b_value then
          Box.(Script_typed_ir.Boxed_set.size)
        else
          Pervasives.op_minus Box.(Script_typed_ir.Boxed_set.size) 1
      else
        if __b_value then
          Pervasives.op_plus Box.(Script_typed_ir.Boxed_set.size) 1
        else
          Box.(Script_typed_ir.Boxed_set.size) in
    existT (A := Set) _ _
      {|
        Script_typed_ir.Boxed_set.elt_ty := elt_ty;
        Script_typed_ir.Boxed_set.OPS := (|OPS|);
        Script_typed_ir.Boxed_set.boxed := boxed;
        Script_typed_ir.Boxed_set.size := size
      |})).

Definition set_mem {elt : Set} (v : elt) (Box : Script_typed_ir.set elt)
  : bool :=
  let 'existS _ _ Box := Box in
  Box.(Script_typed_ir.Boxed_set.OPS).(S.SET.mem) v
    Box.(Script_typed_ir.Boxed_set.boxed).

Definition set_fold {acc elt : Set}
  (f : elt -> acc -> acc) (Box : Script_typed_ir.set elt) : acc -> acc :=
  let 'existS _ _ Box := Box in
  Box.(Script_typed_ir.Boxed_set.OPS).(S.SET.fold) f
    Box.(Script_typed_ir.Boxed_set.boxed).

Definition set_size {elt : Set} (Box : Script_typed_ir.set elt)
  : Alpha_context.Script_int.num :=
  let 'existS _ _ Box := Box in
  Alpha_context.Script_int.abs
    (Alpha_context.Script_int.of_int Box.(Script_typed_ir.Boxed_set.size)).

Definition map_key_ty {a b : Set} (Box : Script_typed_ir.map a b)
  : Script_typed_ir.comparable_ty :=
  let 'existS _ _ Box := Box in
  Box.(Script_typed_ir.Boxed_map.key_ty).

Definition empty_map {a b : Set} (ty : Script_typed_ir.comparable_ty)
  : Script_typed_ir.map a b :=
  let OPS :=
    Map.Make
      (let t : Set := a in
      let compare := compare_comparable ty in
      existT (A := Set) _ _
        {|
          Compare.COMPARABLE.compare := compare
        |}) in
  (pack
    (let key : Set := a in
    let value : Set := b in
    let key_ty := ty in
    let OPS := existT (A := unit) (fun _ => _) tt (|OPS|) in
    let boxed {C : Set} : (|OPS|).(S.MAP.t) C * int :=
      ((|OPS|).(S.MAP.empty), 0) in
    existT (A := Set -> Set) _ _
      {|
        Script_typed_ir.Boxed_map.key_ty := key_ty;
        Script_typed_ir.Boxed_map.OPS := (|OPS|);
        Script_typed_ir.Boxed_map.boxed := boxed
      |})).

Definition map_get {key value : Set}
  (k : key) (Box : Script_typed_ir.map key value) : option value :=
  let 'existS _ _ Box := Box in
  Box.(Script_typed_ir.Boxed_map.OPS).(S.MAP.find_opt) k
    (Pervasives.fst Box.(Script_typed_ir.Boxed_map.boxed)).

Definition map_update {a b : Set}
  (k : a) (v : option b) (Box : Script_typed_ir.map a b)
  : Script_typed_ir.map a b :=
  let 'existS _ _ Box := Box in
  (pack
    (let key : Set := a in
    let value : Set := b in
    let key_ty := Box.(Script_typed_ir.Boxed_map.key_ty) in
    let OPS :=
      existT (A := unit) (fun _ => _) tt Box.(Script_typed_ir.Boxed_map.OPS) in
    let boxed :=
      let '(map, size) := Box.(Script_typed_ir.Boxed_map.boxed) in
      let contains := Box.(Script_typed_ir.Boxed_map.OPS).(S.MAP.mem) k map in
      match v with
      | Some v =>
        ((Box.(Script_typed_ir.Boxed_map.OPS).(S.MAP.add) k v map),
          (Pervasives.op_plus size
            (if contains then
              0
            else
              1)))
      | None =>
        ((Box.(Script_typed_ir.Boxed_map.OPS).(S.MAP.remove) k map),
          (Pervasives.op_minus size
            (if contains then
              1
            else
              0)))
      end in
    existT (A := Set -> Set) _ _
      {|
        Script_typed_ir.Boxed_map.key_ty := key_ty;
        Script_typed_ir.Boxed_map.OPS := (|OPS|);
        Script_typed_ir.Boxed_map.boxed := boxed
      |})).

Definition map_set {a b : Set} (k : a) (v : b) (Box : Script_typed_ir.map a b)
  : Script_typed_ir.map a b :=
  let 'existS _ _ Box := Box in
  (pack
    (let key : Set := a in
    let value : Set := b in
    let key_ty := Box.(Script_typed_ir.Boxed_map.key_ty) in
    let OPS :=
      existT (A := unit) (fun _ => _) tt Box.(Script_typed_ir.Boxed_map.OPS) in
    let boxed :=
      let '(map, size) := Box.(Script_typed_ir.Boxed_map.boxed) in
      ((Box.(Script_typed_ir.Boxed_map.OPS).(S.MAP.add) k v map),
        (if Box.(Script_typed_ir.Boxed_map.OPS).(S.MAP.mem) k map then
          size
        else
          Pervasives.op_plus size 1)) in
    existT (A := Set -> Set) _ _
      {|
        Script_typed_ir.Boxed_map.key_ty := key_ty;
        Script_typed_ir.Boxed_map.OPS := (|OPS|);
        Script_typed_ir.Boxed_map.boxed := boxed
      |})).

Definition map_mem {key value : Set}
  (k : key) (Box : Script_typed_ir.map key value) : bool :=
  let 'existS _ _ Box := Box in
  Box.(Script_typed_ir.Boxed_map.OPS).(S.MAP.mem) k
    (Pervasives.fst Box.(Script_typed_ir.Boxed_map.boxed)).

Definition map_fold {acc key value : Set}
  (f : key -> value -> acc -> acc) (Box : Script_typed_ir.map key value)
  : acc -> acc :=
  let 'existS _ _ Box := Box in
  Box.(Script_typed_ir.Boxed_map.OPS).(S.MAP.fold) f
    (Pervasives.fst Box.(Script_typed_ir.Boxed_map.boxed)).

Definition map_size {key value : Set} (Box : Script_typed_ir.map key value)
  : Alpha_context.Script_int.num :=
  let 'existS _ _ Box := Box in
  Alpha_context.Script_int.abs
    (Alpha_context.Script_int.of_int
      (Pervasives.snd Box.(Script_typed_ir.Boxed_map.boxed))).

Fixpoint ty_of_comparable_ty
  (function_parameter : Script_typed_ir.comparable_struct)
  {struct function_parameter} : Script_typed_ir.ty :=
  match function_parameter with
  | Script_typed_ir.Int_key tname => Script_typed_ir.Int_t tname
  | Script_typed_ir.Nat_key tname => Script_typed_ir.Nat_t tname
  | Script_typed_ir.String_key tname => Script_typed_ir.String_t tname
  | Script_typed_ir.Bytes_key tname => Script_typed_ir.Bytes_t tname
  | Script_typed_ir.Mutez_key tname => Script_typed_ir.Mutez_t tname
  | Script_typed_ir.Bool_key tname => Script_typed_ir.Bool_t tname
  | Script_typed_ir.Key_hash_key tname => Script_typed_ir.Key_hash_t tname
  | Script_typed_ir.Timestamp_key tname => Script_typed_ir.Timestamp_t tname
  | Script_typed_ir.Address_key tname => Script_typed_ir.Address_t tname
  | Script_typed_ir.Pair_key (l, al) (__r_value, ar) tname =>
    Script_typed_ir.Pair_t ((ty_of_comparable_ty l), al, None)
      ((ty_of_comparable_ty __r_value), ar, None) tname false
  end.

Fixpoint comparable_ty_of_ty (function_parameter : Script_typed_ir.ty)
  {struct function_parameter} : option Script_typed_ir.comparable_ty :=
  match function_parameter with
  | Script_typed_ir.Int_t tname => Some (Script_typed_ir.Int_key tname)
  | Script_typed_ir.Nat_t tname => Some (Script_typed_ir.Nat_key tname)
  | Script_typed_ir.String_t tname => Some (Script_typed_ir.String_key tname)
  | Script_typed_ir.Bytes_t tname => Some (Script_typed_ir.Bytes_key tname)
  | Script_typed_ir.Mutez_t tname => Some (Script_typed_ir.Mutez_key tname)
  | Script_typed_ir.Bool_t tname => Some (Script_typed_ir.Bool_key tname)
  | Script_typed_ir.Key_hash_t tname =>
    Some (Script_typed_ir.Key_hash_key tname)
  | Script_typed_ir.Timestamp_t tname =>
    Some (Script_typed_ir.Timestamp_key tname)
  | Script_typed_ir.Address_t tname => Some (Script_typed_ir.Address_key tname)
  | Script_typed_ir.Pair_t (l, al, _) (__r_value, ar, _) pname _ =>
    match comparable_ty_of_ty __r_value with
    | None => None
    | Some rty =>
      match comparable_ty_of_ty l with
      | None => None
      | Some (Script_typed_ir.Pair_key _ _ _) => None
      | Some (Script_typed_ir.Int_key tname) =>
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Int_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Nat_key tname) =>
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Nat_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.String_key tname) =>
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.String_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Bytes_key tname) =>
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Bytes_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Mutez_key tname) =>
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Mutez_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Bool_key tname) =>
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Bool_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Key_hash_key tname) =>
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Key_hash_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Timestamp_key tname) =>
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Timestamp_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Address_key tname) =>
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Address_key tname), al)
            (rty, ar) pname)
      end
    end
  | _ => None
  end.

Definition add_field_annot {A B : Set}
  (__a_value : option Script_typed_ir.field_annot)
  (var : option Script_typed_ir.var_annot)
  (function_parameter : Micheline.node A B) : Micheline.node A B :=
  match function_parameter with
  | Micheline.Prim loc prim args annots =>
    Micheline.Prim loc prim args
      (Pervasives.op_at annots
        (Pervasives.op_at (Script_ir_annot.unparse_field_annot __a_value)
          (Script_ir_annot.unparse_var_annot var)))
  | expr => expr
  end.

Fixpoint unparse_comparable_ty
  (function_parameter : Script_typed_ir.comparable_struct)
  {struct function_parameter} : Alpha_context.Script.node :=
  match function_parameter with
  | Script_typed_ir.Int_key tname =>
    Micheline.Prim (-1) Alpha_context.Script.T_int nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Nat_key tname =>
    Micheline.Prim (-1) Alpha_context.Script.T_nat nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.String_key tname =>
    Micheline.Prim (-1) Alpha_context.Script.T_string nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Bytes_key tname =>
    Micheline.Prim (-1) Alpha_context.Script.T_bytes nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Mutez_key tname =>
    Micheline.Prim (-1) Alpha_context.Script.T_mutez nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Bool_key tname =>
    Micheline.Prim (-1) Alpha_context.Script.T_bool nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Key_hash_key tname =>
    Micheline.Prim (-1) Alpha_context.Script.T_key_hash nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Timestamp_key tname =>
    Micheline.Prim (-1) Alpha_context.Script.T_timestamp nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Address_key tname =>
    Micheline.Prim (-1) Alpha_context.Script.T_address nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Pair_key (l, al) (__r_value, ar) pname =>
    let tl := add_field_annot al None (unparse_comparable_ty l) in
    let tr := add_field_annot ar None (unparse_comparable_ty __r_value) in
    Micheline.Prim (-1) Alpha_context.Script.T_pair [ tl; tr ]
      (Script_ir_annot.unparse_type_annot pname)
  end.

Fixpoint unparse_ty_no_lwt
  (ctxt : Alpha_context.context) (ty : Script_typed_ir.ty) {struct ctxt}
  : Error_monad.tzresult (Alpha_context.Script.node * Alpha_context.context) :=
  let? ctxt := Alpha_context.Gas.consume ctxt Unparse_costs.cycle in
  let __return {A : Set}
    (ctxt : Alpha_context.context)
    (function_parameter : A * list (Micheline.node int A) * Micheline.annot)
    : Error_monad.tzresult (Micheline.node int A * Alpha_context.context) :=
    let '(name, args, annot) := function_parameter in
    let __result_value := Micheline.Prim (-1) name args annot in
    let? ctxt :=
      Alpha_context.Gas.consume ctxt
        (Unparse_costs.prim_cost (List.length args) annot) in
    Error_monad.ok (__result_value, ctxt) in
  match ty with
  | Script_typed_ir.Unit_t tname =>
    __return ctxt
      (Alpha_context.Script.T_unit, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Int_t tname =>
    __return ctxt
      (Alpha_context.Script.T_int, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Nat_t tname =>
    __return ctxt
      (Alpha_context.Script.T_nat, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.String_t tname =>
    __return ctxt
      (Alpha_context.Script.T_string, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Bytes_t tname =>
    __return ctxt
      (Alpha_context.Script.T_bytes, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Mutez_t tname =>
    __return ctxt
      (Alpha_context.Script.T_mutez, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Bool_t tname =>
    __return ctxt
      (Alpha_context.Script.T_bool, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Key_hash_t tname =>
    __return ctxt
      (Alpha_context.Script.T_key_hash, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Key_t tname =>
    __return ctxt
      (Alpha_context.Script.T_key, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Timestamp_t tname =>
    __return ctxt
      (Alpha_context.Script.T_timestamp, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Address_t tname =>
    __return ctxt
      (Alpha_context.Script.T_address, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Signature_t tname =>
    __return ctxt
      (Alpha_context.Script.T_signature, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Operation_t tname =>
    __return ctxt
      (Alpha_context.Script.T_operation, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Chain_id_t tname =>
    __return ctxt
      (Alpha_context.Script.T_chain_id, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Contract_t ut tname =>
    let? '(__t_value, ctxt) := unparse_ty_no_lwt ctxt ut in
    __return ctxt
      (Alpha_context.Script.T_contract, [ __t_value ],
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Pair_t (utl, l_field, l_var) (utr, r_field, r_var) tname _
    =>
    let annot := Script_ir_annot.unparse_type_annot tname in
    let? '(utl, ctxt) := unparse_ty_no_lwt ctxt utl in
    let tl := add_field_annot l_field l_var utl in
    let? '(utr, ctxt) := unparse_ty_no_lwt ctxt utr in
    let tr := add_field_annot r_field r_var utr in
    __return ctxt (Alpha_context.Script.T_pair, [ tl; tr ], annot)
  | Script_typed_ir.Union_t (utl, l_field) (utr, r_field) tname _ =>
    let annot := Script_ir_annot.unparse_type_annot tname in
    let? '(utl, ctxt) := unparse_ty_no_lwt ctxt utl in
    let tl := add_field_annot l_field None utl in
    let? '(utr, ctxt) := unparse_ty_no_lwt ctxt utr in
    let tr := add_field_annot r_field None utr in
    __return ctxt (Alpha_context.Script.T_or, [ tl; tr ], annot)
  | Script_typed_ir.Lambda_t uta utr tname =>
    let? '(ta, ctxt) := unparse_ty_no_lwt ctxt uta in
    let? '(tr, ctxt) := unparse_ty_no_lwt ctxt utr in
    __return ctxt
      (Alpha_context.Script.T_lambda, [ ta; tr ],
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Option_t ut tname _ =>
    let annot := Script_ir_annot.unparse_type_annot tname in
    let? '(ut, ctxt) := unparse_ty_no_lwt ctxt ut in
    __return ctxt (Alpha_context.Script.T_option, [ ut ], annot)
  | Script_typed_ir.List_t ut tname _ =>
    let? '(__t_value, ctxt) := unparse_ty_no_lwt ctxt ut in
    __return ctxt
      (Alpha_context.Script.T_list, [ __t_value ],
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Set_t ut tname =>
    let __t_value := unparse_comparable_ty ut in
    __return ctxt
      (Alpha_context.Script.T_set, [ __t_value ],
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Map_t uta utr tname _ =>
    let ta := unparse_comparable_ty uta in
    let? '(tr, ctxt) := unparse_ty_no_lwt ctxt utr in
    __return ctxt
      (Alpha_context.Script.T_map, [ ta; tr ],
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Big_map_t uta utr tname =>
    let ta := unparse_comparable_ty uta in
    let? '(tr, ctxt) := unparse_ty_no_lwt ctxt utr in
    __return ctxt
      (Alpha_context.Script.T_big_map, [ ta; tr ],
        (Script_ir_annot.unparse_type_annot tname))
  end.

Definition unparse_ty (ctxt : Alpha_context.context) (ty : Script_typed_ir.ty)
  : Lwt.t
    (Error_monad.tzresult (Alpha_context.Script.node * Alpha_context.context)) :=
  Lwt.__return (unparse_ty_no_lwt ctxt ty).

Fixpoint strip_var_annots {A B : Set} (function_parameter : Micheline.node A B)
  {struct function_parameter} : Micheline.node A B :=
  match function_parameter with
  | (Micheline.Int _ _ | Micheline.String _ _ | Micheline.Bytes _ _) as atom =>
    atom
  | Micheline.Seq loc args => Micheline.Seq loc (List.map strip_var_annots args)
  | Micheline.Prim loc name args annots =>
    let not_var_annot (s : string) : bool :=
      (|Compare.Char|).(Compare.S.op_ltgt) (String.get s 0) "@" % char in
    let annots := List.filter not_var_annot annots in
    Micheline.Prim loc name (List.map strip_var_annots args) annots
  end.

Definition serialize_ty_for_error
  (ctxt : Alpha_context.context) (ty : Script_typed_ir.ty)
  : Error_monad.tzresult
    (Micheline.canonical Alpha_context.Script.prim * Alpha_context.context) :=
  Error_monad.op_gtpipequestion
    ((Error_monad.record_trace extensible_type_value)
      (unparse_ty_no_lwt ctxt ty))
    (fun function_parameter =>
      let '(ty, ctxt) := function_parameter in
      ((Micheline.strip_locations (strip_var_annots ty)), ctxt)).

Fixpoint unparse_stack
  (ctxt : Alpha_context.context) (function_parameter : Script_typed_ir.stack_ty)
  {struct ctxt}
  : Lwt.t
    (Error_monad.tzresult
      (list (Alpha_context.Script.expr * Alpha_context.Script.annot) *
        Alpha_context.context)) :=
  match function_parameter with
  | Script_typed_ir.Empty_t => Error_monad.__return (nil, ctxt)
  | Script_typed_ir.Item_t ty rest annot =>
    let=? '(uty, ctxt) := unparse_ty ctxt ty in
    let=? '(urest, ctxt) := unparse_stack ctxt rest in
    Error_monad.__return
      ((cons
        ((Micheline.strip_locations uty),
          (Script_ir_annot.unparse_var_annot annot)) urest), ctxt)
  end.

Definition serialize_stack_for_error
  (ctxt : Alpha_context.context) (stack_ty : Script_typed_ir.stack_ty)
  : Lwt.t
    (Error_monad.tzresult
      (list (Alpha_context.Script.expr * Alpha_context.Script.annot) *
        Alpha_context.context)) :=
  Error_monad.trace extensible_type_value (unparse_stack ctxt stack_ty).

Definition name_of_ty (function_parameter : Script_typed_ir.ty)
  : option Script_typed_ir.type_annot :=
  match function_parameter with
  | Script_typed_ir.Unit_t tname => tname
  | Script_typed_ir.Int_t tname => tname
  | Script_typed_ir.Nat_t tname => tname
  | Script_typed_ir.String_t tname => tname
  | Script_typed_ir.Bytes_t tname => tname
  | Script_typed_ir.Mutez_t tname => tname
  | Script_typed_ir.Bool_t tname => tname
  | Script_typed_ir.Key_hash_t tname => tname
  | Script_typed_ir.Key_t tname => tname
  | Script_typed_ir.Timestamp_t tname => tname
  | Script_typed_ir.Address_t tname => tname
  | Script_typed_ir.Signature_t tname => tname
  | Script_typed_ir.Operation_t tname => tname
  | Script_typed_ir.Chain_id_t tname => tname
  | Script_typed_ir.Contract_t _ tname => tname
  | Script_typed_ir.Pair_t _ _ tname _ => tname
  | Script_typed_ir.Union_t _ _ tname _ => tname
  | Script_typed_ir.Lambda_t _ _ tname => tname
  | Script_typed_ir.Option_t _ tname _ => tname
  | Script_typed_ir.List_t _ tname _ => tname
  | Script_typed_ir.Set_t _ tname => tname
  | Script_typed_ir.Map_t _ _ tname _ => tname
  | Script_typed_ir.Big_map_t _ _ tname => tname
  end.

Inductive eq : Set :=
| Eq : eq.

Definition comparable_ty_eq
  (ctxt : Alpha_context.context) (ta : Script_typed_ir.comparable_ty)
  (tb : Script_typed_ir.comparable_ty) : Error_monad.tzresult eq :=
  match (ta, tb) with
  | (Script_typed_ir.Int_key _, Script_typed_ir.Int_key _) => Pervasives.Ok Eq
  | (Script_typed_ir.Nat_key _, Script_typed_ir.Nat_key _) => Pervasives.Ok Eq
  | (Script_typed_ir.String_key _, Script_typed_ir.String_key _) =>
    Pervasives.Ok Eq
  | (Script_typed_ir.Bytes_key _, Script_typed_ir.Bytes_key _) =>
    Pervasives.Ok Eq
  | (Script_typed_ir.Mutez_key _, Script_typed_ir.Mutez_key _) =>
    Pervasives.Ok Eq
  | (Script_typed_ir.Bool_key _, Script_typed_ir.Bool_key _) => Pervasives.Ok Eq
  | (Script_typed_ir.Key_hash_key _, Script_typed_ir.Key_hash_key _) =>
    Pervasives.Ok Eq
  | (Script_typed_ir.Timestamp_key _, Script_typed_ir.Timestamp_key _) =>
    Pervasives.Ok Eq
  | (Script_typed_ir.Address_key _, Script_typed_ir.Address_key _) =>
    Pervasives.Ok Eq
  | (_, _) =>
    let? '(ta, ctxt) := serialize_ty_for_error ctxt (ty_of_comparable_ty ta) in
    let? '(tb, _ctxt) := serialize_ty_for_error ctxt (ty_of_comparable_ty tb) in
    Error_monad.__error_value extensible_type_value
  end.

Definition record_inconsistent {A : Set}
  (ctxt : Alpha_context.context) (ta : Script_typed_ir.ty)
  (tb : Script_typed_ir.ty)
  : Error_monad.tzresult A -> Error_monad.tzresult A :=
  Error_monad.record_trace_eval
    (fun function_parameter =>
      let '_ := function_parameter in
      let? '(ta, ctxt) := serialize_ty_for_error ctxt ta in
      Error_monad.op_gtpipequestion (serialize_ty_for_error ctxt tb)
        (fun function_parameter =>
          let '(tb, _ctxt) := function_parameter in
          extensible_type_value)).

Definition record_inconsistent_type_annotations {A : Set}
  (ctxt : Alpha_context.context) (loc : Alpha_context.Script.location)
  (ta : Script_typed_ir.ty) (tb : Script_typed_ir.ty)
  : Error_monad.tzresult A -> Error_monad.tzresult A :=
  Error_monad.record_trace_eval
    (fun function_parameter =>
      let '_ := function_parameter in
      let? '(ta, ctxt) := serialize_ty_for_error ctxt ta in
      Error_monad.op_gtpipequestion (serialize_ty_for_error ctxt tb)
        (fun function_parameter =>
          let '(tb, _ctxt) := function_parameter in
          extensible_type_value)).

Fixpoint ty_eq
  (ctxt : Alpha_context.context) (ta : Script_typed_ir.ty)
  (tb : Script_typed_ir.ty) {struct ctxt}
  : Error_monad.tzresult (eq * Alpha_context.context) :=
  let ok (__eq_value : eq) (ctxt : Alpha_context.context) (nb_args : int)
    : Error_monad.tzresult (eq * Alpha_context.context) :=
    let? ctxt :=
      Alpha_context.Gas.consume ctxt
        (Typecheck_costs.type_ (Pervasives.op_star 2 nb_args)) in
    Pervasives.Ok (__eq_value, ctxt) in
  let? ctxt := Alpha_context.Gas.consume ctxt Typecheck_costs.cycle in
  match (ta, tb) with
  | (Script_typed_ir.Unit_t _, Script_typed_ir.Unit_t _) => ok Eq ctxt 0
  | (Script_typed_ir.Int_t _, Script_typed_ir.Int_t _) => ok Eq ctxt 0
  | (Script_typed_ir.Nat_t _, Script_typed_ir.Nat_t _) => ok Eq ctxt 0
  | (Script_typed_ir.Key_t _, Script_typed_ir.Key_t _) => ok Eq ctxt 0
  | (Script_typed_ir.Key_hash_t _, Script_typed_ir.Key_hash_t _) => ok Eq ctxt 0
  | (Script_typed_ir.String_t _, Script_typed_ir.String_t _) => ok Eq ctxt 0
  | (Script_typed_ir.Bytes_t _, Script_typed_ir.Bytes_t _) => ok Eq ctxt 0
  | (Script_typed_ir.Signature_t _, Script_typed_ir.Signature_t _) =>
    ok Eq ctxt 0
  | (Script_typed_ir.Mutez_t _, Script_typed_ir.Mutez_t _) => ok Eq ctxt 0
  | (Script_typed_ir.Timestamp_t _, Script_typed_ir.Timestamp_t _) =>
    ok Eq ctxt 0
  | (Script_typed_ir.Chain_id_t _, Script_typed_ir.Chain_id_t _) => ok Eq ctxt 0
  | (Script_typed_ir.Address_t _, Script_typed_ir.Address_t _) => ok Eq ctxt 0
  | (Script_typed_ir.Bool_t _, Script_typed_ir.Bool_t _) => ok Eq ctxt 0
  | (Script_typed_ir.Operation_t _, Script_typed_ir.Operation_t _) =>
    ok Eq ctxt 0
  | (Script_typed_ir.Map_t tal tar _ _, Script_typed_ir.Map_t tbl tbr _ _) =>
    (record_inconsistent ctxt ta tb)
      (let? 'Eq := comparable_ty_eq ctxt tal tbl in
      let? '(Eq, ctxt) := ty_eq ctxt tar tbr in
      ok Eq ctxt 2)
  | (Script_typed_ir.Big_map_t tal tar _, Script_typed_ir.Big_map_t tbl tbr _)
    =>
    (record_inconsistent ctxt ta tb)
      (let? 'Eq := comparable_ty_eq ctxt tal tbl in
      let? '(Eq, ctxt) := ty_eq ctxt tar tbr in
      ok Eq ctxt 2)
  | (Script_typed_ir.Set_t ea _, Script_typed_ir.Set_t eb _) =>
    (record_inconsistent ctxt ta tb)
      (let? 'Eq := comparable_ty_eq ctxt ea eb in
      ok Eq ctxt 1)
  |
    (Script_typed_ir.Pair_t (tal, _, _) (tar, _, _) _ _,
      Script_typed_ir.Pair_t (tbl, _, _) (tbr, _, _) _ _) =>
    (record_inconsistent ctxt ta tb)
      (let? '(Eq, ctxt) := ty_eq ctxt tal tbl in
      let? '(Eq, ctxt) := ty_eq ctxt tar tbr in
      ok Eq ctxt 2)
  |
    (Script_typed_ir.Union_t (tal, _) (tar, _) _ _,
      Script_typed_ir.Union_t (tbl, _) (tbr, _) _ _) =>
    (record_inconsistent ctxt ta tb)
      (let? '(Eq, ctxt) := ty_eq ctxt tal tbl in
      let? '(Eq, ctxt) := ty_eq ctxt tar tbr in
      ok Eq ctxt 2)
  | (Script_typed_ir.Lambda_t tal tar _, Script_typed_ir.Lambda_t tbl tbr _) =>
    (record_inconsistent ctxt ta tb)
      (let? '(Eq, ctxt) := ty_eq ctxt tal tbl in
      let? '(Eq, ctxt) := ty_eq ctxt tar tbr in
      ok Eq ctxt 2)
  | (Script_typed_ir.Contract_t tal _, Script_typed_ir.Contract_t tbl _) =>
    (record_inconsistent ctxt ta tb)
      (let? '(Eq, ctxt) := ty_eq ctxt tal tbl in
      ok Eq ctxt 1)
  | (Script_typed_ir.Option_t tva _ _, Script_typed_ir.Option_t tvb _ _) =>
    (record_inconsistent ctxt ta tb)
      (let? '(Eq, ctxt) := ty_eq ctxt tva tvb in
      ok Eq ctxt 1)
  | (Script_typed_ir.List_t tva _ _, Script_typed_ir.List_t tvb _ _) =>
    (record_inconsistent ctxt ta tb)
      (let? '(Eq, ctxt) := ty_eq ctxt tva tvb in
      ok Eq ctxt 1)
  | (_, _) =>
    let? '(ta, ctxt) := serialize_ty_for_error ctxt ta in
    let? '(tb, _ctxt) := serialize_ty_for_error ctxt tb in
    Error_monad.__error_value extensible_type_value
  end.

Fixpoint stack_ty_eq
  (ctxt : Alpha_context.context) (lvl : int) (ta : Script_typed_ir.stack_ty)
  (tb : Script_typed_ir.stack_ty) {struct ctxt}
  : Error_monad.tzresult (eq * Alpha_context.context) :=
  match (ta, tb) with
  | (Script_typed_ir.Item_t tva ra _, Script_typed_ir.Item_t tvb rb _) =>
    let? '(Eq, ctxt) :=
      (Error_monad.record_trace extensible_type_value) (ty_eq ctxt tva tvb) in
    let? '(Eq, ctxt) := stack_ty_eq ctxt (Pervasives.op_plus lvl 1) ra rb in
    Pervasives.Ok (Eq, ctxt)
  | (Script_typed_ir.Empty_t, Script_typed_ir.Empty_t) =>
    Pervasives.Ok (Eq, ctxt)
  | (_, _) => Error_monad.__error_value extensible_type_value
  end.

Definition merge_comparable_types
  (legacy : bool) (ta : Script_typed_ir.comparable_ty)
  (tb : Script_typed_ir.comparable_ty)
  : Error_monad.tzresult Script_typed_ir.comparable_ty :=
  match (ta, tb) with
  | (Script_typed_ir.Int_key annot_a, Script_typed_ir.Int_key annot_b) =>
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot => Script_typed_ir.Int_key annot)
  | (Script_typed_ir.Nat_key annot_a, Script_typed_ir.Nat_key annot_b) =>
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot => Script_typed_ir.Nat_key annot)
  | (Script_typed_ir.String_key annot_a, Script_typed_ir.String_key annot_b) =>
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot => Script_typed_ir.String_key annot)
  | (Script_typed_ir.Bytes_key annot_a, Script_typed_ir.Bytes_key annot_b) =>
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot => Script_typed_ir.Bytes_key annot)
  | (Script_typed_ir.Mutez_key annot_a, Script_typed_ir.Mutez_key annot_b) =>
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot => Script_typed_ir.Mutez_key annot)
  | (Script_typed_ir.Bool_key annot_a, Script_typed_ir.Bool_key annot_b) =>
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot => Script_typed_ir.Bool_key annot)
  | (Script_typed_ir.Key_hash_key annot_a, Script_typed_ir.Key_hash_key annot_b)
    =>
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot => Script_typed_ir.Key_hash_key annot)
  |
    (Script_typed_ir.Timestamp_key annot_a,
      Script_typed_ir.Timestamp_key annot_b) =>
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot => Script_typed_ir.Timestamp_key annot)
  | (Script_typed_ir.Address_key annot_a, Script_typed_ir.Address_key annot_b)
    =>
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot => Script_typed_ir.Address_key annot)
  | (_, _) =>
    (* ❌ Assert instruction is not handled. *)
    assert (Error_monad.tzresult Script_typed_ir.comparable_ty) false
  end.

Definition merge_types (legacy : bool)
  : Alpha_context.context -> Alpha_context.Script.location ->
  Script_typed_ir.ty -> Script_typed_ir.ty ->
  Error_monad.tzresult (Script_typed_ir.ty * Alpha_context.context) :=
  let fix help
    (ctxt : Alpha_context.context) (ty1 : Script_typed_ir.ty)
    (ty2 : Script_typed_ir.ty) {struct ctxt}
    : Error_monad.tzresult (Script_typed_ir.ty * Alpha_context.context) :=
    match (ty1, ty2) with
    | (Script_typed_ir.Unit_t tn1, Script_typed_ir.Unit_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Unit_t tname), ctxt))
    | (Script_typed_ir.Int_t tn1, Script_typed_ir.Int_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Int_t tname), ctxt))
    | (Script_typed_ir.Nat_t tn1, Script_typed_ir.Nat_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Nat_t tname), ctxt))
    | (Script_typed_ir.Key_t tn1, Script_typed_ir.Key_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Key_t tname), ctxt))
    | (Script_typed_ir.Key_hash_t tn1, Script_typed_ir.Key_hash_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Key_hash_t tname), ctxt))
    | (Script_typed_ir.String_t tn1, Script_typed_ir.String_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.String_t tname), ctxt))
    | (Script_typed_ir.Bytes_t tn1, Script_typed_ir.Bytes_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Bytes_t tname), ctxt))
    | (Script_typed_ir.Signature_t tn1, Script_typed_ir.Signature_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Signature_t tname), ctxt))
    | (Script_typed_ir.Mutez_t tn1, Script_typed_ir.Mutez_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Mutez_t tname), ctxt))
    | (Script_typed_ir.Timestamp_t tn1, Script_typed_ir.Timestamp_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Timestamp_t tname), ctxt))
    | (Script_typed_ir.Address_t tn1, Script_typed_ir.Address_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Address_t tname), ctxt))
    | (Script_typed_ir.Bool_t tn1, Script_typed_ir.Bool_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Bool_t tname), ctxt))
    | (Script_typed_ir.Chain_id_t tn1, Script_typed_ir.Chain_id_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Chain_id_t tname), ctxt))
    | (Script_typed_ir.Operation_t tn1, Script_typed_ir.Operation_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Operation_t tname), ctxt))
    |
      (Script_typed_ir.Map_t tal tar tn1 has_big_map,
        Script_typed_ir.Map_t tbl tbr tn2 _) =>
      let? tname := Script_ir_annot.merge_type_annot legacy tn1 tn2 in
      let? '(value, ctxt) := help ctxt tar tbr in
      let? '(Eq, ctxt) := ty_eq ctxt tar value in
      Error_monad.op_gtpipequestion (merge_comparable_types legacy tal tbl)
        (fun tk => ((Script_typed_ir.Map_t tk value tname has_big_map), ctxt))
    |
      (Script_typed_ir.Big_map_t tal tar tn1,
        Script_typed_ir.Big_map_t tbl tbr tn2) =>
      let? tname := Script_ir_annot.merge_type_annot legacy tn1 tn2 in
      let? '(value, ctxt) := help ctxt tar tbr in
      let? '(Eq, ctxt) := ty_eq ctxt tar value in
      Error_monad.op_gtpipequestion (merge_comparable_types legacy tal tbl)
        (fun tk => ((Script_typed_ir.Big_map_t tk value tname), ctxt))
    | (Script_typed_ir.Set_t ea tn1, Script_typed_ir.Set_t eb tn2) =>
      let? tname := Script_ir_annot.merge_type_annot legacy tn1 tn2 in
      Error_monad.op_gtpipequestion (merge_comparable_types legacy ea eb)
        (fun e => ((Script_typed_ir.Set_t e tname), ctxt))
    |
      (Script_typed_ir.Pair_t (tal, l_field1, l_var1) (tar, r_field1, r_var1)
        tn1 has_big_map,
        Script_typed_ir.Pair_t (tbl, l_field2, l_var2) (tbr, r_field2, r_var2)
          tn2 _) =>
      let? tname := Script_ir_annot.merge_type_annot legacy tn1 tn2 in
      let? l_field := Script_ir_annot.merge_field_annot legacy l_field1 l_field2
        in
      let? r_field := Script_ir_annot.merge_field_annot legacy r_field1 r_field2
        in
      let l_var := Script_ir_annot.merge_var_annot l_var1 l_var2 in
      let r_var := Script_ir_annot.merge_var_annot r_var1 r_var2 in
      let? '(left_ty, ctxt) := help ctxt tal tbl in
      Error_monad.op_gtpipequestion (help ctxt tar tbr)
        (fun function_parameter =>
          let '(right_ty, ctxt) := function_parameter in
          ((Script_typed_ir.Pair_t (left_ty, l_field, l_var)
            (right_ty, r_field, r_var) tname has_big_map), ctxt))
    |
      (Script_typed_ir.Union_t (tal, tal_annot) (tar, tar_annot) tn1 has_big_map,
        Script_typed_ir.Union_t (tbl, tbl_annot) (tbr, tbr_annot) tn2 _) =>
      let? tname := Script_ir_annot.merge_type_annot legacy tn1 tn2 in
      let? left_annot :=
        Script_ir_annot.merge_field_annot legacy tal_annot tbl_annot in
      let? right_annot :=
        Script_ir_annot.merge_field_annot legacy tar_annot tbr_annot in
      let? '(left_ty, ctxt) := help ctxt tal tbl in
      Error_monad.op_gtpipequestion (help ctxt tar tbr)
        (fun function_parameter =>
          let '(right_ty, ctxt) := function_parameter in
          ((Script_typed_ir.Union_t (left_ty, left_annot)
            (right_ty, right_annot) tname has_big_map), ctxt))
    |
      (Script_typed_ir.Lambda_t tal tar tn1,
        Script_typed_ir.Lambda_t tbl tbr tn2) =>
      let? tname := Script_ir_annot.merge_type_annot legacy tn1 tn2 in
      let? '(left_ty, ctxt) := help ctxt tal tbl in
      Error_monad.op_gtpipequestion (help ctxt tar tbr)
        (fun function_parameter =>
          let '(right_ty, ctxt) := function_parameter in
          ((Script_typed_ir.Lambda_t left_ty right_ty tname), ctxt))
    | (Script_typed_ir.Contract_t tal tn1, Script_typed_ir.Contract_t tbl tn2)
      =>
      let? tname := Script_ir_annot.merge_type_annot legacy tn1 tn2 in
      Error_monad.op_gtpipequestion (help ctxt tal tbl)
        (fun function_parameter =>
          let '(arg_ty, ctxt) := function_parameter in
          ((Script_typed_ir.Contract_t arg_ty tname), ctxt))
    |
      (Script_typed_ir.Option_t tva tn1 has_big_map,
        Script_typed_ir.Option_t tvb tn2 _) =>
      let? tname := Script_ir_annot.merge_type_annot legacy tn1 tn2 in
      Error_monad.op_gtpipequestion (help ctxt tva tvb)
        (fun function_parameter =>
          let '(ty, ctxt) := function_parameter in
          ((Script_typed_ir.Option_t ty tname has_big_map), ctxt))
    |
      (Script_typed_ir.List_t tva tn1 has_big_map,
        Script_typed_ir.List_t tvb tn2 _) =>
      let? tname := Script_ir_annot.merge_type_annot legacy tn1 tn2 in
      Error_monad.op_gtpipequestion (help ctxt tva tvb)
        (fun function_parameter =>
          let '(ty, ctxt) := function_parameter in
          ((Script_typed_ir.List_t ty tname has_big_map), ctxt))
    | (_, _) =>
      (* ❌ Assert instruction is not handled. *)
      assert (Error_monad.tzresult (Script_typed_ir.ty * Alpha_context.context))
        false
    end in
  fun ctxt =>
    fun loc =>
      fun ty1 =>
        fun ty2 =>
          record_inconsistent_type_annotations ctxt loc ty1 ty2
            (help ctxt ty1 ty2).

Definition merge_stacks (legacy : bool) (loc : Alpha_context.Script.location)
  : Alpha_context.context -> Script_typed_ir.stack_ty ->
  Script_typed_ir.stack_ty ->
  Error_monad.tzresult (Script_typed_ir.stack_ty * Alpha_context.context) :=
  let fix help
    (ctxt : Alpha_context.context) (stack1 : Script_typed_ir.stack_ty)
    (stack2 : Script_typed_ir.stack_ty) {struct ctxt}
    : Error_monad.tzresult (Script_typed_ir.stack_ty * Alpha_context.context) :=
    match (stack1, stack2) with
    | (Script_typed_ir.Empty_t, Script_typed_ir.Empty_t) =>
      Error_monad.ok (Script_typed_ir.Empty_t, ctxt)
    |
      (Script_typed_ir.Item_t ty1 rest1 annot1,
        Script_typed_ir.Item_t ty2 rest2 annot2) =>
      let annot := Script_ir_annot.merge_var_annot annot1 annot2 in
      let? '(ty, ctxt) := merge_types legacy ctxt loc ty1 ty2 in
      Error_monad.op_gtpipequestion (help ctxt rest1 rest2)
        (fun function_parameter =>
          let '(rest, ctxt) := function_parameter in
          ((Script_typed_ir.Item_t ty rest annot), ctxt))
    end in
  help.

Definition has_big_map (function_parameter : Script_typed_ir.ty) : bool :=
  match function_parameter with
  | Script_typed_ir.Unit_t _ => false
  | Script_typed_ir.Int_t _ => false
  | Script_typed_ir.Nat_t _ => false
  | Script_typed_ir.Signature_t _ => false
  | Script_typed_ir.String_t _ => false
  | Script_typed_ir.Bytes_t _ => false
  | Script_typed_ir.Mutez_t _ => false
  | Script_typed_ir.Key_hash_t _ => false
  | Script_typed_ir.Key_t _ => false
  | Script_typed_ir.Timestamp_t _ => false
  | Script_typed_ir.Address_t _ => false
  | Script_typed_ir.Bool_t _ => false
  | Script_typed_ir.Lambda_t _ _ _ => false
  | Script_typed_ir.Set_t _ _ => false
  | Script_typed_ir.Big_map_t _ _ _ => true
  | Script_typed_ir.Contract_t _ _ => false
  | Script_typed_ir.Operation_t _ => false
  | Script_typed_ir.Chain_id_t _ => false
  | Script_typed_ir.Pair_t _ _ _ has_big_map => has_big_map
  | Script_typed_ir.Union_t _ _ _ has_big_map => has_big_map
  | Script_typed_ir.Option_t _ _ has_big_map => has_big_map
  | Script_typed_ir.List_t _ _ has_big_map => has_big_map
  | Script_typed_ir.Map_t _ _ _ has_big_map => has_big_map
  end.

Module ConstructorRecordNotations_judgement.
  Module judgement.
    Module Failed.
      Record record {descr : Set} : Set := {
        descr : descr }.
      Arguments record : clear implicits.
    End Failed.
    Definition Failed_skeleton := Failed.record.
  End judgement.
End ConstructorRecordNotations_judgement.
Import ConstructorRecordNotations_judgement.

Reserved Notation "'judgement.Failed".

Inductive judgement (bef : Set) : Set :=
| Typed : Script_typed_ir.descr -> judgement bef
| Failed : forall {aft : Set}, 'judgement.Failed aft -> judgement bef

where "'judgement.Failed" := (fun (t_aft : Set) =>
  judgement.Failed_skeleton
    ((Script_typed_ir.stack_ty -> Script_typed_ir.descr) * t_aft)).

Module judgement.
  Include ConstructorRecordNotations_judgement.judgement.
  Definition Failed := 'judgement.Failed.
End judgement.

Arguments Typed {_}.
Arguments Failed {_ _}.

Module branch.
  Record record : Set := Build {
    branch :
      (Script_typed_ir.descr -> Script_typed_ir.descr -> Script_typed_ir.descr)
        * r }.
  Definition with_branch branch (r : record) :=
    Build branch.
End branch.
Definition branch := branch.record.

Definition merge_branches {a b bef : Set}
  (legacy : bool) (ctxt : Alpha_context.context) (loc : int) (btr : judgement a)
  (bfr : judgement b) (function_parameter : branch)
  : Lwt.t (Error_monad.tzresult (judgement bef * Alpha_context.context)) :=
  let '{| branch.branch := branch |} := function_parameter in
  match (btr, bfr) with
  |
    (Typed ({| Script_typed_ir.descr.aft := aftbt |} as dbt),
      Typed ({| Script_typed_ir.descr.aft := aftbf |} as dbf)) =>
    let unmatched_branches (function_parameter : unit)
      : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
      let '_ := function_parameter in
      let=? '(aftbt, ctxt) := serialize_stack_for_error ctxt aftbt in
      Error_monad.op_gtgtpipequestion (serialize_stack_for_error ctxt aftbf)
        (fun function_parameter =>
          let '(aftbf, _ctxt) := function_parameter in
          extensible_type_value) in
    Error_monad.trace_eval unmatched_branches
      (let=? '(Eq, ctxt) := Lwt.__return (stack_ty_eq ctxt 1 aftbt aftbf) in
      let=? '(merged_stack, ctxt) :=
        Lwt.__return (merge_stacks legacy loc ctxt aftbt aftbf) in
      Error_monad.__return
        ((Typed
          (branch (Script_typed_ir.descr.with_aft merged_stack dbt)
            (Script_typed_ir.descr.with_aft merged_stack dbf))), ctxt))
  |
    (Failed {| judgement.Failed.descr := descrt |},
      Failed {| judgement.Failed.descr := descrf |}) =>
    let __descr_value (ret : Script_typed_ir.stack_ty)
      : Script_typed_ir.descr :=
      branch (descrt ret) (descrf ret) in
    Error_monad.__return
      ((Failed {| judgement.Failed.descr := __descr_value |}), ctxt)
  | (Typed dbt, Failed {| judgement.Failed.descr := descrf |}) =>
    Error_monad.__return
      ((Typed (branch dbt (descrf dbt.(Script_typed_ir.descr.aft)))), ctxt)
  | (Failed {| judgement.Failed.descr := descrt |}, Typed dbf) =>
    Error_monad.__return
      ((Typed (branch (descrt dbf.(Script_typed_ir.descr.aft)) dbf)), ctxt)
  end.

Fixpoint parse_comparable_ty
  (ctxt : Alpha_context.context) (ty : Alpha_context.Script.node) {struct ctxt}
  : Error_monad.tzresult (ex_comparable_ty * Alpha_context.context) :=
  let? ctxt := Alpha_context.Gas.consume ctxt Typecheck_costs.cycle in
  let? ctxt := Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0) in
  match ty with
  | Micheline.Prim loc Alpha_context.Script.T_int [] annot =>
    Error_monad.op_gtpipequestion (Script_ir_annot.parse_type_annot loc annot)
      (fun tname => ((Ex_comparable_ty (Script_typed_ir.Int_key tname)), ctxt))
  | Micheline.Prim loc Alpha_context.Script.T_nat [] annot =>
    Error_monad.op_gtpipequestion (Script_ir_annot.parse_type_annot loc annot)
      (fun tname => ((Ex_comparable_ty (Script_typed_ir.Nat_key tname)), ctxt))
  | Micheline.Prim loc Alpha_context.Script.T_string [] annot =>
    Error_monad.op_gtpipequestion (Script_ir_annot.parse_type_annot loc annot)
      (fun tname =>
        ((Ex_comparable_ty (Script_typed_ir.String_key tname)), ctxt))
  | Micheline.Prim loc Alpha_context.Script.T_bytes [] annot =>
    Error_monad.op_gtpipequestion (Script_ir_annot.parse_type_annot loc annot)
      (fun tname => ((Ex_comparable_ty (Script_typed_ir.Bytes_key tname)), ctxt))
  | Micheline.Prim loc Alpha_context.Script.T_mutez [] annot =>
    Error_monad.op_gtpipequestion (Script_ir_annot.parse_type_annot loc annot)
      (fun tname => ((Ex_comparable_ty (Script_typed_ir.Mutez_key tname)), ctxt))
  | Micheline.Prim loc Alpha_context.Script.T_bool [] annot =>
    Error_monad.op_gtpipequestion (Script_ir_annot.parse_type_annot loc annot)
      (fun tname => ((Ex_comparable_ty (Script_typed_ir.Bool_key tname)), ctxt))
  | Micheline.Prim loc Alpha_context.Script.T_key_hash [] annot =>
    Error_monad.op_gtpipequestion (Script_ir_annot.parse_type_annot loc annot)
      (fun tname =>
        ((Ex_comparable_ty (Script_typed_ir.Key_hash_key tname)), ctxt))
  | Micheline.Prim loc Alpha_context.Script.T_timestamp [] annot =>
    Error_monad.op_gtpipequestion (Script_ir_annot.parse_type_annot loc annot)
      (fun tname =>
        ((Ex_comparable_ty (Script_typed_ir.Timestamp_key tname)), ctxt))
  | Micheline.Prim loc Alpha_context.Script.T_address [] annot =>
    Error_monad.op_gtpipequestion (Script_ir_annot.parse_type_annot loc annot)
      (fun tname =>
        ((Ex_comparable_ty (Script_typed_ir.Address_key tname)), ctxt))
  |
    Micheline.Prim loc
      ((Alpha_context.Script.T_int | Alpha_context.Script.T_nat |
      Alpha_context.Script.T_string | Alpha_context.Script.T_mutez |
      Alpha_context.Script.T_bool | Alpha_context.Script.T_key |
      Alpha_context.Script.T_address | Alpha_context.Script.T_timestamp) as prim)
      l _ => Error_monad.__error_value extensible_type_value
  |
    Micheline.Prim loc
      (Alpha_context.Script.T_pair | Alpha_context.Script.T_or |
      Alpha_context.Script.T_set | Alpha_context.Script.T_map |
      Alpha_context.Script.T_list | Alpha_context.Script.T_option |
      Alpha_context.Script.T_lambda | Alpha_context.Script.T_unit |
      Alpha_context.Script.T_signature | Alpha_context.Script.T_contract) _ _ =>
    Error_monad.__error_value extensible_type_value
  | expr =>
    Error_monad.__error_value
      (unexpected expr nil Script_tc_errors.Type_namespace
        [
          Alpha_context.Script.T_int;
          Alpha_context.Script.T_nat;
          Alpha_context.Script.T_string;
          Alpha_context.Script.T_mutez;
          Alpha_context.Script.T_bool;
          Alpha_context.Script.T_key;
          Alpha_context.Script.T_key_hash;
          Alpha_context.Script.T_timestamp
        ])
  end

with parse_packable_ty (ctxt : Alpha_context.context) (legacy : bool)
  {struct ctxt}
  : Alpha_context.Script.node ->
  Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  parse_ty ctxt legacy false false legacy

with parse_parameter_ty (ctxt : Alpha_context.context) (legacy : bool)
  {struct ctxt}
  : Alpha_context.Script.node ->
  Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  parse_ty ctxt legacy true false true

with parse_any_ty (ctxt : Alpha_context.context) (legacy : bool) {struct ctxt}
  : Alpha_context.Script.node ->
  Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  parse_ty ctxt legacy true true true

with parse_ty
  (ctxt : Alpha_context.context) (legacy : bool) (allow_big_map : bool)
  (allow_operation : bool) (allow_contract : bool)
  (node : Alpha_context.Script.node) {struct ctxt}
  : Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  let? ctxt := Alpha_context.Gas.consume ctxt Typecheck_costs.cycle in
  match
    (node,
      match node with
      | Micheline.Prim loc Alpha_context.Script.T_big_map args annot =>
        allow_big_map
      | _ => false
      end) with
  | (Micheline.Prim loc Alpha_context.Script.T_unit [] annot, _) =>
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt => ((Ex_ty (Script_typed_ir.Unit_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_int [] annot, _) =>
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt => ((Ex_ty (Script_typed_ir.Int_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_nat [] annot, _) =>
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt => ((Ex_ty (Script_typed_ir.Nat_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_string [] annot, _) =>
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt => ((Ex_ty (Script_typed_ir.String_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_bytes [] annot, _) =>
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt => ((Ex_ty (Script_typed_ir.Bytes_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_mutez [] annot, _) =>
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt => ((Ex_ty (Script_typed_ir.Mutez_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_bool [] annot, _) =>
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt => ((Ex_ty (Script_typed_ir.Bool_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_key [] annot, _) =>
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt => ((Ex_ty (Script_typed_ir.Key_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_key_hash [] annot, _) =>
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt => ((Ex_ty (Script_typed_ir.Key_hash_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_timestamp [] annot, _) =>
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt => ((Ex_ty (Script_typed_ir.Timestamp_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_address [] annot, _) =>
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt => ((Ex_ty (Script_typed_ir.Address_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_signature [] annot, _) =>
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt => ((Ex_ty (Script_typed_ir.Signature_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_operation [] annot, _) =>
    if allow_operation then
      let? ty_name := Script_ir_annot.parse_type_annot loc annot in
      Error_monad.op_gtpipequestion
        (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
        (fun ctxt => ((Ex_ty (Script_typed_ir.Operation_t ty_name)), ctxt))
    else
      Error_monad.__error_value extensible_type_value
  | (Micheline.Prim loc Alpha_context.Script.T_chain_id [] annot, _) =>
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt => ((Ex_ty (Script_typed_ir.Chain_id_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_contract (cons utl []) annot, _)
    =>
    if allow_contract then
      let? '(Ex_ty tl, ctxt) := parse_parameter_ty ctxt legacy utl in
      let? ty_name := Script_ir_annot.parse_type_annot loc annot in
      Error_monad.op_gtpipequestion
        (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 1))
        (fun ctxt => ((Ex_ty (Script_typed_ir.Contract_t tl ty_name)), ctxt))
    else
      Error_monad.__error_value extensible_type_value
  |
    (Micheline.Prim loc Alpha_context.Script.T_pair (cons utl (cons utr []))
      annot, _) =>
    let? '(utl, left_field) := Script_ir_annot.extract_field_annot utl in
    let? '(utr, right_field) := Script_ir_annot.extract_field_annot utr in
    let? '(Ex_ty tl, ctxt) :=
      parse_ty ctxt legacy allow_big_map allow_operation allow_contract utl in
    let? '(Ex_ty tr, ctxt) :=
      parse_ty ctxt legacy allow_big_map allow_operation allow_contract utr in
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 2))
      (fun ctxt =>
        ((Ex_ty
          (Script_typed_ir.Pair_t (tl, left_field, None) (tr, right_field, None)
            ty_name (Pervasives.op_pipepipe (has_big_map tl) (has_big_map tr)))),
          ctxt))
  |
    (Micheline.Prim loc Alpha_context.Script.T_or (cons utl (cons utr [])) annot,
      _) =>
    let? '(utl, left_constr) := Script_ir_annot.extract_field_annot utl in
    let? '(utr, right_constr) := Script_ir_annot.extract_field_annot utr in
    let? '(Ex_ty tl, ctxt) :=
      parse_ty ctxt legacy allow_big_map allow_operation allow_contract utl in
    let? '(Ex_ty tr, ctxt) :=
      parse_ty ctxt legacy allow_big_map allow_operation allow_contract utr in
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 2))
      (fun ctxt =>
        ((Ex_ty
          (Script_typed_ir.Union_t (tl, left_constr) (tr, right_constr) ty_name
            (Pervasives.op_pipepipe (has_big_map tl) (has_big_map tr)))), ctxt))
  |
    (Micheline.Prim loc Alpha_context.Script.T_lambda (cons uta (cons utr []))
      annot, _) =>
    let? '(Ex_ty ta, ctxt) := parse_any_ty ctxt legacy uta in
    let? '(Ex_ty tr, ctxt) := parse_any_ty ctxt legacy utr in
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 2))
      (fun ctxt => ((Ex_ty (Script_typed_ir.Lambda_t ta tr ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_option (cons ut []) annot, _) =>
    let? '(ut, ty_name) :=
      if legacy then
        let? '(ut, _some_constr) := Script_ir_annot.extract_field_annot ut in
        let? '(ty_name, _none_constr, _) :=
          Script_ir_annot.parse_composed_type_annot loc annot in
        Error_monad.ok (ut, ty_name)
      else
        let? ty_name := Script_ir_annot.parse_type_annot loc annot in
        Error_monad.ok (ut, ty_name) in
    let? '(Ex_ty __t_value, ctxt) :=
      parse_ty ctxt legacy allow_big_map allow_operation allow_contract ut in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 2))
      (fun ctxt =>
        ((Ex_ty
          (Script_typed_ir.Option_t __t_value ty_name (has_big_map __t_value))),
          ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_list (cons ut []) annot, _) =>
    let? '(Ex_ty __t_value, ctxt) :=
      parse_ty ctxt legacy allow_big_map allow_operation allow_contract ut in
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 1))
      (fun ctxt =>
        ((Ex_ty
          (Script_typed_ir.List_t __t_value ty_name (has_big_map __t_value))),
          ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_set (cons ut []) annot, _) =>
    let? '(Ex_comparable_ty __t_value, ctxt) := parse_comparable_ty ctxt ut in
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 1))
      (fun ctxt => ((Ex_ty (Script_typed_ir.Set_t __t_value ty_name)), ctxt))
  |
    (Micheline.Prim loc Alpha_context.Script.T_map (cons uta (cons utr []))
      annot, _) =>
    let? '(Ex_comparable_ty ta, ctxt) := parse_comparable_ty ctxt uta in
    let? '(Ex_ty tr, ctxt) :=
      parse_ty ctxt legacy allow_big_map allow_operation allow_contract utr in
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 2))
      (fun ctxt =>
        ((Ex_ty (Script_typed_ir.Map_t ta tr ty_name (has_big_map tr))), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_big_map args annot, true) =>
    let? '(big_map_ty, ctxt) := parse_big_map_ty ctxt legacy loc args annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 2))
      (fun ctxt => (big_map_ty, ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_big_map _ _, _) =>
    Error_monad.__error_value extensible_type_value
  |
    (Micheline.Prim loc
      ((Alpha_context.Script.T_unit | Alpha_context.Script.T_signature |
      Alpha_context.Script.T_int | Alpha_context.Script.T_nat |
      Alpha_context.Script.T_string | Alpha_context.Script.T_bytes |
      Alpha_context.Script.T_mutez | Alpha_context.Script.T_bool |
      Alpha_context.Script.T_key | Alpha_context.Script.T_key_hash |
      Alpha_context.Script.T_timestamp | Alpha_context.Script.T_address) as prim)
      l _, _) => Error_monad.__error_value extensible_type_value
  |
    (Micheline.Prim loc
      ((Alpha_context.Script.T_set | Alpha_context.Script.T_list |
      Alpha_context.Script.T_option | Alpha_context.Script.T_contract) as prim)
      l _, _) => Error_monad.__error_value extensible_type_value
  |
    (Micheline.Prim loc
      ((Alpha_context.Script.T_pair | Alpha_context.Script.T_or |
      Alpha_context.Script.T_map | Alpha_context.Script.T_lambda) as prim) l _,
      _) => Error_monad.__error_value extensible_type_value
  | (expr, _) =>
    Error_monad.__error_value
      (unexpected expr nil Script_tc_errors.Type_namespace
        [
          Alpha_context.Script.T_pair;
          Alpha_context.Script.T_or;
          Alpha_context.Script.T_set;
          Alpha_context.Script.T_map;
          Alpha_context.Script.T_list;
          Alpha_context.Script.T_option;
          Alpha_context.Script.T_lambda;
          Alpha_context.Script.T_unit;
          Alpha_context.Script.T_signature;
          Alpha_context.Script.T_contract;
          Alpha_context.Script.T_int;
          Alpha_context.Script.T_nat;
          Alpha_context.Script.T_operation;
          Alpha_context.Script.T_string;
          Alpha_context.Script.T_bytes;
          Alpha_context.Script.T_mutez;
          Alpha_context.Script.T_bool;
          Alpha_context.Script.T_key;
          Alpha_context.Script.T_key_hash;
          Alpha_context.Script.T_timestamp;
          Alpha_context.Script.T_chain_id
        ])
  end

with parse_big_map_ty
  (ctxt : Alpha_context.context) (legacy : bool)
  (big_map_loc : Alpha_context.Script.location)
  (args :
    list
      (Micheline.node Alpha_context.Script.location Alpha_context.Script.prim))
  (map_annot : Micheline.annot) {struct ctxt}
  : Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  let? ctxt := Alpha_context.Gas.consume ctxt Typecheck_costs.cycle in
  match args with
  | cons key_ty (cons value_ty []) =>
    let? '(Ex_comparable_ty key_ty, ctxt) := parse_comparable_ty ctxt key_ty in
    let? '(Ex_ty value_ty, ctxt) := parse_packable_ty ctxt legacy value_ty in
    Error_monad.op_gtpipequestion
      (Script_ir_annot.parse_type_annot big_map_loc map_annot)
      (fun map_name =>
        let big_map_ty := Script_typed_ir.Big_map_t key_ty value_ty map_name in
        ((Ex_ty big_map_ty), ctxt))
  | args => Error_monad.__error_value extensible_type_value
  end

with parse_storage_ty
  (ctxt : Alpha_context.context) (legacy : bool)
  (node : Alpha_context.Script.node) {struct ctxt}
  : Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  match
    (node,
      match node with
      |
        Micheline.Prim loc Alpha_context.Script.T_pair
          (cons
            (Micheline.Prim big_map_loc Alpha_context.Script.T_big_map args
              map_annot) (cons remaining_storage [])) storage_annot => legacy
      | _ => false
      end) with
  |
    (Micheline.Prim loc Alpha_context.Script.T_pair
      (cons
        (Micheline.Prim big_map_loc Alpha_context.Script.T_big_map args
          map_annot) (cons remaining_storage [])) storage_annot, true) =>
    match
      (storage_annot,
        match storage_annot with
        | cons single [] =>
          Pervasives.op_andand
            ((|Compare.Int|).(Compare.S.op_gt) (String.length single) 0)
            ((|Compare.Char|).(Compare.S.op_eq) (String.get single 0) "%" % char)
        | _ => false
        end) with
    | ([], _) => parse_ty ctxt legacy true false legacy node
    | (cons single [], true) => parse_ty ctxt legacy true false legacy node
    | (_, _) =>
      let? ctxt := Alpha_context.Gas.consume ctxt Typecheck_costs.cycle in
      let? '(Ex_ty big_map_ty, ctxt) :=
        parse_big_map_ty ctxt legacy big_map_loc args map_annot in
      let? '(Ex_ty remaining_storage, ctxt) :=
        parse_ty ctxt legacy true false legacy remaining_storage in
      let? '(ty_name, map_field, storage_field) :=
        Script_ir_annot.parse_composed_type_annot loc storage_annot in
      Error_monad.op_gtpipequestion
        (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 5))
        (fun ctxt =>
          ((Ex_ty
            (Script_typed_ir.Pair_t (big_map_ty, map_field, None)
              (remaining_storage, storage_field, None) ty_name true)), ctxt))
    end
  | (_, _) => parse_ty ctxt legacy true false legacy node
  end.

Definition check_packable
  (legacy : bool) (loc : Alpha_context.Script.location)
  (root : Script_typed_ir.ty) : Error_monad.tzresult unit :=
  let fix check (function_parameter : Script_typed_ir.ty)
    {struct function_parameter} : Error_monad.tzresult unit :=
    match
      (function_parameter,
        match function_parameter with
        | Script_typed_ir.Contract_t _ _ => legacy
        | _ => false
        end) with
    | (Script_typed_ir.Big_map_t _ _ _, _) =>
      Error_monad.__error_value extensible_type_value
    | (Script_typed_ir.Operation_t _, _) =>
      Error_monad.__error_value extensible_type_value
    | (Script_typed_ir.Unit_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Int_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Nat_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Signature_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.String_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Bytes_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Mutez_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Key_hash_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Key_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Timestamp_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Address_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Bool_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Chain_id_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Pair_t (l_ty, _, _) (r_ty, _, _) _ _, _) =>
      let? '_ := check l_ty in
      check r_ty
    | (Script_typed_ir.Union_t (l_ty, _) (r_ty, _) _ _, _) =>
      let? '_ := check l_ty in
      check r_ty
    | (Script_typed_ir.Option_t v_ty _ _, _) => check v_ty
    | (Script_typed_ir.List_t elt_ty _ _, _) => check elt_ty
    | (Script_typed_ir.Set_t _ _, _) => Error_monad.ok tt
    | (Script_typed_ir.Map_t _ elt_ty _ _, _) => check elt_ty
    | (Script_typed_ir.Lambda_t _l_ty _r_ty _, _) => Error_monad.ok tt
    | (Script_typed_ir.Contract_t _ _, true) => Error_monad.ok tt
    | (Script_typed_ir.Contract_t _ _, _) =>
      Error_monad.__error_value extensible_type_value
    end in
  check root.

Inductive ex_script : Set :=
| Ex_script : forall {c : Set}, Script_typed_ir.script c -> ex_script.

Inductive dig_proof_argument (bef : Set) : Set :=
| Dig_proof_argument :
  Script_typed_ir.stack_prefix_preservation_witness *
    (Script_typed_ir.ty * option Script_typed_ir.var_annot) *
    Script_typed_ir.stack_ty -> dig_proof_argument bef.

Arguments Dig_proof_argument {_}.

Inductive dug_proof_argument (bef x : Set) : Set :=
| Dug_proof_argument :
  Script_typed_ir.stack_prefix_preservation_witness * unit *
    Script_typed_ir.stack_ty -> dug_proof_argument bef x.

Arguments Dug_proof_argument {_ _}.

Inductive dipn_proof_argument (bef : Set) : Set :=
| Dipn_proof_argument :
  Script_typed_ir.stack_prefix_preservation_witness *
    (Alpha_context.context * Script_typed_ir.descr) * Script_typed_ir.stack_ty
  -> dipn_proof_argument bef.

Arguments Dipn_proof_argument {_}.

Inductive dropn_proof_argument (bef : Set) : Set :=
| Dropn_proof_argument :
  Script_typed_ir.stack_prefix_preservation_witness * Script_typed_ir.stack_ty *
    Script_typed_ir.stack_ty -> dropn_proof_argument bef.

Arguments Dropn_proof_argument {_}.

Definition parse_var_annot
  (loc : int) (default : option (option Script_typed_ir.var_annot))
  (annot : list string)
  : Lwt.t (Error_monad.tzresult (option Script_typed_ir.var_annot)) :=
  Lwt.__return (Script_ir_annot.parse_var_annot loc default annot).

Definition parse_entrypoint_annot
  (loc : int) (default : option (option Script_typed_ir.var_annot))
  (annot : list string)
  : Lwt.t
    (Error_monad.tzresult
      (option Script_typed_ir.var_annot * option Script_typed_ir.field_annot)) :=
  Lwt.__return (Script_ir_annot.parse_entrypoint_annot loc default annot).

Definition parse_constr_annot
  (loc : int) (if_special_first : option (option Script_typed_ir.field_annot))
  (if_special_second : option (option Script_typed_ir.field_annot))
  (annot : list string)
  : Lwt.t
    (Error_monad.tzresult
      (option Script_typed_ir.var_annot * option Script_typed_ir.type_annot *
        option Script_typed_ir.field_annot * option Script_typed_ir.field_annot)) :=
  Lwt.__return
    (Script_ir_annot.parse_constr_annot loc if_special_first if_special_second
      annot).

Definition parse_two_var_annot (loc : int) (annot : list string)
  : Lwt.t
    (Error_monad.tzresult
      (option Script_typed_ir.var_annot * option Script_typed_ir.var_annot)) :=
  Lwt.__return (Script_ir_annot.parse_two_var_annot loc annot).

Definition parse_destr_annot
  (loc : int) (annot : list string)
  (default_accessor : option Script_typed_ir.field_annot)
  (field_name : option Script_typed_ir.field_annot)
  (pair_annot : option Script_typed_ir.var_annot)
  (value_annot : option Script_typed_ir.var_annot)
  : Lwt.t
    (Error_monad.tzresult
      (option Script_typed_ir.var_annot * option Script_typed_ir.field_annot)) :=
  Lwt.__return
    (Script_ir_annot.parse_destr_annot loc annot default_accessor field_name
      pair_annot value_annot).

Definition parse_var_type_annot (loc : int) (annot : list string)
  : Lwt.t
    (Error_monad.tzresult
      (option Script_typed_ir.var_annot * option Script_typed_ir.type_annot)) :=
  Lwt.__return (Script_ir_annot.parse_var_type_annot loc annot).

Definition find_entrypoint
  (full : Script_typed_ir.ty)
  (root_name : option (|Compare.String|).(Compare.S.t))
  (entrypoint : (|Compare.String|).(Compare.S.t))
  : Error_monad.tzresult
    ((Alpha_context.Script.node -> Alpha_context.Script.node) * ex_ty) :=
  let fix find_entrypoint (__t_value : Script_typed_ir.ty) (entrypoint : string)
    {struct __t_value}
    : (Alpha_context.Script.node -> Alpha_context.Script.node) * ex_ty :=
    match __t_value with
    | Script_typed_ir.Union_t (tl, al) (tr, ar) _ _ =>
      if
        match al with
        | None => false
        | Some (Script_typed_ir.Field_annot l) =>
          (|Compare.String|).(Compare.S.op_eq) l entrypoint
        end then
        ((fun e => Micheline.Prim 0 Alpha_context.Script.D_Left [ e ] nil),
          (Ex_ty tl))
      else
        if
          match ar with
          | None => false
          | Some (Script_typed_ir.Field_annot __r_value) =>
            (|Compare.String|).(Compare.S.op_eq) __r_value entrypoint
          end then
          ((fun e => Micheline.Prim 0 Alpha_context.Script.D_Right [ e ] nil),
            (Ex_ty tr))
        else
          (* ❌ Try-with are not handled *)
          try
            (let '(f, __t_value) := find_entrypoint tl entrypoint in
            ((fun e => Micheline.Prim 0 Alpha_context.Script.D_Left [ f e ] nil),
              __t_value))
    | _ => Pervasives.raise extensible_type_value
    end in
  let entrypoint :=
    if (|Compare.String|).(Compare.S.op_eq) entrypoint "" then
      "default"
    else
      entrypoint in
  if (|Compare.Int|).(Compare.S.op_gt) (String.length entrypoint) 31 then
    Error_monad.__error_value extensible_type_value
  else
    match
      (root_name,
        match root_name with
        | Some root_name =>
          (|Compare.String|).(Compare.S.op_eq) entrypoint root_name
        | _ => false
        end) with
    | (Some root_name, true) => Error_monad.ok ((fun e => e), (Ex_ty full))
    | (_, _) =>
      (* ❌ Try-with are not handled *)
      try (Error_monad.ok (find_entrypoint full entrypoint))
    end.

Definition find_entrypoint_for_type
  (full : Script_typed_ir.ty) (expected : Script_typed_ir.ty)
  (root_name : option (|Compare.String|).(Compare.S.t))
  (entrypoint : (|Compare.String|).(Compare.S.t)) (ctxt : Alpha_context.context)
  : Error_monad.tzresult (Alpha_context.context * string * Script_typed_ir.ty) :=
  match (entrypoint, root_name) with
  | ("default", Some "root") =>
    match find_entrypoint full root_name entrypoint with
    | (Pervasives.Error _) as err => err
    | Pervasives.Ok (_, Ex_ty ty) =>
      match ty_eq ctxt expected ty with
      | Pervasives.Ok (Eq, ctxt) => Error_monad.ok (ctxt, "default", ty)
      | Pervasives.Error _ =>
        let? '(Eq, ctxt) := ty_eq ctxt expected full in
        Error_monad.ok (ctxt, "root", full)
      end
    end
  | _ =>
    let? '(_, Ex_ty ty) := find_entrypoint full root_name entrypoint in
    let? '(Eq, ctxt) := ty_eq ctxt expected ty in
    Error_monad.ok (ctxt, entrypoint, ty)
  end.

Definition Entrypoints :=
  __Set.Make
    (existT (A := Set) _ _
      {|
        Compare.COMPARABLE.compare := String.compare
      |}).

(* ❌ The definition of exceptions is not handled. *)
(* exception Duplicate *)

(* ❌ The definition of exceptions is not handled. *)
(* exception Too_long *)

Definition well_formed_entrypoints
  (full : Script_typed_ir.ty) (root_name : option (|Entrypoints|).(S.SET.elt))
  : Error_monad.tzresult unit :=
  let merge {A : Set}
    (path : list A) (annot : option Script_typed_ir.field_annot)
    (ty : Script_typed_ir.ty) (reachable : bool)
    (function_parameter : option (list A) * (|Entrypoints|).(S.SET.t))
    : option (list A) * (|Entrypoints|).(S.SET.t) :=
    let '(first_unreachable, all) as acc := function_parameter in
    match annot with
    | (None | Some (Script_typed_ir.Field_annot "")) =>
      if reachable then
        acc
      else
        match ty with
        | Script_typed_ir.Union_t _ _ _ _ => acc
        | _ =>
          match first_unreachable with
          | None => ((Some (List.rev path)), all)
          | Some _ => acc
          end
        end
    | Some (Script_typed_ir.Field_annot name) =>
      if (|Compare.Int|).(Compare.S.op_gt) (String.length name) 31 then
        Pervasives.raise extensible_type_value
      else
        if (|Entrypoints|).(S.SET.mem) name all then
          Pervasives.raise extensible_type_value
        else
          (first_unreachable, ((|Entrypoints|).(S.SET.add) name all))
    end in
  let fix check
    (__t_value : Script_typed_ir.ty) (path : list Alpha_context.Script.prim)
    (reachable : bool)
    (acc : option (list Alpha_context.Script.prim) * (|Entrypoints|).(S.SET.t))
    {struct __t_value}
    : option (list Alpha_context.Script.prim) * (|Entrypoints|).(S.SET.t) :=
    match __t_value with
    | Script_typed_ir.Union_t (tl, al) (tr, ar) _ _ =>
      let acc :=
        merge (cons Alpha_context.Script.D_Left path) al tl reachable acc in
      let acc :=
        merge (cons Alpha_context.Script.D_Right path) ar tr reachable acc in
      let acc :=
        check tl (cons Alpha_context.Script.D_Left path)
          match al with
          | Some _ => true
          | None => reachable
          end acc in
      check tr (cons Alpha_context.Script.D_Right path)
        match ar with
        | Some _ => true
        | None => reachable
        end acc
    | _ => acc
    end in
  (* ❌ Try-with are not handled *)
  try
    (let '(init, reachable) :=
      match root_name with
      | (None | Some "") => ((|Entrypoints|).(S.SET.empty), false)
      | Some name => (((|Entrypoints|).(S.SET.singleton) name), true)
      end in
    let '(first_unreachable, all) := check full nil reachable (None, init) in
    if Pervasives.not ((|Entrypoints|).(S.SET.mem) "default" all) then
      Error_monad.ok tt
    else
      match first_unreachable with
      | None => Error_monad.ok tt
      | Some path => Error_monad.__error_value extensible_type_value
      end).

Fixpoint parse_data {a : Set}
  (type_logger : option type_logger) (ctxt : Alpha_context.context)
  (legacy : bool) (ty : Script_typed_ir.ty)
  (script_data : Alpha_context.Script.node) {struct type_logger}
  : Lwt.t (Error_monad.tzresult (a * Alpha_context.context)) :=
  let=? ctxt :=
    Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle) in
  let __error_value (function_parameter : unit)
    : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
    let '_ := function_parameter in
    Error_monad.op_gtgtpipequestion
      (Lwt.__return (serialize_ty_for_error ctxt ty))
      (fun function_parameter =>
        let '(ty, _ctxt) := function_parameter in
        extensible_type_value) in
  let traced {B : Set} (body : Lwt.t (Error_monad.tzresult B))
    : Lwt.t (Error_monad.tzresult B) :=
    Error_monad.trace_eval __error_value body in
  let parse_items {B C D E : Set}
    (type_logger : option type_logger) (loc : Alpha_context.Script.location)
    (ctxt : Alpha_context.context)
    (expr : Micheline.node B Alpha_context.Script.prim)
    (key_type : Script_typed_ir.comparable_ty) (value_type : Script_typed_ir.ty)
    (items :
      list
        (Micheline.node Alpha_context.Script.location Alpha_context.Script.prim))
    (item_wrapper : C -> D)
    : Lwt.t
      (Error_monad.tzresult (Script_typed_ir.map E D * Alpha_context.context)) :=
    let length := List.length items in
    Error_monad.op_gtgtpipequestion
      (traced
        (Error_monad.fold_left_s
          (fun function_parameter =>
            let '(last_value, map, ctxt) := function_parameter in
            fun item =>
              let=? ctxt :=
                Lwt.__return
                  (Alpha_context.Gas.consume ctxt
                    (Typecheck_costs.map_element length)) in
              match item with
              |
                Micheline.Prim _ Alpha_context.Script.D_Elt (cons k (cons v []))
                  _ =>
                let=? '(k, ctxt) :=
                  parse_comparable_data type_logger ctxt key_type k in
                let=? '(v, ctxt) :=
                  parse_data type_logger ctxt legacy value_type v in
                let=? '_ :=
                  match last_value with
                  | Some value =>
                    if
                      (|Compare.Int|).(Compare.S.op_lteq) 0
                        (compare_comparable key_type value k) then
                      if
                        (|Compare.Int|).(Compare.S.op_eq) 0
                          (compare_comparable key_type value k) then
                        Error_monad.fail extensible_type_value
                      else
                        Error_monad.fail extensible_type_value
                    else
                      Error_monad.return_unit
                  | None => Error_monad.return_unit
                  end in
                Error_monad.__return
                  ((Some k), (map_update k (Some (item_wrapper v)) map), ctxt)
              | Micheline.Prim loc Alpha_context.Script.D_Elt l _ =>
                Error_monad.fail extensible_type_value
              | Micheline.Prim loc name _ _ =>
                Error_monad.fail extensible_type_value
              |
                (Micheline.Int _ _ | Micheline.String _ _ | Micheline.Bytes _ _
                | Micheline.Seq _ _) =>
                Error_monad.op_gtgteqquestion (__error_value tt)
                  Error_monad.fail
              end) (None, (empty_map key_type), ctxt) items))
      (fun function_parameter =>
        let '(_, items, ctxt) := function_parameter in
        (items, ctxt)) in
  match (ty, script_data) with
  |
    (Script_typed_ir.Unit_t _,
      Micheline.Prim loc Alpha_context.Script.D_Unit [] annot) =>
    let=? '_ :=
      if legacy then
        Error_monad.__return tt
      else
        Script_ir_annot.fail_unexpected_annot loc annot in
    Error_monad.op_gtgtpipequestion
      (Lwt.__return
        (Alpha_context.Gas.consume ctxt Typecheck_costs.__unit_value))
      (fun ctxt => (tt, ctxt))
  |
    (Script_typed_ir.Unit_t _,
      Micheline.Prim loc Alpha_context.Script.D_Unit l _) =>
    traced (Error_monad.fail extensible_type_value)
  | (Script_typed_ir.Unit_t _, expr) =>
    traced
      (Error_monad.fail
        (unexpected expr nil Script_tc_errors.Constant_namespace
          [ Alpha_context.Script.D_Unit ]))
  |
    (Script_typed_ir.Bool_t _,
      Micheline.Prim loc Alpha_context.Script.D_True [] annot) =>
    let=? '_ :=
      if legacy then
        Error_monad.__return tt
      else
        Script_ir_annot.fail_unexpected_annot loc annot in
    Error_monad.op_gtgtpipequestion
      (Lwt.__return
        (Alpha_context.Gas.consume ctxt Typecheck_costs.__bool_value))
      (fun ctxt => (true, ctxt))
  |
    (Script_typed_ir.Bool_t _,
      Micheline.Prim loc Alpha_context.Script.D_False [] annot) =>
    let=? '_ :=
      if legacy then
        Error_monad.__return tt
      else
        Script_ir_annot.fail_unexpected_annot loc annot in
    Error_monad.op_gtgtpipequestion
      (Lwt.__return
        (Alpha_context.Gas.consume ctxt Typecheck_costs.__bool_value))
      (fun ctxt => (false, ctxt))
  |
    (Script_typed_ir.Bool_t _,
      Micheline.Prim loc
        ((Alpha_context.Script.D_True | Alpha_context.Script.D_False) as c) l _)
    => traced (Error_monad.fail extensible_type_value)
  | (Script_typed_ir.Bool_t _, expr) =>
    traced
      (Error_monad.fail
        (unexpected expr nil Script_tc_errors.Constant_namespace
          [ Alpha_context.Script.D_True; Alpha_context.Script.D_False ]))
  | (Script_typed_ir.String_t _, Micheline.String _ v) =>
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt
          (Typecheck_costs.__string_value (String.length v))) in
    let fix check_printable_ascii (i : (|Compare.Int|).(Compare.S.t)) {struct i}
      : bool :=
      if (|Compare.Int|).(Compare.S.op_lt) i 0 then
        true
      else
        match String.get v i with
        |
          ("010" % char | " " % char | "!" % char | """" % char | "#" % char |
          "$" % char | "%" % char | "&" % char | "'" % char | "(" % char |
          ")" % char | "*" % char | "+" % char | "," % char | "-" % char |
          "." % char | "/" % char | "0" % char | "1" % char | "2" % char |
          "3" % char | "4" % char | "5" % char | "6" % char | "7" % char |
          "8" % char | "9" % char | ":" % char | ";" % char | "<" % char |
          "=" % char | ">" % char | "?" % char | "@" % char | "A" % char |
          "B" % char | "C" % char | "D" % char | "E" % char | "F" % char |
          "G" % char | "H" % char | "I" % char | "J" % char | "K" % char |
          "L" % char | "M" % char | "N" % char | "O" % char | "P" % char |
          "Q" % char | "R" % char | "S" % char | "T" % char | "U" % char |
          "V" % char | "W" % char | "X" % char | "Y" % char | "Z" % char |
          "[" % char | "\" % char | "]" % char | "^" % char | "_" % char |
          "`" % char | "a" % char | "b" % char | "c" % char | "d" % char |
          "e" % char | "f" % char | "g" % char | "h" % char | "i" % char |
          "j" % char | "k" % char | "l" % char | "m" % char | "n" % char |
          "o" % char | "p" % char | "q" % char | "r" % char | "s" % char |
          "t" % char | "u" % char | "v" % char | "w" % char | "x" % char |
          "y" % char | "z" % char | "{" % char | "|" % char | "}" % char |
          "~" % char) => check_printable_ascii (Pervasives.op_minus i 1)
        | _ => false
        end in
    if check_printable_ascii (Pervasives.op_minus (String.length v) 1) then
      Error_monad.__return (v, ctxt)
    else
      Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
  | (Script_typed_ir.String_t _, expr) =>
    traced (Error_monad.fail extensible_type_value)
  | (Script_typed_ir.Bytes_t _, Micheline.Bytes _ v) =>
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt
          (Typecheck_costs.__string_value (MBytes.length v))) in
    Error_monad.__return (v, ctxt)
  | (Script_typed_ir.Bytes_t _, expr) =>
    traced (Error_monad.fail extensible_type_value)
  | (Script_typed_ir.Int_t _, Micheline.Int _ v) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt (Typecheck_costs.z v)) in
    Error_monad.__return ((Alpha_context.Script_int.of_zint v), ctxt)
  | (Script_typed_ir.Nat_t _, Micheline.Int _ v) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt (Typecheck_costs.z v)) in
    let v := Alpha_context.Script_int.of_zint v in
    if
      (|Compare.Int|).(Compare.S.op_gteq)
        (Alpha_context.Script_int.compare v Alpha_context.Script_int.zero) 0
      then
      Error_monad.__return ((Alpha_context.Script_int.abs v), ctxt)
    else
      Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
  | (Script_typed_ir.Int_t _, expr) =>
    traced (Error_monad.fail extensible_type_value)
  | (Script_typed_ir.Nat_t _, expr) =>
    traced (Error_monad.fail extensible_type_value)
  | (Script_typed_ir.Mutez_t _, Micheline.Int _ v) =>
    let=? ctxt :=
      Lwt.__return
        (let? ctxt := Alpha_context.Gas.consume ctxt Typecheck_costs.tez in
        Alpha_context.Gas.consume ctxt
          Michelson_v1_gas.Cost_of.Legacy.z_to_int64) in
    (* ❌ Try-with are not handled *)
    try
      match Alpha_context.Tez.of_mutez (Z.to_int64 v) with
      | None => Pervasives.raise extensible_type_value
      | Some tez => Error_monad.__return (tez, ctxt)
      end
  | (Script_typed_ir.Mutez_t _, expr) =>
    traced (Error_monad.fail extensible_type_value)
  | (Script_typed_ir.Timestamp_t _, Micheline.Int _ v) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt (Typecheck_costs.z v)) in
    Error_monad.__return ((Alpha_context.Script_timestamp.of_zint v), ctxt)
  | (Script_typed_ir.Timestamp_t _, Micheline.String _ s) =>
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt Typecheck_costs.string_timestamp) in
    match Alpha_context.Script_timestamp.of_string s with
    | Some v => Error_monad.__return (v, ctxt)
    | None => Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
    end
  | (Script_typed_ir.Timestamp_t _, expr) =>
    traced (Error_monad.fail extensible_type_value)
  | (Script_typed_ir.Key_t _, Micheline.Bytes _ __bytes_value) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.__key_value)
      in
    match
      Data_encoding.Binary.of_bytes
        (|Signature.Public_key|).(S.SPublic_key.encoding) __bytes_value with
    | Some k => Error_monad.__return (k, ctxt)
    | None => Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
    end
  | (Script_typed_ir.Key_t _, Micheline.String _ s) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.__key_value)
      in
    match (|Signature.Public_key|).(S.SPublic_key.of_b58check_opt) s with
    | Some k => Error_monad.__return (k, ctxt)
    | None => Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
    end
  | (Script_typed_ir.Key_t _, expr) =>
    traced (Error_monad.fail extensible_type_value)
  | (Script_typed_ir.Key_hash_t _, Micheline.Bytes _ __bytes_value) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.key_hash) in
    match
      Data_encoding.Binary.of_bytes
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding)
        __bytes_value with
    | Some k => Error_monad.__return (k, ctxt)
    | None => Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
    end
  | (Script_typed_ir.Key_hash_t _, Micheline.String _ s) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.key_hash) in
    match (|Signature.Public_key_hash|).(S.SPublic_key_hash.of_b58check_opt) s
      with
    | Some k => Error_monad.__return (k, ctxt)
    | None => Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
    end
  | (Script_typed_ir.Key_hash_t _, expr) =>
    traced (Error_monad.fail extensible_type_value)
  | (Script_typed_ir.Signature_t _, Micheline.Bytes _ __bytes_value) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.signature) in
    match Data_encoding.Binary.of_bytes Signature.encoding __bytes_value with
    | Some k => Error_monad.__return (k, ctxt)
    | None => Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
    end
  | (Script_typed_ir.Signature_t _, Micheline.String _ s) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.signature) in
    match Signature.of_b58check_opt s with
    | Some s => Error_monad.__return (s, ctxt)
    | None => Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
    end
  | (Script_typed_ir.Signature_t _, expr) =>
    traced (Error_monad.fail extensible_type_value)
  | (Script_typed_ir.Operation_t _, _) =>
    (* ❌ Assert instruction is not handled. *)
    assert (Lwt.t (Error_monad.tzresult (a * Alpha_context.context))) false
  | (Script_typed_ir.Chain_id_t _, Micheline.Bytes _ __bytes_value) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.chain_id) in
    match
      Data_encoding.Binary.of_bytes (|Chain_id|).(S.HASH.encoding) __bytes_value
      with
    | Some k => Error_monad.__return (k, ctxt)
    | None => Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
    end
  | (Script_typed_ir.Chain_id_t _, Micheline.String _ s) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.chain_id) in
    match (|Chain_id|).(S.HASH.of_b58check_opt) s with
    | Some s => Error_monad.__return (s, ctxt)
    | None => Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
    end
  | (Script_typed_ir.Chain_id_t _, expr) =>
    traced (Error_monad.fail extensible_type_value)
  | (Script_typed_ir.Address_t _, Micheline.Bytes loc __bytes_value) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.contract) in
    match
      Data_encoding.Binary.of_bytes
        (Data_encoding.tup2 Alpha_context.Contract.encoding
          Data_encoding.__Variable.__string_value) __bytes_value with
    | Some (c, entrypoint) =>
      if (|Compare.Int|).(Compare.S.op_gt) (String.length entrypoint) 31 then
        Error_monad.fail extensible_type_value
      else
        let=? entrypoint :=
          match entrypoint with
          | "" => Error_monad.__return "default"
          | "default" => Error_monad.fail extensible_type_value
          | name => Error_monad.__return name
          end in
        Error_monad.__return ((c, entrypoint), ctxt)
    | None => Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
    end
  | (Script_typed_ir.Address_t _, Micheline.String loc s) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.contract) in
    let=? '(addr, entrypoint) :=
      match String.index_opt s "%" % char with
      | None => Error_monad.__return (s, "default")
      | Some pos =>
        let len :=
          Pervasives.op_minus (Pervasives.op_minus (String.length s) pos) 1 in
        let name := String.sub s (Pervasives.op_plus pos 1) len in
        if (|Compare.Int|).(Compare.S.op_gt) len 31 then
          Error_monad.fail extensible_type_value
        else
          match ((String.sub s 0 pos), name) with
          | (_, "default") => traced (Error_monad.fail extensible_type_value)
          | addr_and_name => Error_monad.__return addr_and_name
          end
      end in
    let=? c := Lwt.__return (Alpha_context.Contract.of_b58check addr) in
    Error_monad.__return ((c, entrypoint), ctxt)
  | (Script_typed_ir.Address_t _, expr) =>
    traced (Error_monad.fail extensible_type_value)
  | (Script_typed_ir.Contract_t ty _, Micheline.Bytes loc __bytes_value) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.contract) in
    match
      Data_encoding.Binary.of_bytes
        (Data_encoding.tup2 Alpha_context.Contract.encoding
          Data_encoding.__Variable.__string_value) __bytes_value with
    | Some (c, entrypoint) =>
      if (|Compare.Int|).(Compare.S.op_gt) (String.length entrypoint) 31 then
        Error_monad.fail extensible_type_value
      else
        let=? entrypoint :=
          match entrypoint with
          | "" => Error_monad.__return "default"
          | "default" => traced (Error_monad.fail extensible_type_value)
          | name => Error_monad.__return name
          end in
        let=? '(ctxt, _) :=
          traced (parse_contract legacy ctxt loc ty c entrypoint) in
        Error_monad.__return ((ty, (c, entrypoint)), ctxt)
    | None => Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
    end
  | (Script_typed_ir.Contract_t ty _, Micheline.String loc s) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.contract) in
    let=? '(addr, entrypoint) :=
      match String.index_opt s "%" % char with
      | None => Error_monad.__return (s, "default")
      | Some pos =>
        let len :=
          Pervasives.op_minus (Pervasives.op_minus (String.length s) pos) 1 in
        let name := String.sub s (Pervasives.op_plus pos 1) len in
        if (|Compare.Int|).(Compare.S.op_gt) len 31 then
          Error_monad.fail extensible_type_value
        else
          match ((String.sub s 0 pos), name) with
          | (_, "default") => traced (Error_monad.fail extensible_type_value)
          | addr_and_name => Error_monad.__return addr_and_name
          end
      end in
    let=? c := traced (Lwt.__return (Alpha_context.Contract.of_b58check addr))
      in
    let=? '(ctxt, _) := parse_contract legacy ctxt loc ty c entrypoint in
    Error_monad.__return ((ty, (c, entrypoint)), ctxt)
  | (Script_typed_ir.Contract_t _ _, expr) =>
    traced (Error_monad.fail extensible_type_value)
  |
    (Script_typed_ir.Pair_t (ta, _, _) (tb, _, _) _ _,
      Micheline.Prim loc Alpha_context.Script.D_Pair (cons va (cons vb []))
        annot) =>
    let=? '_ :=
      if legacy then
        Error_monad.__return tt
      else
        Script_ir_annot.fail_unexpected_annot loc annot in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.pair) in
    let=? '(va, ctxt) := traced (parse_data type_logger ctxt legacy ta va) in
    let=? '(vb, ctxt) := parse_data type_logger ctxt legacy tb vb in
    Error_monad.__return ((va, vb), ctxt)
  |
    (Script_typed_ir.Pair_t _ _ _ _,
      Micheline.Prim loc Alpha_context.Script.D_Pair l _) =>
    Error_monad.fail extensible_type_value
  | (Script_typed_ir.Pair_t _ _ _ _, expr) =>
    traced
      (Error_monad.fail
        (unexpected expr nil Script_tc_errors.Constant_namespace
          [ Alpha_context.Script.D_Pair ]))
  |
    (Script_typed_ir.Union_t (tl, _) _ _ _,
      Micheline.Prim loc Alpha_context.Script.D_Left (cons v []) annot) =>
    let=? '_ :=
      if legacy then
        Error_monad.__return tt
      else
        Script_ir_annot.fail_unexpected_annot loc annot in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.union) in
    let=? '(v, ctxt) := traced (parse_data type_logger ctxt legacy tl v) in
    Error_monad.__return ((Script_typed_ir.L v), ctxt)
  |
    (Script_typed_ir.Union_t _ _ _ _,
      Micheline.Prim loc Alpha_context.Script.D_Left l _) =>
    Error_monad.fail extensible_type_value
  |
    (Script_typed_ir.Union_t _ (tr, _) _ _,
      Micheline.Prim loc Alpha_context.Script.D_Right (cons v []) annot) =>
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.union) in
    let=? '(v, ctxt) := traced (parse_data type_logger ctxt legacy tr v) in
    Error_monad.__return ((Script_typed_ir.R v), ctxt)
  |
    (Script_typed_ir.Union_t _ _ _ _,
      Micheline.Prim loc Alpha_context.Script.D_Right l _) =>
    Error_monad.fail extensible_type_value
  | (Script_typed_ir.Union_t _ _ _ _, expr) =>
    traced
      (Error_monad.fail
        (unexpected expr nil Script_tc_errors.Constant_namespace
          [ Alpha_context.Script.D_Left; Alpha_context.Script.D_Right ]))
  |
    (Script_typed_ir.Lambda_t ta tr _ty_name,
      (Micheline.Seq _loc _) as script_instr) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.lambda) in
    traced
      (parse_returning type_logger Lambda ctxt legacy
        (ta, (Some (Script_typed_ir.Var_annot "@arg"))) tr script_instr)
  | (Script_typed_ir.Lambda_t _ _ _, expr) =>
    traced (Error_monad.fail extensible_type_value)
  |
    (Script_typed_ir.Option_t __t_value _ _,
      Micheline.Prim loc Alpha_context.Script.D_Some (cons v []) annot) =>
    let=? '_ :=
      if legacy then
        Error_monad.__return tt
      else
        Script_ir_annot.fail_unexpected_annot loc annot in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.some) in
    let=? '(v, ctxt) := traced (parse_data type_logger ctxt legacy __t_value v)
      in
    Error_monad.__return ((Some v), ctxt)
  |
    (Script_typed_ir.Option_t _ _ _,
      Micheline.Prim loc Alpha_context.Script.D_Some l _) =>
    Error_monad.fail extensible_type_value
  |
    (Script_typed_ir.Option_t _ _ _,
      Micheline.Prim loc Alpha_context.Script.D_None [] annot) =>
    let=? '_ :=
      if legacy then
        Error_monad.__return tt
      else
        Script_ir_annot.fail_unexpected_annot loc annot in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.none) in
    Error_monad.__return (None, ctxt)
  |
    (Script_typed_ir.Option_t _ _ _,
      Micheline.Prim loc Alpha_context.Script.D_None l _) =>
    Error_monad.fail extensible_type_value
  | (Script_typed_ir.Option_t _ _ _, expr) =>
    traced
      (Error_monad.fail
        (unexpected expr nil Script_tc_errors.Constant_namespace
          [ Alpha_context.Script.D_Some; Alpha_context.Script.D_None ]))
  | (Script_typed_ir.List_t __t_value _ty_name _, Micheline.Seq _loc items) =>
    traced
      (Error_monad.fold_right_s
        (fun v =>
          fun function_parameter =>
            let '(rest, ctxt) := function_parameter in
            let=? ctxt :=
              Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.list_element) in
            let=? '(v, ctxt) := parse_data type_logger ctxt legacy __t_value v
              in
            Error_monad.__return ((cons v rest), ctxt)) items (nil, ctxt))
  | (Script_typed_ir.List_t _ _ _, expr) =>
    traced (Error_monad.fail extensible_type_value)
  | (Script_typed_ir.Set_t __t_value _ty_name, (Micheline.Seq loc vs) as expr)
    =>
    let length := List.length vs in
    Error_monad.op_gtgtpipequestion
      (traced
        (Error_monad.fold_left_s
          (fun function_parameter =>
            let '(last_value, set, ctxt) := function_parameter in
            fun v =>
              let=? ctxt :=
                Lwt.__return
                  (Alpha_context.Gas.consume ctxt
                    (Typecheck_costs.set_element length)) in
              let=? '(v, ctxt) :=
                parse_comparable_data type_logger ctxt __t_value v in
              let=? '_ :=
                match last_value with
                | Some value =>
                  if
                    (|Compare.Int|).(Compare.S.op_lteq) 0
                      (compare_comparable __t_value value v) then
                    if
                      (|Compare.Int|).(Compare.S.op_eq) 0
                        (compare_comparable __t_value value v) then
                      Error_monad.fail extensible_type_value
                    else
                      Error_monad.fail extensible_type_value
                  else
                    Error_monad.return_unit
                | None => Error_monad.return_unit
                end in
              let=? ctxt :=
                Lwt.__return
                  (Alpha_context.Gas.consume ctxt
                    (Michelson_v1_gas.Cost_of.Legacy.set_update v false set)) in
              Error_monad.__return ((Some v), (set_update v true set), ctxt))
          (None, (empty_set __t_value), ctxt) vs))
      (fun function_parameter =>
        let '(_, set, ctxt) := function_parameter in
        (set, ctxt))
  | (Script_typed_ir.Set_t _ _, expr) =>
    traced (Error_monad.fail extensible_type_value)
  | (Script_typed_ir.Map_t tk tv _ty_name _, (Micheline.Seq loc vs) as expr) =>
    parse_items type_logger loc ctxt expr tk tv vs (fun x => x)
  | (Script_typed_ir.Map_t _ _ _ _, expr) =>
    traced (Error_monad.fail extensible_type_value)
  | (Script_typed_ir.Big_map_t tk tv _ty_name, (Micheline.Seq loc vs) as expr)
    =>
    Error_monad.op_gtgtpipequestion
      (parse_items type_logger loc ctxt expr tk tv vs (fun x => Some x))
      (fun function_parameter =>
        let '(diff, ctxt) := function_parameter in
        ({| Script_typed_ir.big_map.id := None;
          Script_typed_ir.big_map.diff := diff;
          Script_typed_ir.big_map.key_type := ty_of_comparable_ty tk;
          Script_typed_ir.big_map.value_type := tv |}, ctxt))
  | (Script_typed_ir.Big_map_t tk tv _ty_name, Micheline.Int loc id) =>
    let=? function_parameter := Alpha_context.Big_map.__exists ctxt id in
    match function_parameter with
    | (_, None) => traced (Error_monad.fail extensible_type_value)
    | (ctxt, Some (btk, btv)) =>
      Lwt.__return
        (let? '(Ex_comparable_ty btk, ctxt) :=
          parse_comparable_ty ctxt (Micheline.root btk) in
        let? '(Ex_ty btv, ctxt) :=
          parse_packable_ty ctxt legacy (Micheline.root btv) in
        let? 'Eq := comparable_ty_eq ctxt tk btk in
        let? '(Eq, ctxt) := ty_eq ctxt tv btv in
        Error_monad.ok
          ({| Script_typed_ir.big_map.id := Some id;
            Script_typed_ir.big_map.diff := empty_map tk;
            Script_typed_ir.big_map.key_type := ty_of_comparable_ty tk;
            Script_typed_ir.big_map.value_type := tv |}, ctxt))
    end
  | (Script_typed_ir.Big_map_t _tk _tv _, expr) =>
    traced (Error_monad.fail extensible_type_value)
  end

with parse_comparable_data {a : Set}
  (type_logger : option type_logger) (ctxt : Alpha_context.context)
  (ty : Script_typed_ir.comparable_ty) (script_data : Alpha_context.Script.node)
  {struct type_logger}
  : Lwt.t (Error_monad.tzresult (a * Alpha_context.context)) :=
  parse_data type_logger ctxt false (ty_of_comparable_ty ty) script_data

with parse_returning
  (type_logger : option type_logger) (tc_context : tc_context)
  (ctxt : Alpha_context.context) (legacy : bool)
  (function_parameter : Script_typed_ir.ty * option Script_typed_ir.var_annot)
  {struct type_logger}
  : Script_typed_ir.ty -> Alpha_context.Script.node ->
  Lwt.t (Error_monad.tzresult (Script_typed_ir.lambda * Alpha_context.context)) :=
  let '(arg, arg_annot) := function_parameter in
  fun ret =>
    fun script_instr =>
      let=? function_parameter :=
        parse_instr type_logger tc_context ctxt legacy script_instr
          (Script_typed_ir.Item_t arg Script_typed_ir.Empty_t arg_annot) in
      match function_parameter with
      |
        (Typed
          ({|
            Script_typed_ir.descr.loc := loc;
              Script_typed_ir.descr.aft :=
                (Script_typed_ir.Item_t ty Script_typed_ir.Empty_t _)
                  as stack_ty
              |} as __descr_value), ctxt) =>
        Error_monad.trace_eval
          (fun function_parameter =>
            let '_ := function_parameter in
            let=? '(ret, ctxt) := Lwt.__return (serialize_ty_for_error ctxt ret)
              in
            Error_monad.op_gtgtpipequestion
              (serialize_stack_for_error ctxt stack_ty)
              (fun function_parameter =>
                let '(stack_ty, _ctxt) := function_parameter in
                extensible_type_value))
          (let=? '(Eq, ctxt) := Lwt.__return (ty_eq ctxt ty ret) in
          let=? '(_ret, ctxt) :=
            Lwt.__return (merge_types legacy ctxt loc ty ret) in
          Error_monad.__return
            ({| Script_typed_ir.lambda.lam := (__descr_value, script_instr) |},
              ctxt))
      |
        (Typed {|
          Script_typed_ir.descr.loc := loc;
            Script_typed_ir.descr.aft := stack_ty
            |}, ctxt) =>
        let=? '(ret, ctxt) := Lwt.__return (serialize_ty_for_error ctxt ret) in
        let=? '(stack_ty, _ctxt) := serialize_stack_for_error ctxt stack_ty in
        Error_monad.fail extensible_type_value
      | (Failed {| judgement.Failed.descr := __descr_value |}, ctxt) =>
        Error_monad.__return
          ({|
            Script_typed_ir.lambda.lam :=
              ((__descr_value
                (Script_typed_ir.Item_t ret Script_typed_ir.Empty_t None)),
                script_instr) |}, ctxt)
      end

with parse_int32
  (n : Micheline.node Alpha_context.Script.location Alpha_context.Script.prim)
  {struct n} : Error_monad.tzresult int :=
  let error' (function_parameter : unit) : Error_monad.__error :=
    let '_ := function_parameter in
    extensible_type_value in
  match n with
  | Micheline.Int _ n' =>
    (* ❌ Try-with are not handled *)
    try
      (let n'' := Z.to_int n' in
      if
        Pervasives.op_andand ((|Compare.Int|).(Compare.S.op_lteq) 0 n'')
          ((|Compare.Int|).(Compare.S.op_lteq) n'' (Int32.to_int Int32.max_int))
        then
        Error_monad.ok n''
      else
        Error_monad.__error_value (error' tt))
  | _ => Error_monad.__error_value (error' tt)
  end

with parse_instr {bef : Set}
  (type_logger : option type_logger) (tc_context : tc_context)
  (ctxt : Alpha_context.context) (legacy : bool)
  (script_instr : Alpha_context.Script.node)
  (stack_ty : Script_typed_ir.stack_ty) {struct type_logger}
  : Lwt.t (Error_monad.tzresult (judgement bef * Alpha_context.context)) :=
  let _check_item {B : Set}
    (check : Error_monad.tzresult B) (loc : Alpha_context.Script.location)
    (name : Alpha_context.Script.prim) (n : int) (m : int)
    : Lwt.t (Error_monad.tzresult B) :=
    (Error_monad.trace_eval
      (fun function_parameter =>
        let '_ := function_parameter in
        Error_monad.op_gtgtpipequestion
          (serialize_stack_for_error ctxt stack_ty)
          (fun function_parameter =>
            let '(stack_ty, _ctxt) := function_parameter in
            extensible_type_value)))
      ((Error_monad.trace extensible_type_value) (Lwt.__return check)) in
  let check_item_ty
    (ctxt : Alpha_context.context) (exp : Script_typed_ir.ty)
    (got : Script_typed_ir.ty) (loc : Alpha_context.Script.location)
    (name : Alpha_context.Script.prim) (n : int) (m : int)
    : Lwt.t
      (Error_monad.tzresult (eq * Script_typed_ir.ty * Alpha_context.context)) :=
    (Error_monad.trace_eval
      (fun function_parameter =>
        let '_ := function_parameter in
        Error_monad.op_gtgtpipequestion
          (serialize_stack_for_error ctxt stack_ty)
          (fun function_parameter =>
            let '(stack_ty, _ctxt) := function_parameter in
            extensible_type_value)))
      ((Error_monad.trace extensible_type_value)
        (Lwt.__return
          (let? '(Eq, ctxt) := ty_eq ctxt exp got in
          let? '(ty, ctxt) := merge_types legacy ctxt loc exp got in
          Error_monad.ok (Eq, ty, ctxt)))) in
  let check_item_comparable_ty
    (exp : Script_typed_ir.comparable_ty) (got : Script_typed_ir.comparable_ty)
    (loc : Alpha_context.Script.location) (name : Alpha_context.Script.prim)
    (n : int) (m : int)
    : Lwt.t (Error_monad.tzresult (eq * Script_typed_ir.comparable_ty)) :=
    (Error_monad.trace_eval
      (fun function_parameter =>
        let '_ := function_parameter in
        Error_monad.op_gtgtpipequestion
          (serialize_stack_for_error ctxt stack_ty)
          (fun function_parameter =>
            let '(stack_ty, _ctxt) := function_parameter in
            extensible_type_value)))
      ((Error_monad.trace extensible_type_value)
        (Lwt.__return
          (let? 'Eq := comparable_ty_eq ctxt exp got in
          let? ty := merge_comparable_types legacy exp got in
          Error_monad.ok (Eq, ty)))) in
  let log_stack
    (ctxt : Alpha_context.context) (loc : int)
    (stack_ty : Script_typed_ir.stack_ty) (aft : Script_typed_ir.stack_ty)
    : Lwt.t (Error_monad.tzresult unit) :=
    match (type_logger, script_instr) with
    |
      ((None, _) |
      (Some _,
        (Micheline.Seq (-1) _ | Micheline.Int _ _ | Micheline.String _ _ |
        Micheline.Bytes _ _))) => Error_monad.return_unit
    | (Some log, (Micheline.Prim _ _ _ _ | Micheline.Seq _ _)) =>
      let ctxt := Alpha_context.Gas.set_unlimited ctxt in
      let=? '(stack_ty, _) := unparse_stack ctxt stack_ty in
      let=? '(aft, _) := unparse_stack ctxt aft in
      (* ❌ Sequences of instructions are ignored (operator ";") *)
      (* ❌ instruction_sequence ";" *)
      Error_monad.return_unit
    end in
  let outer_return {B : Set} : B -> Lwt.t (Error_monad.tzresult B) :=
    Error_monad.__return in
  let __return (ctxt : Alpha_context.context) (judgement : judgement bef)
    : Lwt.t (Error_monad.tzresult (judgement bef * Alpha_context.context)) :=
    match judgement with
    |
      Typed {|
        Script_typed_ir.descr.loc := loc;
          Script_typed_ir.descr.aft := aft;
          Script_typed_ir.descr.instr := instr
          |} =>
      let maximum_type_size :=
        Alpha_context.Constants.michelson_maximum_type_size ctxt in
      let type_size :=
        type_size_of_stack_head aft (number_of_generated_growing_types instr) in
      if (|Compare.Int|).(Compare.S.op_gt) type_size maximum_type_size then
        Error_monad.fail extensible_type_value
      else
        Error_monad.__return (judgement, ctxt)
    | Failed _ => Error_monad.__return (judgement, ctxt)
    end in
  let typed
    (ctxt : Alpha_context.context) (loc : int) (instr : Script_typed_ir.instr)
    (aft : Script_typed_ir.stack_ty)
    : Lwt.t (Error_monad.tzresult (judgement bef * Alpha_context.context)) :=
    let=? '_ := log_stack ctxt loc stack_ty aft in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Typecheck_costs.instr instr)) in
    __return ctxt
      (Typed
        {| Script_typed_ir.descr.loc := loc;
          Script_typed_ir.descr.bef := stack_ty;
          Script_typed_ir.descr.aft := aft; Script_typed_ir.descr.instr := instr
          |}) in
  let=? ctxt :=
    Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle) in
  match
    ((script_instr, stack_ty),
      match (script_instr, stack_ty) with
      |
        (Micheline.Prim loc Alpha_context.Script.I_DIP (cons n (cons code []))
          result_annot, __stack_value) =>
        match parse_int32 n with
        | Pervasives.Ok _ => true
        | Pervasives.Error _ => false
        end
      | _ => false
      end) with
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DROP [] annot,
      Script_typed_ir.Item_t _ rest _), _) =>
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    typed ctxt loc Script_typed_ir.Drop rest
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DROP (cons n []) result_annot,
      whole_stack), _) =>
    let=? whole_n := Lwt.__return (parse_int32 n) in
    let fix make_proof_argument {tstk : Set}
      (n : int) (stk : Script_typed_ir.stack_ty) {struct n}
      : Lwt.t (Error_monad.tzresult (dropn_proof_argument tstk)) :=
      match (((|Compare.Int|).(Compare.S.op_eq) n 0), stk) with
      | (true, rest) =>
        outer_return (Dropn_proof_argument (Script_typed_ir.Rest, rest, rest))
      | (false, Script_typed_ir.Item_t v rest annot) =>
        let=? 'Dropn_proof_argument (n', stack_after_drops, aft') :=
          make_proof_argument (Pervasives.op_minus n 1) rest in
        outer_return
          (Dropn_proof_argument
            ((Script_typed_ir.Prefix n'), stack_after_drops,
              (Script_typed_ir.Item_t v aft' annot)))
      | (_, _) =>
        let=? '(whole_stack, _ctxt) :=
          serialize_stack_for_error ctxt whole_stack in
        Error_monad.fail extensible_type_value
      end in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc result_annot in
    let=? 'Dropn_proof_argument (n', stack_after_drops, _aft) :=
      make_proof_argument whole_n whole_stack in
    typed ctxt loc (Script_typed_ir.Dropn whole_n n') stack_after_drops
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DROP ((cons _ (cons _ _)) as l)
      _, _), _) => Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DUP [] annot,
      Script_typed_ir.Item_t v rest stack_annot), _) =>
    let=? annot := parse_var_annot loc (Some stack_annot) annot in
    typed ctxt loc Script_typed_ir.Dup
      (Script_typed_ir.Item_t v (Script_typed_ir.Item_t v rest stack_annot)
        annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DIG (cons n []) result_annot,
      __stack_value), _) =>
    let fix make_proof_argument {tstk : Set}
      (n : int) (stk : Script_typed_ir.stack_ty) {struct n}
      : Lwt.t (Error_monad.tzresult (dig_proof_argument tstk)) :=
      match (((|Compare.Int|).(Compare.S.op_eq) n 0), stk) with
      | (true, Script_typed_ir.Item_t v rest annot) =>
        outer_return
          (Dig_proof_argument (Script_typed_ir.Rest, (v, annot), rest))
      | (false, Script_typed_ir.Item_t v rest annot) =>
        let=? 'Dig_proof_argument (n', (x, xv), aft') :=
          make_proof_argument (Pervasives.op_minus n 1) rest in
        outer_return
          (Dig_proof_argument
            ((Script_typed_ir.Prefix n'), (x, xv),
              (Script_typed_ir.Item_t v aft' annot)))
      | (_, _) =>
        let=? '(whole_stack, _ctxt) :=
          serialize_stack_for_error ctxt __stack_value in
        Error_monad.fail extensible_type_value
      end in
    let=? n := Lwt.__return (parse_int32 n) in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc result_annot in
    let=? 'Dig_proof_argument (n', (x, stack_annot), aft) :=
      make_proof_argument n __stack_value in
    typed ctxt loc (Script_typed_ir.Dig n n')
      (Script_typed_ir.Item_t x aft stack_annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DIG
      (([] | cons _ (cons _ _)) as l) _, _), _) =>
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DUG (cons n []) result_annot,
      Script_typed_ir.Item_t x whole_stack stack_annot), _) =>
    let=? whole_n := Lwt.__return (parse_int32 n) in
    let fix make_proof_argument {tstk x : Set}
      (n : int) (x : Script_typed_ir.ty)
      (stack_annot : option Script_typed_ir.var_annot)
      (stk : Script_typed_ir.stack_ty) {struct n}
      : Lwt.t (Error_monad.tzresult (dug_proof_argument tstk x)) :=
      match (((|Compare.Int|).(Compare.S.op_eq) n 0), stk) with
      | (true, rest) =>
        outer_return
          (Dug_proof_argument
            (Script_typed_ir.Rest, tt,
              (Script_typed_ir.Item_t x rest stack_annot)))
      | (false, Script_typed_ir.Item_t v rest annot) =>
        let=? 'Dug_proof_argument (n', _, aft') :=
          make_proof_argument (Pervasives.op_minus n 1) x stack_annot rest in
        outer_return
          (Dug_proof_argument
            ((Script_typed_ir.Prefix n'), tt,
              (Script_typed_ir.Item_t v aft' annot)))
      | (_, _) =>
        let=? '(whole_stack, _ctxt) :=
          serialize_stack_for_error ctxt whole_stack in
        Error_monad.fail extensible_type_value
      end in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc result_annot in
    let=? 'Dug_proof_argument (n', _, aft) :=
      make_proof_argument whole_n x stack_annot whole_stack in
    typed ctxt loc (Script_typed_ir.Dug whole_n n') aft
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DUG (cons _ []) result_annot,
      Script_typed_ir.Empty_t as __stack_value), _) =>
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc result_annot in
    let=? '(__stack_value, _ctxt) :=
      serialize_stack_for_error ctxt __stack_value in
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DUG
      (([] | cons _ (cons _ _)) as l) _, _), _) =>
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SWAP [] annot,
      Script_typed_ir.Item_t v (Script_typed_ir.Item_t w rest stack_annot)
        cur_top_annot), _) =>
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    typed ctxt loc Script_typed_ir.Swap
      (Script_typed_ir.Item_t w (Script_typed_ir.Item_t v rest cur_top_annot)
        stack_annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_PUSH
      (cons __t_value (cons d [])) annot, __stack_value), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? '(Ex_ty __t_value, ctxt) :=
      Lwt.__return (parse_packable_ty ctxt legacy __t_value) in
    let=? '(v, ctxt) := parse_data type_logger ctxt legacy __t_value d in
    typed ctxt loc (Script_typed_ir.Const v)
      (Script_typed_ir.Item_t __t_value __stack_value annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_UNIT [] annot, __stack_value), _)
    =>
    let=? '(annot, ty_name) := parse_var_type_annot loc annot in
    typed ctxt loc (Script_typed_ir.Const tt)
      (Script_typed_ir.Item_t (Script_typed_ir.Unit_t ty_name) __stack_value
        annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SOME [] annot,
      Script_typed_ir.Item_t __t_value rest _), _) =>
    let=? '(annot, ty_name) := parse_var_type_annot loc annot in
    typed ctxt loc Script_typed_ir.Cons_some
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t __t_value ty_name (has_big_map __t_value))
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_NONE (cons __t_value []) annot,
      __stack_value), _) =>
    let=? '(Ex_ty __t_value, ctxt) :=
      Lwt.__return (parse_any_ty ctxt legacy __t_value) in
    let=? '(annot, ty_name) := parse_var_type_annot loc annot in
    typed ctxt loc (Script_typed_ir.Cons_none __t_value)
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t __t_value ty_name (has_big_map __t_value))
        __stack_value annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_IF_NONE (cons bt (cons bf []))
      annot,
      (Script_typed_ir.Item_t (Script_typed_ir.Option_t __t_value _ _) rest
        option_annot) as bef), _) =>
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] bt in
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] bf in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    let annot :=
      Script_ir_annot.gen_access_annot option_annot None
        Script_ir_annot.default_some_annot in
    let=? '(btr, ctxt) := parse_instr type_logger tc_context ctxt legacy bt rest
      in
    let=? '(bfr, ctxt) :=
      parse_instr type_logger tc_context ctxt legacy bf
        (Script_typed_ir.Item_t __t_value rest annot) in
    let branch (ibt : Script_typed_ir.descr) (ibf : Script_typed_ir.descr)
      : Script_typed_ir.descr :=
      {| Script_typed_ir.descr.loc := loc; Script_typed_ir.descr.bef := bef;
        Script_typed_ir.descr.aft := ibt.(Script_typed_ir.descr.aft);
        Script_typed_ir.descr.instr := Script_typed_ir.If_none ibt ibf |} in
    let=? '(judgement, ctxt) :=
      merge_branches legacy ctxt loc btr bfr {| branch.branch := branch |} in
    __return ctxt judgement
  |
    ((Micheline.Prim loc Alpha_context.Script.I_PAIR [] annot,
      Script_typed_ir.Item_t __a_value
        (Script_typed_ir.Item_t __b_value rest snd_annot) fst_annot), _) =>
    let=? '(annot, ty_name, l_field, r_field) :=
      parse_constr_annot loc
        (Some (Script_ir_annot.var_to_field_annot fst_annot))
        (Some (Script_ir_annot.var_to_field_annot snd_annot)) annot in
    typed ctxt loc Script_typed_ir.Cons_pair
      (Script_typed_ir.Item_t
        (Script_typed_ir.Pair_t (__a_value, l_field, fst_annot)
          (__b_value, r_field, snd_annot) ty_name
          (Pervasives.op_pipepipe (has_big_map __a_value)
            (has_big_map __b_value))) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CAR [] annot,
      Script_typed_ir.Item_t
        (Script_typed_ir.Pair_t (__a_value, expected_field_annot, a_annot) _ _ _)
        rest pair_annot), _) =>
    let=? '(annot, field_annot) :=
      parse_destr_annot loc annot Script_ir_annot.default_car_annot
        expected_field_annot pair_annot a_annot in
    let=? '_ :=
      Lwt.__return
        (Script_ir_annot.check_correct_field field_annot expected_field_annot)
      in
    typed ctxt loc Script_typed_ir.Car
      (Script_typed_ir.Item_t __a_value rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CDR [] annot,
      Script_typed_ir.Item_t
        (Script_typed_ir.Pair_t _ (__b_value, expected_field_annot, b_annot) _ _)
        rest pair_annot), _) =>
    let=? '(annot, field_annot) :=
      parse_destr_annot loc annot Script_ir_annot.default_cdr_annot
        expected_field_annot pair_annot b_annot in
    let=? '_ :=
      Lwt.__return
        (Script_ir_annot.check_correct_field field_annot expected_field_annot)
      in
    typed ctxt loc Script_typed_ir.Cdr
      (Script_typed_ir.Item_t __b_value rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_LEFT (cons tr []) annot,
      Script_typed_ir.Item_t tl rest stack_annot), _) =>
    let=? '(Ex_ty tr, ctxt) := Lwt.__return (parse_any_ty ctxt legacy tr) in
    let=? '(annot, tname, l_field, r_field) :=
      parse_constr_annot loc
        (Some (Script_ir_annot.var_to_field_annot stack_annot)) None annot in
    typed ctxt loc Script_typed_ir.Left
      (Script_typed_ir.Item_t
        (Script_typed_ir.Union_t (tl, l_field) (tr, r_field) tname
          (Pervasives.op_pipepipe (has_big_map tl) (has_big_map tr))) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_RIGHT (cons tl []) annot,
      Script_typed_ir.Item_t tr rest stack_annot), _) =>
    let=? '(Ex_ty tl, ctxt) := Lwt.__return (parse_any_ty ctxt legacy tl) in
    let=? '(annot, tname, l_field, r_field) :=
      parse_constr_annot loc None
        (Some (Script_ir_annot.var_to_field_annot stack_annot)) annot in
    typed ctxt loc Script_typed_ir.Right
      (Script_typed_ir.Item_t
        (Script_typed_ir.Union_t (tl, l_field) (tr, r_field) tname
          (Pervasives.op_pipepipe (has_big_map tl) (has_big_map tr))) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_IF_LEFT (cons bt (cons bf []))
      annot,
      (Script_typed_ir.Item_t
        (Script_typed_ir.Union_t (tl, l_field) (tr, r_field) _ _) rest
        union_annot) as bef), _) =>
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] bt in
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] bf in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    let left_annot :=
      Script_ir_annot.gen_access_annot union_annot
        (Some Script_ir_annot.default_left_annot) l_field in
    let right_annot :=
      Script_ir_annot.gen_access_annot union_annot
        (Some Script_ir_annot.default_right_annot) r_field in
    let=? '(btr, ctxt) :=
      parse_instr type_logger tc_context ctxt legacy bt
        (Script_typed_ir.Item_t tl rest left_annot) in
    let=? '(bfr, ctxt) :=
      parse_instr type_logger tc_context ctxt legacy bf
        (Script_typed_ir.Item_t tr rest right_annot) in
    let branch (ibt : Script_typed_ir.descr) (ibf : Script_typed_ir.descr)
      : Script_typed_ir.descr :=
      {| Script_typed_ir.descr.loc := loc; Script_typed_ir.descr.bef := bef;
        Script_typed_ir.descr.aft := ibt.(Script_typed_ir.descr.aft);
        Script_typed_ir.descr.instr := Script_typed_ir.If_left ibt ibf |} in
    let=? '(judgement, ctxt) :=
      merge_branches legacy ctxt loc btr bfr {| branch.branch := branch |} in
    __return ctxt judgement
  |
    ((Micheline.Prim loc Alpha_context.Script.I_NIL (cons __t_value []) annot,
      __stack_value), _) =>
    let=? '(Ex_ty __t_value, ctxt) :=
      Lwt.__return (parse_any_ty ctxt legacy __t_value) in
    let=? '(annot, ty_name) := parse_var_type_annot loc annot in
    typed ctxt loc Script_typed_ir.Nil
      (Script_typed_ir.Item_t
        (Script_typed_ir.List_t __t_value ty_name (has_big_map __t_value))
        __stack_value annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CONS [] annot,
      Script_typed_ir.Item_t tv
        (Script_typed_ir.Item_t
          (Script_typed_ir.List_t __t_value ty_name has_big_map) rest _) _), _)
    =>
    let=? '(Eq, __t_value, ctxt) :=
      check_item_ty ctxt tv __t_value loc Alpha_context.Script.I_CONS 1 2 in
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Cons_list
      (Script_typed_ir.Item_t
        (Script_typed_ir.List_t __t_value ty_name has_big_map) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_IF_CONS (cons bt (cons bf []))
      annot,
      (Script_typed_ir.Item_t
        (Script_typed_ir.List_t __t_value ty_name has_big_map) rest list_annot)
        as bef), _) =>
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] bt in
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] bf in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    let hd_annot :=
      Script_ir_annot.gen_access_annot list_annot None
        Script_ir_annot.default_hd_annot in
    let tl_annot :=
      Script_ir_annot.gen_access_annot list_annot None
        Script_ir_annot.default_tl_annot in
    let=? '(btr, ctxt) :=
      parse_instr type_logger tc_context ctxt legacy bt
        (Script_typed_ir.Item_t __t_value
          (Script_typed_ir.Item_t
            (Script_typed_ir.List_t __t_value ty_name has_big_map) rest tl_annot)
          hd_annot) in
    let=? '(bfr, ctxt) := parse_instr type_logger tc_context ctxt legacy bf rest
      in
    let branch (ibt : Script_typed_ir.descr) (ibf : Script_typed_ir.descr)
      : Script_typed_ir.descr :=
      {| Script_typed_ir.descr.loc := loc; Script_typed_ir.descr.bef := bef;
        Script_typed_ir.descr.aft := ibt.(Script_typed_ir.descr.aft);
        Script_typed_ir.descr.instr := Script_typed_ir.If_cons ibt ibf |} in
    let=? '(judgement, ctxt) :=
      merge_branches legacy ctxt loc btr bfr {| branch.branch := branch |} in
    __return ctxt judgement
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SIZE [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.List_t _ _ _) rest _), _) =>
    let=? '(annot, tname) := parse_var_type_annot loc annot in
    typed ctxt loc Script_typed_ir.List_size
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_MAP (cons body []) annot,
      Script_typed_ir.Item_t (Script_typed_ir.List_t __elt_value _ _)
        starting_rest list_annot), _) =>
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] body in
    let=? '(ret_annot, list_ty_name) := parse_var_type_annot loc annot in
    let elt_annot :=
      Script_ir_annot.gen_access_annot list_annot None
        Script_ir_annot.default_elt_annot in
    let=? '(judgement, ctxt) :=
      parse_instr type_logger tc_context ctxt legacy body
        (Script_typed_ir.Item_t __elt_value starting_rest elt_annot) in
    match judgement with
    |
      Typed
        ({| Script_typed_ir.descr.aft := Script_typed_ir.Item_t ret rest _ |} as
          ibody) =>
      let invalid_map_body (function_parameter : unit)
        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
        let '_ := function_parameter in
        Error_monad.op_gtgtpipequestion
          (serialize_stack_for_error ctxt ibody.(Script_typed_ir.descr.aft))
          (fun function_parameter =>
            let '(aft, _ctxt) := function_parameter in
            extensible_type_value) in
      Error_monad.trace_eval invalid_map_body
        (let=? '(Eq, ctxt) :=
          Lwt.__return (stack_ty_eq ctxt 1 rest starting_rest) in
        let=? '(rest, ctxt) :=
          Lwt.__return (merge_stacks legacy loc ctxt rest starting_rest) in
        typed ctxt loc (Script_typed_ir.List_map ibody)
          (Script_typed_ir.Item_t
            (Script_typed_ir.List_t ret list_ty_name (has_big_map ret)) rest
            ret_annot))
    | Typed {| Script_typed_ir.descr.aft := aft |} =>
      let=? '(aft, _ctxt) := serialize_stack_for_error ctxt aft in
      Error_monad.fail extensible_type_value
    | Failed _ => Error_monad.fail extensible_type_value
    end
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ITER (cons body []) annot,
      Script_typed_ir.Item_t (Script_typed_ir.List_t __elt_value _ _) rest
        list_annot), _) =>
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] body in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    let elt_annot :=
      Script_ir_annot.gen_access_annot list_annot None
        Script_ir_annot.default_elt_annot in
    let=? '(judgement, ctxt) :=
      parse_instr type_logger tc_context ctxt legacy body
        (Script_typed_ir.Item_t __elt_value rest elt_annot) in
    match judgement with
    | Typed ({| Script_typed_ir.descr.aft := aft |} as ibody) =>
      let invalid_iter_body (function_parameter : unit)
        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
        let '_ := function_parameter in
        let=? '(aft, ctxt) :=
          serialize_stack_for_error ctxt ibody.(Script_typed_ir.descr.aft) in
        Error_monad.op_gtgtpipequestion (serialize_stack_for_error ctxt rest)
          (fun function_parameter =>
            let '(rest, _ctxt) := function_parameter in
            extensible_type_value) in
      Error_monad.trace_eval invalid_iter_body
        (let=? '(Eq, ctxt) := Lwt.__return (stack_ty_eq ctxt 1 aft rest) in
        let=? '(rest, ctxt) :=
          Lwt.__return (merge_stacks legacy loc ctxt aft rest) in
        typed ctxt loc (Script_typed_ir.List_iter ibody) rest)
    | Failed {| judgement.Failed.descr := __descr_value |} =>
      typed ctxt loc (Script_typed_ir.List_iter (__descr_value rest)) rest
    end
  |
    ((Micheline.Prim loc Alpha_context.Script.I_EMPTY_SET (cons __t_value [])
      annot, rest), _) =>
    let=? '(Ex_comparable_ty __t_value, ctxt) :=
      Lwt.__return (parse_comparable_ty ctxt __t_value) in
    let=? '(annot, tname) := parse_var_type_annot loc annot in
    typed ctxt loc (Script_typed_ir.Empty_set __t_value)
      (Script_typed_ir.Item_t (Script_typed_ir.Set_t __t_value tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ITER (cons body []) annot,
      Script_typed_ir.Item_t (Script_typed_ir.Set_t comp_elt _) rest set_annot),
      _) =>
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] body in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    let elt_annot :=
      Script_ir_annot.gen_access_annot set_annot None
        Script_ir_annot.default_elt_annot in
    let __elt_value := ty_of_comparable_ty comp_elt in
    let=? '(judgement, ctxt) :=
      parse_instr type_logger tc_context ctxt legacy body
        (Script_typed_ir.Item_t __elt_value rest elt_annot) in
    match judgement with
    | Typed ({| Script_typed_ir.descr.aft := aft |} as ibody) =>
      let invalid_iter_body (function_parameter : unit)
        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
        let '_ := function_parameter in
        let=? '(aft, ctxt) :=
          serialize_stack_for_error ctxt ibody.(Script_typed_ir.descr.aft) in
        Error_monad.op_gtgtpipequestion (serialize_stack_for_error ctxt rest)
          (fun function_parameter =>
            let '(rest, _ctxt) := function_parameter in
            extensible_type_value) in
      Error_monad.trace_eval invalid_iter_body
        (let=? '(Eq, ctxt) := Lwt.__return (stack_ty_eq ctxt 1 aft rest) in
        let=? '(rest, ctxt) :=
          Lwt.__return (merge_stacks legacy loc ctxt aft rest) in
        typed ctxt loc (Script_typed_ir.Set_iter ibody) rest)
    | Failed {| judgement.Failed.descr := __descr_value |} =>
      typed ctxt loc (Script_typed_ir.Set_iter (__descr_value rest)) rest
    end
  |
    ((Micheline.Prim loc Alpha_context.Script.I_MEM [] annot,
      Script_typed_ir.Item_t v
        (Script_typed_ir.Item_t (Script_typed_ir.Set_t __elt_value _) rest _) _),
      _) =>
    let __elt_value := ty_of_comparable_ty __elt_value in
    let=? '(annot, tname) := parse_var_type_annot loc annot in
    let=? '(Eq, _, ctxt) :=
      check_item_ty ctxt __elt_value v loc Alpha_context.Script.I_MEM 1 2 in
    typed ctxt loc Script_typed_ir.Set_mem
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_UPDATE [] annot,
      Script_typed_ir.Item_t v
        (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _)
          (Script_typed_ir.Item_t (Script_typed_ir.Set_t __elt_value tname) rest
            set_annot) _) _), _) =>
    match comparable_ty_of_ty v with
    | None =>
      let=? '(v, _ctxt) := unparse_ty ctxt v in
      Error_monad.fail extensible_type_value
    | Some v =>
      let=? annot := parse_var_annot loc (Some set_annot) annot in
      let=? '(Eq, __elt_value) :=
        check_item_comparable_ty __elt_value v loc Alpha_context.Script.I_UPDATE
          1 3 in
      typed ctxt loc Script_typed_ir.Set_update
        (Script_typed_ir.Item_t (Script_typed_ir.Set_t __elt_value tname) rest
          annot)
    end
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SIZE [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Set_t _ _) rest _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Set_size
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_EMPTY_MAP (cons tk (cons tv []))
      annot, __stack_value), _) =>
    let=? '(Ex_comparable_ty tk, ctxt) :=
      Lwt.__return (parse_comparable_ty ctxt tk) in
    let=? '(Ex_ty tv, ctxt) := Lwt.__return (parse_any_ty ctxt legacy tv) in
    let=? '(annot, ty_name) := parse_var_type_annot loc annot in
    typed ctxt loc (Script_typed_ir.Empty_map tk tv)
      (Script_typed_ir.Item_t
        (Script_typed_ir.Map_t tk tv ty_name (has_big_map tv)) __stack_value
        annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_MAP (cons body []) annot,
      Script_typed_ir.Item_t (Script_typed_ir.Map_t ck __elt_value _ _)
        starting_rest _map_annot), _) =>
    let k := ty_of_comparable_ty ck in
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] body in
    let=? '(ret_annot, ty_name) := parse_var_type_annot loc annot in
    let k_name :=
      Script_ir_annot.field_to_var_annot Script_ir_annot.default_key_annot in
    let e_name :=
      Script_ir_annot.field_to_var_annot Script_ir_annot.default_elt_annot in
    let=? '(judgement, ctxt) :=
      parse_instr type_logger tc_context ctxt legacy body
        (Script_typed_ir.Item_t
          (Script_typed_ir.Pair_t (k, None, k_name) (__elt_value, None, e_name)
            None (has_big_map __elt_value)) starting_rest None) in
    match judgement with
    |
      Typed
        ({| Script_typed_ir.descr.aft := Script_typed_ir.Item_t ret rest _ |} as
          ibody) =>
      let invalid_map_body (function_parameter : unit)
        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
        let '_ := function_parameter in
        Error_monad.op_gtgtpipequestion
          (serialize_stack_for_error ctxt ibody.(Script_typed_ir.descr.aft))
          (fun function_parameter =>
            let '(aft, _ctxt) := function_parameter in
            extensible_type_value) in
      Error_monad.trace_eval invalid_map_body
        (let=? '(Eq, ctxt) :=
          Lwt.__return (stack_ty_eq ctxt 1 rest starting_rest) in
        let=? '(rest, ctxt) :=
          Lwt.__return (merge_stacks legacy loc ctxt rest starting_rest) in
        typed ctxt loc (Script_typed_ir.Map_map ibody)
          (Script_typed_ir.Item_t
            (Script_typed_ir.Map_t ck ret ty_name (has_big_map ret)) rest
            ret_annot))
    | Typed {| Script_typed_ir.descr.aft := aft |} =>
      let=? '(aft, _ctxt) := serialize_stack_for_error ctxt aft in
      Error_monad.fail extensible_type_value
    | Failed _ => Error_monad.fail extensible_type_value
    end
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ITER (cons body []) annot,
      Script_typed_ir.Item_t (Script_typed_ir.Map_t comp_elt element_ty _ _)
        rest _map_annot), _) =>
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] body in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    let k_name :=
      Script_ir_annot.field_to_var_annot Script_ir_annot.default_key_annot in
    let e_name :=
      Script_ir_annot.field_to_var_annot Script_ir_annot.default_elt_annot in
    let __key_value := ty_of_comparable_ty comp_elt in
    let=? '(judgement, ctxt) :=
      parse_instr type_logger tc_context ctxt legacy body
        (Script_typed_ir.Item_t
          (Script_typed_ir.Pair_t (__key_value, None, k_name)
            (element_ty, None, e_name) None (has_big_map element_ty)) rest None)
      in
    match judgement with
    | Typed ({| Script_typed_ir.descr.aft := aft |} as ibody) =>
      let invalid_iter_body (function_parameter : unit)
        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
        let '_ := function_parameter in
        let=? '(aft, ctxt) :=
          serialize_stack_for_error ctxt ibody.(Script_typed_ir.descr.aft) in
        Error_monad.op_gtgtpipequestion (serialize_stack_for_error ctxt rest)
          (fun function_parameter =>
            let '(rest, _ctxt) := function_parameter in
            extensible_type_value) in
      Error_monad.trace_eval invalid_iter_body
        (let=? '(Eq, ctxt) := Lwt.__return (stack_ty_eq ctxt 1 aft rest) in
        let=? '(rest, ctxt) :=
          Lwt.__return (merge_stacks legacy loc ctxt aft rest) in
        typed ctxt loc (Script_typed_ir.Map_iter ibody) rest)
    | Failed {| judgement.Failed.descr := __descr_value |} =>
      typed ctxt loc (Script_typed_ir.Map_iter (__descr_value rest)) rest
    end
  |
    ((Micheline.Prim loc Alpha_context.Script.I_MEM [] annot,
      Script_typed_ir.Item_t vk
        (Script_typed_ir.Item_t (Script_typed_ir.Map_t ck _ _ _) rest _) _), _)
    =>
    let k := ty_of_comparable_ty ck in
    let=? '(Eq, _, ctxt) :=
      check_item_ty ctxt vk k loc Alpha_context.Script.I_MEM 1 2 in
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Map_mem
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_GET [] annot,
      Script_typed_ir.Item_t vk
        (Script_typed_ir.Item_t
          (Script_typed_ir.Map_t ck __elt_value _ has_big_map) rest _) _), _) =>
    let k := ty_of_comparable_ty ck in
    let=? '(Eq, _, ctxt) :=
      check_item_ty ctxt vk k loc Alpha_context.Script.I_GET 1 2 in
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Map_get
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t __elt_value None has_big_map) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_UPDATE [] annot,
      Script_typed_ir.Item_t vk
        (Script_typed_ir.Item_t (Script_typed_ir.Option_t vv _ _)
          (Script_typed_ir.Item_t
            (Script_typed_ir.Map_t ck v map_name has_big_map) rest map_annot) _)
        _), _) =>
    let k := ty_of_comparable_ty ck in
    let=? '(Eq, _, ctxt) :=
      check_item_ty ctxt vk k loc Alpha_context.Script.I_UPDATE 1 3 in
    let=? '(Eq, v, ctxt) :=
      check_item_ty ctxt vv v loc Alpha_context.Script.I_UPDATE 2 3 in
    let=? annot := parse_var_annot loc (Some map_annot) annot in
    typed ctxt loc Script_typed_ir.Map_update
      (Script_typed_ir.Item_t (Script_typed_ir.Map_t ck v map_name has_big_map)
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SIZE [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Map_t _ _ _ _) rest _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Map_size
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_EMPTY_BIG_MAP
      (cons tk (cons tv [])) annot, __stack_value), _) =>
    let=? '(Ex_comparable_ty tk, ctxt) :=
      Lwt.__return (parse_comparable_ty ctxt tk) in
    let=? '(Ex_ty tv, ctxt) := Lwt.__return (parse_packable_ty ctxt legacy tv)
      in
    let=? '(annot, ty_name) := parse_var_type_annot loc annot in
    typed ctxt loc (Script_typed_ir.Empty_big_map tk tv)
      (Script_typed_ir.Item_t (Script_typed_ir.Big_map_t tk tv ty_name)
        __stack_value annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_MEM [] annot,
      Script_typed_ir.Item_t set_key
        (Script_typed_ir.Item_t (Script_typed_ir.Big_map_t map_key _ _) rest _)
        _), _) =>
    let k := ty_of_comparable_ty map_key in
    let=? '(Eq, _, ctxt) :=
      check_item_ty ctxt set_key k loc Alpha_context.Script.I_MEM 1 2 in
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Big_map_mem
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_GET [] annot,
      Script_typed_ir.Item_t vk
        (Script_typed_ir.Item_t (Script_typed_ir.Big_map_t ck __elt_value _)
          rest _) _), _) =>
    let k := ty_of_comparable_ty ck in
    let=? '(Eq, _, ctxt) :=
      check_item_ty ctxt vk k loc Alpha_context.Script.I_GET 1 2 in
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Big_map_get
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t __elt_value None (has_big_map __elt_value))
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_UPDATE [] annot,
      Script_typed_ir.Item_t set_key
        (Script_typed_ir.Item_t (Script_typed_ir.Option_t set_value _ _)
          (Script_typed_ir.Item_t
            (Script_typed_ir.Big_map_t map_key map_value map_name) rest
            map_annot) _) _), _) =>
    let k := ty_of_comparable_ty map_key in
    let=? '(Eq, _, ctxt) :=
      check_item_ty ctxt set_key k loc Alpha_context.Script.I_UPDATE 1 3 in
    let=? '(Eq, map_value, ctxt) :=
      check_item_ty ctxt set_value map_value loc Alpha_context.Script.I_UPDATE 2
        3 in
    let=? annot := parse_var_annot loc (Some map_annot) annot in
    typed ctxt loc Script_typed_ir.Big_map_update
      (Script_typed_ir.Item_t
        (Script_typed_ir.Big_map_t map_key map_value map_name) rest annot)
  | ((Micheline.Seq loc [], __stack_value), _) =>
    typed ctxt loc Script_typed_ir.Nop __stack_value
  | ((Micheline.Seq loc (cons single []), __stack_value), _) =>
    let=? '(judgement, ctxt) :=
      parse_instr type_logger tc_context ctxt legacy single __stack_value in
    match judgement with
    | Typed ({| Script_typed_ir.descr.aft := aft |} as instr) =>
      let nop :=
        {| Script_typed_ir.descr.loc := loc; Script_typed_ir.descr.bef := aft;
          Script_typed_ir.descr.aft := aft;
          Script_typed_ir.descr.instr := Script_typed_ir.Nop |} in
      typed ctxt loc (Script_typed_ir.Seq instr nop) aft
    | Failed {| judgement.Failed.descr := __descr_value |} =>
      let __descr_value (aft : Script_typed_ir.stack_ty)
        : Script_typed_ir.descr :=
        let nop :=
          {| Script_typed_ir.descr.loc := loc; Script_typed_ir.descr.bef := aft;
            Script_typed_ir.descr.aft := aft;
            Script_typed_ir.descr.instr := Script_typed_ir.Nop |} in
        let __descr_value := __descr_value aft in
        Script_typed_ir.descr.with_instr (Script_typed_ir.Seq __descr_value nop)
          __descr_value in
      __return ctxt (Failed {| judgement.Failed.descr := __descr_value |})
    end
  | ((Micheline.Seq loc (cons hd tl), __stack_value), _) =>
    let=? '(judgement, ctxt) :=
      parse_instr type_logger tc_context ctxt legacy hd __stack_value in
    match judgement with
    | Failed _ => Error_monad.fail extensible_type_value
    | Typed ({| Script_typed_ir.descr.aft := middle |} as ihd) =>
      let=? '(judgement, ctxt) :=
        parse_instr type_logger tc_context ctxt legacy (Micheline.Seq (-1) tl)
          middle in
      match judgement with
      | Failed {| judgement.Failed.descr := __descr_value |} =>
        let __descr_value (ret : Script_typed_ir.stack_ty)
          : Script_typed_ir.descr :=
          {| Script_typed_ir.descr.loc := loc;
            Script_typed_ir.descr.bef := __stack_value;
            Script_typed_ir.descr.aft := ret;
            Script_typed_ir.descr.instr :=
              Script_typed_ir.Seq ihd (__descr_value ret) |} in
        __return ctxt (Failed {| judgement.Failed.descr := __descr_value |})
      | Typed itl =>
        typed ctxt loc (Script_typed_ir.Seq ihd itl)
          itl.(Script_typed_ir.descr.aft)
      end
    end
  |
    ((Micheline.Prim loc Alpha_context.Script.I_IF (cons bt (cons bf [])) annot,
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _) rest _) as bef), _) =>
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] bt in
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] bf in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    let=? '(btr, ctxt) := parse_instr type_logger tc_context ctxt legacy bt rest
      in
    let=? '(bfr, ctxt) := parse_instr type_logger tc_context ctxt legacy bf rest
      in
    let branch (ibt : Script_typed_ir.descr) (ibf : Script_typed_ir.descr)
      : Script_typed_ir.descr :=
      {| Script_typed_ir.descr.loc := loc; Script_typed_ir.descr.bef := bef;
        Script_typed_ir.descr.aft := ibt.(Script_typed_ir.descr.aft);
        Script_typed_ir.descr.instr := Script_typed_ir.If ibt ibf |} in
    let=? '(judgement, ctxt) :=
      merge_branches legacy ctxt loc btr bfr {| branch.branch := branch |} in
    __return ctxt judgement
  |
    ((Micheline.Prim loc Alpha_context.Script.I_LOOP (cons body []) annot,
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _) rest _stack_annot) as
        __stack_value), _) =>
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] body in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    let=? '(judgement, ctxt) :=
      parse_instr type_logger tc_context ctxt legacy body rest in
    match judgement with
    | Typed ibody =>
      let unmatched_branches (function_parameter : unit)
        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
        let '_ := function_parameter in
        let=? '(aft, ctxt) :=
          serialize_stack_for_error ctxt ibody.(Script_typed_ir.descr.aft) in
        Error_monad.op_gtgtpipequestion
          (serialize_stack_for_error ctxt __stack_value)
          (fun function_parameter =>
            let '(__stack_value, _ctxt) := function_parameter in
            extensible_type_value) in
      Error_monad.trace_eval unmatched_branches
        (let=? '(Eq, ctxt) :=
          Lwt.__return
            (stack_ty_eq ctxt 1 ibody.(Script_typed_ir.descr.aft) __stack_value)
          in
        let=? '(_stack, ctxt) :=
          Lwt.__return
            (merge_stacks legacy loc ctxt ibody.(Script_typed_ir.descr.aft)
              __stack_value) in
        typed ctxt loc (Script_typed_ir.Loop ibody) rest)
    | Failed {| judgement.Failed.descr := __descr_value |} =>
      let ibody := __descr_value __stack_value in
      typed ctxt loc (Script_typed_ir.Loop ibody) rest
    end
  |
    ((Micheline.Prim loc Alpha_context.Script.I_LOOP_LEFT (cons body []) annot,
      (Script_typed_ir.Item_t
        (Script_typed_ir.Union_t (tl, l_field) (tr, _) _ _) rest union_annot) as
        __stack_value), _) =>
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] body in
    let=? annot := parse_var_annot loc None annot in
    let l_annot :=
      Script_ir_annot.gen_access_annot union_annot
        (Some Script_ir_annot.default_left_annot) l_field in
    let=? '(judgement, ctxt) :=
      parse_instr type_logger tc_context ctxt legacy body
        (Script_typed_ir.Item_t tl rest l_annot) in
    match judgement with
    | Typed ibody =>
      let unmatched_branches (function_parameter : unit)
        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
        let '_ := function_parameter in
        let=? '(aft, ctxt) :=
          serialize_stack_for_error ctxt ibody.(Script_typed_ir.descr.aft) in
        Error_monad.op_gtgtpipequestion
          (serialize_stack_for_error ctxt __stack_value)
          (fun function_parameter =>
            let '(__stack_value, _ctxt) := function_parameter in
            extensible_type_value) in
      Error_monad.trace_eval unmatched_branches
        (let=? '(Eq, ctxt) :=
          Lwt.__return
            (stack_ty_eq ctxt 1 ibody.(Script_typed_ir.descr.aft) __stack_value)
          in
        let=? '(_stack, ctxt) :=
          Lwt.__return
            (merge_stacks legacy loc ctxt ibody.(Script_typed_ir.descr.aft)
              __stack_value) in
        typed ctxt loc (Script_typed_ir.Loop_left ibody)
          (Script_typed_ir.Item_t tr rest annot))
    | Failed {| judgement.Failed.descr := __descr_value |} =>
      let ibody := __descr_value __stack_value in
      typed ctxt loc (Script_typed_ir.Loop_left ibody)
        (Script_typed_ir.Item_t tr rest annot)
    end
  |
    ((Micheline.Prim loc Alpha_context.Script.I_LAMBDA
      (cons arg (cons ret (cons code []))) annot, __stack_value), _) =>
    let=? '(Ex_ty arg, ctxt) := Lwt.__return (parse_any_ty ctxt legacy arg) in
    let=? '(Ex_ty ret, ctxt) := Lwt.__return (parse_any_ty ctxt legacy ret) in
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] code in
    let=? annot := parse_var_annot loc None annot in
    let=? '(lambda, ctxt) :=
      parse_returning type_logger Lambda ctxt legacy
        (arg, Script_ir_annot.default_arg_annot) ret code in
    typed ctxt loc (Script_typed_ir.Lambda lambda)
      (Script_typed_ir.Item_t (Script_typed_ir.Lambda_t arg ret None)
        __stack_value annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_EXEC [] annot,
      Script_typed_ir.Item_t arg
        (Script_typed_ir.Item_t (Script_typed_ir.Lambda_t param ret _) rest _) _),
      _) =>
    let=? '(Eq, _, ctxt) :=
      check_item_ty ctxt arg param loc Alpha_context.Script.I_EXEC 1 2 in
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Exec (Script_typed_ir.Item_t ret rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_APPLY [] annot,
      Script_typed_ir.Item_t capture
        (Script_typed_ir.Item_t
          (Script_typed_ir.Lambda_t
            (Script_typed_ir.Pair_t (capture_ty, _, _) (arg_ty, _, _) lam_annot
              _) ret _) rest _) _), _) =>
    let=? '_ := Lwt.__return (check_packable false loc capture_ty) in
    let=? '(Eq, capture_ty, ctxt) :=
      check_item_ty ctxt capture capture_ty loc Alpha_context.Script.I_APPLY 1 2
      in
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc (Script_typed_ir.Apply capture_ty)
      (Script_typed_ir.Item_t (Script_typed_ir.Lambda_t arg_ty ret lam_annot)
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DIP (cons code []) annot,
      Script_typed_ir.Item_t v rest stack_annot), _) =>
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] code in
    let=? '(judgement, ctxt) :=
      parse_instr type_logger (add_dip v stack_annot tc_context) ctxt legacy
        code rest in
    match judgement with
    | Typed __descr_value =>
      typed ctxt loc (Script_typed_ir.Dip __descr_value)
        (Script_typed_ir.Item_t v __descr_value.(Script_typed_ir.descr.aft)
          stack_annot)
    | Failed _ => Error_monad.fail extensible_type_value
    end
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DIP (cons n (cons code []))
      result_annot, __stack_value), true) =>
    let fix make_proof_argument {tstk : Set}
      (n : int) (inner_tc_context : tc_context) (stk : Script_typed_ir.stack_ty)
      {struct n} : Lwt.t (Error_monad.tzresult (dipn_proof_argument tstk)) :=
      match (((|Compare.Int|).(Compare.S.op_eq) n 0), stk) with
      | (true, rest) =>
        let=? '(judgement, ctxt) :=
          parse_instr type_logger inner_tc_context ctxt legacy code rest in
        match judgement with
        | Typed __descr_value =>
          outer_return
            (Dipn_proof_argument
              (Script_typed_ir.Rest, (ctxt, __descr_value),
                __descr_value.(Script_typed_ir.descr.aft)))
        | Failed _ => Error_monad.fail extensible_type_value
        end
      | (false, Script_typed_ir.Item_t v rest annot) =>
        let=? 'Dipn_proof_argument (n', __descr_value, aft') :=
          make_proof_argument (Pervasives.op_minus n 1)
            (add_dip v annot tc_context) rest in
        outer_return
          (Dipn_proof_argument
            ((Script_typed_ir.Prefix n'), __descr_value,
              (Script_typed_ir.Item_t v aft' annot)))
      | (_, _) =>
        let=? '(whole_stack, _ctxt) :=
          serialize_stack_for_error ctxt __stack_value in
        Error_monad.fail extensible_type_value
      end in
    let=? n := Lwt.__return (parse_int32 n) in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc result_annot in
    let=? 'Dipn_proof_argument (n', (new_ctxt, __descr_value), aft) :=
      make_proof_argument n tc_context __stack_value in
    typed new_ctxt loc (Script_typed_ir.Dipn n n' __descr_value) aft
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DIP
      (([] | cons _ (cons _ (cons _ _))) as l) _, _), _) =>
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_FAILWITH [] annot,
      Script_typed_ir.Item_t v _rest _), _) =>
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    let __descr_value (aft : Script_typed_ir.stack_ty)
      : Script_typed_ir.descr :=
      {| Script_typed_ir.descr.loc := loc;
        Script_typed_ir.descr.bef := stack_ty; Script_typed_ir.descr.aft := aft;
        Script_typed_ir.descr.instr := Script_typed_ir.Failwith v |} in
    let=? '_ := log_stack ctxt loc stack_ty Script_typed_ir.Empty_t in
    __return ctxt (Failed {| judgement.Failed.descr := __descr_value |})
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname)
        (Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Add_timestamp_to_seconds
      (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t _)
        (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname) rest _) _),
      _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Add_seconds_to_timestamp
      (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname)
        (Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Sub_timestamp_seconds
      (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tn2) rest _) _), _)
    =>
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Diff_timestamps
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CONCAT [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.String_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.String_t tn2) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Concat_string_pair
      (Script_typed_ir.Item_t (Script_typed_ir.String_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CONCAT [] annot,
      Script_typed_ir.Item_t
        (Script_typed_ir.List_t (Script_typed_ir.String_t tname) _ _) rest
        list_annot), _) =>
    let=? annot := parse_var_annot loc (Some list_annot) annot in
    typed ctxt loc Script_typed_ir.Concat_string
      (Script_typed_ir.Item_t (Script_typed_ir.String_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SLICE [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
          (Script_typed_ir.Item_t (Script_typed_ir.String_t tname) rest
            string_annot) _) _), _) =>
    let=? annot :=
      parse_var_annot loc
        (Some
          (Script_ir_annot.gen_access_annot string_annot None
            Script_ir_annot.default_slice_annot)) annot in
    typed ctxt loc Script_typed_ir.Slice_string
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t (Script_typed_ir.String_t tname) None false)
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SIZE [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.String_t _) rest _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.String_size
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CONCAT [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Bytes_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t tn2) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Concat_bytes_pair
      (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CONCAT [] annot,
      Script_typed_ir.Item_t
        (Script_typed_ir.List_t (Script_typed_ir.Bytes_t tname) _ _) rest
        list_annot), _) =>
    let=? annot := parse_var_annot loc (Some list_annot) annot in
    typed ctxt loc Script_typed_ir.Concat_bytes
      (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SLICE [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
          (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t tname) rest
            bytes_annot) _) _), _) =>
    let=? annot :=
      parse_var_annot loc
        (Some
          (Script_ir_annot.gen_access_annot bytes_annot None
            Script_ir_annot.default_slice_annot)) annot in
    typed ctxt loc Script_typed_ir.Slice_bytes
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t (Script_typed_ir.Bytes_t tname) None false)
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SIZE [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Bytes_size
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn2) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Add_tez
      (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn2) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Sub_tez
      (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Mul_teznat
      (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
        (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname) rest _) _), _)
    =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Mul_nattez
      (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_OR [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn2) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Or
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_AND [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn2) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.And
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_XOR [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn2) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Xor
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_NOT [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Not
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ABS [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Abs_int
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ISNAT [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest int_annot), _) =>
    let=? annot := parse_var_annot loc (Some int_annot) annot in
    typed ctxt loc Script_typed_ir.Is_nat
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t (Script_typed_ir.Nat_t None) None false) rest
        annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_INT [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Int_nat
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_NEG [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Neg_int
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_NEG [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Neg_nat
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Int_t tn2) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Add_intint
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t tname)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Add_intnat
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
        (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Add_natint
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Add_natnat
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Int_t tn2) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Sub_int
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t tname)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Sub_int
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
        (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Sub_int
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? _tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Sub_int
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Int_t tn2) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Mul_intint
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t tname)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Mul_intnat
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
        (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Mul_natint
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Mul_natnat
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Ediv_teznat
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t
          (Script_typed_ir.Pair_t ((Script_typed_ir.Mutez_t tname), None, None)
            ((Script_typed_ir.Mutez_t tname), None, None) None false) None false)
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn2) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Ediv_tez
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t
          (Script_typed_ir.Pair_t ((Script_typed_ir.Nat_t None), None, None)
            ((Script_typed_ir.Mutez_t tname), None, None) None false) None false)
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Int_t tn2) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Ediv_intint
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t
          (Script_typed_ir.Pair_t ((Script_typed_ir.Int_t tname), None, None)
            ((Script_typed_ir.Nat_t None), None, None) None false) None false)
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t tname)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Ediv_intnat
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t
          (Script_typed_ir.Pair_t ((Script_typed_ir.Int_t tname), None, None)
            ((Script_typed_ir.Nat_t None), None, None) None false) None false)
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname)
        (Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Ediv_natint
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t
          (Script_typed_ir.Pair_t ((Script_typed_ir.Int_t None), None, None)
            ((Script_typed_ir.Nat_t tname), None, None) None false) None false)
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Ediv_natnat
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t
          (Script_typed_ir.Pair_t ((Script_typed_ir.Nat_t tname), None, None)
            ((Script_typed_ir.Nat_t tname), None, None) None false) None false)
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_LSL [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Lsl_nat
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_LSR [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Lsr_nat
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_OR [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Or_nat
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_AND [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.And_nat
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_AND [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t _)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.And_int_nat
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_XOR [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Xor_nat
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_NOT [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Not_int
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_NOT [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Not_nat
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_COMPARE [] annot,
      Script_typed_ir.Item_t t1 (Script_typed_ir.Item_t t2 rest _) _), _) =>
    let=? annot := parse_var_annot loc None annot in
    let=? '(Eq, __t_value, ctxt) :=
      check_item_ty ctxt t1 t2 loc Alpha_context.Script.I_COMPARE 1 2 in
    match comparable_ty_of_ty __t_value with
    | None =>
      let=? '(__t_value, _ctxt) :=
        Lwt.__return (serialize_ty_for_error ctxt __t_value) in
      Error_monad.fail extensible_type_value
    | Some __key_value =>
      typed ctxt loc (Script_typed_ir.Compare __key_value)
        (Script_typed_ir.Item_t (Script_typed_ir.Int_t None) rest annot)
    end
  |
    ((Micheline.Prim loc Alpha_context.Script.I_EQ [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Eq
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_NEQ [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Neq
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_LT [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Lt
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_GT [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Gt
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_LE [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Le
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_GE [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Ge
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CAST (cons cast_t []) annot,
      Script_typed_ir.Item_t __t_value __stack_value item_annot), _) =>
    let=? annot := parse_var_annot loc (Some item_annot) annot in
    let=? '(Ex_ty cast_t, ctxt) :=
      Lwt.__return (parse_any_ty ctxt legacy cast_t) in
    let=? '(Eq, ctxt) := Lwt.__return (ty_eq ctxt cast_t __t_value) in
    let=? '(_, ctxt) :=
      Lwt.__return (merge_types legacy ctxt loc cast_t __t_value) in
    typed ctxt loc Script_typed_ir.Nop
      (Script_typed_ir.Item_t cast_t __stack_value annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_RENAME [] annot,
      Script_typed_ir.Item_t __t_value __stack_value _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Nop
      (Script_typed_ir.Item_t __t_value __stack_value annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_PACK [] annot,
      Script_typed_ir.Item_t __t_value rest unpacked_annot), _) =>
    let=? '_ := Lwt.__return (check_packable true loc __t_value) in
    let=? annot :=
      parse_var_annot loc
        (Some
          (Script_ir_annot.gen_access_annot unpacked_annot None
            Script_ir_annot.default_pack_annot)) annot in
    typed ctxt loc (Script_typed_ir.Pack __t_value)
      (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_UNPACK (cons ty []) annot,
      Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest packed_annot), _)
    =>
    let=? '(Ex_ty __t_value, ctxt) :=
      Lwt.__return (parse_packable_ty ctxt legacy ty) in
    let=? '(annot, ty_name) := parse_var_type_annot loc annot in
    let annot :=
      Script_ir_annot.default_annot
        (Script_ir_annot.gen_access_annot packed_annot None
          Script_ir_annot.default_unpack_annot) annot in
    typed ctxt loc (Script_typed_ir.Unpack __t_value)
      (Script_typed_ir.Item_t (Script_typed_ir.Option_t __t_value ty_name false)
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ADDRESS [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Contract_t _ _) rest
        contract_annot), _) =>
    let=? annot :=
      parse_var_annot loc
        (Some
          (Script_ir_annot.gen_access_annot contract_annot None
            Script_ir_annot.default_addr_annot)) annot in
    typed ctxt loc Script_typed_ir.Address
      (Script_typed_ir.Item_t (Script_typed_ir.Address_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CONTRACT (cons ty []) annot,
      Script_typed_ir.Item_t (Script_typed_ir.Address_t _) rest addr_annot), _)
    =>
    let=? '(Ex_ty __t_value, ctxt) :=
      Lwt.__return (parse_parameter_ty ctxt legacy ty) in
    let=? '(annot, entrypoint) :=
      parse_entrypoint_annot loc
        (Some
          (Script_ir_annot.gen_access_annot addr_annot None
            Script_ir_annot.default_contract_annot)) annot in
    let=? entrypoint :=
      Lwt.__return
        match entrypoint with
        | None => Pervasives.Ok "default"
        | Some (Script_typed_ir.Field_annot "default") =>
          Error_monad.__error_value extensible_type_value
        | Some (Script_typed_ir.Field_annot entrypoint) =>
          if (|Compare.Int|).(Compare.S.op_gt) (String.length entrypoint) 31
            then
            Error_monad.__error_value extensible_type_value
          else
            Pervasives.Ok entrypoint
        end in
    typed ctxt loc (Script_typed_ir.Contract __t_value entrypoint)
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t (Script_typed_ir.Contract_t __t_value None)
          None false) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_TRANSFER_TOKENS [] annot,
      Script_typed_ir.Item_t __p_value
        (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t _)
          (Script_typed_ir.Item_t (Script_typed_ir.Contract_t cp _) rest _) _) _),
      _) =>
    let=? '(Eq, _, ctxt) :=
      check_item_ty ctxt __p_value cp loc Alpha_context.Script.I_TRANSFER_TOKENS
        1 4 in
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Transfer_tokens
      (Script_typed_ir.Item_t (Script_typed_ir.Operation_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SET_DELEGATE [] annot,
      Script_typed_ir.Item_t
        (Script_typed_ir.Option_t (Script_typed_ir.Key_hash_t _) _ _) rest _), _)
    =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Set_delegate
      (Script_typed_ir.Item_t (Script_typed_ir.Operation_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CREATE_ACCOUNT [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Key_hash_t _)
        (Script_typed_ir.Item_t
          (Script_typed_ir.Option_t (Script_typed_ir.Key_hash_t _) _ _)
          (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _)
            (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t _) rest _) _) _) _),
      _) =>
    if legacy then
      let=? '(op_annot, addr_annot) := parse_two_var_annot loc annot in
      typed ctxt loc Script_typed_ir.Create_account
        (Script_typed_ir.Item_t (Script_typed_ir.Operation_t None)
          (Script_typed_ir.Item_t (Script_typed_ir.Address_t None) rest
            addr_annot) op_annot)
    else
      Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_IMPLICIT_ACCOUNT [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Key_hash_t _) rest _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Implicit_account
      (Script_typed_ir.Item_t
        (Script_typed_ir.Contract_t (Script_typed_ir.Unit_t None) None) rest
        annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CREATE_CONTRACT
      (cons ((Micheline.Seq _ _) as code) []) annot,
      Script_typed_ir.Item_t (Script_typed_ir.Key_hash_t _)
        (Script_typed_ir.Item_t
          (Script_typed_ir.Option_t (Script_typed_ir.Key_hash_t _) _ _)
          (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _)
            (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _)
              (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t _)
                (Script_typed_ir.Item_t ginit rest _) _) _) _) _) _), _) =>
    if legacy then
      let=? '(op_annot, addr_annot) := parse_two_var_annot loc annot in
      let cannonical_code := Pervasives.fst (Micheline.extract_locations code)
        in
      let=? '(arg_type, storage_type, code_field, root_name) :=
        Lwt.__return (parse_toplevel legacy cannonical_code) in
      let=? '(Ex_ty arg_type, ctxt) :=
        Error_monad.trace extensible_type_value
          (Lwt.__return (parse_parameter_ty ctxt legacy arg_type)) in
      let=? '_ :=
        if legacy then
          Error_monad.__return tt
        else
          Lwt.__return (well_formed_entrypoints arg_type root_name) in
      let=? '(Ex_ty storage_type, ctxt) :=
        Error_monad.trace extensible_type_value
          (Lwt.__return (parse_storage_ty ctxt legacy storage_type)) in
      let arg_annot :=
        Script_ir_annot.default_annot Script_ir_annot.default_param_annot
          (Script_ir_annot.type_to_var_annot (name_of_ty arg_type)) in
      let storage_annot :=
        Script_ir_annot.default_annot Script_ir_annot.default_storage_annot
          (Script_ir_annot.type_to_var_annot (name_of_ty storage_type)) in
      let arg_type_full :=
        Script_typed_ir.Pair_t (arg_type, None, arg_annot)
          (storage_type, None, storage_annot) None
          (Pervasives.op_pipepipe (has_big_map arg_type)
            (has_big_map storage_type)) in
      let ret_type_full :=
        Script_typed_ir.Pair_t
          ((Script_typed_ir.List_t (Script_typed_ir.Operation_t None) None false),
            None, None) (storage_type, None, None) None
          (has_big_map storage_type) in
      let=?
        '({|
          Script_typed_ir.lambda.lam :=
            ({|
              Script_typed_ir.descr.bef :=
                Script_typed_ir.Item_t arg
                  Script_typed_ir.Empty_t _;
                Script_typed_ir.descr.aft :=
                  Script_typed_ir.Item_t ret
                    Script_typed_ir.Empty_t
                    _
                |}, _)
            |} as lambda, ctxt) :=
        Error_monad.trace extensible_type_value
          (parse_returning type_logger
            (Toplevel
              {| tc_context.Toplevel.storage_type := storage_type;
                tc_context.Toplevel.param_type := arg_type;
                tc_context.Toplevel.root_name := root_name;
                tc_context.Toplevel.legacy_create_contract_literal := true |})
            ctxt legacy (arg_type_full, None) ret_type_full code_field) in
      let=? '(Eq, ctxt) := Lwt.__return (ty_eq ctxt arg arg_type_full) in
      let=? '(_, ctxt) :=
        Lwt.__return (merge_types legacy ctxt loc arg arg_type_full) in
      let=? '(Eq, ctxt) := Lwt.__return (ty_eq ctxt ret ret_type_full) in
      let=? '(_, ctxt) :=
        Lwt.__return (merge_types legacy ctxt loc ret ret_type_full) in
      let=? '(Eq, ctxt) := Lwt.__return (ty_eq ctxt storage_type ginit) in
      let=? '(_, ctxt) :=
        Lwt.__return (merge_types legacy ctxt loc storage_type ginit) in
      typed ctxt loc
        (Script_typed_ir.Create_contract storage_type arg_type lambda root_name)
        (Script_typed_ir.Item_t (Script_typed_ir.Operation_t None)
          (Script_typed_ir.Item_t (Script_typed_ir.Address_t None) rest
            addr_annot) op_annot)
    else
      Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CREATE_CONTRACT
      (cons ((Micheline.Seq _ _) as code) []) annot,
      Script_typed_ir.Item_t
        (Script_typed_ir.Option_t (Script_typed_ir.Key_hash_t _) _ _)
        (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t _)
          (Script_typed_ir.Item_t ginit rest _) _) _), _) =>
    let=? '(op_annot, addr_annot) := parse_two_var_annot loc annot in
    let cannonical_code := Pervasives.fst (Micheline.extract_locations code) in
    let=? '(arg_type, storage_type, code_field, root_name) :=
      Lwt.__return (parse_toplevel legacy cannonical_code) in
    let=? '(Ex_ty arg_type, ctxt) :=
      Error_monad.trace extensible_type_value
        (Lwt.__return (parse_parameter_ty ctxt legacy arg_type)) in
    let=? '_ :=
      if legacy then
        Error_monad.__return tt
      else
        Lwt.__return (well_formed_entrypoints arg_type root_name) in
    let=? '(Ex_ty storage_type, ctxt) :=
      Error_monad.trace extensible_type_value
        (Lwt.__return (parse_storage_ty ctxt legacy storage_type)) in
    let arg_annot :=
      Script_ir_annot.default_annot Script_ir_annot.default_param_annot
        (Script_ir_annot.type_to_var_annot (name_of_ty arg_type)) in
    let storage_annot :=
      Script_ir_annot.default_annot Script_ir_annot.default_storage_annot
        (Script_ir_annot.type_to_var_annot (name_of_ty storage_type)) in
    let arg_type_full :=
      Script_typed_ir.Pair_t (arg_type, None, arg_annot)
        (storage_type, None, storage_annot) None
        (Pervasives.op_pipepipe (has_big_map arg_type)
          (has_big_map storage_type)) in
    let ret_type_full :=
      Script_typed_ir.Pair_t
        ((Script_typed_ir.List_t (Script_typed_ir.Operation_t None) None false),
          None, None) (storage_type, None, None) None (has_big_map storage_type)
      in
    let=?
      '({|
        Script_typed_ir.lambda.lam :=
          ({|
            Script_typed_ir.descr.bef :=
              Script_typed_ir.Item_t arg Script_typed_ir.Empty_t _;
              Script_typed_ir.descr.aft :=
                Script_typed_ir.Item_t ret
                  Script_typed_ir.Empty_t
                  _
              |}, _)
          |} as lambda, ctxt) :=
      Error_monad.trace extensible_type_value
        (parse_returning type_logger
          (Toplevel
            {| tc_context.Toplevel.storage_type := storage_type;
              tc_context.Toplevel.param_type := arg_type;
              tc_context.Toplevel.root_name := root_name;
              tc_context.Toplevel.legacy_create_contract_literal := false |})
          ctxt legacy (arg_type_full, None) ret_type_full code_field) in
    let=? '(Eq, ctxt) := Lwt.__return (ty_eq ctxt arg arg_type_full) in
    let=? '(_, ctxt) :=
      Lwt.__return (merge_types legacy ctxt loc arg arg_type_full) in
    let=? '(Eq, ctxt) := Lwt.__return (ty_eq ctxt ret ret_type_full) in
    let=? '(_, ctxt) :=
      Lwt.__return (merge_types legacy ctxt loc ret ret_type_full) in
    let=? '(Eq, ctxt) := Lwt.__return (ty_eq ctxt storage_type ginit) in
    let=? '(_, ctxt) :=
      Lwt.__return (merge_types legacy ctxt loc storage_type ginit) in
    typed ctxt loc
      (Script_typed_ir.Create_contract_2 storage_type arg_type lambda root_name)
      (Script_typed_ir.Item_t (Script_typed_ir.Operation_t None)
        (Script_typed_ir.Item_t (Script_typed_ir.Address_t None) rest addr_annot)
        op_annot)
  | ((Micheline.Prim loc Alpha_context.Script.I_NOW [] annot, __stack_value), _)
    =>
    let=? annot :=
      parse_var_annot loc (Some Script_ir_annot.default_now_annot) annot in
    typed ctxt loc Script_typed_ir.Now
      (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t None) __stack_value
        annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_AMOUNT [] annot, __stack_value),
      _) =>
    let=? annot :=
      parse_var_annot loc (Some Script_ir_annot.default_amount_annot) annot in
    typed ctxt loc Script_typed_ir.Amount
      (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t None) __stack_value annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CHAIN_ID [] annot, __stack_value),
      _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.ChainId
      (Script_typed_ir.Item_t (Script_typed_ir.Chain_id_t None) __stack_value
        annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_BALANCE [] annot, __stack_value),
      _) =>
    let=? annot :=
      parse_var_annot loc (Some Script_ir_annot.default_balance_annot) annot in
    typed ctxt loc Script_typed_ir.Balance
      (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t None) __stack_value annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_HASH_KEY [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Key_t _) rest _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Hash_key
      (Script_typed_ir.Item_t (Script_typed_ir.Key_hash_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CHECK_SIGNATURE [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Key_t _)
        (Script_typed_ir.Item_t (Script_typed_ir.Signature_t _)
          (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest _) _) _), _)
    =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Check_signature
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_BLAKE2B [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Blake2b
      (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SHA256 [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Sha256
      (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SHA512 [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest _), _) =>
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Sha512
      (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_STEPS_TO_QUOTA [] annot,
      __stack_value), _) =>
    if legacy then
      let=? annot :=
        parse_var_annot loc (Some Script_ir_annot.default_steps_annot) annot in
      typed ctxt loc Script_typed_ir.Steps_to_quota
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) __stack_value annot)
    else
      Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SOURCE [] annot, __stack_value),
      _) =>
    let=? annot :=
      parse_var_annot loc (Some Script_ir_annot.default_source_annot) annot in
    typed ctxt loc Script_typed_ir.Source
      (Script_typed_ir.Item_t (Script_typed_ir.Address_t None) __stack_value
        annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SENDER [] annot, __stack_value),
      _) =>
    let=? annot :=
      parse_var_annot loc (Some Script_ir_annot.default_sender_annot) annot in
    typed ctxt loc Script_typed_ir.Sender
      (Script_typed_ir.Item_t (Script_typed_ir.Address_t None) __stack_value
        annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SELF [] annot, __stack_value), _)
    =>
    let=? '(annot, entrypoint) :=
      parse_entrypoint_annot loc (Some Script_ir_annot.default_self_annot) annot
      in
    let entrypoint :=
      Option.unopt_map
        (fun function_parameter =>
          let 'Script_typed_ir.Field_annot annot := function_parameter in
          annot) "default" entrypoint in
    let fix get_toplevel_type (function_parameter : tc_context)
      {struct function_parameter}
      : Lwt.t (Error_monad.tzresult (judgement bef * Alpha_context.context)) :=
      match function_parameter with
      | Lambda => Error_monad.fail extensible_type_value
      | Dip _ prev => get_toplevel_type prev
      |
        Toplevel {|
          tc_context.Toplevel.param_type := param_type;
            tc_context.Toplevel.root_name := root_name;
            tc_context.Toplevel.legacy_create_contract_literal := false
            |} =>
        let=? '(_, Ex_ty param_type) :=
          Lwt.__return (find_entrypoint param_type root_name entrypoint) in
        typed ctxt loc (Script_typed_ir.Self param_type entrypoint)
          (Script_typed_ir.Item_t (Script_typed_ir.Contract_t param_type None)
            __stack_value annot)
      |
        Toplevel {|
          tc_context.Toplevel.param_type := param_type;
            tc_context.Toplevel.root_name := _;
            tc_context.Toplevel.legacy_create_contract_literal := true
            |} =>
        typed ctxt loc (Script_typed_ir.Self param_type "default")
          (Script_typed_ir.Item_t (Script_typed_ir.Contract_t param_type None)
            __stack_value annot)
      end in
    get_toplevel_type tc_context
  |
    ((Micheline.Prim loc
      ((Alpha_context.Script.I_DUP | Alpha_context.Script.I_SWAP |
      Alpha_context.Script.I_SOME | Alpha_context.Script.I_UNIT |
      Alpha_context.Script.I_PAIR | Alpha_context.Script.I_CAR |
      Alpha_context.Script.I_CDR | Alpha_context.Script.I_CONS |
      Alpha_context.Script.I_CONCAT | Alpha_context.Script.I_SLICE |
      Alpha_context.Script.I_MEM | Alpha_context.Script.I_UPDATE |
      Alpha_context.Script.I_MAP | Alpha_context.Script.I_GET |
      Alpha_context.Script.I_EXEC | Alpha_context.Script.I_FAILWITH |
      Alpha_context.Script.I_SIZE | Alpha_context.Script.I_ADD |
      Alpha_context.Script.I_SUB | Alpha_context.Script.I_MUL |
      Alpha_context.Script.I_EDIV | Alpha_context.Script.I_OR |
      Alpha_context.Script.I_AND | Alpha_context.Script.I_XOR |
      Alpha_context.Script.I_NOT | Alpha_context.Script.I_ABS |
      Alpha_context.Script.I_NEG | Alpha_context.Script.I_LSL |
      Alpha_context.Script.I_LSR | Alpha_context.Script.I_COMPARE |
      Alpha_context.Script.I_EQ | Alpha_context.Script.I_NEQ |
      Alpha_context.Script.I_LT | Alpha_context.Script.I_GT |
      Alpha_context.Script.I_LE | Alpha_context.Script.I_GE |
      Alpha_context.Script.I_TRANSFER_TOKENS |
      Alpha_context.Script.I_CREATE_ACCOUNT |
      Alpha_context.Script.I_SET_DELEGATE | Alpha_context.Script.I_NOW |
      Alpha_context.Script.I_IMPLICIT_ACCOUNT | Alpha_context.Script.I_AMOUNT |
      Alpha_context.Script.I_BALANCE | Alpha_context.Script.I_CHECK_SIGNATURE |
      Alpha_context.Script.I_HASH_KEY | Alpha_context.Script.I_SOURCE |
      Alpha_context.Script.I_SENDER | Alpha_context.Script.I_BLAKE2B |
      Alpha_context.Script.I_SHA256 | Alpha_context.Script.I_SHA512 |
      Alpha_context.Script.I_STEPS_TO_QUOTA | Alpha_context.Script.I_ADDRESS) as
        name) ((cons _ _) as l) _, _), _) =>
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc
      ((Alpha_context.Script.I_NONE | Alpha_context.Script.I_LEFT |
      Alpha_context.Script.I_RIGHT | Alpha_context.Script.I_NIL |
      Alpha_context.Script.I_MAP | Alpha_context.Script.I_ITER |
      Alpha_context.Script.I_EMPTY_SET | Alpha_context.Script.I_DIP |
      Alpha_context.Script.I_LOOP | Alpha_context.Script.I_LOOP_LEFT |
      Alpha_context.Script.I_CONTRACT) as name) (([] | cons _ (cons _ _)) as l)
      _, _), _) => Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc
      ((Alpha_context.Script.I_PUSH | Alpha_context.Script.I_IF_NONE |
      Alpha_context.Script.I_IF_LEFT | Alpha_context.Script.I_IF_CONS |
      Alpha_context.Script.I_EMPTY_MAP | Alpha_context.Script.I_IF) as name)
      (([] | cons _ [] | cons _ (cons _ (cons _ _))) as l) _, _), _) =>
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_LAMBDA
      (([] | cons _ [] | cons _ (cons _ (cons _ (cons _ _)))) as l) _, _), _) =>
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc
      ((Alpha_context.Script.I_ADD | Alpha_context.Script.I_SUB |
      Alpha_context.Script.I_MUL | Alpha_context.Script.I_EDIV |
      Alpha_context.Script.I_AND | Alpha_context.Script.I_OR |
      Alpha_context.Script.I_XOR | Alpha_context.Script.I_LSL |
      Alpha_context.Script.I_LSR) as name) [] _,
      Script_typed_ir.Item_t ta (Script_typed_ir.Item_t tb _ _) _), _) =>
    let=? '(ta, ctxt) := Lwt.__return (serialize_ty_for_error ctxt ta) in
    let=? '(tb, _ctxt) := Lwt.__return (serialize_ty_for_error ctxt tb) in
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc
      ((Alpha_context.Script.I_NEG | Alpha_context.Script.I_ABS |
      Alpha_context.Script.I_NOT | Alpha_context.Script.I_CONCAT |
      Alpha_context.Script.I_SIZE | Alpha_context.Script.I_EQ |
      Alpha_context.Script.I_NEQ | Alpha_context.Script.I_LT |
      Alpha_context.Script.I_GT | Alpha_context.Script.I_LE |
      Alpha_context.Script.I_GE) as name) [] _,
      Script_typed_ir.Item_t __t_value _ _), _) =>
    let=? '(__t_value, _ctxt) :=
      Lwt.__return (serialize_ty_for_error ctxt __t_value) in
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc
      ((Alpha_context.Script.I_UPDATE | Alpha_context.Script.I_SLICE) as name)
      [] _, __stack_value), _) =>
    let=? '(__stack_value, _ctxt) :=
      serialize_stack_for_error ctxt __stack_value in
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CREATE_CONTRACT _ _,
      __stack_value), _) =>
    let=? '(__stack_value, _ctxt) :=
      serialize_stack_for_error ctxt __stack_value in
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CREATE_ACCOUNT [] _,
      __stack_value), _) =>
    let=? '(__stack_value, _ctxt) :=
      serialize_stack_for_error ctxt __stack_value in
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_TRANSFER_TOKENS [] _,
      __stack_value), _) =>
    let=? '(__stack_value, _ctxt) :=
      serialize_stack_for_error ctxt __stack_value in
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc
      ((Alpha_context.Script.I_DROP | Alpha_context.Script.I_DUP |
      Alpha_context.Script.I_CAR | Alpha_context.Script.I_CDR |
      Alpha_context.Script.I_SOME | Alpha_context.Script.I_BLAKE2B |
      Alpha_context.Script.I_SHA256 | Alpha_context.Script.I_SHA512 |
      Alpha_context.Script.I_DIP | Alpha_context.Script.I_IF_NONE |
      Alpha_context.Script.I_LEFT | Alpha_context.Script.I_RIGHT |
      Alpha_context.Script.I_IF_LEFT | Alpha_context.Script.I_IF |
      Alpha_context.Script.I_LOOP | Alpha_context.Script.I_IF_CONS |
      Alpha_context.Script.I_IMPLICIT_ACCOUNT | Alpha_context.Script.I_NEG |
      Alpha_context.Script.I_ABS | Alpha_context.Script.I_INT |
      Alpha_context.Script.I_NOT | Alpha_context.Script.I_HASH_KEY |
      Alpha_context.Script.I_EQ | Alpha_context.Script.I_NEQ |
      Alpha_context.Script.I_LT | Alpha_context.Script.I_GT |
      Alpha_context.Script.I_LE | Alpha_context.Script.I_GE) as name) _ _,
      __stack_value), _) =>
    let=? '(__stack_value, _ctxt) :=
      serialize_stack_for_error ctxt __stack_value in
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc
      ((Alpha_context.Script.I_SWAP | Alpha_context.Script.I_PAIR |
      Alpha_context.Script.I_CONS | Alpha_context.Script.I_GET |
      Alpha_context.Script.I_MEM | Alpha_context.Script.I_EXEC |
      Alpha_context.Script.I_CHECK_SIGNATURE | Alpha_context.Script.I_ADD |
      Alpha_context.Script.I_SUB | Alpha_context.Script.I_MUL |
      Alpha_context.Script.I_EDIV | Alpha_context.Script.I_AND |
      Alpha_context.Script.I_OR | Alpha_context.Script.I_XOR |
      Alpha_context.Script.I_LSL | Alpha_context.Script.I_LSR) as name) _ _,
      __stack_value), _) =>
    let=? '(__stack_value, _ctxt) :=
      serialize_stack_for_error ctxt __stack_value in
    Error_monad.fail extensible_type_value
  | ((expr, _), _) =>
    Error_monad.fail
      (unexpected expr [ Script_tc_errors.Seq_kind ]
        Script_tc_errors.Instr_namespace
        [
          Alpha_context.Script.I_DROP;
          Alpha_context.Script.I_DUP;
          Alpha_context.Script.I_DIG;
          Alpha_context.Script.I_DUG;
          Alpha_context.Script.I_SWAP;
          Alpha_context.Script.I_SOME;
          Alpha_context.Script.I_UNIT;
          Alpha_context.Script.I_PAIR;
          Alpha_context.Script.I_CAR;
          Alpha_context.Script.I_CDR;
          Alpha_context.Script.I_CONS;
          Alpha_context.Script.I_MEM;
          Alpha_context.Script.I_UPDATE;
          Alpha_context.Script.I_MAP;
          Alpha_context.Script.I_ITER;
          Alpha_context.Script.I_GET;
          Alpha_context.Script.I_EXEC;
          Alpha_context.Script.I_FAILWITH;
          Alpha_context.Script.I_SIZE;
          Alpha_context.Script.I_CONCAT;
          Alpha_context.Script.I_ADD;
          Alpha_context.Script.I_SUB;
          Alpha_context.Script.I_MUL;
          Alpha_context.Script.I_EDIV;
          Alpha_context.Script.I_OR;
          Alpha_context.Script.I_AND;
          Alpha_context.Script.I_XOR;
          Alpha_context.Script.I_NOT;
          Alpha_context.Script.I_ABS;
          Alpha_context.Script.I_INT;
          Alpha_context.Script.I_NEG;
          Alpha_context.Script.I_LSL;
          Alpha_context.Script.I_LSR;
          Alpha_context.Script.I_COMPARE;
          Alpha_context.Script.I_EQ;
          Alpha_context.Script.I_NEQ;
          Alpha_context.Script.I_LT;
          Alpha_context.Script.I_GT;
          Alpha_context.Script.I_LE;
          Alpha_context.Script.I_GE;
          Alpha_context.Script.I_TRANSFER_TOKENS;
          Alpha_context.Script.I_CREATE_ACCOUNT;
          Alpha_context.Script.I_CREATE_CONTRACT;
          Alpha_context.Script.I_NOW;
          Alpha_context.Script.I_AMOUNT;
          Alpha_context.Script.I_BALANCE;
          Alpha_context.Script.I_IMPLICIT_ACCOUNT;
          Alpha_context.Script.I_CHECK_SIGNATURE;
          Alpha_context.Script.I_BLAKE2B;
          Alpha_context.Script.I_SHA256;
          Alpha_context.Script.I_SHA512;
          Alpha_context.Script.I_HASH_KEY;
          Alpha_context.Script.I_STEPS_TO_QUOTA;
          Alpha_context.Script.I_PUSH;
          Alpha_context.Script.I_NONE;
          Alpha_context.Script.I_LEFT;
          Alpha_context.Script.I_RIGHT;
          Alpha_context.Script.I_NIL;
          Alpha_context.Script.I_EMPTY_SET;
          Alpha_context.Script.I_DIP;
          Alpha_context.Script.I_LOOP;
          Alpha_context.Script.I_IF_NONE;
          Alpha_context.Script.I_IF_LEFT;
          Alpha_context.Script.I_IF_CONS;
          Alpha_context.Script.I_EMPTY_MAP;
          Alpha_context.Script.I_IF;
          Alpha_context.Script.I_SOURCE;
          Alpha_context.Script.I_SENDER;
          Alpha_context.Script.I_SELF;
          Alpha_context.Script.I_LAMBDA
        ])
  end

with parse_contract
  (legacy : bool) (ctxt : Alpha_context.context)
  (loc : Alpha_context.Script.location) (arg : Script_typed_ir.ty)
  (contract : Alpha_context.Contract.t) (entrypoint : string) {struct legacy}
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * Script_typed_ir.typed_contract)) :=
  let=? ctxt :=
    Lwt.__return
      (Alpha_context.Gas.consume ctxt Typecheck_costs.contract_exists) in
  let=? function_parameter := Alpha_context.Contract.__exists ctxt contract in
  match function_parameter with
  | false => Error_monad.fail extensible_type_value
  | true =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.get_script)
      in
    let=? '(ctxt, code) :=
      (Error_monad.trace extensible_type_value)
        (Alpha_context.Contract.get_script_code ctxt contract) in
    match code with
    | None =>
      Lwt.__return
        (let? '(Eq, ctxt) := ty_eq ctxt arg (Script_typed_ir.Unit_t None) in
        match entrypoint with
        | "default" =>
          let contract := (arg, (contract, entrypoint)) in
          Error_monad.ok (ctxt, contract)
        | entrypoint => Error_monad.__error_value extensible_type_value
        end)
    | Some code =>
      let=? '(code, ctxt) :=
        Alpha_context.Script.force_decode_in_context ctxt code in
      Lwt.__return
        (let? '(arg_type, _, _, root_name) := parse_toplevel true code in
        let? '(Ex_ty targ, ctxt) := parse_parameter_ty ctxt true arg_type in
        let __return
          (ctxt : Alpha_context.context) (targ : Script_typed_ir.ty)
          (entrypoint : string)
          : Error_monad.tzresult
            (Alpha_context.context * Script_typed_ir.typed_contract) :=
          let? '(arg, ctxt) := merge_types legacy ctxt loc targ arg in
          let contract := (arg, (contract, entrypoint)) in
          Error_monad.ok (ctxt, contract) in
        let? '(ctxt, entrypoint, targ) :=
          find_entrypoint_for_type targ arg root_name entrypoint ctxt in
        let? '(targ, ctxt) := merge_types legacy ctxt loc targ arg in
        __return ctxt targ entrypoint)
    end
  end

with parse_contract_for_script
  (legacy : bool) (ctxt : Alpha_context.context)
  (loc : Alpha_context.Script.location) (arg : Script_typed_ir.ty)
  (contract : Alpha_context.Contract.t) (entrypoint : string) {struct legacy}
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * option Script_typed_ir.typed_contract)) :=
  let=? ctxt :=
    Lwt.__return
      (Alpha_context.Gas.consume ctxt Typecheck_costs.contract_exists) in
  let=? function_parameter := Alpha_context.Contract.__exists ctxt contract in
  match function_parameter with
  | false => Error_monad.__return (ctxt, None)
  | true =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.get_script)
      in
    let=? '(ctxt, code) :=
      (Error_monad.trace extensible_type_value)
        (Alpha_context.Contract.get_script_code ctxt contract) in
    match code with
    | None =>
      match entrypoint with
      | "default" =>
        Lwt.__return
          match ty_eq ctxt arg (Script_typed_ir.Unit_t None) with
          | Pervasives.Ok (Eq, ctxt) =>
            let contract := (arg, (contract, entrypoint)) in
            Error_monad.ok (ctxt, (Some contract))
          | Pervasives.Error _ =>
            let? ctxt := Alpha_context.Gas.consume ctxt Typecheck_costs.cycle in
            Error_monad.ok (ctxt, None)
          end
      | _ => Error_monad.__return (ctxt, None)
      end
    | Some code =>
      let=? '(code, ctxt) :=
        Alpha_context.Script.force_decode_in_context ctxt code in
      Lwt.__return
        match parse_toplevel true code with
        | Pervasives.Error _ => Error_monad.__error_value extensible_type_value
        | Pervasives.Ok (arg_type, _, _, root_name) =>
          match parse_parameter_ty ctxt true arg_type with
          | Pervasives.Error _ =>
            Error_monad.__error_value extensible_type_value
          | Pervasives.Ok (Ex_ty targ, ctxt) =>
            match
              let? '(ctxt, entrypoint, targ) :=
                find_entrypoint_for_type targ arg root_name entrypoint ctxt in
              let? '(targ, ctxt) := merge_types legacy ctxt loc targ arg in
              let? '(arg, ctxt) := merge_types legacy ctxt loc targ arg in
              let contract := (arg, (contract, entrypoint)) in
              Error_monad.ok (ctxt, (Some contract)) with
            | Pervasives.Ok res => Error_monad.ok res
            | Pervasives.Error _ =>
              let? '(Eq, ctxt) := ty_eq ctxt targ targ in
              let? '(_, ctxt) := merge_types legacy ctxt loc targ targ in
              Error_monad.ok (ctxt, None)
            end
          end
        end
    end
  end

with parse_toplevel (legacy : bool) (toplevel : Alpha_context.Script.expr)
  {struct legacy}
  : Error_monad.tzresult
    (Alpha_context.Script.node * Alpha_context.Script.node *
      Alpha_context.Script.node * option string) :=
  (Error_monad.record_trace extensible_type_value)
    match Micheline.root toplevel with
    | Micheline.Int loc _ => Error_monad.__error_value extensible_type_value
    | Micheline.String loc _ => Error_monad.__error_value extensible_type_value
    | Micheline.Bytes loc _ => Error_monad.__error_value extensible_type_value
    | Micheline.Prim loc _ _ _ =>
      Error_monad.__error_value extensible_type_value
    | Micheline.Seq _ fields =>
      let fix find_fields
        (__p_value :
          option
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim * Alpha_context.Script.location *
              Micheline.annot))
        (s :
          option
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim * Alpha_context.Script.location *
              Micheline.annot))
        (c :
          option
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim * Alpha_context.Script.location *
              Micheline.annot))
        (fields :
          list
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim)) {struct __p_value}
        : Error_monad.tzresult
          (option
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim * Alpha_context.Script.location *
              Micheline.annot) *
            option
              (Micheline.node Alpha_context.Script.location
                Alpha_context.Script.prim * Alpha_context.Script.location *
                Micheline.annot) *
            option
              (Micheline.node Alpha_context.Script.location
                Alpha_context.Script.prim * Alpha_context.Script.location *
                Micheline.annot)) :=
        match fields with
        | [] => Error_monad.ok (__p_value, s, c)
        | cons (Micheline.Int loc _) _ =>
          Error_monad.__error_value extensible_type_value
        | cons (Micheline.String loc _) _ =>
          Error_monad.__error_value extensible_type_value
        | cons (Micheline.Bytes loc _) _ =>
          Error_monad.__error_value extensible_type_value
        | cons (Micheline.Seq loc _) _ =>
          Error_monad.__error_value extensible_type_value
        |
          cons
            (Micheline.Prim loc Alpha_context.Script.K_parameter (cons arg [])
              annot) rest =>
          match __p_value with
          | None => find_fields (Some (arg, loc, annot)) s c rest
          | Some _ => Error_monad.__error_value extensible_type_value
          end
        |
          cons
            (Micheline.Prim loc Alpha_context.Script.K_storage (cons arg [])
              annot) rest =>
          match s with
          | None => find_fields __p_value (Some (arg, loc, annot)) c rest
          | Some _ => Error_monad.__error_value extensible_type_value
          end
        |
          cons
            (Micheline.Prim loc Alpha_context.Script.K_code (cons arg []) annot)
            rest =>
          match c with
          | None => find_fields __p_value s (Some (arg, loc, annot)) rest
          | Some _ => Error_monad.__error_value extensible_type_value
          end
        |
          cons
            (Micheline.Prim loc
              ((Alpha_context.Script.K_parameter |
              Alpha_context.Script.K_storage | Alpha_context.Script.K_code) as
                name) args _) _ =>
          Error_monad.__error_value extensible_type_value
        | cons (Micheline.Prim loc name _ _) _ =>
          let allowed :=
            [
              Alpha_context.Script.K_parameter;
              Alpha_context.Script.K_storage;
              Alpha_context.Script.K_code
            ] in
          Error_monad.__error_value extensible_type_value
        end in
      let? function_parameter := find_fields None None None fields in
      match function_parameter with
      | (None, _, _) => Error_monad.__error_value extensible_type_value
      | (Some _, None, _) => Error_monad.__error_value extensible_type_value
      | (Some _, Some _, None) =>
        Error_monad.__error_value extensible_type_value
      |
        (Some (__p_value, ploc, pannot), Some (s, sloc, sannot),
          Some (c, cloc, carrot)) =>
        let maybe_root_name :=
          let? '(__p_value, root_name) :=
            Script_ir_annot.extract_field_annot __p_value in
          match root_name with
          | Some (Script_typed_ir.Field_annot root_name) =>
            Error_monad.ok (__p_value, pannot, (Some root_name))
          | None =>
            match
              (pannot,
                match pannot with
                | cons single [] =>
                  Pervasives.op_andand
                    ((|Compare.Int|).(Compare.S.op_gt) (String.length single) 0)
                    ((|Compare.Char|).(Compare.S.op_eq) (String.get single 0)
                      "%" % char)
                | _ => false
                end) with
            | (cons single [], true) =>
              Error_monad.ok
                (__p_value, nil,
                  (Some
                    (String.sub single 1
                      (Pervasives.op_minus (String.length single) 1))))
            | (_, _) => Error_monad.ok (__p_value, pannot, None)
            end
          end in
        if legacy then
          let '(__p_value, root_name) :=
            match maybe_root_name with
            | Pervasives.Ok (__p_value, _, root_name) => (__p_value, root_name)
            | Pervasives.Error _ => (__p_value, None)
            end in
          Error_monad.ok (__p_value, s, c, root_name)
        else
          let? '(__p_value, pannot, root_name) := maybe_root_name in
          let? '_ := Script_ir_annot.error_unexpected_annot ploc pannot in
          let? '_ := Script_ir_annot.error_unexpected_annot cloc carrot in
          let? '_ := Script_ir_annot.error_unexpected_annot sloc sannot in
          Error_monad.ok (__p_value, s, c, root_name)
      end
    end.

Definition parse_script
  (type_logger : option type_logger) (ctxt : Alpha_context.context)
  (legacy : bool) (function_parameter : Alpha_context.Script.t)
  : Lwt.t (Error_monad.tzresult (ex_script * Alpha_context.context)) :=
  let '{|
    Alpha_context.Script.t.code := code;
      Alpha_context.Script.t.storage := storage
      |} := function_parameter in
  let=? '(code, ctxt) := Alpha_context.Script.force_decode_in_context ctxt code
    in
  let=? '(storage, ctxt) :=
    Alpha_context.Script.force_decode_in_context ctxt storage in
  let=? '(arg_type, storage_type, code_field, root_name) :=
    Lwt.__return (parse_toplevel legacy code) in
  let=? '(Ex_ty arg_type, ctxt) :=
    Error_monad.trace extensible_type_value
      (Lwt.__return (parse_parameter_ty ctxt legacy arg_type)) in
  let=? '_ :=
    if legacy then
      Error_monad.__return tt
    else
      Lwt.__return (well_formed_entrypoints arg_type root_name) in
  let=? '(Ex_ty storage_type, ctxt) :=
    Error_monad.trace extensible_type_value
      (Lwt.__return (parse_storage_ty ctxt legacy storage_type)) in
  let arg_annot :=
    Script_ir_annot.default_annot Script_ir_annot.default_param_annot
      (Script_ir_annot.type_to_var_annot (name_of_ty arg_type)) in
  let storage_annot :=
    Script_ir_annot.default_annot Script_ir_annot.default_storage_annot
      (Script_ir_annot.type_to_var_annot (name_of_ty storage_type)) in
  let arg_type_full :=
    Script_typed_ir.Pair_t (arg_type, None, arg_annot)
      (storage_type, None, storage_annot) None
      (Pervasives.op_pipepipe (has_big_map arg_type) (has_big_map storage_type))
    in
  let ret_type_full :=
    Script_typed_ir.Pair_t
      ((Script_typed_ir.List_t (Script_typed_ir.Operation_t None) None false),
        None, None) (storage_type, None, None) None (has_big_map storage_type)
    in
  let=? '(storage, ctxt) :=
    Error_monad.trace_eval
      (fun function_parameter =>
        let '_ := function_parameter in
        Error_monad.op_gtgtpipequestion
          (Lwt.__return (serialize_ty_for_error ctxt storage_type))
          (fun function_parameter =>
            let '(storage_type, _ctxt) := function_parameter in
            extensible_type_value))
      (parse_data type_logger ctxt legacy storage_type (Micheline.root storage))
    in
  let=? '(code, ctxt) :=
    Error_monad.trace extensible_type_value
      (parse_returning type_logger
        (Toplevel
          {| tc_context.Toplevel.storage_type := storage_type;
            tc_context.Toplevel.param_type := arg_type;
            tc_context.Toplevel.root_name := root_name;
            tc_context.Toplevel.legacy_create_contract_literal := false |}) ctxt
        legacy (arg_type_full, None) ret_type_full code_field) in
  Error_monad.__return
    ((Ex_script
      {| Script_typed_ir.script.code := code;
        Script_typed_ir.script.arg_type := arg_type;
        Script_typed_ir.script.storage := storage;
        Script_typed_ir.script.storage_type := storage_type;
        Script_typed_ir.script.root_name := root_name |}), ctxt).

Definition typecheck_code
  (ctxt : Alpha_context.context) (code : Alpha_context.Script.expr)
  : Lwt.t
    (Error_monad.tzresult (Script_tc_errors.type_map * Alpha_context.context)) :=
  let legacy := false in
  let=? '(arg_type, storage_type, code_field, root_name) :=
    Lwt.__return (parse_toplevel legacy code) in
  let type_map := Pervasives.__ref_value nil in
  let=? '(Ex_ty arg_type, ctxt) :=
    Error_monad.trace extensible_type_value
      (Lwt.__return (parse_parameter_ty ctxt legacy arg_type)) in
  let=? '_ :=
    if legacy then
      Error_monad.__return tt
    else
      Lwt.__return (well_formed_entrypoints arg_type root_name) in
  let=? '(Ex_ty storage_type, ctxt) :=
    Error_monad.trace extensible_type_value
      (Lwt.__return (parse_storage_ty ctxt legacy storage_type)) in
  let arg_annot :=
    Script_ir_annot.default_annot Script_ir_annot.default_param_annot
      (Script_ir_annot.type_to_var_annot (name_of_ty arg_type)) in
  let storage_annot :=
    Script_ir_annot.default_annot Script_ir_annot.default_storage_annot
      (Script_ir_annot.type_to_var_annot (name_of_ty storage_type)) in
  let arg_type_full :=
    Script_typed_ir.Pair_t (arg_type, None, arg_annot)
      (storage_type, None, storage_annot) None
      (Pervasives.op_pipepipe (has_big_map arg_type) (has_big_map storage_type))
    in
  let ret_type_full :=
    Script_typed_ir.Pair_t
      ((Script_typed_ir.List_t (Script_typed_ir.Operation_t None) None false),
        None, None) (storage_type, None, None) None (has_big_map storage_type)
    in
  let __result_value :=
    parse_returning
      (Some
        (fun loc =>
          fun bef =>
            fun aft =>
              Pervasives.op_coloneq type_map
                (cons (loc, (bef, aft)) (Pervasives.op_exclamation type_map))))
      (Toplevel
        {| tc_context.Toplevel.storage_type := storage_type;
          tc_context.Toplevel.param_type := arg_type;
          tc_context.Toplevel.root_name := root_name;
          tc_context.Toplevel.legacy_create_contract_literal := false |}) ctxt
      legacy (arg_type_full, None) ret_type_full code_field in
  let=? '({| Script_typed_ir.lambda.lam := _ |}, ctxt) :=
    Error_monad.trace extensible_type_value __result_value in
  Error_monad.__return ((Pervasives.op_exclamation type_map), ctxt).

Definition typecheck_data
  (type_logger : option type_logger) (ctxt : Alpha_context.context)
  (function_parameter : Alpha_context.Script.expr * Alpha_context.Script.expr)
  : Lwt.t (Error_monad.tzresult Alpha_context.context) :=
  let '(data, exp_ty) := function_parameter in
  let legacy := false in
  let=? '(Ex_ty exp_ty, ctxt) :=
    Error_monad.trace extensible_type_value
      (Lwt.__return (parse_packable_ty ctxt legacy (Micheline.root exp_ty))) in
  let=? '(_, ctxt) :=
    Error_monad.trace_eval
      (fun function_parameter =>
        let '_ := function_parameter in
        Error_monad.op_gtgtpipequestion
          (Lwt.__return (serialize_ty_for_error ctxt exp_ty))
          (fun function_parameter =>
            let '(exp_ty, _ctxt) := function_parameter in
            extensible_type_value))
      (parse_data type_logger ctxt legacy exp_ty (Micheline.root data)) in
  Error_monad.__return ctxt.

Definition Entrypoints_map :=
  Map.Make
    (existT (A := Set) _ _
      {|
        Compare.COMPARABLE.compare := String.compare
      |}).

Definition list_entrypoints
  (full : Script_typed_ir.ty) (ctxt : Alpha_context.context)
  (root_name : option (|Entrypoints_map|).(S.MAP.key))
  : Error_monad.tzresult
    (list (list Alpha_context.Script.prim) *
      (|Entrypoints_map|).(S.MAP.t)
        (list Alpha_context.Script.prim * Alpha_context.Script.node)) :=
  let merge {A : Set}
    (path : list A) (annot : option Script_typed_ir.field_annot)
    (ty : Script_typed_ir.ty) (reachable : bool)
    (function_parameter :
      list (list A) *
        (|Entrypoints_map|).(S.MAP.t) (list A * Alpha_context.Script.node))
    : Error_monad.tzresult
      (list (list A) *
        (|Entrypoints_map|).(S.MAP.t) (list A * Alpha_context.Script.node)) :=
    let '(unreachables, all) as acc := function_parameter in
    match annot with
    | (None | Some (Script_typed_ir.Field_annot "")) =>
      Error_monad.ok
        (if reachable then
          acc
        else
          match ty with
          | Script_typed_ir.Union_t _ _ _ _ => acc
          | _ => ((cons (List.rev path) unreachables), all)
          end)
    | Some (Script_typed_ir.Field_annot name) =>
      if (|Compare.Int|).(Compare.S.op_gt) (String.length name) 31 then
        Error_monad.ok ((cons (List.rev path) unreachables), all)
      else
        if (|Entrypoints_map|).(S.MAP.mem) name all then
          Error_monad.ok ((cons (List.rev path) unreachables), all)
        else
          let? '(unparsed_ty, _) := unparse_ty_no_lwt ctxt ty in
          Error_monad.ok
            (unreachables,
              ((|Entrypoints_map|).(S.MAP.add) name
                ((List.rev path), unparsed_ty) all))
    end in
  let fix fold_tree
    (__t_value : Script_typed_ir.ty) (path : list Alpha_context.Script.prim)
    (reachable : bool)
    (acc :
      list (list Alpha_context.Script.prim) *
        (|Entrypoints_map|).(S.MAP.t)
          (list Alpha_context.Script.prim * Alpha_context.Script.node))
    {struct __t_value}
    : Error_monad.tzresult
      (list (list Alpha_context.Script.prim) *
        (|Entrypoints_map|).(S.MAP.t)
          (list Alpha_context.Script.prim * Alpha_context.Script.node)) :=
    match __t_value with
    | Script_typed_ir.Union_t (tl, al) (tr, ar) _ _ =>
      let? acc :=
        merge (cons Alpha_context.Script.D_Left path) al tl reachable acc in
      let? acc :=
        merge (cons Alpha_context.Script.D_Right path) ar tr reachable acc in
      let? acc :=
        fold_tree tl (cons Alpha_context.Script.D_Left path)
          match al with
          | Some _ => true
          | None => reachable
          end acc in
      fold_tree tr (cons Alpha_context.Script.D_Right path)
        match ar with
        | Some _ => true
        | None => reachable
        end acc
    | _ => Error_monad.ok acc
    end in
  let? '(unparsed_full, _) := unparse_ty_no_lwt ctxt full in
  in
  fold_tree full nil reachable (nil, init).

Fixpoint unparse_data {a : Set}
  (ctxt : Alpha_context.context) (mode : unparsing_mode)
  (ty : Script_typed_ir.ty) (__a_value : a) {struct ctxt}
  : Lwt.t
    (Error_monad.tzresult (Alpha_context.Script.node * Alpha_context.context)) :=
  let=? ctxt :=
    Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.cycle) in
  match (ty, __a_value) with
  | (Script_typed_ir.Unit_t _, _) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.__unit_value)
      in
    Error_monad.__return
      ((Micheline.Prim (-1) Alpha_context.Script.D_Unit nil nil), ctxt)
  
  | (Script_typed_ir.Int_t _, v) =>
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Unparse_costs.__int_value v)) in
    Error_monad.__return
      ((Micheline.Int (-1) (Alpha_context.Script_int.to_zint v)), ctxt)
  
  | (Script_typed_ir.Nat_t _, v) =>
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Unparse_costs.__int_value v)) in
    Error_monad.__return
      ((Micheline.Int (-1) (Alpha_context.Script_int.to_zint v)), ctxt)
  
  | (Script_typed_ir.String_t _, s) =>
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Unparse_costs.__string_value s)) in
    Error_monad.__return ((Micheline.String (-1) s), ctxt)
  
  | (Script_typed_ir.Bytes_t _, s) =>
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Unparse_costs.__bytes_value s)) in
    Error_monad.__return ((Micheline.Bytes (-1) s), ctxt)
  
  | (Script_typed_ir.Bool_t _, true) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.__bool_value)
      in
    Error_monad.__return
      ((Micheline.Prim (-1) Alpha_context.Script.D_True nil nil), ctxt)
  
  | (Script_typed_ir.Bool_t _, false) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.__bool_value)
      in
    Error_monad.__return
      ((Micheline.Prim (-1) Alpha_context.Script.D_False nil nil), ctxt)
  
  | (Script_typed_ir.Timestamp_t _, __t_value) =>
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Unparse_costs.timestamp __t_value)) in
    match mode with
    | Optimized =>
      Error_monad.__return
        ((Micheline.Int (-1) (Alpha_context.Script_timestamp.to_zint __t_value)),
          ctxt)
    | Readable =>
      match Alpha_context.Script_timestamp.to_notation __t_value with
      | None =>
        Error_monad.__return
          ((Micheline.Int (-1)
            (Alpha_context.Script_timestamp.to_zint __t_value)), ctxt)
      | Some s => Error_monad.__return ((Micheline.String (-1) s), ctxt)
      end
    end
  
  | (Script_typed_ir.Address_t _, (c, entrypoint)) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.contract) in
    match mode with
    | Optimized =>
      let entrypoint :=
        match entrypoint with
        | "default" => ""
        | name => name
        end in
      let __bytes_value :=
        Data_encoding.Binary.to_bytes_exn
          (Data_encoding.tup2 Alpha_context.Contract.encoding
            Data_encoding.__Variable.__string_value) (c, entrypoint) in
      Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
    | Readable =>
      let notation :=
        match entrypoint with
        | "default" => Alpha_context.Contract.to_b58check c
        | entrypoint =>
          Pervasives.op_caret (Alpha_context.Contract.to_b58check c)
            (Pervasives.op_caret "%" entrypoint)
        end in
      Error_monad.__return ((Micheline.String (-1) notation), ctxt)
    end
  
  | (Script_typed_ir.Contract_t _ _, (_, (c, entrypoint))) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.contract) in
    match mode with
    | Optimized =>
      let entrypoint :=
        match entrypoint with
        | "default" => ""
        | name => name
        end in
      let __bytes_value :=
        Data_encoding.Binary.to_bytes_exn
          (Data_encoding.tup2 Alpha_context.Contract.encoding
            Data_encoding.__Variable.__string_value) (c, entrypoint) in
      Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
    | Readable =>
      let notation :=
        match entrypoint with
        | "default" => Alpha_context.Contract.to_b58check c
        | entrypoint =>
          Pervasives.op_caret (Alpha_context.Contract.to_b58check c)
            (Pervasives.op_caret "%" entrypoint)
        end in
      Error_monad.__return ((Micheline.String (-1) notation), ctxt)
    end
  
  | (Script_typed_ir.Signature_t _, s) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.signature) in
    match mode with
    | Optimized =>
      let __bytes_value :=
        Data_encoding.Binary.to_bytes_exn Signature.encoding s in
      Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
    | Readable =>
      Error_monad.__return
        ((Micheline.String (-1) (Signature.to_b58check s)), ctxt)
    end
  
  | (Script_typed_ir.Mutez_t _, v) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.tez) in
    Error_monad.__return
      ((Micheline.Int (-1) (Z.of_int64 (Alpha_context.Tez.to_mutez v))), ctxt)
  
  | (Script_typed_ir.Key_t _, k) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.__key_value) in
    match mode with
    | Optimized =>
      let __bytes_value :=
        Data_encoding.Binary.to_bytes_exn
          (|Signature.Public_key|).(S.SPublic_key.encoding) k in
      Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
    | Readable =>
      Error_monad.__return
        ((Micheline.String (-1)
          ((|Signature.Public_key|).(S.SPublic_key.to_b58check) k)), ctxt)
    end
  
  | (Script_typed_ir.Key_hash_t _, k) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.key_hash) in
    match mode with
    | Optimized =>
      let __bytes_value :=
        Data_encoding.Binary.to_bytes_exn
          (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding) k in
      Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
    | Readable =>
      Error_monad.__return
        ((Micheline.String (-1)
          ((|Signature.Public_key_hash|).(S.SPublic_key_hash.to_b58check) k)),
          ctxt)
    end
  
  | (Script_typed_ir.Operation_t _, (op, _big_map_diff)) =>
    let __bytes_value :=
      Data_encoding.Binary.to_bytes_exn
        Alpha_context.Operation.internal_operation_encoding op in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Unparse_costs.operation __bytes_value))
      in
    Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
  
  | (Script_typed_ir.Chain_id_t _, chain_id) =>
    let __bytes_value :=
      Data_encoding.Binary.to_bytes_exn (|Chain_id|).(S.HASH.encoding) chain_id
      in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Unparse_costs.chain_id __bytes_value))
      in
    Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
  
  | (Script_typed_ir.Pair_t (tl, _, _) (tr, _, _) _ _, (l, __r_value)) =>
    let 'existT _ [__1, __2] [tl, tr, l, __r_value] :=
      existT (A := [Set ** Set])
        (fun '[__1, __2] =>
          [Script_typed_ir.ty ** Script_typed_ir.ty ** __1 ** __2]) [_, _]
        [tl, tr, l, __r_value] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.pair) in
    let=? '(l, ctxt) := unparse_data ctxt mode tl l in
    let=? '(__r_value, ctxt) := unparse_data ctxt mode tr __r_value in
    Error_monad.__return
      ((Micheline.Prim (-1) Alpha_context.Script.D_Pair [ l; __r_value ] nil),
        ctxt)
  
  | (Script_typed_ir.Union_t (tl, _) _ _ _, Script_typed_ir.L l) =>
    let 'existT _ __3 [tl, l] :=
      existT (A := Set) (fun __3 => [Script_typed_ir.ty ** __3]) _ [tl, l] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.union) in
    let=? '(l, ctxt) := unparse_data ctxt mode tl l in
    Error_monad.__return
      ((Micheline.Prim (-1) Alpha_context.Script.D_Left [ l ] nil), ctxt)
  
  | (Script_typed_ir.Union_t _ (tr, _) _ _, Script_typed_ir.R __r_value) =>
    let 'existT _ __6 [tr, __r_value] :=
      existT (A := Set) (fun __6 => [Script_typed_ir.ty ** __6]) _
        [tr, __r_value] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.union) in
    let=? '(__r_value, ctxt) := unparse_data ctxt mode tr __r_value in
    Error_monad.__return
      ((Micheline.Prim (-1) Alpha_context.Script.D_Right [ __r_value ] nil),
        ctxt)
  
  | (Script_typed_ir.Option_t __t_value _ _, Some v) =>
    let 'existT _ __7 [__t_value, v] :=
      existT (A := Set) (fun __7 => [Script_typed_ir.ty ** __7]) _
        [__t_value, v] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.some) in
    let=? '(v, ctxt) := unparse_data ctxt mode __t_value v in
    Error_monad.__return
      ((Micheline.Prim (-1) Alpha_context.Script.D_Some [ v ] nil), ctxt)
  
  | (Script_typed_ir.Option_t _ _ _, None) =>
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.none) in
    Error_monad.__return
      ((Micheline.Prim (-1) Alpha_context.Script.D_None nil nil), ctxt)
  
  | (Script_typed_ir.List_t __t_value _ _, items) =>
    let=? '(items, ctxt) :=
      Error_monad.fold_left_s
        (fun function_parameter =>
          let '(l, ctxt) := function_parameter in
          fun element =>
            let=? ctxt :=
              Lwt.__return
                (Alpha_context.Gas.consume ctxt Unparse_costs.list_element) in
            let=? '(unparsed, ctxt) := unparse_data ctxt mode __t_value element
              in
            Error_monad.__return ((cons unparsed l), ctxt)) (nil, ctxt) items in
    Error_monad.__return ((Micheline.Seq (-1) (List.rev items)), ctxt)
  
  | (Script_typed_ir.Set_t __t_value _, set) =>
    let __t_value := ty_of_comparable_ty __t_value in
    let=? '(items, ctxt) :=
      Error_monad.fold_left_s
        (fun function_parameter =>
          let '(l, ctxt) := function_parameter in
          fun item =>
            let=? ctxt :=
              Lwt.__return
                (Alpha_context.Gas.consume ctxt Unparse_costs.set_element) in
            let=? '(item, ctxt) := unparse_data ctxt mode __t_value item in
            Error_monad.__return ((cons item l), ctxt)) (nil, ctxt)
        (set_fold (fun e => fun acc => cons e acc) set nil) in
    Error_monad.__return ((Micheline.Seq (-1) items), ctxt)
  
  | (Script_typed_ir.Map_t kt vt _ _, map) =>
    let kt := ty_of_comparable_ty kt in
    let=? '(items, ctxt) :=
      Error_monad.fold_left_s
        (fun function_parameter =>
          let '(l, ctxt) := function_parameter in
          fun function_parameter =>
            let '(k, v) := function_parameter in
            let=? ctxt :=
              Lwt.__return
                (Alpha_context.Gas.consume ctxt Unparse_costs.map_element) in
            let=? '(__key_value, ctxt) := unparse_data ctxt mode kt k in
            let=? '(value, ctxt) := unparse_data ctxt mode vt v in
            Error_monad.__return
              ((cons
                (Micheline.Prim (-1) Alpha_context.Script.D_Elt
                  [ __key_value; value ] nil) l), ctxt)) (nil, ctxt)
        (map_fold (fun k => fun v => fun acc => cons (k, v) acc) map nil) in
    Error_monad.__return ((Micheline.Seq (-1) items), ctxt)
  
  |
    (Script_typed_ir.Big_map_t kt vt _, {|
      Script_typed_ir.big_map.id := None;
        Script_typed_ir.big_map.diff := Diff
        |}) =>
    let 'existT _ [__13, __14] [kt, vt, Diff] :=
      existT (A := [Set ** Set])
        (fun '[__13, __14] =>
          [Script_typed_ir.comparable_ty ** Script_typed_ir.ty **
            Script_typed_ir.map __13 (option __14)]) [_, _] [kt, vt, Diff] in
    let 'existS _ _ Diff := Diff in
    let kt := ty_of_comparable_ty kt in
    let=? '(items, ctxt) :=
      Error_monad.fold_left_s
        (fun function_parameter =>
          let '(l, ctxt) := function_parameter in
          fun function_parameter =>
            let '(k, v) := function_parameter in
            let=? ctxt :=
              Lwt.__return
                (Alpha_context.Gas.consume ctxt Unparse_costs.map_element) in
            let=? '(__key_value, ctxt) := unparse_data ctxt mode kt k in
            let=? '(value, ctxt) := unparse_data ctxt mode vt v in
            Error_monad.__return
              ((cons
                (Micheline.Prim (-1) Alpha_context.Script.D_Elt
                  [ __key_value; value ] nil) l), ctxt)) (nil, ctxt)
        (Diff.(Script_typed_ir.Boxed_map.OPS).(S.MAP.fold)
          (fun k =>
            fun v =>
              fun acc =>
                match v with
                | None => acc
                | Some v => cons (k, v) acc
                end) (Pervasives.fst Diff.(Script_typed_ir.Boxed_map.boxed)) nil)
      in
    Error_monad.__return ((Micheline.Seq (-1) items), ctxt)
  
  |
    (Script_typed_ir.Big_map_t _kt _kv _, {|
      Script_typed_ir.big_map.id := Some id;
        Script_typed_ir.big_map.diff := Diff
        |}) =>
    let 'existT _ [__15, __16] [_kt, _kv, id, Diff] :=
      existT (A := [Set ** Set])
        (fun '[__15, __16] =>
          [Script_typed_ir.comparable_ty ** Script_typed_ir.ty ** Z.t **
            Script_typed_ir.map __15 (option __16)]) [_, _] [_kt, _kv, id, Diff]
      in
    let 'existS _ _ Diff := Diff in
    if
      (|Compare.Int|).(Compare.S.op_eq)
        (Diff.(Script_typed_ir.Boxed_map.OPS).(S.MAP.cardinal)
          (Pervasives.fst Diff.(Script_typed_ir.Boxed_map.boxed))) 0 then
      Error_monad.__return ((Micheline.Int (-1) id), ctxt)
    else
      (* ❌ Assert instruction is not handled. *)
      assert
        (Lwt.t
          (Error_monad.tzresult
            (Micheline.node int Alpha_context.Script.prim *
              Alpha_context.context))) false
  
  |
    (Script_typed_ir.Lambda_t _ _ _, {|
      Script_typed_ir.lambda.lam := (_, original_code) |}) =>
    unparse_code ctxt mode original_code
  end

with unparse_code (ctxt : Alpha_context.context) (mode : unparsing_mode)
  {struct ctxt}
  : Alpha_context.Script.node ->
  Lwt.t
    (Error_monad.tzresult
      (Micheline.node int Alpha_context.Script.prim * Alpha_context.context)) :=
  let legacy := true in
  fun function_parameter =>
    match function_parameter with
    |
      Micheline.Prim loc Alpha_context.Script.I_PUSH (cons ty (cons data []))
        annot =>
      let=? '(Ex_ty __t_value, ctxt) :=
        Lwt.__return (parse_packable_ty ctxt legacy ty) in
      let=? '(data, ctxt) := parse_data None ctxt legacy __t_value data in
      let=? '(data, ctxt) := unparse_data ctxt mode __t_value data in
      let=? ctxt :=
        Lwt.__return
          (Alpha_context.Gas.consume ctxt (Unparse_costs.prim_cost 2 annot)) in
      Error_monad.__return
        ((Micheline.Prim loc Alpha_context.Script.I_PUSH [ ty; data ] annot),
          ctxt)
    | Micheline.Seq loc items =>
      let=? '(items, ctxt) :=
        Error_monad.fold_left_s
          (fun function_parameter =>
            let '(l, ctxt) := function_parameter in
            fun item =>
              let=? '(item, ctxt) := unparse_code ctxt mode item in
              Error_monad.__return ((cons item l), ctxt)) (nil, ctxt) items in
      let=? ctxt :=
        Lwt.__return
          (Alpha_context.Gas.consume ctxt
            (Unparse_costs.seq_cost (List.length items))) in
      Error_monad.__return ((Micheline.Seq loc (List.rev items)), ctxt)
    | Micheline.Prim loc prim items annot =>
      let=? '(items, ctxt) :=
        Error_monad.fold_left_s
          (fun function_parameter =>
            let '(l, ctxt) := function_parameter in
            fun item =>
              let=? '(item, ctxt) := unparse_code ctxt mode item in
              Error_monad.__return ((cons item l), ctxt)) (nil, ctxt) items in
      let=? ctxt :=
        Lwt.__return
          (Alpha_context.Gas.consume ctxt (Unparse_costs.prim_cost 3 annot)) in
      Error_monad.__return
        ((Micheline.Prim loc prim (List.rev items) annot), ctxt)
    | (Micheline.Int _ _ | Micheline.String _ _ | Micheline.Bytes _ _) as atom
      => Error_monad.__return (atom, ctxt)
    end.

Definition unparse_script {A : Set}
  (ctxt : Alpha_context.context) (mode : unparsing_mode)
  (function_parameter : Script_typed_ir.script A)
  : Lwt.t
    (Error_monad.tzresult (Alpha_context.Script.t * Alpha_context.context)) :=
  let '{|
    Script_typed_ir.script.code := code;
      Script_typed_ir.script.arg_type := arg_type;
      Script_typed_ir.script.storage := storage;
      Script_typed_ir.script.storage_type := storage_type;
      Script_typed_ir.script.root_name := root_name
      |} := function_parameter in
  let '{| Script_typed_ir.lambda.lam := (_, original_code) |} := code in
  let=? '(code, ctxt) := unparse_code ctxt mode original_code in
  let=? '(storage, ctxt) := unparse_data ctxt mode storage_type storage in
  let=? '(arg_type, ctxt) := unparse_ty ctxt arg_type in
  let=? '(storage_type, ctxt) := unparse_ty ctxt storage_type in
  let arg_type :=
    add_field_annot
      (Option.map (fun n => Script_typed_ir.Field_annot n) root_name) None
      arg_type in
  let code :=
    Micheline.Seq (-1)
      [
        Micheline.Prim (-1) Alpha_context.Script.K_parameter [ arg_type ] nil;
        Micheline.Prim (-1) Alpha_context.Script.K_storage [ storage_type ] nil;
        Micheline.Prim (-1) Alpha_context.Script.K_code [ code ] nil
      ] in
  let=? ctxt :=
    Lwt.__return
      (let? ctxt := Alpha_context.Gas.consume ctxt (Unparse_costs.seq_cost 3) in
      let? ctxt :=
        Alpha_context.Gas.consume ctxt (Unparse_costs.prim_cost 1 nil) in
      let? ctxt :=
        Alpha_context.Gas.consume ctxt (Unparse_costs.prim_cost 1 nil) in
      Alpha_context.Gas.consume ctxt (Unparse_costs.prim_cost 1 nil)) in
  Error_monad.__return
    ({|
      Alpha_context.Script.t.code :=
        Alpha_context.Script.__lazy_expr_value (Micheline.strip_locations code);
      Alpha_context.Script.t.storage :=
        Alpha_context.Script.__lazy_expr_value
          (Micheline.strip_locations storage) |}, ctxt).

Definition pack_data {A : Set}
  (ctxt : Alpha_context.context) (typ : Script_typed_ir.ty) (data : A)
  : Lwt.t (Error_monad.tzresult (MBytes.t * Alpha_context.context)) :=
  let=? '(unparsed, ctxt) := unparse_data ctxt Optimized typ data in
  let __bytes_value :=
    Data_encoding.Binary.to_bytes_exn Alpha_context.Script.expr_encoding
      (Micheline.strip_locations unparsed) in
  let=? ctxt :=
    Lwt.__return
      (Alpha_context.Gas.consume ctxt
        (Alpha_context.Script.serialized_cost __bytes_value)) in
  let __bytes_value :=
    MBytes.concat "" [ MBytes.of_string "\005"; __bytes_value ] in
  let=? ctxt :=
    Lwt.__return
      (Alpha_context.Gas.consume ctxt
        (Alpha_context.Script.serialized_cost __bytes_value)) in
  Error_monad.__return (__bytes_value, ctxt).

Definition hash_data {A : Set}
  (ctxt : Alpha_context.context) (typ : Script_typed_ir.ty) (data : A)
  : Lwt.t (Error_monad.tzresult (Script_expr_hash.t * Alpha_context.context)) :=
  let=? '(__bytes_value, ctxt) := pack_data ctxt typ data in
  let=? ctxt :=
    Lwt.__return
      (Alpha_context.Gas.consume ctxt
        (Michelson_v1_gas.Cost_of.Legacy.__hash_value __bytes_value
          Script_expr_hash.size)) in
  Error_monad.__return
    ((Script_expr_hash.hash_bytes None [ __bytes_value ]), ctxt).

Definition empty_big_map {A B : Set}
  (tk : Script_typed_ir.comparable_ty) (tv : Script_typed_ir.ty)
  : Script_typed_ir.big_map A B :=
  {| Script_typed_ir.big_map.id := None;
    Script_typed_ir.big_map.diff := empty_map tk;
    Script_typed_ir.big_map.key_type := ty_of_comparable_ty tk;
    Script_typed_ir.big_map.value_type := tv |}.

Definition big_map_mem {A B : Set}
  (ctxt : Alpha_context.context) (__key_value : A)
  (function_parameter : Script_typed_ir.big_map A B)
  : Lwt.t (Error_monad.tzresult (bool * Alpha_context.context)) :=
  let '{|
    Script_typed_ir.big_map.id := id;
      Script_typed_ir.big_map.diff := diff;
      Script_typed_ir.big_map.key_type := key_type
      |} := function_parameter in
  match ((map_get __key_value diff), id) with
  | (None, None) => Error_monad.__return (false, ctxt)
  | (None, Some id) =>
    let=? '(__hash_value, ctxt) := hash_data ctxt key_type __key_value in
    let=? '(ctxt, res) := Alpha_context.Big_map.mem ctxt id __hash_value in
    Error_monad.__return (res, ctxt)
  | (Some None, _) => Error_monad.__return (false, ctxt)
  | (Some (Some _), _) => Error_monad.__return (true, ctxt)
  end.

Definition big_map_get {A B : Set}
  (ctxt : Alpha_context.context) (__key_value : A)
  (function_parameter : Script_typed_ir.big_map A B)
  : Lwt.t (Error_monad.tzresult (option B * Alpha_context.context)) :=
  let '{|
    Script_typed_ir.big_map.id := id;
      Script_typed_ir.big_map.diff := diff;
      Script_typed_ir.big_map.key_type := key_type;
      Script_typed_ir.big_map.value_type := value_type
      |} := function_parameter in
  match ((map_get __key_value diff), id) with
  | (Some x, _) => Error_monad.__return (x, ctxt)
  | (None, None) => Error_monad.__return (None, ctxt)
  | (None, Some id) =>
    let=? '(__hash_value, ctxt) := hash_data ctxt key_type __key_value in
    let=? function_parameter :=
      Alpha_context.Big_map.get_opt ctxt id __hash_value in
    match function_parameter with
    | (ctxt, None) => Error_monad.__return (None, ctxt)
    | (ctxt, Some value) =>
      let=? '(x, ctxt) :=
        parse_data None ctxt true value_type (Micheline.root value) in
      Error_monad.__return ((Some x), ctxt)
    end
  end.

Definition big_map_update {A B : Set}
  (__key_value : A) (value : option B)
  (function_parameter : Script_typed_ir.big_map A B)
  : Script_typed_ir.big_map A B :=
  let '{| Script_typed_ir.big_map.diff := diff |} as map := function_parameter
    in
  Script_typed_ir.big_map.with_diff (map_set __key_value value diff) map.

Definition Ids :=
  __Set.Make
    (existT (A := Set) _ _
      {|
        Compare.COMPARABLE.compare := (|Compare.Z|).(Compare.S.compare)
      |}).

Definition big_map_ids : Set := (|Ids|).(S.SET.t).

Definition no_big_map_id : (|Ids|).(S.SET.t) := (|Ids|).(S.SET.empty).

Definition diff_of_big_map {A B : Set}
  (ctxt : Alpha_context.context)
  (fresh :
    Alpha_context.context ->
    Lwt.t
      (Error_monad.tzresult (Alpha_context.context * Alpha_context.Big_map.id)))
  (mode : unparsing_mode) (ids : (|Ids|).(S.SET.t))
  (function_parameter : Script_typed_ir.big_map A B)
  : Lwt.t
    (Error_monad.tzresult
      (list Alpha_context.Contract.big_map_diff_item * Alpha_context.Big_map.id
        * Alpha_context.context)) :=
  let '{|
    Script_typed_ir.big_map.id := id;
      Script_typed_ir.big_map.diff := diff;
      Script_typed_ir.big_map.key_type := key_type;
      Script_typed_ir.big_map.value_type := value_type
      |} := function_parameter in
  let=? ctxt :=
    Lwt.__return
      (Alpha_context.Gas.consume ctxt
        (Michelson_v1_gas.Cost_of.Legacy.map_to_list diff)) in
  let=? '(ctxt, init, big_map) :=
    match id with
    | Some id =>
      if (|Ids|).(S.SET.mem) id ids then
        let=? '(ctxt, duplicate) := fresh ctxt in
        Error_monad.__return
          (ctxt, [ Alpha_context.Contract.Copy id duplicate ], duplicate)
      else
        Error_monad.__return (ctxt, nil, id)
    | None =>
      let=? '(ctxt, id) := fresh ctxt in
      let=? '(kt, ctxt) := unparse_ty ctxt key_type in
      let=? '(kv, ctxt) := unparse_ty ctxt value_type in
      Error_monad.__return
        (ctxt,
          [
            Alpha_context.Contract.Alloc
              {|
                Alpha_context.Contract.big_map_diff_item.Alloc.big_map :=
                  id;
                Alpha_context.Contract.big_map_diff_item.Alloc.key_type :=
                  Micheline.strip_locations kt;
                Alpha_context.Contract.big_map_diff_item.Alloc.value_type :=
                  Micheline.strip_locations kv |}
          ], id)
    end in
  let pairs :=
    map_fold
      (fun __key_value => fun value => fun acc => cons (__key_value, value) acc)
      diff nil in
  let=? '(diff, ctxt) :=
    Error_monad.fold_left_s
      (fun function_parameter =>
        let '(acc, ctxt) := function_parameter in
        fun function_parameter =>
          let '(__key_value, value) := function_parameter in
          let=? ctxt :=
            Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle)
            in
          let=? '(diff_key_hash, ctxt) := hash_data ctxt key_type __key_value in
          let=? '(key_node, ctxt) := unparse_data ctxt mode key_type __key_value
            in
          let diff_key := Micheline.strip_locations key_node in
          let=? '(diff_value, ctxt) :=
            match value with
            | None => Error_monad.__return (None, ctxt)
            | Some x =>
              let=? '(node, ctxt) := unparse_data ctxt mode value_type x in
              Error_monad.__return
                ((Some (Micheline.strip_locations node)), ctxt)
            end in
          let diff_item :=
            Alpha_context.Contract.Update
              {|
                Alpha_context.Contract.big_map_diff_item.Update.big_map :=
                  big_map;
                Alpha_context.Contract.big_map_diff_item.Update.diff_key :=
                  diff_key;
                Alpha_context.Contract.big_map_diff_item.Update.diff_key_hash :=
                  diff_key_hash;
                Alpha_context.Contract.big_map_diff_item.Update.diff_value :=
                  diff_value |} in
          Error_monad.__return ((cons diff_item acc), ctxt)) (nil, ctxt) pairs
    in
  Error_monad.__return ((Pervasives.op_at init diff), big_map, ctxt).

Fixpoint extract_big_map_updates {a : Set}
  (ctxt : Alpha_context.context)
  (fresh :
    Alpha_context.context ->
    Lwt.t
      (Error_monad.tzresult (Alpha_context.context * Alpha_context.Big_map.id)))
  (mode : unparsing_mode) (ids : (|Ids|).(S.SET.t))
  (acc : list Alpha_context.Contract.big_map_diff) (ty : Script_typed_ir.ty)
  (x : a) {struct ctxt}
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * a * (|Ids|).(S.SET.t) *
        list Alpha_context.Contract.big_map_diff)) :=
  match (ty, x) with
  | (Script_typed_ir.Big_map_t _ _ _, map) =>
    let=? '(diff, id, ctxt) := diff_of_big_map ctxt fresh mode ids map in
    let Map := map.(Script_typed_ir.big_map.diff) in
    let 'existS _ _ Map := Map in
    let map :=
      Script_typed_ir.big_map.with_diff
        (empty_map Map.(Script_typed_ir.Boxed_map.key_ty))
        (Script_typed_ir.big_map.with_id (Some id) map) in
    Error_monad.__return
      (ctxt, map, ((|Ids|).(S.SET.add) id ids), (cons diff acc))
  
  | (Script_typed_ir.Pair_t (tyl, _, _) (tyr, _, _) _ true, (xl, xr)) =>
    let 'existT _ [__2, __3] [tyl, tyr, xl, xr] :=
      existT (A := [Set ** Set])
        (fun '[__2, __3] =>
          [Script_typed_ir.ty ** Script_typed_ir.ty ** __2 ** __3]) [_, _]
        [tyl, tyr, xl, xr] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle) in
    let=? '(ctxt, xl, ids, acc) :=
      extract_big_map_updates ctxt fresh mode ids acc tyl xl in
    let=? '(ctxt, xr, ids, acc) :=
      extract_big_map_updates ctxt fresh mode ids acc tyr xr in
    Error_monad.__return (ctxt, (xl, xr), ids, acc)
  
  | (Script_typed_ir.Union_t (ty, _) (_, _) _ true, Script_typed_ir.L x) =>
    let 'existT _ __4 [ty, x] :=
      existT (A := Set) (fun __4 => [Script_typed_ir.ty ** __4]) _ [ty, x] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle) in
    let=? '(ctxt, x, ids, acc) :=
      extract_big_map_updates ctxt fresh mode ids acc ty x in
    Error_monad.__return (ctxt, (Script_typed_ir.L x), ids, acc)
  
  | (Script_typed_ir.Union_t (_, _) (ty, _) _ true, Script_typed_ir.R x) =>
    let 'existT _ __7 [ty, x] :=
      existT (A := Set) (fun __7 => [Script_typed_ir.ty ** __7]) _ [ty, x] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle) in
    let=? '(ctxt, x, ids, acc) :=
      extract_big_map_updates ctxt fresh mode ids acc ty x in
    Error_monad.__return (ctxt, (Script_typed_ir.R x), ids, acc)
  
  | (Script_typed_ir.Option_t ty _ true, Some x) =>
    let 'existT _ __8 [ty, x] :=
      existT (A := Set) (fun __8 => [Script_typed_ir.ty ** __8]) _ [ty, x] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle) in
    let=? '(ctxt, x, ids, acc) :=
      extract_big_map_updates ctxt fresh mode ids acc ty x in
    Error_monad.__return (ctxt, (Some x), ids, acc)
  
  | (Script_typed_ir.List_t ty _ true, l) =>
    let=? '(ctxt, l, ids, acc) :=
      Error_monad.fold_left_s
        (fun function_parameter =>
          let '(ctxt, l, ids, acc) := function_parameter in
          fun x =>
            let=? ctxt :=
              Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle) in
            let=? '(ctxt, x, ids, acc) :=
              extract_big_map_updates ctxt fresh mode ids acc ty x in
            Error_monad.__return (ctxt, (cons x l), ids, acc))
        (ctxt, nil, ids, acc) l in
    Error_monad.__return (ctxt, (List.rev l), ids, acc)
  
  | (Script_typed_ir.Map_t _ ty _ true, M as m) =>
    let 'existS _ _ M := M in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt
          (Michelson_v1_gas.Cost_of.Legacy.map_to_list m)) in
    let=? '(ctxt, m, ids, acc) :=
      Error_monad.fold_left_s
        (fun function_parameter =>
          let '(ctxt, m, ids, acc) := function_parameter in
          fun function_parameter =>
            let '(k, x) := function_parameter in
            let=? ctxt :=
              Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle) in
            let=? '(ctxt, x, ids, acc) :=
              extract_big_map_updates ctxt fresh mode ids acc ty x in
            Error_monad.__return
              (ctxt, (M.(Script_typed_ir.Boxed_map.OPS).(S.MAP.add) k x m), ids,
                acc))
        (ctxt, M.(Script_typed_ir.Boxed_map.OPS).(S.MAP.empty), ids, acc)
        (M.(Script_typed_ir.Boxed_map.OPS).(S.MAP.bindings)
          (Pervasives.fst M.(Script_typed_ir.Boxed_map.boxed))) in
    let M :=
      let OPS :=
        existT (A := unit) (fun _ => _) tt M.(Script_typed_ir.Boxed_map.OPS) in
      let key : Set := M.(Script_typed_ir.Boxed_map.key) in
      let value : Set := M.(Script_typed_ir.Boxed_map.value) in
      let key_ty := M.(Script_typed_ir.Boxed_map.key_ty) in
      let boxed := (m, (Pervasives.snd M.(Script_typed_ir.Boxed_map.boxed))) in
      existT (A := unit) (fun _ => _) tt
        {|
          Script_typed_ir.Boxed_map.OPS := (|OPS|);
          Script_typed_ir.Boxed_map.key_ty := key_ty;
          Script_typed_ir.Boxed_map.boxed := boxed
        |} in
    Error_monad.__return
      (ctxt, (pack (existT (A := Set -> Set) _ _ (|M|))), ids, acc)
  
  | (Script_typed_ir.Option_t _ _ true, None) =>
    Error_monad.__return (ctxt, None, ids, acc)
  
  | (Script_typed_ir.List_t _ _ false, v) =>
    Error_monad.__return (ctxt, v, ids, acc)
  
  | (Script_typed_ir.Map_t _ _ _ false, v) =>
    Error_monad.__return (ctxt, v, ids, acc)
  
  | (Script_typed_ir.Option_t _ _ false, None) =>
    Error_monad.__return (ctxt, None, ids, acc)
  
  | (Script_typed_ir.Pair_t _ _ _ false, v) =>
    Error_monad.__return (ctxt, v, ids, acc)
  
  | (Script_typed_ir.Union_t _ _ _ false, v) =>
    Error_monad.__return (ctxt, v, ids, acc)
  
  | (Script_typed_ir.Option_t _ _ false, v) =>
    Error_monad.__return (ctxt, v, ids, acc)
  
  | (Script_typed_ir.Chain_id_t _, v) =>
    Error_monad.__return (ctxt, v, ids, acc)
  
  | (Script_typed_ir.Set_t _ _, v) => Error_monad.__return (ctxt, v, ids, acc)
  
  | (Script_typed_ir.Unit_t _, v) => Error_monad.__return (ctxt, v, ids, acc)
  
  | (Script_typed_ir.Int_t _, v) => Error_monad.__return (ctxt, v, ids, acc)
  
  | (Script_typed_ir.Nat_t _, v) => Error_monad.__return (ctxt, v, ids, acc)
  
  | (Script_typed_ir.Signature_t _, v) =>
    Error_monad.__return (ctxt, v, ids, acc)
  
  | (Script_typed_ir.String_t _, v) => Error_monad.__return (ctxt, v, ids, acc)
  
  | (Script_typed_ir.Bytes_t _, v) => Error_monad.__return (ctxt, v, ids, acc)
  
  | (Script_typed_ir.Mutez_t _, v) => Error_monad.__return (ctxt, v, ids, acc)
  
  | (Script_typed_ir.Key_hash_t _, v) =>
    Error_monad.__return (ctxt, v, ids, acc)
  
  | (Script_typed_ir.Key_t _, v) => Error_monad.__return (ctxt, v, ids, acc)
  
  | (Script_typed_ir.Timestamp_t _, v) =>
    Error_monad.__return (ctxt, v, ids, acc)
  
  | (Script_typed_ir.Address_t _, v) => Error_monad.__return (ctxt, v, ids, acc)
  
  | (Script_typed_ir.Bool_t _, v) => Error_monad.__return (ctxt, v, ids, acc)
  
  | (Script_typed_ir.Lambda_t _ _ _, v) =>
    Error_monad.__return (ctxt, v, ids, acc)
  
  | (Script_typed_ir.Contract_t _ _, v) =>
    Error_monad.__return (ctxt, v, ids, acc)
  
  | (Script_typed_ir.Operation_t _, _) =>
    (* ❌ Assert instruction is not handled. *)
    assert
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff))) false
  end.

Definition collect_big_maps {A : Set}
  (ctxt : Alpha_context.context) (ty : Script_typed_ir.ty) (x : A)
  : Lwt.t (Error_monad.tzresult ((|Ids|).(S.SET.t) * Alpha_context.context)) :=
  let fix collect {a : Set}
    (ctxt : Alpha_context.context) (ty : Script_typed_ir.ty) (x : a)
    (acc : (|Ids|).(S.SET.t)) {struct ctxt}
    : Error_monad.tzresult ((|Ids|).(S.SET.t) * Alpha_context.context) :=
    match (ty, x) with
    |
      (Script_typed_ir.Big_map_t _ _ _, {|
        Script_typed_ir.big_map.id := Some id |}) =>
      let? ctxt := Alpha_context.Gas.consume ctxt Typecheck_costs.cycle in
      Error_monad.ok (((|Ids|).(S.SET.add) id acc), ctxt)
    
    | (Script_typed_ir.Pair_t (tyl, _, _) (tyr, _, _) _ true, (xl, xr)) =>
      let 'existT _ [__2, __3] [tyl, tyr, xl, xr] :=
        existT (A := [Set ** Set])
          (fun '[__2, __3] =>
            [Script_typed_ir.ty ** Script_typed_ir.ty ** __2 ** __3]) [_, _]
          [tyl, tyr, xl, xr] in
      let? '(acc, ctxt) := collect ctxt tyl xl acc in
      collect ctxt tyr xr acc
    
    | (Script_typed_ir.Union_t (ty, _) (_, _) _ true, Script_typed_ir.L x) =>
      let 'existT _ __4 [ty, x] :=
        existT (A := Set) (fun __4 => [Script_typed_ir.ty ** __4]) _ [ty, x] in
      collect ctxt ty x acc
    
    | (Script_typed_ir.Union_t (_, _) (ty, _) _ true, Script_typed_ir.R x) =>
      let 'existT _ __7 [ty, x] :=
        existT (A := Set) (fun __7 => [Script_typed_ir.ty ** __7]) _ [ty, x] in
      collect ctxt ty x acc
    
    | (Script_typed_ir.Option_t ty _ true, Some x) =>
      let 'existT _ __8 [ty, x] :=
        existT (A := Set) (fun __8 => [Script_typed_ir.ty ** __8]) _ [ty, x] in
      collect ctxt ty x acc
    
    | (Script_typed_ir.List_t ty _ true, l) =>
      List.fold_left
        (fun acc =>
          fun x =>
            let? '(acc, ctxt) := acc in
            collect ctxt ty x acc) (Error_monad.ok (acc, ctxt)) l
    
    | (Script_typed_ir.Map_t _ ty _ true, m) =>
      map_fold
        (fun function_parameter =>
          let '_ := function_parameter in
          fun v =>
            fun acc =>
              let? '(acc, ctxt) := acc in
              collect ctxt ty v acc) m (Error_monad.ok (acc, ctxt))
    
    | (Script_typed_ir.List_t _ _ false, _) => Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Map_t _ _ _ false, _) => Error_monad.ok (acc, ctxt)
    
    |
      (Script_typed_ir.Big_map_t _ _ _, {| Script_typed_ir.big_map.id := None |})
      => Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Option_t _ _ true, None) => Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Option_t _ _ false, _) => Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Union_t _ _ _ false, _) => Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Pair_t _ _ _ false, _) => Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Chain_id_t _, _) => Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Set_t _ _, _) => Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Unit_t _, _) => Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Int_t _, _) => Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Nat_t _, _) => Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Signature_t _, _) => Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.String_t _, _) => Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Bytes_t _, _) => Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Mutez_t _, _) => Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Key_hash_t _, _) => Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Key_t _, _) => Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Timestamp_t _, _) => Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Address_t _, _) => Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Bool_t _, _) => Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Lambda_t _ _ _, _) => Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Contract_t _ _, _) => Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Operation_t _, _) =>
      (* ❌ Assert instruction is not handled. *)
      assert (Error_monad.tzresult ((|Ids|).(S.SET.t) * Alpha_context.context))
        false
    end in
  Lwt.__return (collect ctxt ty x no_big_map_id).

Definition extract_big_map_diff {A : Set}
  (ctxt : Alpha_context.context) (mode : unparsing_mode) (temporary : bool)
  (to_duplicate : (|Ids|).(S.SET.t)) (to_update : (|Ids|).(S.SET.t))
  (ty : Script_typed_ir.ty) (v : A)
  : Lwt.t
    (Error_monad.tzresult
      (A * option (list Alpha_context.Contract.big_map_diff_item) *
        Alpha_context.context)) :=
  let to_duplicate := (|Ids|).(S.SET.diff) to_duplicate to_update in
  let fresh :=
    if temporary then
      fun c => Error_monad.__return (Alpha_context.Big_map.fresh_temporary c)
    else
      Alpha_context.Big_map.fresh in
  let=? '(ctxt, v, alive, diffs) :=
    extract_big_map_updates ctxt fresh mode to_duplicate nil ty v in
  let diffs :=
    if temporary then
      diffs
    else
      let dead := (|Ids|).(S.SET.diff) to_update alive in
      cons
        ((|Ids|).(S.SET.fold)
          (fun id => fun acc => cons (Alpha_context.Contract.Clear id) acc) dead
          nil) diffs in
  match diffs with
  | [] => Error_monad.__return (v, None, ctxt)
  | diffs => Error_monad.__return (v, (Some (List.flatten diffs)), ctxt)
  end.

Definition list_of_big_map_ids (ids : (|Ids|).(S.SET.t))
  : list (|Ids|).(S.SET.elt) := (|Ids|).(S.SET.elements) ids.
